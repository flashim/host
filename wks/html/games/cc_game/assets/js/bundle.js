/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/createjs-module/createjs.js":
/*!**************************************************!*\
  !*** ./node_modules/createjs-module/createjs.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;var createjs = (this.createjs = (this.createjs || {}));\n/*!\n* CreateJS\n* Visit http://createjs.com/ for documentation, updates and examples.\n*\n* Copyright (c) 2010 gskinner.com, inc.\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nthis.createjs = this.createjs||{};\n\n\n//##############################################################################\n// extend.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Sets up the prototype chain and constructor property for a new class.\n *\n * This should be called right after creating the class constructor.\n *\n * \tfunction MySubClass() {}\n * \tcreatejs.extend(MySubClass, MySuperClass);\n * \tMySubClass.prototype.doSomething = function() { }\n *\n * \tvar foo = new MySubClass();\n * \tconsole.log(foo instanceof MySuperClass); // true\n * \tconsole.log(foo.prototype.constructor === MySubClass); // true\n *\n * @method extend\n * @param {Function} subclass The subclass.\n * @param {Function} superclass The superclass to extend.\n * @return {Function} Returns the subclass's new prototype.\n */\ncreatejs.extend = function(subclass, superclass) {\n\t\"use strict\";\n\n\tfunction o() { this.constructor = subclass; }\n\to.prototype = superclass.prototype;\n\treturn (subclass.prototype = new o());\n};\n\n//##############################################################################\n// promote.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.\n * It is recommended to use the super class's name as the prefix.\n * An alias to the super class's constructor is always added in the format `prefix_constructor`.\n * This allows the subclass to call super class methods without using `function.call`, providing better performance.\n *\n * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, \"MySuperClass\")`\n * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the\n * prototype of `MySubClass` as `MySuperClass_draw`.\n *\n * This should be called after the class's prototype is fully defined.\n *\n * \tfunction ClassA(name) {\n * \t\tthis.name = name;\n * \t}\n * \tClassA.prototype.greet = function() {\n * \t\treturn \"Hello \"+this.name;\n * \t}\n *\n * \tfunction ClassB(name, punctuation) {\n * \t\tthis.ClassA_constructor(name);\n * \t\tthis.punctuation = punctuation;\n * \t}\n * \tcreatejs.extend(ClassB, ClassA);\n * \tClassB.prototype.greet = function() {\n * \t\treturn this.ClassA_greet()+this.punctuation;\n * \t}\n * \tcreatejs.promote(ClassB, \"ClassA\");\n *\n * \tvar foo = new ClassB(\"World\", \"!?!\");\n * \tconsole.log(foo.greet()); // Hello World!?!\n *\n * @method promote\n * @param {Function} subclass The class to promote super class methods on.\n * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.\n * @return {Function} Returns the subclass.\n */\ncreatejs.promote = function(subclass, prefix) {\n\t\"use strict\";\n\n\tvar subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;\n\tif (supP) {\n\t\tsubP[(prefix+=\"_\") + \"constructor\"] = supP.constructor; // constructor is not always innumerable\n\t\tfor (var n in supP) {\n\t\t\tif (subP.hasOwnProperty(n) && (typeof supP[n] == \"function\")) { subP[prefix + n] = supP[n]; }\n\t\t}\n\t}\n\treturn subclass;\n};\n\n//##############################################################################\n// indexOf.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of\n * that value.  Returns -1 if value is not found.\n *\n *      var i = createjs.indexOf(myArray, myElementToFind);\n *\n * @method indexOf\n * @param {Array} array Array to search for searchElement\n * @param searchElement Element to find in array.\n * @return {Number} The first index of searchElement in array.\n */\ncreatejs.indexOf = function (array, searchElement){\n\t\"use strict\";\n\n\tfor (var i = 0,l=array.length; i < l; i++) {\n\t\tif (searchElement === array[i]) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n//##############################################################################\n// Event.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n// constructor:\n\t/**\n\t * Contains properties and methods shared by all events for use with\n\t * {{#crossLink \"EventDispatcher\"}}{{/crossLink}}.\n\t * \n\t * Note that Event objects are often reused, so you should never\n\t * rely on an event object's state outside of the call stack it was received in.\n\t * @class Event\n\t * @param {String} type The event type.\n\t * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.\n\t * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.\n\t * @constructor\n\t **/\n\tfunction Event(type, bubbles, cancelable) {\n\t\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The type of event.\n\t\t * @property type\n\t\t * @type String\n\t\t **/\n\t\tthis.type = type;\n\t\n\t\t/**\n\t\t * The object that generated an event.\n\t\t * @property target\n\t\t * @type Object\n\t\t * @default null\n\t\t * @readonly\n\t\t*/\n\t\tthis.target = null;\n\t\n\t\t/**\n\t\t * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will\n\t\t * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event\n\t\t * is generated from childObj, then a listener on parentObj would receive the event with\n\t\t * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).\n\t\t * @property currentTarget\n\t\t * @type Object\n\t\t * @default null\n\t\t * @readonly\n\t\t*/\n\t\tthis.currentTarget = null;\n\t\n\t\t/**\n\t\t * For bubbling events, this indicates the current event phase:<OL>\n\t\t * \t<LI> capture phase: starting from the top parent to the target</LI>\n\t\t * \t<LI> at target phase: currently being dispatched from the target</LI>\n\t\t * \t<LI> bubbling phase: from the target to the top parent</LI>\n\t\t * </OL>\n\t\t * @property eventPhase\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t*/\n\t\tthis.eventPhase = 0;\n\t\n\t\t/**\n\t\t * Indicates whether the event will bubble through the display list.\n\t\t * @property bubbles\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.bubbles = !!bubbles;\n\t\n\t\t/**\n\t\t * Indicates whether the default behaviour of this event can be cancelled via\n\t\t * {{#crossLink \"Event/preventDefault\"}}{{/crossLink}}. This is set via the Event constructor.\n\t\t * @property cancelable\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.cancelable = !!cancelable;\n\t\n\t\t/**\n\t\t * The epoch time at which this event was created.\n\t\t * @property timeStamp\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t*/\n\t\tthis.timeStamp = (new Date()).getTime();\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/preventDefault\"}}{{/crossLink}} has been called\n\t\t * on this event.\n\t\t * @property defaultPrevented\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.defaultPrevented = false;\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/stopPropagation\"}}{{/crossLink}} or\n\t\t * {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called on this event.\n\t\t * @property propagationStopped\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.propagationStopped = false;\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called\n\t\t * on this event.\n\t\t * @property immediatePropagationStopped\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.immediatePropagationStopped = false;\n\t\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/remove\"}}{{/crossLink}} has been called on this event.\n\t\t * @property removed\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.removed = false;\n\t}\n\tvar p = Event.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n// public methods:\n\t/**\n\t * Sets {{#crossLink \"Event/defaultPrevented\"}}{{/crossLink}} to true if the event is cancelable.\n\t * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will\n\t * cancel the default behaviour associated with the event.\n\t * @method preventDefault\n\t **/\n\tp.preventDefault = function() {\n\t\tthis.defaultPrevented = this.cancelable&&true;\n\t};\n\n\t/**\n\t * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} to true.\n\t * Mirrors the DOM event standard.\n\t * @method stopPropagation\n\t **/\n\tp.stopPropagation = function() {\n\t\tthis.propagationStopped = true;\n\t};\n\n\t/**\n\t * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} and\n\t * {{#crossLink \"Event/immediatePropagationStopped\"}}{{/crossLink}} to true.\n\t * Mirrors the DOM event standard.\n\t * @method stopImmediatePropagation\n\t **/\n\tp.stopImmediatePropagation = function() {\n\t\tthis.immediatePropagationStopped = this.propagationStopped = true;\n\t};\n\t\n\t/**\n\t * Causes the active listener to be removed via removeEventListener();\n\t * \n\t * \t\tmyBtn.addEventListener(\"click\", function(evt) {\n\t * \t\t\t// do stuff...\n\t * \t\t\tevt.remove(); // removes this listener.\n\t * \t\t});\n\t * \n\t * @method remove\n\t **/\n\tp.remove = function() {\n\t\tthis.removed = true;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Event instance.\n\t * @method clone\n\t * @return {Event} a clone of the Event instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Event(this.type, this.bubbles, this.cancelable);\n\t};\n\t\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the instance.\n\t * @return {Event} Returns the instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Event (type=\"+this.type+\")]\";\n\t};\n\n\tcreatejs.Event = Event;\n}());\n\n//##############################################################################\n// EventDispatcher.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * EventDispatcher provides methods for managing queues of event listeners and dispatching events.\n\t *\n\t * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the\n\t * EventDispatcher {{#crossLink \"EventDispatcher/initialize\"}}{{/crossLink}} method.\n\t * \n\t * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the\n\t * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports\n\t * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.\n\t * \n\t * EventDispatcher also exposes a {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}} method, which makes it easier\n\t * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The \n\t * {{#crossLink \"EventDispatcher/off\"}}{{/crossLink}} method is merely an alias to\n\t * {{#crossLink \"EventDispatcher/removeEventListener\"}}{{/crossLink}}.\n\t * \n\t * Another addition to the DOM Level 2 model is the {{#crossLink \"EventDispatcher/removeAllEventListeners\"}}{{/crossLink}}\n\t * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also \n\t * includes a {{#crossLink \"Event/remove\"}}{{/crossLink}} method which removes the active listener.\n\t *\n\t * <h4>Example</h4>\n\t * Add EventDispatcher capabilities to the \"MyClass\" class.\n\t *\n\t *      EventDispatcher.initialize(MyClass.prototype);\n\t *\n\t * Add an event (see {{#crossLink \"EventDispatcher/addEventListener\"}}{{/crossLink}}).\n\t *\n\t *      instance.addEventListener(\"eventName\", handlerMethod);\n\t *      function handlerMethod(event) {\n\t *          console.log(event.target + \" Was Clicked\");\n\t *      }\n\t *\n\t * <b>Maintaining proper scope</b><br />\n\t * Scope (ie. \"this\") can be be a challenge with events. Using the {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}}\n\t * method to subscribe to events simplifies this.\n\t *\n\t *      instance.addEventListener(\"click\", function(event) {\n\t *          console.log(instance == this); // false, scope is ambiguous.\n\t *      });\n\t *      \n\t *      instance.on(\"click\", function(event) {\n\t *          console.log(instance == this); // true, \"on\" uses dispatcher scope by default.\n\t *      });\n\t * \n\t * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage\n\t * scope.\n\t *\n\t * <b>Browser support</b>\n\t * The event model in CreateJS can be used separately from the suite in any project, however the inheritance model\n\t * requires modern browsers (IE9+).\n\t *      \n\t *\n\t * @class EventDispatcher\n\t * @constructor\n\t **/\n\tfunction EventDispatcher() {\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @protected\n\t\t * @property _listeners\n\t\t * @type Object\n\t\t **/\n\t\tthis._listeners = null;\n\t\t\n\t\t/**\n\t\t * @protected\n\t\t * @property _captureListeners\n\t\t * @type Object\n\t\t **/\n\t\tthis._captureListeners = null;\n\t}\n\tvar p = EventDispatcher.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// static public methods:\n\t/**\n\t * Static initializer to mix EventDispatcher methods into a target object or prototype.\n\t * \n\t * \t\tEventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class\n\t * \t\tEventDispatcher.initialize(myObject); // add to a specific instance\n\t * \n\t * @method initialize\n\t * @static\n\t * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a\n\t * prototype.\n\t **/\n\tEventDispatcher.initialize = function(target) {\n\t\ttarget.addEventListener = p.addEventListener;\n\t\ttarget.on = p.on;\n\t\ttarget.removeEventListener = target.off =  p.removeEventListener;\n\t\ttarget.removeAllEventListeners = p.removeAllEventListeners;\n\t\ttarget.hasEventListener = p.hasEventListener;\n\t\ttarget.dispatchEvent = p.dispatchEvent;\n\t\ttarget._dispatchEvent = p._dispatchEvent;\n\t\ttarget.willTrigger = p.willTrigger;\n\t};\n\t\n\n// public methods:\n\t/**\n\t * Adds the specified event listener. Note that adding multiple listeners to the same function will result in\n\t * multiple callbacks getting fired.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.addEventListener(\"click\", handleClick);\n\t *      function handleClick(event) {\n\t *         // Click happened.\n\t *      }\n\t *\n\t * @method addEventListener\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n\t * the event is dispatched.\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t * @return {Function | Object} Returns the listener for chaining or assignment.\n\t **/\n\tp.addEventListener = function(type, listener, useCapture) {\n\t\tvar listeners;\n\t\tif (useCapture) {\n\t\t\tlisteners = this._captureListeners = this._captureListeners||{};\n\t\t} else {\n\t\t\tlisteners = this._listeners = this._listeners||{};\n\t\t}\n\t\tvar arr = listeners[type];\n\t\tif (arr) { this.removeEventListener(type, listener, useCapture); }\n\t\tarr = listeners[type]; // remove may have deleted the array\n\t\tif (!arr) { listeners[type] = [listener];  }\n\t\telse { arr.push(listener); }\n\t\treturn listener;\n\t};\n\t\n\t/**\n\t * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener\n\t * only run once, associate arbitrary data with the listener, and remove the listener.\n\t * \n\t * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.\n\t * The wrapper function is returned for use with `removeEventListener` (or `off`).\n\t * \n\t * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use\n\t * {{#crossLink \"Event/remove\"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls\n\t * to `on` with the same params will create multiple listeners.\n\t * \n\t * <h4>Example</h4>\n\t * \n\t * \t\tvar listener = myBtn.on(\"click\", handleClick, null, false, {count:3});\n\t * \t\tfunction handleClick(evt, data) {\n\t * \t\t\tdata.count -= 1;\n\t * \t\t\tconsole.log(this == myBtn); // true - scope defaults to the dispatcher\n\t * \t\t\tif (data.count == 0) {\n\t * \t\t\t\talert(\"clicked 3 times!\");\n\t * \t\t\t\tmyBtn.off(\"click\", listener);\n\t * \t\t\t\t// alternately: evt.remove();\n\t * \t\t\t}\n\t * \t\t}\n\t * \n\t * @method on\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n\t * the event is dispatched.\n\t * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).\n\t * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.\n\t * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.\n\t * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.\n\t **/\n\tp.on = function(type, listener, scope, once, data, useCapture) {\n\t\tif (listener.handleEvent) {\n\t\t\tscope = scope||listener;\n\t\t\tlistener = listener.handleEvent;\n\t\t}\n\t\tscope = scope||this;\n\t\treturn this.addEventListener(type, function(evt) {\n\t\t\t\tlistener.call(scope, evt, data);\n\t\t\t\tonce&&evt.remove();\n\t\t\t}, useCapture);\n\t};\n\n\t/**\n\t * Removes the specified event listener.\n\t *\n\t * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy\n\t * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or\n\t * closure will not work.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.removeEventListener(\"click\", handleClick);\n\t *\n\t * @method removeEventListener\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener The listener function or object.\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t **/\n\tp.removeEventListener = function(type, listener, useCapture) {\n\t\tvar listeners = useCapture ? this._captureListeners : this._listeners;\n\t\tif (!listeners) { return; }\n\t\tvar arr = listeners[type];\n\t\tif (!arr) { return; }\n\t\tfor (var i=0,l=arr.length; i<l; i++) {\n\t\t\tif (arr[i] == listener) {\n\t\t\t\tif (l==1) { delete(listeners[type]); } // allows for faster checks.\n\t\t\t\telse { arr.splice(i,1); }\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/**\n\t * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the\n\t * .on method.\n\t * \n\t * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See \n\t * {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}} for an example.\n\t *\n\t * @method off\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener The listener function or object.\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t **/\n\tp.off = p.removeEventListener;\n\n\t/**\n\t * Removes all listeners for the specified type, or all listeners of all types.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      // Remove all listeners\n\t *      displayObject.removeAllEventListeners();\n\t *\n\t *      // Remove all click listeners\n\t *      displayObject.removeAllEventListeners(\"click\");\n\t *\n\t * @method removeAllEventListeners\n\t * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.\n\t **/\n\tp.removeAllEventListeners = function(type) {\n\t\tif (!type) { this._listeners = this._captureListeners = null; }\n\t\telse {\n\t\t\tif (this._listeners) { delete(this._listeners[type]); }\n\t\t\tif (this._captureListeners) { delete(this._captureListeners[type]); }\n\t\t}\n\t};\n\n\t/**\n\t * Dispatches the specified event to all listeners.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      // Use a string event\n\t *      this.dispatchEvent(\"complete\");\n\t *\n\t *      // Use an Event instance\n\t *      var event = new createjs.Event(\"progress\");\n\t *      this.dispatchEvent(event);\n\t *\n\t * @method dispatchEvent\n\t * @param {Object | String | Event} eventObj An object with a \"type\" property, or a string type.\n\t * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,\n\t * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can\n\t * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.\n\t * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.\n\t * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.\n\t * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.\n\t **/\n\tp.dispatchEvent = function(eventObj, bubbles, cancelable) {\n\t\tif (typeof eventObj == \"string\") {\n\t\t\t// skip everything if there's no listeners and it doesn't bubble:\n\t\t\tvar listeners = this._listeners;\n\t\t\tif (!bubbles && (!listeners || !listeners[eventObj])) { return true; }\n\t\t\teventObj = new createjs.Event(eventObj, bubbles, cancelable);\n\t\t} else if (eventObj.target && eventObj.clone) {\n\t\t\t// redispatching an active event object, so clone it:\n\t\t\teventObj = eventObj.clone();\n\t\t}\n\t\t\n\t\t// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent\n\t\ttry { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events\n\n\t\tif (!eventObj.bubbles || !this.parent) {\n\t\t\tthis._dispatchEvent(eventObj, 2);\n\t\t} else {\n\t\t\tvar top=this, list=[top];\n\t\t\twhile (top.parent) { list.push(top = top.parent); }\n\t\t\tvar i, l=list.length;\n\n\t\t\t// capture & atTarget\n\t\t\tfor (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 1+(i==0));\n\t\t\t}\n\t\t\t// bubbling\n\t\t\tfor (i=1; i<l && !eventObj.propagationStopped; i++) {\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 3);\n\t\t\t}\n\t\t}\n\t\treturn !eventObj.defaultPrevented;\n\t};\n\n\t/**\n\t * Indicates whether there is at least one listener for the specified event type.\n\t * @method hasEventListener\n\t * @param {String} type The string type of the event.\n\t * @return {Boolean} Returns true if there is at least one listener for the specified event.\n\t **/\n\tp.hasEventListener = function(type) {\n\t\tvar listeners = this._listeners, captureListeners = this._captureListeners;\n\t\treturn !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));\n\t};\n\t\n\t/**\n\t * Indicates whether there is at least one listener for the specified event type on this object or any of its\n\t * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the\n\t * specified type is dispatched from this object, it will trigger at least one listener.\n\t * \n\t * This is similar to {{#crossLink \"EventDispatcher/hasEventListener\"}}{{/crossLink}}, but it searches the entire\n\t * event flow for a listener, not just this object.\n\t * @method willTrigger\n\t * @param {String} type The string type of the event.\n\t * @return {Boolean} Returns `true` if there is at least one listener for the specified event.\n\t **/\n\tp.willTrigger = function(type) {\n\t\tvar o = this;\n\t\twhile (o) {\n\t\t\tif (o.hasEventListener(type)) { return true; }\n\t\t\to = o.parent;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[EventDispatcher]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _dispatchEvent\n\t * @param {Object | String | Event} eventObj\n\t * @param {Object} eventPhase\n\t * @protected\n\t **/\n\tp._dispatchEvent = function(eventObj, eventPhase) {\n\t\tvar l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;\n\t\tif (eventObj && listeners) {\n\t\t\tvar arr = listeners[eventObj.type];\n\t\t\tif (!arr||!(l=arr.length)) { return; }\n\t\t\ttry { eventObj.currentTarget = this; } catch (e) {}\n\t\t\ttry { eventObj.eventPhase = eventPhase; } catch (e) {}\n\t\t\teventObj.removed = false;\n\t\t\t\n\t\t\tarr = arr.slice(); // to avoid issues with items being removed or added during the dispatch\n\t\t\tfor (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {\n\t\t\t\tvar o = arr[i];\n\t\t\t\tif (o.handleEvent) { o.handleEvent(eventObj); }\n\t\t\t\telse { o(eventObj); }\n\t\t\t\tif (eventObj.removed) {\n\t\t\t\t\tthis.off(eventObj.type, o, eventPhase==1);\n\t\t\t\t\teventObj.removed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\n\tcreatejs.EventDispatcher = EventDispatcher;\n}());\n\n//##############################################################################\n// Ticker.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick\n\t * event to be notified when a set time interval has elapsed.\n\t *\n\t * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval\n\t * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and\n\t * can not be instantiated.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n\t *      function handleTick(event) {\n\t *          // Actions carried out each tick (aka frame)\n\t *          if (!event.paused) {\n\t *              // Actions carried out when the Ticker is not paused.\n\t *          }\n\t *      }\n\t *\n\t * @class Ticker\n\t * @uses EventDispatcher\n\t * @static\n\t **/\n\tfunction Ticker() {\n\t\tthrow \"Ticker cannot be instantiated.\";\n\t}\n\n\n// constants:\n\t/**\n\t * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It\n\t * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and\n\t * dispatches the tick when the time is within a certain threshold.\n\t *\n\t * This mode has a higher variance for time between frames than {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}},\n\t * but does not require that content be time based as with {{#crossLink \"Ticker/RAF:property\"}}{{/crossLink}} while\n\t * gaining the benefits of that API (screen synch, background throttling).\n\t *\n\t * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so\n\t * framerates of 10, 12, 15, 20, and 30 work well.\n\t *\n\t * Falls back to {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}} if the requestAnimationFrame API is not\n\t * supported.\n\t * @property RAF_SYNCHED\n\t * @static\n\t * @type {String}\n\t * @default \"synched\"\n\t * @readonly\n\t **/\n\tTicker.RAF_SYNCHED = \"synched\";\n\n\t/**\n\t * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.\n\t * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.\n\t * You can leverage {{#crossLink \"Ticker/getTime\"}}{{/crossLink}} and the {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}}\n\t * event object's \"delta\" properties to make this easier.\n\t *\n\t * Falls back on {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}} if the requestAnimationFrame API is not\n\t * supported.\n\t * @property RAF\n\t * @static\n\t * @type {String}\n\t * @default \"raf\"\n\t * @readonly\n\t **/\n\tTicker.RAF = \"raf\";\n\n\t/**\n\t * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not\n\t * provide the benefits of requestAnimationFrame (screen synch, background throttling).\n\t * @property TIMEOUT\n\t * @static\n\t * @type {String}\n\t * @default \"timeout\"\n\t * @readonly\n\t **/\n\tTicker.TIMEOUT = \"timeout\";\n\n\n// static events:\n\t/**\n\t * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using\n\t * {{#crossLink \"Ticker/setPaused\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n\t *      function handleTick(event) {\n\t *          console.log(\"Paused:\", event.paused, event.delta);\n\t *      }\n\t *\n\t * @event tick\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Boolean} paused Indicates whether the ticker is currently paused.\n\t * @param {Number} delta The time elapsed in ms since the last tick.\n\t * @param {Number} time The total time in ms since Ticker was initialized.\n\t * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,\n\t * \tyou could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.\n\t * @since 0.6.0\n\t */\n\n\n// public static properties:\n\t/**\n\t * Deprecated in favour of {{#crossLink \"Ticker/timingMode\"}}{{/crossLink}}, and will be removed in a future version. If true, timingMode will\n\t * use {{#crossLink \"Ticker/RAF_SYNCHED\"}}{{/crossLink}} by default.\n\t * @deprecated Deprecated in favour of {{#crossLink \"Ticker/timingMode\"}}{{/crossLink}}.\n\t * @property useRAF\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tTicker.useRAF = false;\n\n\t/**\n\t * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See\n\t * {{#crossLink \"Ticker/TIMEOUT\"}}{{/crossLink}}, {{#crossLink \"Ticker/RAF\"}}{{/crossLink}}, and\n\t * {{#crossLink \"Ticker/RAF_SYNCHED\"}}{{/crossLink}} for mode details.\n\t * @property timingMode\n\t * @static\n\t * @type {String}\n\t * @default Ticker.TIMEOUT\n\t **/\n\tTicker.timingMode = null;\n\n\t/**\n\t * Specifies a maximum value for the delta property in the tick event object. This is useful when building time\n\t * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,\n\t * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value\n\t * (ex. maxDelta=50 when running at 40fps).\n\t * \n\t * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta\n\t * when using both delta and other values.\n\t * \n\t * If 0, there is no maximum.\n\t * @property maxDelta\n\t * @static\n\t * @type {number}\n\t * @default 0\n\t */\n\tTicker.maxDelta = 0;\n\t\n\t/**\n\t * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property\n\t * of the event will be `true`. Also, while paused the `runTime` will not increase. See {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}},\n\t * {{#crossLink \"Ticker/getTime\"}}{{/crossLink}}, and {{#crossLink \"Ticker/getEventTime\"}}{{/crossLink}} for more\n\t * info.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n\t *      createjs.Ticker.paused = true;\n\t *      function handleTick(event) {\n\t *          console.log(event.paused,\n\t *          \tcreatejs.Ticker.getTime(false),\n\t *          \tcreatejs.Ticker.getTime(true));\n\t *      }\n\t *\n\t * @property paused\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tTicker.paused = false;\n\n\n// mix-ins:\n\t// EventDispatcher methods:\n\tTicker.removeEventListener = null;\n\tTicker.removeAllEventListeners = null;\n\tTicker.dispatchEvent = null;\n\tTicker.hasEventListener = null;\n\tTicker._listeners = null;\n\tcreatejs.EventDispatcher.initialize(Ticker); // inject EventDispatcher methods.\n\tTicker._addEventListener = Ticker.addEventListener;\n\tTicker.addEventListener = function() {\n\t\t!Ticker._inited&&Ticker.init();\n\t\treturn Ticker._addEventListener.apply(Ticker, arguments);\n\t};\n\n\n// private static properties:\n\t/**\n\t * @property _inited\n\t * @static\n\t * @type {Boolean}\n\t * @protected\n\t **/\n\tTicker._inited = false;\n\n\t/**\n\t * @property _startTime\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._startTime = 0;\n\n\t/**\n\t * @property _pausedTime\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._pausedTime=0;\n\n\t/**\n\t * The number of ticks that have passed\n\t * @property _ticks\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._ticks = 0;\n\n\t/**\n\t * The number of ticks that have passed while Ticker has been paused\n\t * @property _pausedTicks\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._pausedTicks = 0;\n\n\t/**\n\t * @property _interval\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._interval = 50;\n\n\t/**\n\t * @property _lastTime\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._lastTime = 0;\n\n\t/**\n\t * @property _times\n\t * @static\n\t * @type {Array}\n\t * @protected\n\t **/\n\tTicker._times = null;\n\n\t/**\n\t * @property _tickTimes\n\t * @static\n\t * @type {Array}\n\t * @protected\n\t **/\n\tTicker._tickTimes = null;\n\n\t/**\n\t * Stores the timeout or requestAnimationFrame id.\n\t * @property _timerId\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._timerId = null;\n\t\n\t/**\n\t * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode\n\t * if that property changed and a tick hasn't fired.\n\t * @property _raf\n\t * @static\n\t * @type {Boolean}\n\t * @protected\n\t **/\n\tTicker._raf = true;\n\t\n\n// static getter / setters:\n\t/**\n\t * Use the {{#crossLink \"Ticker/interval:property\"}}{{/crossLink}} property instead.\n\t * @method setInterval\n\t * @static\n\t * @param {Number} interval\n\t * @deprecated\n\t **/\n\tTicker.setInterval = function(interval) {\n\t\tTicker._interval = interval;\n\t\tif (!Ticker._inited) { return; }\n\t\tTicker._setupTick();\n\t};\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/interval:property\"}}{{/crossLink}} property instead.\n\t * @method getInterval\n\t * @static\n\t * @return {Number}\n\t * @deprecated\n\t **/\n\tTicker.getInterval = function() {\n\t\treturn Ticker._interval;\n\t};\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/framerate:property\"}}{{/crossLink}} property instead.\n\t * @method setFPS\n\t * @static\n\t * @param {Number} value\n\t * @deprecated\n\t **/\n\tTicker.setFPS = function(value) {\n\t\tTicker.setInterval(1000/value);\n\t};\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/framerate:property\"}}{{/crossLink}} property instead.\n\t * @method getFPS\n\t * @static\n\t * @return {Number}\n\t * @deprecated\n\t **/\n\tTicker.getFPS = function() {\n\t\treturn 1000/Ticker._interval;\n\t};\n\n\t/**\n\t * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).\n\t * Note that actual time between ticks may be more than specified depending on CPU load.\n\t * This property is ignored if the ticker is using the `RAF` timing mode.\n\t * @property interval\n\t * @static\n\t * @type {Number}\n\t **/\n\t \n\t/**\n\t * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where\n\t * `framerate == 1000/interval`.\n\t * @property framerate\n\t * @static\n\t * @type {Number}\n\t **/\n\ttry {\n\t\tObject.defineProperties(Ticker, {\n\t\t\tinterval: { get: Ticker.getInterval, set: Ticker.setInterval },\n\t\t\tframerate: { get: Ticker.getFPS, set: Ticker.setFPS }\n\t\t});\n\t} catch (e) { console.log(e); }\n\n\n// public static methods:\n\t/**\n\t * Starts the tick. This is called automatically when the first listener is added.\n\t * @method init\n\t * @static\n\t **/\n\tTicker.init = function() {\n\t\tif (Ticker._inited) { return; }\n\t\tTicker._inited = true;\n\t\tTicker._times = [];\n\t\tTicker._tickTimes = [];\n\t\tTicker._startTime = Ticker._getTime();\n\t\tTicker._times.push(Ticker._lastTime = 0);\n\t\tTicker.interval = Ticker._interval;\n\t};\n\t\n\t/**\n\t * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.\n\t * @method reset\n\t * @static\n\t **/\n\tTicker.reset = function() {\n\t\tif (Ticker._raf) {\n\t\t\tvar f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;\n\t\t\tf&&f(Ticker._timerId);\n\t\t} else {\n\t\t\tclearTimeout(Ticker._timerId);\n\t\t}\n\t\tTicker.removeAllEventListeners(\"tick\");\n\t\tTicker._timerId = Ticker._times = Ticker._tickTimes = null;\n\t\tTicker._startTime = Ticker._lastTime = Ticker._ticks = 0;\n\t\tTicker._inited = false;\n\t};\n\n\t/**\n\t * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS\n\t * because it only measures the time spent within the tick execution stack. \n\t * \n\t * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between \n\t * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that \n\t * there may be up to 35ms of \"idle\" time between the end of one tick and the start of the next.\n\t *\n\t * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of\n\t * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something\n\t * other than the tick is using ~80ms (another script, DOM rendering, etc).\n\t * @method getMeasuredTickTime\n\t * @static\n\t * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.\n\t * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.\n\t * @return {Number} The average time spent in a tick in milliseconds.\n\t **/\n\tTicker.getMeasuredTickTime = function(ticks) {\n\t\tvar ttl=0, times=Ticker._tickTimes;\n\t\tif (!times || times.length < 1) { return -1; }\n\n\t\t// by default, calculate average for the past ~1 second:\n\t\tticks = Math.min(times.length, ticks||(Ticker.getFPS()|0));\n\t\tfor (var i=0; i<ticks; i++) { ttl += times[i]; }\n\t\treturn ttl/ticks;\n\t};\n\n\t/**\n\t * Returns the actual frames / ticks per second.\n\t * @method getMeasuredFPS\n\t * @static\n\t * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.\n\t * Defaults to the number of ticks per second.\n\t * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ\n\t * from the target frames per second.\n\t **/\n\tTicker.getMeasuredFPS = function(ticks) {\n\t\tvar times = Ticker._times;\n\t\tif (!times || times.length < 2) { return -1; }\n\n\t\t// by default, calculate fps for the past ~1 second:\n\t\tticks = Math.min(times.length-1, ticks||(Ticker.getFPS()|0));\n\t\treturn 1000/((times[0]-times[ticks])/ticks);\n\t};\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/paused:property\"}}{{/crossLink}} property instead.\n\t * @method setPaused\n\t * @static\n\t * @param {Boolean} value\n\t * @deprecated\n\t **/\n\tTicker.setPaused = function(value) {\n\t\t// TODO: deprecated.\n\t\tTicker.paused = value;\n\t};\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/paused:property\"}}{{/crossLink}} property instead.\n\t * @method getPaused\n\t * @static\n\t * @return {Boolean}\n\t * @deprecated\n\t **/\n\tTicker.getPaused = function() {\n\t\t// TODO: deprecated.\n\t\treturn Ticker.paused;\n\t};\n\n\t/**\n\t * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink \"Ticker/init\"}}.\n\t * Returns -1 if Ticker has not been initialized. For example, you could use\n\t * this in a time synchronized animation to determine the exact amount of time that has elapsed.\n\t * @method getTime\n\t * @static\n\t * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.\n\t * If false, the value returned will be total time elapsed since the first tick event listener was added.\n\t * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.\n\t **/\n\tTicker.getTime = function(runTime) {\n\t\treturn Ticker._startTime ? Ticker._getTime() - (runTime ? Ticker._pausedTime : 0) : -1;\n\t};\n\n\t/**\n\t * Similar to the {{#crossLink \"Ticker/getTime\"}}{{/crossLink}} method, but returns the time on the most recent {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}}\n\t * event object.\n\t * @method getEventTime\n\t * @static\n\t * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.\n\t * @returns {number} The time or runTime property from the most recent tick event or -1.\n\t */\n\tTicker.getEventTime = function(runTime) {\n\t\treturn Ticker._startTime ? (Ticker._lastTime || Ticker._startTime) - (runTime ? Ticker._pausedTime : 0) : -1;\n\t};\n\t\n\t/**\n\t * Returns the number of ticks that have been broadcast by Ticker.\n\t * @method getTicks\n\t * @static\n\t * @param {Boolean} pauseable Indicates whether to include ticks that would have been broadcast\n\t * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.\n\t * If false, tick events that would have been broadcast while Ticker was paused will be included in the return\n\t * value. The default value is false.\n\t * @return {Number} of ticks that have been broadcast.\n\t **/\n\tTicker.getTicks = function(pauseable) {\n\t\treturn  Ticker._ticks - (pauseable ? Ticker._pausedTicks : 0);\n\t};\n\n\n// private static methods:\n\t/**\n\t * @method _handleSynch\n\t * @static\n\t * @protected\n\t **/\n\tTicker._handleSynch = function() {\n\t\tTicker._timerId = null;\n\t\tTicker._setupTick();\n\n\t\t// run if enough time has elapsed, with a little bit of flexibility to be early:\n\t\tif (Ticker._getTime() - Ticker._lastTime >= (Ticker._interval-1)*0.97) {\n\t\t\tTicker._tick();\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleRAF\n\t * @static\n\t * @protected\n\t **/\n\tTicker._handleRAF = function() {\n\t\tTicker._timerId = null;\n\t\tTicker._setupTick();\n\t\tTicker._tick();\n\t};\n\n\t/**\n\t * @method _handleTimeout\n\t * @static\n\t * @protected\n\t **/\n\tTicker._handleTimeout = function() {\n\t\tTicker._timerId = null;\n\t\tTicker._setupTick();\n\t\tTicker._tick();\n\t};\n\n\t/**\n\t * @method _setupTick\n\t * @static\n\t * @protected\n\t **/\n\tTicker._setupTick = function() {\n\t\tif (Ticker._timerId != null) { return; } // avoid duplicates\n\n\t\tvar mode = Ticker.timingMode||(Ticker.useRAF&&Ticker.RAF_SYNCHED);\n\t\tif (mode == Ticker.RAF_SYNCHED || mode == Ticker.RAF) {\n\t\t\tvar f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;\n\t\t\tif (f) {\n\t\t\t\tTicker._timerId = f(mode == Ticker.RAF ? Ticker._handleRAF : Ticker._handleSynch);\n\t\t\t\tTicker._raf = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTicker._raf = false;\n\t\tTicker._timerId = setTimeout(Ticker._handleTimeout, Ticker._interval);\n\t};\n\n\t/**\n\t * @method _tick\n\t * @static\n\t * @protected\n\t **/\n\tTicker._tick = function() {\n\t\tvar paused = Ticker.paused;\n\t\tvar time = Ticker._getTime();\n\t\tvar elapsedTime = time-Ticker._lastTime;\n\t\tTicker._lastTime = time;\n\t\tTicker._ticks++;\n\t\t\n\t\tif (paused) {\n\t\t\tTicker._pausedTicks++;\n\t\t\tTicker._pausedTime += elapsedTime;\n\t\t}\n\t\t\n\t\tif (Ticker.hasEventListener(\"tick\")) {\n\t\t\tvar event = new createjs.Event(\"tick\");\n\t\t\tvar maxDelta = Ticker.maxDelta;\n\t\t\tevent.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;\n\t\t\tevent.paused = paused;\n\t\t\tevent.time = time;\n\t\t\tevent.runTime = time-Ticker._pausedTime;\n\t\t\tTicker.dispatchEvent(event);\n\t\t}\n\t\t\n\t\tTicker._tickTimes.unshift(Ticker._getTime()-time);\n\t\twhile (Ticker._tickTimes.length > 100) { Ticker._tickTimes.pop(); }\n\n\t\tTicker._times.unshift(time);\n\t\twhile (Ticker._times.length > 100) { Ticker._times.pop(); }\n\t};\n\n\t/**\n\t * @method _getTime\n\t * @static\n\t * @protected\n\t **/\n\tvar now = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);\n\tTicker._getTime = function() {\n\t\treturn ((now&&now.call(performance))||(new Date().getTime())) - Ticker._startTime;\n\t};\n\n\n\tcreatejs.Ticker = Ticker;\n}());\n\n//##############################################################################\n// UID.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Global utility for generating sequential unique ID numbers. The UID class uses a static interface (ex. <code>UID.get()</code>)\n\t * and should not be instantiated.\n\t * @class UID\n\t * @static\n\t **/\n\tfunction UID() {\n\t\tthrow \"UID cannot be instantiated\";\n\t}\n\n\n// private static properties:\n\t/**\n\t * @property _nextID\n\t * @type Number\n\t * @protected\n\t **/\n\tUID._nextID = 0;\n\n\n// public static methods:\n\t/**\n\t * Returns the next unique id.\n\t * @method get\n\t * @return {Number} The next unique id\n\t * @static\n\t **/\n\tUID.get = function() {\n\t\treturn UID._nextID++;\n\t};\n\n\n\tcreatejs.UID = UID;\n}());\n\n//##############################################################################\n// MouseEvent.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Passed as the parameter to all mouse/pointer/touch related events. For a listing of mouse events and their properties,\n\t * see the {{#crossLink \"DisplayObject\"}}{{/crossLink}} and {{#crossLink \"Stage\"}}{{/crossLink}} event listings.\n\t * @class MouseEvent\n\t * @param {String} type The event type.\n\t * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.\n\t * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.\n\t * @param {Number} stageX The normalized x position relative to the stage.\n\t * @param {Number} stageY The normalized y position relative to the stage.\n\t * @param {MouseEvent} nativeEvent The native DOM event related to this mouse event.\n\t * @param {Number} pointerID The unique id for the pointer.\n\t * @param {Boolean} primary Indicates whether this is the primary pointer in a multitouch environment.\n\t * @param {Number} rawX The raw x position relative to the stage.\n\t * @param {Number} rawY The raw y position relative to the stage.\n\t * @param {DisplayObject} relatedTarget The secondary target for the event.\n\t * @extends Event\n\t * @constructor\n\t **/\n\tfunction MouseEvent(type, bubbles, cancelable, stageX, stageY, nativeEvent, pointerID, primary, rawX, rawY, relatedTarget) {\n\t\tthis.Event_constructor(type, bubbles, cancelable);\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The normalized x position on the stage. This will always be within the range 0 to stage width.\n\t\t * @property stageX\n\t\t * @type Number\n\t\t*/\n\t\tthis.stageX = stageX;\n\t\n\t\t/**\n\t\t * The normalized y position on the stage. This will always be within the range 0 to stage height.\n\t\t * @property stageY\n\t\t * @type Number\n\t\t **/\n\t\tthis.stageY = stageY;\n\t\n\t\t/**\n\t\t * The raw x position relative to the stage. Normally this will be the same as the stageX value, unless\n\t\t * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.\n\t\t * @property rawX\n\t\t * @type Number\n\t\t*/\n\t\tthis.rawX = (rawX==null)?stageX:rawX;\n\t\n\t\t/**\n\t\t * The raw y position relative to the stage. Normally this will be the same as the stageY value, unless\n\t\t * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.\n\t\t * @property rawY\n\t\t * @type Number\n\t\t*/\n\t\tthis.rawY = (rawY==null)?stageY:rawY;\n\t\n\t\t/**\n\t\t * The native MouseEvent generated by the browser. The properties and API for this\n\t\t * event may differ between browsers. This property will be null if the\n\t\t * EaselJS property was not directly generated from a native MouseEvent.\n\t\t * @property nativeEvent\n\t\t * @type HtmlMouseEvent\n\t\t * @default null\n\t\t **/\n\t\tthis.nativeEvent = nativeEvent;\n\t\n\t\t/**\n\t\t * The unique id for the pointer (touch point or cursor). This will be either -1 for the mouse, or the system\n\t\t * supplied id value.\n\t\t * @property pointerID\n\t\t * @type {Number}\n\t\t */\n\t\tthis.pointerID = pointerID;\n\t\n\t\t/**\n\t\t * Indicates whether this is the primary pointer in a multitouch environment. This will always be true for the mouse.\n\t\t * For touch pointers, the first pointer in the current stack will be considered the primary pointer.\n\t\t * @property primary\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.primary = !!primary;\n\t\t\n\t\t/**\n\t\t * The secondary target for the event, if applicable. This is used for mouseout/rollout\n\t\t * events to indicate the object that the mouse entered from, mouseover/rollover for the object the mouse exited,\n\t\t * and stagemousedown/stagemouseup events for the object that was the under the cursor, if any.\n\t\t * \n\t\t * Only valid interaction targets will be returned (ie. objects with mouse listeners or a cursor set).\n\t\t * @property relatedTarget\n\t\t * @type {DisplayObject}\n\t\t */\n\t\tthis.relatedTarget = relatedTarget;\n\t}\n\tvar p = createjs.extend(MouseEvent, createjs.Event);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\t\n// getter / setters:\n\t/**\n\t * Returns the x position of the mouse in the local coordinate system of the current target (ie. the dispatcher).\n\t * @property localX\n\t * @type {Number}\n\t * @readonly\n\t */\n\tp._get_localX = function() {\n\t\treturn this.currentTarget.globalToLocal(this.rawX, this.rawY).x;\n\t};\n\t\n\t/**\n\t * Returns the y position of the mouse in the local coordinate system of the current target (ie. the dispatcher).\n\t * @property localY\n\t * @type {Number}\n\t * @readonly\n\t */\n\tp._get_localY = function() {\n\t\treturn this.currentTarget.globalToLocal(this.rawX, this.rawY).y;\n\t};\n\t\n\t/**\n\t * Indicates whether the event was generated by a touch input (versus a mouse input).\n\t * @property isTouch\n\t * @type {Boolean}\n\t * @readonly\n\t */\n\tp._get_isTouch = function() {\n\t\treturn this.pointerID !== -1;\n\t};\n\t\n\t\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tlocalX: { get: p._get_localX },\n\t\t\tlocalY: { get: p._get_localY },\n\t\t\tisTouch: { get: p._get_isTouch }\n\t\t});\n\t} catch (e) {} // TODO: use Log\n\n\n// public methods:\n\t/**\n\t * Returns a clone of the MouseEvent instance.\n\t * @method clone\n\t * @return {MouseEvent} a clone of the MouseEvent instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new MouseEvent(this.type, this.bubbles, this.cancelable, this.stageX, this.stageY, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[MouseEvent (type=\"+this.type+\" stageX=\"+this.stageX+\" stageY=\"+this.stageY+\")]\";\n\t};\n\n\n\tcreatejs.MouseEvent = createjs.promote(MouseEvent, \"Event\");\n}());\n\n//##############################################################################\n// Matrix2D.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.\n\t *\n\t * This matrix can be visualized as:\n\t *\n\t * \t[ a  c  tx\n\t * \t  b  d  ty\n\t * \t  0  0  1  ]\n\t *\n\t * Note the locations of b and c.\n\t *\n\t * @class Matrix2D\n\t * @param {Number} [a=1] Specifies the a property for the new matrix.\n\t * @param {Number} [b=0] Specifies the b property for the new matrix.\n\t * @param {Number} [c=0] Specifies the c property for the new matrix.\n\t * @param {Number} [d=1] Specifies the d property for the new matrix.\n\t * @param {Number} [tx=0] Specifies the tx property for the new matrix.\n\t * @param {Number} [ty=0] Specifies the ty property for the new matrix.\n\t * @constructor\n\t **/\n\tfunction Matrix2D(a, b, c, d, tx, ty) {\n\t\tthis.setValues(a,b,c,d,tx,ty);\n\t\t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * Position (0, 0) in a 3x3 affine transformation matrix.\n\t\t * @property a\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (0, 1) in a 3x3 affine transformation matrix.\n\t\t * @property b\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (1, 0) in a 3x3 affine transformation matrix.\n\t\t * @property c\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (1, 1) in a 3x3 affine transformation matrix.\n\t\t * @property d\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (2, 0) in a 3x3 affine transformation matrix.\n\t\t * @property tx\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (2, 1) in a 3x3 affine transformation matrix.\n\t\t * @property ty\n\t\t * @type Number\n\t\t **/\n\t}\n\tvar p = Matrix2D.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// constants:\n\t/**\n\t * Multiplier for converting degrees to radians. Used internally by Matrix2D.\n\t * @property DEG_TO_RAD\n\t * @static\n\t * @final\n\t * @type Number\n\t * @readonly\n\t **/\n\tMatrix2D.DEG_TO_RAD = Math.PI/180;\n\n\n// static public properties:\n\t/**\n\t * An identity matrix, representing a null transformation.\n\t * @property identity\n\t * @static\n\t * @type Matrix2D\n\t * @readonly\n\t **/\n\tMatrix2D.identity = null; // set at bottom of class definition.\n\t\n\n// public methods:\n\t/**\n\t * Sets the specified values on this instance. \n\t * @method setValues\n\t * @param {Number} [a=1] Specifies the a property for the new matrix.\n\t * @param {Number} [b=0] Specifies the b property for the new matrix.\n\t * @param {Number} [c=0] Specifies the c property for the new matrix.\n\t * @param {Number} [d=1] Specifies the d property for the new matrix.\n\t * @param {Number} [tx=0] Specifies the tx property for the new matrix.\n\t * @param {Number} [ty=0] Specifies the ty property for the new matrix.\n\t * @return {Matrix2D} This instance. Useful for chaining method calls.\n\t*/\n\tp.setValues = function(a, b, c, d, tx, ty) {\n\t\t// don't forget to update docs in the constructor if these change:\n\t\tthis.a = (a == null) ? 1 : a;\n\t\tthis.b = b || 0;\n\t\tthis.c = c || 0;\n\t\tthis.d = (d == null) ? 1 : d;\n\t\tthis.tx = tx || 0;\n\t\tthis.ty = ty || 0;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Appends the specified matrix properties to this matrix. All parameters are required.\n\t * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.\n\t * @method append\n\t * @param {Number} a\n\t * @param {Number} b\n\t * @param {Number} c\n\t * @param {Number} d\n\t * @param {Number} tx\n\t * @param {Number} ty\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.append = function(a, b, c, d, tx, ty) {\n\t\tvar a1 = this.a;\n\t\tvar b1 = this.b;\n\t\tvar c1 = this.c;\n\t\tvar d1 = this.d;\n\t\tif (a != 1 || b != 0 || c != 0 || d != 1) {\n\t\t\tthis.a  = a1*a+c1*b;\n\t\t\tthis.b  = b1*a+d1*b;\n\t\t\tthis.c  = a1*c+c1*d;\n\t\t\tthis.d  = b1*c+d1*d;\n\t\t}\n\t\tthis.tx = a1*tx+c1*ty+this.tx;\n\t\tthis.ty = b1*tx+d1*ty+this.ty;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Prepends the specified matrix properties to this matrix.\n\t * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.\n\t * All parameters are required.\n\t * @method prepend\n\t * @param {Number} a\n\t * @param {Number} b\n\t * @param {Number} c\n\t * @param {Number} d\n\t * @param {Number} tx\n\t * @param {Number} ty\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.prepend = function(a, b, c, d, tx, ty) {\n\t\tvar a1 = this.a;\n\t\tvar c1 = this.c;\n\t\tvar tx1 = this.tx;\n\n\t\tthis.a  = a*a1+c*this.b;\n\t\tthis.b  = b*a1+d*this.b;\n\t\tthis.c  = a*c1+c*this.d;\n\t\tthis.d  = b*c1+d*this.d;\n\t\tthis.tx = a*tx1+c*this.ty+tx;\n\t\tthis.ty = b*tx1+d*this.ty+ty;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Appends the specified matrix to this matrix.\n\t * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.\n\t * @method appendMatrix\n\t * @param {Matrix2D} matrix\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.appendMatrix = function(matrix) {\n\t\treturn this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n\t};\n\n\t/**\n\t * Prepends the specified matrix to this matrix.\n\t * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.\n\t * For example, you could calculate the combined transformation for a child object using:\n\t * \n\t * \tvar o = myDisplayObject;\n\t * \tvar mtx = o.getMatrix();\n\t * \twhile (o = o.parent) {\n\t * \t\t// prepend each parent's transformation in turn:\n\t * \t\to.prependMatrix(o.getMatrix());\n\t * \t}\n\t * @method prependMatrix\n\t * @param {Matrix2D} matrix\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.prependMatrix = function(matrix) {\n\t\treturn this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n\t};\n\n\t/**\n\t * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.\n\t * For example, you can use this to generate a matrix representing the transformations of a display object:\n\t * \n\t * \tvar mtx = new createjs.Matrix2D();\n\t * \tmtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);\n\t * @method appendTransform\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} scaleX\n\t * @param {Number} scaleY\n\t * @param {Number} rotation\n\t * @param {Number} skewX\n\t * @param {Number} skewY\n\t * @param {Number} regX Optional.\n\t * @param {Number} regY Optional.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.appendTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n\t\tif (rotation%360) {\n\t\t\tvar r = rotation*Matrix2D.DEG_TO_RAD;\n\t\t\tvar cos = Math.cos(r);\n\t\t\tvar sin = Math.sin(r);\n\t\t} else {\n\t\t\tcos = 1;\n\t\t\tsin = 0;\n\t\t}\n\n\t\tif (skewX || skewY) {\n\t\t\t// TODO: can this be combined into a single append operation?\n\t\t\tskewX *= Matrix2D.DEG_TO_RAD;\n\t\t\tskewY *= Matrix2D.DEG_TO_RAD;\n\t\t\tthis.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\n\t\t\tthis.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);\n\t\t} else {\n\t\t\tthis.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);\n\t\t}\n\t\t\n\t\tif (regX || regY) {\n\t\t\t// append the registration offset:\n\t\t\tthis.tx -= regX*this.a+regY*this.c; \n\t\t\tthis.ty -= regX*this.b+regY*this.d;\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Generates matrix properties from the specified display object transform properties, and prepends them to this matrix.\n\t * For example, you could calculate the combined transformation for a child object using:\n\t * \n\t * \tvar o = myDisplayObject;\n\t * \tvar mtx = new createjs.Matrix2D();\n\t * \tdo  {\n\t * \t\t// prepend each parent's transformation in turn:\n\t * \t\tmtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);\n\t * \t} while (o = o.parent);\n\t * \t\n\t * \tNote that the above example would not account for {{#crossLink \"DisplayObject/transformMatrix:property\"}}{{/crossLink}}\n\t * \tvalues. See {{#crossLink \"Matrix2D/prependMatrix\"}}{{/crossLink}} for an example that does.\n\t * @method prependTransform\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} scaleX\n\t * @param {Number} scaleY\n\t * @param {Number} rotation\n\t * @param {Number} skewX\n\t * @param {Number} skewY\n\t * @param {Number} regX Optional.\n\t * @param {Number} regY Optional.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.prependTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n\t\tif (rotation%360) {\n\t\t\tvar r = rotation*Matrix2D.DEG_TO_RAD;\n\t\t\tvar cos = Math.cos(r);\n\t\t\tvar sin = Math.sin(r);\n\t\t} else {\n\t\t\tcos = 1;\n\t\t\tsin = 0;\n\t\t}\n\n\t\tif (regX || regY) {\n\t\t\t// prepend the registration offset:\n\t\t\tthis.tx -= regX; this.ty -= regY;\n\t\t}\n\t\tif (skewX || skewY) {\n\t\t\t// TODO: can this be combined into a single prepend operation?\n\t\t\tskewX *= Matrix2D.DEG_TO_RAD;\n\t\t\tskewY *= Matrix2D.DEG_TO_RAD;\n\t\t\tthis.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);\n\t\t\tthis.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\n\t\t} else {\n\t\t\tthis.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Applies a clockwise rotation transformation to the matrix.\n\t * @method rotate\n\t * @param {Number} angle The angle to rotate by, in degrees. To use a value in radians, multiply it by `180/Math.PI`.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.rotate = function(angle) {\n\t\tangle = angle*Matrix2D.DEG_TO_RAD;\n\t\tvar cos = Math.cos(angle);\n\t\tvar sin = Math.sin(angle);\n\n\t\tvar a1 = this.a;\n\t\tvar b1 = this.b;\n\n\t\tthis.a = a1*cos+this.c*sin;\n\t\tthis.b = b1*cos+this.d*sin;\n\t\tthis.c = -a1*sin+this.c*cos;\n\t\tthis.d = -b1*sin+this.d*cos;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Applies a skew transformation to the matrix.\n\t * @method skew\n\t * @param {Number} skewX The amount to skew horizontally in degrees. To use a value in radians, multiply it by `180/Math.PI`.\n\t * @param {Number} skewY The amount to skew vertically in degrees.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t*/\n\tp.skew = function(skewX, skewY) {\n\t\tskewX = skewX*Matrix2D.DEG_TO_RAD;\n\t\tskewY = skewY*Matrix2D.DEG_TO_RAD;\n\t\tthis.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Applies a scale transformation to the matrix.\n\t * @method scale\n\t * @param {Number} x The amount to scale horizontally. E.G. a value of 2 will double the size in the X direction, and 0.5 will halve it.\n\t * @param {Number} y The amount to scale vertically.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.scale = function(x, y) {\n\t\tthis.a *= x;\n\t\tthis.b *= x;\n\t\tthis.c *= y;\n\t\tthis.d *= y;\n\t\t//this.tx *= x;\n\t\t//this.ty *= y;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Translates the matrix on the x and y axes.\n\t * @method translate\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.translate = function(x, y) {\n\t\tthis.tx += this.a*x + this.c*y;\n\t\tthis.ty += this.b*x + this.d*y;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).\n\t * @method identity\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.identity = function() {\n\t\tthis.a = this.d = 1;\n\t\tthis.b = this.c = this.tx = this.ty = 0;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Inverts the matrix, causing it to perform the opposite transformation.\n\t * @method invert\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.invert = function() {\n\t\tvar a1 = this.a;\n\t\tvar b1 = this.b;\n\t\tvar c1 = this.c;\n\t\tvar d1 = this.d;\n\t\tvar tx1 = this.tx;\n\t\tvar n = a1*d1-b1*c1;\n\n\t\tthis.a = d1/n;\n\t\tthis.b = -b1/n;\n\t\tthis.c = -c1/n;\n\t\tthis.d = a1/n;\n\t\tthis.tx = (c1*this.ty-d1*tx1)/n;\n\t\tthis.ty = -(a1*this.ty-b1*tx1)/n;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns true if the matrix is an identity matrix.\n\t * @method isIdentity\n\t * @return {Boolean}\n\t **/\n\tp.isIdentity = function() {\n\t\treturn this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;\n\t};\n\t\n\t/**\n\t * Returns true if this matrix is equal to the specified matrix (all property values are equal).\n\t * @method equals\n\t * @param {Matrix2D} matrix The matrix to compare.\n\t * @return {Boolean}\n\t **/\n\tp.equals = function(matrix) {\n\t\treturn this.tx === matrix.tx && this.ty === matrix.ty && this.a === matrix.a && this.b === matrix.b && this.c === matrix.c && this.d === matrix.d;\n\t};\n\n\t/**\n\t * Transforms a point according to this matrix.\n\t * @method transformPoint\n\t * @param {Number} x The x component of the point to transform.\n\t * @param {Number} y The y component of the point to transform.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a generic object with x/y properties will be returned.\n\t * @return {Point} This matrix. Useful for chaining method calls.\n\t **/\n\tp.transformPoint = function(x, y, pt) {\n\t\tpt = pt||{};\n\t\tpt.x = x*this.a+y*this.c+this.tx;\n\t\tpt.y = x*this.b+y*this.d+this.ty;\n\t\treturn pt;\n\t};\n\n\t/**\n\t * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that these values\n\t * may not match the transform properties you used to generate the matrix, though they will produce the same visual\n\t * results.\n\t * @method decompose\n\t * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.\n\t * @return {Object} The target, or a new generic object with the transform properties applied.\n\t*/\n\tp.decompose = function(target) {\n\t\t// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation even when scale is negative\n\t\tif (target == null) { target = {}; }\n\t\ttarget.x = this.tx;\n\t\ttarget.y = this.ty;\n\t\ttarget.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);\n\t\ttarget.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);\n\n\t\tvar skewX = Math.atan2(-this.c, this.d);\n\t\tvar skewY = Math.atan2(this.b, this.a);\n\n\t\tvar delta = Math.abs(1-skewX/skewY);\n\t\tif (delta < 0.00001) { // effectively identical, can use rotation:\n\t\t\ttarget.rotation = skewY/Matrix2D.DEG_TO_RAD;\n\t\t\tif (this.a < 0 && this.d >= 0) {\n\t\t\t\ttarget.rotation += (target.rotation <= 0) ? 180 : -180;\n\t\t\t}\n\t\t\ttarget.skewX = target.skewY = 0;\n\t\t} else {\n\t\t\ttarget.skewX = skewX/Matrix2D.DEG_TO_RAD;\n\t\t\ttarget.skewY = skewY/Matrix2D.DEG_TO_RAD;\n\t\t}\n\t\treturn target;\n\t};\n\t\n\t/**\n\t * Copies all properties from the specified matrix to this matrix.\n\t * @method copy\n\t * @param {Matrix2D} matrix The matrix to copy properties from.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t*/\n\tp.copy = function(matrix) {\n\t\treturn this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n\t};\n\n\t/**\n\t * Returns a clone of the Matrix2D instance.\n\t * @method clone\n\t * @return {Matrix2D} a clone of the Matrix2D instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Matrix2D(this.a, this.b, this.c, this.d, this.tx, this.ty);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Matrix2D (a=\"+this.a+\" b=\"+this.b+\" c=\"+this.c+\" d=\"+this.d+\" tx=\"+this.tx+\" ty=\"+this.ty+\")]\";\n\t};\n\n\t// this has to be populated after the class is defined:\n\tMatrix2D.identity = new Matrix2D();\n\n\n\tcreatejs.Matrix2D = Matrix2D;\n}());\n\n//##############################################################################\n// DisplayProps.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * Used for calculating and encapsulating display related properties.\n\t * @class DisplayProps\n\t * @param {Number} [visible=true] Visible value.\n\t * @param {Number} [alpha=1] Alpha value.\n\t * @param {Number} [shadow=null] A Shadow instance or null.\n\t * @param {Number} [compositeOperation=null] A compositeOperation value or null.\n\t * @param {Number} [matrix] A transformation matrix. Defaults to a new identity matrix.\n\t * @constructor\n\t **/\n\tfunction DisplayProps(visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.setValues(visible, alpha, shadow, compositeOperation, matrix);\n\t\t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * Property representing the alpha that will be applied to a display object.\n\t\t * @property alpha\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Property representing the shadow that will be applied to a display object.\n\t\t * @property shadow\n\t\t * @type Shadow\n\t\t **/\n\t\n\t\t/**\n\t\t * Property representing the compositeOperation that will be applied to a display object.\n\t\t * You can find a list of valid composite operations at:\n\t\t * <a href=\"https://developer.mozilla.org/en/Canvas_tutorial/Compositing\">https://developer.mozilla.org/en/Canvas_tutorial/Compositing</a>\n\t\t * @property compositeOperation\n\t\t * @type String\n\t\t **/\n\t\t\n\t\t/**\n\t\t * Property representing the value for visible that will be applied to a display object.\n\t\t * @property visible\n\t\t * @type Boolean\n\t\t **/\n\t\t\n\t\t/**\n\t\t * The transformation matrix that will be applied to a display object.\n\t\t * @property matrix\n\t\t * @type Matrix2D\n\t\t **/\n\t}\n\tvar p = DisplayProps.prototype;\n\n// initialization:\n\t/**\n\t * Reinitializes the instance with the specified values.\n\t * @method setValues\n\t * @param {Number} [visible=true] Visible value.\n\t * @param {Number} [alpha=1] Alpha value.\n\t * @param {Number} [shadow=null] A Shadow instance or null.\n\t * @param {Number} [compositeOperation=null] A compositeOperation value or null.\n\t * @param {Number} [matrix] A transformation matrix. Defaults to an identity matrix.\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.setValues = function (visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.visible = visible == null ? true : !!visible;\n\t\tthis.alpha = alpha == null ? 1 : alpha;\n\t\tthis.shadow = shadow;\n\t\tthis.compositeOperation = compositeOperation;\n\t\tthis.matrix = matrix || (this.matrix&&this.matrix.identity()) || new createjs.Matrix2D();\n\t\treturn this;\n\t};\n\n// public methods:\n\t/**\n\t * Appends the specified display properties. This is generally used to apply a child's properties its parent's.\n\t * @method append\n\t * @param {Boolean} visible desired visible value\n\t * @param {Number} alpha desired alpha value\n\t * @param {Shadow} shadow desired shadow value\n\t * @param {String} compositeOperation desired composite operation value\n\t * @param {Matrix2D} [matrix] a Matrix2D instance\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.append = function(visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.alpha *= alpha;\n\t\tthis.shadow = shadow || this.shadow;\n\t\tthis.compositeOperation = compositeOperation || this.compositeOperation;\n\t\tthis.visible = this.visible && visible;\n\t\tmatrix&&this.matrix.appendMatrix(matrix);\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Prepends the specified display properties. This is generally used to apply a parent's properties to a child's.\n\t * For example, to get the combined display properties that would be applied to a child, you could use:\n\t * \n\t * \tvar o = myDisplayObject;\n\t * \tvar props = new createjs.DisplayProps();\n\t * \tdo {\n\t * \t\t// prepend each parent's props in turn:\n\t * \t\tprops.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation, o.getMatrix());\n\t * \t} while (o = o.parent);\n\t * \t\n\t * @method prepend\n\t * @param {Boolean} visible desired visible value\n\t * @param {Number} alpha desired alpha value\n\t * @param {Shadow} shadow desired shadow value\n\t * @param {String} compositeOperation desired composite operation value\n\t * @param {Matrix2D} [matrix] a Matrix2D instance\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.prepend = function(visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.alpha *= alpha;\n\t\tthis.shadow = this.shadow || shadow;\n\t\tthis.compositeOperation = this.compositeOperation || compositeOperation;\n\t\tthis.visible = this.visible && visible;\n\t\tmatrix&&this.matrix.prependMatrix(matrix);\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Resets this instance and its matrix to default values.\n\t * @method identity\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.identity = function() {\n\t\tthis.visible = true;\n\t\tthis.alpha = 1;\n\t\tthis.shadow = this.compositeOperation = null;\n\t\tthis.matrix.identity();\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a clone of the DisplayProps instance. Clones the associated matrix.\n\t * @method clone\n\t * @return {DisplayProps} a clone of the DisplayProps instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new DisplayProps(this.alpha, this.shadow, this.compositeOperation, this.visible, this.matrix.clone());\n\t};\n\n// private methods:\n\n\tcreatejs.DisplayProps = DisplayProps;\n})();\n\n//##############################################################################\n// Point.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Represents a point on a 2 dimensional x / y coordinate system.\n\t *\n\t * <h4>Example</h4>\n\t * \n\t *      var point = new createjs.Point(0, 100);\n\t * \n\t * @class Point\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @constructor\n\t **/\n\tfunction Point(x, y) {\n\t \tthis.setValues(x, y);\n\t \t\n\t \t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * X position.\n\t\t * @property x\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Y position.\n\t\t * @property y\n\t\t * @type Number\n\t\t **/\n\t}\n\tvar p = Point.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\t\n// public methods:\n\t/** \n\t * Sets the specified values on this instance.\n\t * @method setValues\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @return {Point} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.setValues = function(x, y) {\n\t\tthis.x = x||0;\n\t\tthis.y = y||0;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Copies all properties from the specified point to this point.\n\t * @method copy\n\t * @param {Point} point The point to copy properties from.\n\t * @return {Point} This point. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.copy = function(point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Point instance.\n\t * @method clone\n\t * @return {Point} a clone of the Point instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Point(this.x, this.y);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Point (x=\"+this.x+\" y=\"+this.y+\")]\";\n\t};\n\t\n\t\n\tcreatejs.Point = Point;\n}());\n\n//##############################################################################\n// Rectangle.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Represents a rectangle as defined by the points (x, y) and (x+width, y+height).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var rect = new createjs.Rectangle(0, 0, 100, 100);\n\t *\n\t * @class Rectangle\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @param {Number} [width=0] The width of the Rectangle.\n\t * @param {Number} [height=0] The height of the Rectangle.\n\t * @constructor\n\t **/\n\tfunction Rectangle(x, y, width, height) {\n\t\tthis.setValues(x, y, width, height);\n\t\t\n\t\t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * X position.\n\t\t * @property x\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Y position.\n\t\t * @property y\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Width.\n\t\t * @property width\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Height.\n\t\t * @property height\n\t\t * @type Number\n\t\t **/\n\t}\n\tvar p = Rectangle.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// public methods:\n\t/** \n\t * Sets the specified values on this instance.\n\t * @method setValues\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @param {Number} [width=0] The width of the Rectangle.\n\t * @param {Number} [height=0] The height of the Rectangle.\n\t * @return {Rectangle} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.setValues = function(x, y, width, height) {\n\t\t// don't forget to update docs in the constructor if these change:\n\t\tthis.x = x||0;\n\t\tthis.y = y||0;\n\t\tthis.width = width||0;\n\t\tthis.height = height||0;\n\t\treturn this;\n\t};\n\t\n\t/** \n\t * Extends the rectangle's bounds to include the described point or rectangle.\n\t * @method extend\n\t * @param {Number} x X position of the point or rectangle.\n\t * @param {Number} y Y position of the point or rectangle.\n\t * @param {Number} [width=0] The width of the rectangle.\n\t * @param {Number} [height=0] The height of the rectangle.\n\t * @return {Rectangle} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.extend = function(x, y, width, height) {\n\t\twidth = width||0;\n\t\theight = height||0;\n\t\tif (x+width > this.x+this.width) { this.width = x+width-this.x; }\n\t\tif (y+height > this.y+this.height) { this.height = y+height-this.y; }\n\t\tif (x < this.x) { this.width += this.x-x; this.x = x; }\n\t\tif (y < this.y) { this.height += this.y-y; this.y = y; }\n\t\treturn this;\n\t};\n\t\n\t/** \n\t * Adds the specified padding to the rectangle's bounds.\n\t * @method pad\n\t * @param {Number} top\n\t * @param {Number} left\n\t * @param {Number} right\n\t * @param {Number} bottom\n\t * @return {Rectangle} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.pad = function(top, left, bottom, right) {\n\t\tthis.x -= left;\n\t\tthis.y -= top;\n\t\tthis.width += left+right;\n\t\tthis.height += top+bottom;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Copies all properties from the specified rectangle to this rectangle.\n\t * @method copy\n\t * @param {Rectangle} rectangle The rectangle to copy properties from.\n\t * @return {Rectangle} This rectangle. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.copy = function(rectangle) {\n\t\treturn this.setValues(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n\t};\n\t\n\t/** \n\t * Returns true if this rectangle fully encloses the described point or rectangle.\n\t * @method contains\n\t * @param {Number} x X position of the point or rectangle.\n\t * @param {Number} y Y position of the point or rectangle.\n\t * @param {Number} [width=0] The width of the rectangle.\n\t * @param {Number} [height=0] The height of the rectangle.\n\t * @return {Boolean} True if the described point or rectangle is contained within this rectangle.\n\t*/\n\tp.contains = function(x, y, width, height) {\n\t\twidth = width||0;\n\t\theight = height||0;\n\t\treturn (x >= this.x && x+width <= this.x+this.width && y >= this.y && y+height <= this.y+this.height);\n\t};\n\t\n\t/** \n\t * Returns a new rectangle which contains this rectangle and the specified rectangle.\n\t * @method union\n\t * @param {Rectangle} rect The rectangle to calculate a union with.\n\t * @return {Rectangle} A new rectangle describing the union.\n\t*/\n\tp.union = function(rect) {\n\t\treturn this.clone().extend(rect.x, rect.y, rect.width, rect.height);\n\t};\n\t\n\t/** \n\t * Returns a new rectangle which describes the intersection (overlap) of this rectangle and the specified rectangle,\n\t * or null if they do not intersect.\n\t * @method intersection\n\t * @param {Rectangle} rect The rectangle to calculate an intersection with.\n\t * @return {Rectangle} A new rectangle describing the intersection or null.\n\t*/\n\tp.intersection = function(rect) {\n\t\tvar x1 = rect.x, y1 = rect.y, x2 = x1+rect.width, y2 = y1+rect.height;\n\t\tif (this.x > x1) { x1 = this.x; }\n\t\tif (this.y > y1) { y1 = this.y; }\n\t\tif (this.x + this.width < x2) { x2 = this.x + this.width; }\n\t\tif (this.y + this.height < y2) { y2 = this.y + this.height; }\n\t\treturn (x2 <= x1 || y2 <= y1) ? null : new Rectangle(x1, y1, x2-x1, y2-y1);\n\t};\n\t\n\t/** \n\t * Returns true if the specified rectangle intersects (has any overlap) with this rectangle.\n\t * @method intersects\n\t * @param {Rectangle} rect The rectangle to compare.\n\t * @return {Boolean} True if the rectangles intersect.\n\t*/\n\tp.intersects = function(rect) {\n\t\treturn (rect.x <= this.x+this.width && this.x <= rect.x+rect.width && rect.y <= this.y+this.height && this.y <= rect.y + rect.height);\n\t};\n\t\n\t/** \n\t * Returns true if the width or height are equal or less than 0.\n\t * @method isEmpty\n\t * @return {Boolean} True if the rectangle is empty.\n\t*/\n\tp.isEmpty = function() {\n\t\treturn this.width <= 0 || this.height <= 0;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Rectangle instance.\n\t * @method clone\n\t * @return {Rectangle} a clone of the Rectangle instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Rectangle(this.x, this.y, this.width, this.height);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Rectangle (x=\"+this.x+\" y=\"+this.y+\" width=\"+this.width+\" height=\"+this.height+\")]\";\n\t};\n\t\n\t\n\tcreatejs.Rectangle = Rectangle;\n}());\n\n//##############################################################################\n// ButtonHelper.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The ButtonHelper is a helper class to create interactive buttons from {{#crossLink \"MovieClip\"}}{{/crossLink}} or\n\t * {{#crossLink \"Sprite\"}}{{/crossLink}} instances. This class will intercept mouse events from an object, and\n\t * automatically call {{#crossLink \"Sprite/gotoAndStop\"}}{{/crossLink}} or {{#crossLink \"Sprite/gotoAndPlay\"}}{{/crossLink}},\n\t * to the respective animation labels, add a pointer cursor, and allows the user to define a hit state frame.\n\t *\n\t * The ButtonHelper instance does not need to be added to the stage, but a reference should be maintained to prevent\n\t * garbage collection.\n\t * \n\t * Note that over states will not work unless you call {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var helper = new createjs.ButtonHelper(myInstance, \"out\", \"over\", \"down\", false, myInstance, \"hit\");\n\t *      myInstance.addEventListener(\"click\", handleClick);\n\t *      function handleClick(event) {\n\t *          // Click Happened.\n\t *      }\n\t *\n\t * @class ButtonHelper\n\t * @param {Sprite|MovieClip} target The instance to manage.\n\t * @param {String} [outLabel=\"out\"] The label or animation to go to when the user rolls out of the button.\n\t * @param {String} [overLabel=\"over\"] The label or animation to go to when the user rolls over the button.\n\t * @param {String} [downLabel=\"down\"] The label or animation to go to when the user presses the button.\n\t * @param {Boolean} [play=false] If the helper should call \"gotoAndPlay\" or \"gotoAndStop\" on the button when changing\n\t * states.\n\t * @param {DisplayObject} [hitArea] An optional item to use as the hit state for the button. If this is not defined,\n\t * then the button's visible states will be used instead. Note that the same instance as the \"target\" argument can be\n\t * used for the hitState.\n\t * @param {String} [hitLabel] The label or animation on the hitArea instance that defines the hitArea bounds. If this is\n\t * null, then the default state of the hitArea will be used. *\n\t * @constructor\n\t */\n\tfunction ButtonHelper(target, outLabel, overLabel, downLabel, play, hitArea, hitLabel) {\n\t\tif (!target.addEventListener) { return; }\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The target for this button helper.\n\t\t * @property target\n\t\t * @type MovieClip | Sprite\n\t\t * @readonly\n\t\t **/\n\t\tthis.target = target;\n\t\n\t\t/**\n\t\t * The label name or frame number to display when the user mouses out of the target. Defaults to \"over\".\n\t\t * @property overLabel\n\t\t * @type String | Number\n\t\t **/\n\t\tthis.overLabel = overLabel == null ? \"over\" : overLabel;\n\t\n\t\t/**\n\t\t * The label name or frame number to display when the user mouses over the target. Defaults to \"out\".\n\t\t * @property outLabel\n\t\t * @type String | Number\n\t\t **/\n\t\tthis.outLabel = outLabel == null ? \"out\" : outLabel;\n\t\n\t\t/**\n\t\t * The label name or frame number to display when the user presses on the target. Defaults to \"down\".\n\t\t * @property downLabel\n\t\t * @type String | Number\n\t\t **/\n\t\tthis.downLabel = downLabel == null ? \"down\" : downLabel;\n\t\n\t\t/**\n\t\t * If true, then ButtonHelper will call gotoAndPlay, if false, it will use gotoAndStop. Default is false.\n\t\t * @property play\n\t\t * @default false\n\t\t * @type Boolean\n\t\t **/\n\t\tthis.play = play;\n\t\t\n\t\t\n\t//  private properties\n\t\t/**\n\t\t * @property _isPressed\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._isPressed = false;\n\t\n\t\t/**\n\t\t * @property _isOver\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._isOver = false;\n\t\n\t\t/**\n\t\t * @property _enabled\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._enabled = false;\n\t\t\n\t// setup:\n\t\ttarget.mouseChildren = false; // prevents issues when children are removed from the display list when state changes.\n\t\tthis.enabled = true;\n\t\tthis.handleEvent({});\n\t\tif (hitArea) {\n\t\t\tif (hitLabel) {\n\t\t\t\thitArea.actionsEnabled = false;\n\t\t\t\thitArea.gotoAndStop&&hitArea.gotoAndStop(hitLabel);\n\t\t\t}\n\t\t\ttarget.hitArea = hitArea;\n\t\t}\n\t}\n\tvar p = ButtonHelper.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"ButtonHelper/enabled:property\"}}{{/crossLink}} property instead.\n\t * @method setEnabled\n\t * @param {Boolean} value\n\t * @deprecated\n\t **/\n\tp.setEnabled = function(value) { // TODO: deprecated.\n\t\tif (value == this._enabled) { return; }\n\t\tvar o = this.target;\n\t\tthis._enabled = value;\n\t\tif (value) {\n\t\t\to.cursor = \"pointer\";\n\t\t\to.addEventListener(\"rollover\", this);\n\t\t\to.addEventListener(\"rollout\", this);\n\t\t\to.addEventListener(\"mousedown\", this);\n\t\t\to.addEventListener(\"pressup\", this);\n\t\t\tif (o._reset) { o.__reset = o._reset; o._reset = this._reset;}\n\t\t} else {\n\t\t\to.cursor = null;\n\t\t\to.removeEventListener(\"rollover\", this);\n\t\t\to.removeEventListener(\"rollout\", this);\n\t\t\to.removeEventListener(\"mousedown\", this);\n\t\t\to.removeEventListener(\"pressup\", this);\n\t\t\tif (o.__reset) { o._reset = o.__reset; delete(o.__reset); }\n\t\t}\n\t};\n\t/**\n\t * Use the {{#crossLink \"ButtonHelper/enabled:property\"}}{{/crossLink}} property instead.\n\t * @method getEnabled\n\t * @return {Boolean}\n\t * @deprecated\n\t **/\n\tp.getEnabled = function() {\n\t\treturn this._enabled;\n\t};\n\n\t/**\n\t * Enables or disables the button functionality on the target.\n\t * @property enabled\n\t * @type {Boolean}\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tenabled: { get: p.getEnabled, set: p.setEnabled }\n\t\t});\n\t} catch (e) {} // TODO: use Log\n\n\n// public methods:\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[ButtonHelper]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method handleEvent\n\t * @param {Object} evt The mouse event to handle.\n\t * @protected\n\t **/\n\tp.handleEvent = function(evt) {\n\t\tvar label, t = this.target, type = evt.type;\n\t\tif (type == \"mousedown\") {\n\t\t\tthis._isPressed = true;\n\t\t\tlabel = this.downLabel;\n\t\t} else if (type == \"pressup\") {\n\t\t\tthis._isPressed = false;\n\t\t\tlabel = this._isOver ? this.overLabel : this.outLabel;\n\t\t} else if (type == \"rollover\") {\n\t\t\tthis._isOver = true;\n\t\t\tlabel = this._isPressed ? this.downLabel : this.overLabel;\n\t\t} else { // rollout and default\n\t\t\tthis._isOver = false;\n\t\t\tlabel = this._isPressed ? this.overLabel : this.outLabel;\n\t\t}\n\t\tif (this.play) {\n\t\t\tt.gotoAndPlay&&t.gotoAndPlay(label);\n\t\t} else {\n\t\t\tt.gotoAndStop&&t.gotoAndStop(label);\n\t\t}\n\t};\n\t\n\t/**\n\t * Injected into target. Preserves the paused state through a reset.\n\t * @method _reset\n\t * @protected\n\t **/\n\tp._reset = function() {\n\t\t// TODO: explore better ways to handle this issue. This is hacky & disrupts object signatures.\n\t\tvar p = this.paused;\n\t\tthis.__reset();\n\t\tthis.paused = p;\n\t};\n\n\n\tcreatejs.ButtonHelper = ButtonHelper;\n}());\n\n//##############################################################################\n// Shadow.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * This class encapsulates the properties required to define a shadow to apply to a {{#crossLink \"DisplayObject\"}}{{/crossLink}}\n\t * via its <code>shadow</code> property.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myImage.shadow = new createjs.Shadow(\"#000000\", 5, 5, 10);\n\t *\n\t * @class Shadow\n\t * @constructor\n\t * @param {String} color The color of the shadow. This can be any valid CSS color value.\n\t * @param {Number} offsetX The x offset of the shadow in pixels.\n\t * @param {Number} offsetY The y offset of the shadow in pixels.\n\t * @param {Number} blur The size of the blurring effect.\n\t **/\n\tfunction Shadow(color, offsetX, offsetY, blur) {\n\t\t\n\t\t\n\t// public properties:\n\t\t/** \n\t\t * The color of the shadow. This can be any valid CSS color value.\n\t\t * @property color\n\t\t * @type String\n\t\t * @default null\n\t\t */\n\t\tthis.color = color||\"black\";\n\t\n\t\t/** The x offset of the shadow.\n\t\t * @property offsetX\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.offsetX = offsetX||0;\n\t\n\t\t/** The y offset of the shadow.\n\t\t * @property offsetY\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.offsetY = offsetY||0;\n\t\n\t\t/** The blur of the shadow.\n\t\t * @property blur\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.blur = blur||0;\n\t}\n\tvar p = Shadow.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// static public properties:\n\t/**\n\t * An identity shadow object (all properties are set to 0).\n\t * @property identity\n\t * @type Shadow\n\t * @static\n\t * @final\n\t * @readonly\n\t **/\n\tShadow.identity = new Shadow(\"transparent\", 0, 0, 0);\n\n\n// public methods:\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Shadow]\";\n\t};\n\n\t/**\n\t * Returns a clone of this Shadow instance.\n\t * @method clone\n\t * @return {Shadow} A clone of the current Shadow instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Shadow(this.color, this.offsetX, this.offsetY, this.blur);\n\t};\n\t\n\n\tcreatejs.Shadow = Shadow;\n}());\n\n//##############################################################################\n// SpriteSheet.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Encapsulates the properties and methods associated with a sprite sheet. A sprite sheet is a series of images (usually\n\t * animation frames) combined into a larger image (or images). For example, an animation consisting of eight 100x100\n\t * images could be combined into a single 400x200 sprite sheet (4 frames across by 2 high).\n\t *\n\t * The data passed to the SpriteSheet constructor defines:\n\t * <ol>\n\t * \t<li> The source image or images to use.</li>\n\t * \t<li> The positions of individual image frames.</li>\n\t * \t<li> Sequences of frames that form named animations. Optional.</li>\n\t * \t<li> The target playback framerate. Optional.</li>\n\t * </ol>\n\t * <h3>SpriteSheet Format</h3>\n\t * SpriteSheets are an object with two required properties (`images` and `frames`), and two optional properties\n\t * (`framerate` and `animations`). This makes them easy to define in javascript code, or in JSON.\n\t *\n\t * <h4>images</h4>\n\t * An array of source images. Images can be either an HTMlimage\n\t * instance, or a uri to an image. The former is recommended to control preloading.\n\t *\n\t * \timages: [image1, \"path/to/image2.png\"],\n\t *\n\t * <h4>frames</h4>\n\t * Defines the individual frames. There are two supported formats for frame data:\n\t * When all of the frames are the same size (in a grid), use an object with `width`, `height`, `regX`, `regY`,\n\t * and `count` properties.\n\t *\n\t * <ul>\n\t *  <li>`width` & `height` are required and specify the dimensions of the frames</li>\n\t *  <li>`regX` & `regY` indicate the registration point or \"origin\" of the frames</li>\n\t *  <li>`spacing` indicate the spacing between frames</li>\n\t *  <li>`margin` specify the margin around the image(s)</li>\n\t *  <li>`count` allows you to specify the total number of frames in the spritesheet; if omitted, this will\n\t *  be calculated based on the dimensions of the source images and the frames. Frames will be assigned\n\t *  indexes based on their position in the source images (left to right, top to bottom).</li>\n\t * </ul>\n\t *\n\t *  \tframes: {width:64, height:64, count:20, regX: 32, regY:64, spacing:0, margin:0}\n\t *\n\t * If the frames are of different sizes, use an array of frame definitions. Each definition is itself an array\n\t * with 4 required and 3 optional entries, in the order:\n\t *\n\t * <ul>\n\t *  <li>The first four, `x`, `y`, `width`, and `height` are required and define the frame rectangle.</li>\n\t *  <li>The fifth, `imageIndex`, specifies the index of the source image (defaults to 0)</li>\n\t *  <li>The last two, `regX` and `regY` specify the registration point of the frame</li>\n\t * </ul>\n\t *\n\t * \tframes: [\n\t * \t\t// x, y, width, height, imageIndex*, regX*, regY*\n\t * \t\t[64, 0, 96, 64],\n\t * \t\t[0, 0, 64, 64, 1, 32, 32]\n\t * \t\t// etc.\n\t * \t]\n\t *\n\t * <h4>animations</h4>\n\t * Optional. An object defining sequences of frames to play as named animations. Each property corresponds to an\n\t * animation of the same name. Each animation must specify the frames to play, and may\n\t * also include a relative playback `speed` (ex. 2 would playback at double speed, 0.5 at half), and\n\t * the name of the `next` animation to sequence to after it completes.\n\t *\n\t * There are three formats supported for defining the frames in an animation, which can be mixed and matched as appropriate:\n\t * <ol>\n\t * \t<li>for a single frame animation, you can simply specify the frame index\n\t *\n\t * \t\tanimations: {\n\t * \t\t\tsit: 7\n\t * \t\t}\n\t *\n\t * </li>\n\t * <li>\n\t *      for an animation of consecutive frames, you can use an array with two required, and two optional entries\n\t * \t\tin the order: `start`, `end`, `next`, and `speed`. This will play the frames from start to end inclusive.\n\t *\n\t * \t\tanimations: {\n\t * \t\t\t// start, end, next*, speed*\n\t * \t\t\trun: [0, 8],\n\t * \t\t\tjump: [9, 12, \"run\", 2]\n\t * \t\t}\n\t *\n\t *  </li>\n\t *  <li>\n\t *     for non-consecutive frames, you can use an object with a `frames` property defining an array of frame\n\t *     indexes to play in order. The object can also specify `next` and `speed` properties.\n\t *\n\t * \t\tanimations: {\n\t * \t\t\twalk: {\n\t * \t\t\t\tframes: [1,2,3,3,2,1]\n\t * \t\t\t},\n\t * \t\t\tshoot: {\n\t * \t\t\t\tframes: [1,4,5,6],\n\t * \t\t\t\tnext: \"walk\",\n\t * \t\t\t\tspeed: 0.5\n\t * \t\t\t}\n\t * \t\t}\n\t *\n\t *  </li>\n\t * </ol>\n\t * <strong>Note:</strong> the `speed` property was added in EaselJS 0.7.0. Earlier versions had a `frequency`\n\t * property instead, which was the inverse of `speed`. For example, a value of \"4\" would be 1/4 normal speed in\n\t * earlier versions, but is 4x normal speed in EaselJS 0.7.0+.\n\t *\n\t * <h4>framerate</h4>\n\t * Optional. Indicates the default framerate to play this spritesheet at in frames per second. See\n\t * {{#crossLink \"SpriteSheet/framerate:property\"}}{{/crossLink}} for more information.\n\t *\n\t * \t\tframerate: 20\n\t *\n\t * Note that the Sprite framerate will only work if the stage update method is provided with the {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}}\n\t * event generated by the {{#crossLink \"Ticker\"}}{{/crossLink}}.\n\t *\n\t * \t\tcreatejs.Ticker.on(\"tick\", handleTick);\n\t * \t\tfunction handleTick(event) {\n\t *\t\t\tstage.update(event);\n\t *\t\t}\n\t *\n\t * <h3>Example</h3>\n\t * To define a simple sprite sheet, with a single image \"sprites.jpg\" arranged in a regular 50x50 grid with three\n\t * animations: \"stand\" showing the first frame, \"run\" looping frame 1-5 inclusive, and \"jump\" playing frame 6-8 and\n\t * sequencing back to run.\n\t *\n\t * \t\tvar data = {\n\t * \t\t\timages: [\"sprites.jpg\"],\n\t * \t\t\tframes: {width:50, height:50},\n\t * \t\t\tanimations: {\n\t * \t\t\t\tstand:0,\n\t * \t\t\t\trun:[1,5],\n\t * \t\t\t\tjump:[6,8,\"run\"]\n\t * \t\t\t}\n\t * \t\t};\n\t * \t\tvar spriteSheet = new createjs.SpriteSheet(data);\n\t * \t\tvar animation = new createjs.Sprite(spriteSheet, \"run\");\n\t *\n\t * <h3>Generating SpriteSheet Images</h3>\n\t * Spritesheets can be created manually by combining images in PhotoShop, and specifying the frame size or\n\t * coordinates manually, however there are a number of tools that facilitate this.\n\t * <ul>\n\t *     <li>Exporting SpriteSheets or HTML5 content from Flash Pro supports the EaselJS SpriteSheet format.</li>\n\t *     <li>The popular <a href=\"https://www.codeandweb.com/texturepacker/easeljs\" target=\"_blank\">Texture Packer</a> has\n\t *     EaselJS support.\n\t *     <li>SWF animations in Flash can be exported to SpriteSheets using <a href=\"http://createjs.com/zoe\" target=\"_blank\"></a></li>\n\t * </ul>\n\t *\n\t * <h3>Cross Origin Issues</h3>\n\t * <strong>Warning:</strong> Images loaded cross-origin will throw cross-origin security errors when interacted with\n\t * using:\n\t * <ul>\n\t *     <li>a mouse</li>\n\t *     <li>methods such as {{#crossLink \"Container/getObjectUnderPoint\"}}{{/crossLink}}</li>\n\t *     <li>Filters (see {{#crossLink \"Filter\"}}{{/crossLink}})</li>\n\t *     <li>caching (see {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}})</li>\n\t * </ul>\n\t * You can get around this by setting `crossOrigin` property on your images before passing them to EaselJS, or\n\t * setting the `crossOrigin` property on PreloadJS' LoadQueue or LoadItems.\n\t *\n\t * \t\tvar image = new Image();\n\t * \t\timg.crossOrigin=\"Anonymous\";\n\t * \t\timg.src = \"http://server-with-CORS-support.com/path/to/image.jpg\";\n\t *\n\t * If you pass string paths to SpriteSheets, they will not work cross-origin. The server that stores the image must\n\t * support cross-origin requests, or this will not work. For more information, check out\n\t * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS\" target=\"_blank\">CORS overview on MDN</a>.\n\t *\n\t * @class SpriteSheet\n\t * @constructor\n\t * @param {Object} data An object describing the SpriteSheet data.\n\t * @extends EventDispatcher\n\t **/\n\tfunction SpriteSheet(data) {\n\t\tthis.EventDispatcher_constructor();\n\n\n\t\t// public properties:\n\t\t/**\n\t\t * Indicates whether all images are finished loading.\n\t\t * @property complete\n\t\t * @type Boolean\n\t\t * @readonly\n\t\t **/\n\t\tthis.complete = true;\n\n\t\t/**\n\t\t * Specifies the framerate to use by default for Sprite instances using the SpriteSheet. See the Sprite class\n\t\t * {{#crossLink \"Sprite/framerate:property\"}}{{/crossLink}} for more information.\n\t\t * @property framerate\n\t\t * @type Number\n\t\t **/\n\t\tthis.framerate = 0;\n\n\n\t\t// private properties:\n\t\t/**\n\t\t * @property _animations\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._animations = null;\n\n\t\t/**\n\t\t * @property _frames\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._frames = null;\n\n\t\t/**\n\t\t * @property _images\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._images = null;\n\n\t\t/**\n\t\t * @property _data\n\t\t * @protected\n\t\t * @type Object\n\t\t **/\n\t\tthis._data = null;\n\n\t\t/**\n\t\t * @property _loadCount\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._loadCount = 0;\n\n\t\t// only used for simple frame defs:\n\t\t/**\n\t\t * @property _frameHeight\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._frameHeight = 0;\n\n\t\t/**\n\t\t * @property _frameWidth\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._frameWidth = 0;\n\n\t\t/**\n\t\t * @property _numFrames\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._numFrames = 0;\n\n\t\t/**\n\t\t * @property _regX\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._regX = 0;\n\n\t\t/**\n\t\t * @property _regY\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._regY = 0;\n\n\t\t/**\n\t\t * @property _spacing\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._spacing = 0;\n\n\t\t/**\n\t\t * @property _margin\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._margin = 0;\n\n\t\t// setup:\n\t\tthis._parseData(data);\n\t}\n\tvar p = createjs.extend(SpriteSheet, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// events:\n\t/**\n\t * Dispatched when all images are loaded.  Note that this only fires if the images\n\t * were not fully loaded when the sprite sheet was initialized. You should check the complete property\n\t * to prior to adding a listener. Ex.\n\t *\n\t * \tvar sheet = new createjs.SpriteSheet(data);\n\t * \tif (!sheet.complete) {\n\t * \t\t// not preloaded, listen for the complete event:\n\t * \t\tsheet.addEventListener(\"complete\", handler);\n\t * \t}\n\t *\n\t * @event complete\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when getFrame is called with a valid frame index. This is primarily intended for use by {{#crossLink \"SpriteSheetBuilder\"}}{{/crossLink}}\n\t * when doing on-demand rendering.\n\t * @event getframe\n\t * @param {Number} index The frame index.\n\t * @param {Object} frame The frame object that getFrame will return.\n\t */\n\n\t/**\n\t * Dispatched when an image encounters an error. A SpriteSheet will dispatch an error event for each image that\n\t * encounters an error, and will still dispatch a {{#crossLink \"SpriteSheet/complete:event\"}}{{/crossLink}}\n\t * event once all images are finished processing, even if an error is encountered.\n\t * @event error\n\t * @param {String} src The source of the image that failed to load.\n\t * @since 0.8.2\n\t */\n\n\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"SpriteSheet/animations:property\"}}{{/crossLink}} property instead.\n\t * @method getAnimations\n\t * @return {Array}\n\t * @deprecated\n\t **/\n\tp.getAnimations = function() {\n\t\treturn this._animations.slice();\n\t};\n\n\t/**\n\t * Returns an array of all available animation names available on this sprite sheet as strings.\n\t * @property animations\n\t * @type {Array}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tanimations: { get: p.getAnimations }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Returns the total number of frames in the specified animation, or in the whole sprite\n\t * sheet if the animation param is omitted. Returns 0 if the spritesheet relies on calculated frame counts, and\n\t * the images have not been fully loaded.\n\t * @method getNumFrames\n\t * @param {String} animation The name of the animation to get a frame count for.\n\t * @return {Number} The number of frames in the animation, or in the entire sprite sheet if the animation param is omitted.\n\t */\n\tp.getNumFrames = function(animation) {\n\t\tif (animation == null) {\n\t\t\treturn this._frames ? this._frames.length : this._numFrames || 0;\n\t\t} else {\n\t\t\tvar data = this._data[animation];\n\t\t\tif (data == null) { return 0; }\n\t\t\telse { return data.frames.length; }\n\t\t}\n\t};\n\n\t/**\n\t * Returns an object defining the specified animation. The returned object contains:<UL>\n\t * \t<li>frames: an array of the frame ids in the animation</li>\n\t * \t<li>speed: the playback speed for this animation</li>\n\t * \t<li>name: the name of the animation</li>\n\t * \t<li>next: the default animation to play next. If the animation loops, the name and next property will be the\n\t * \tsame.</li>\n\t * </UL>\n\t * @method getAnimation\n\t * @param {String} name The name of the animation to get.\n\t * @return {Object} a generic object with frames, speed, name, and next properties.\n\t **/\n\tp.getAnimation = function(name) {\n\t\treturn this._data[name];\n\t};\n\n\t/**\n\t * Returns an object specifying the image and source rect of the specified frame. The returned object has:<UL>\n\t * \t<li>an image property holding a reference to the image object in which the frame is found</li>\n\t * \t<li>a rect property containing a Rectangle instance which defines the boundaries for the frame within that\n\t * \timage.</li>\n\t * \t<li> A regX and regY property corresponding to the regX/Y values for the frame.\n\t * </UL>\n\t * @method getFrame\n\t * @param {Number} frameIndex The index of the frame.\n\t * @return {Object} a generic object with image and rect properties. Returns null if the frame does not exist.\n\t **/\n\tp.getFrame = function(frameIndex) {\n\t\tvar frame;\n\t\tif (this._frames && (frame=this._frames[frameIndex])) { return frame; }\n\t\treturn null;\n\t};\n\n\t/**\n\t * Returns a {{#crossLink \"Rectangle\"}}{{/crossLink}} instance defining the bounds of the specified frame relative\n\t * to the origin. For example, a 90 x 70 frame with a regX of 50 and a regY of 40 would return:\n\t *\n\t * \t[x=-50, y=-40, width=90, height=70]\n\t *\n\t * @method getFrameBounds\n\t * @param {Number} frameIndex The index of the frame.\n\t * @param {Rectangle} [rectangle] A Rectangle instance to copy the values into. By default a new instance is created.\n\t * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully loaded.\n\t **/\n\tp.getFrameBounds = function(frameIndex, rectangle) {\n\t\tvar frame = this.getFrame(frameIndex);\n\t\treturn frame ? (rectangle||new createjs.Rectangle()).setValues(-frame.regX, -frame.regY, frame.rect.width, frame.rect.height) : null;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[SpriteSheet]\";\n\t};\n\n\t/**\n\t * SpriteSheet cannot be cloned. A SpriteSheet can be shared by multiple Sprite instances without cloning it.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\tthrow(\"SpriteSheet cannot be cloned.\")\n\t};\n\n// private methods:\n\t/**\n\t * @method _parseData\n\t * @param {Object} data An object describing the SpriteSheet data.\n\t * @protected\n\t **/\n\tp._parseData = function(data) {\n\t\tvar i,l,o,a;\n\t\tif (data == null) { return; }\n\n\t\tthis.framerate = data.framerate||0;\n\n\t\t// parse images:\n\t\tif (data.images && (l=data.images.length) > 0) {\n\t\t\ta = this._images = [];\n\t\t\tfor (i=0; i<l; i++) {\n\t\t\t\tvar img = data.images[i];\n\t\t\t\tif (typeof img == \"string\") {\n\t\t\t\t\tvar src = img;\n\t\t\t\t\timg = document.createElement(\"img\");\n\t\t\t\t\timg.src = src;\n\t\t\t\t}\n\t\t\t\ta.push(img);\n\t\t\t\tif (!img.getContext && !img.naturalWidth) {\n\t\t\t\t\tthis._loadCount++;\n\t\t\t\t\tthis.complete = false;\n\t\t\t\t\t(function(o, src) { img.onload = function() { o._handleImageLoad(src); } })(this, src);\n\t\t\t\t\t(function(o, src) { img.onerror = function() { o._handleImageError(src); } })(this, src);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// parse frames:\n\t\tif (data.frames == null) { // nothing\n\t\t} else if (Array.isArray(data.frames)) {\n\t\t\tthis._frames = [];\n\t\t\ta = data.frames;\n\t\t\tfor (i=0,l=a.length;i<l;i++) {\n\t\t\t\tvar arr = a[i];\n\t\t\t\tthis._frames.push({image:this._images[arr[4]?arr[4]:0], rect:new createjs.Rectangle(arr[0],arr[1],arr[2],arr[3]), regX:arr[5]||0, regY:arr[6]||0 });\n\t\t\t}\n\t\t} else {\n\t\t\to = data.frames;\n\t\t\tthis._frameWidth = o.width;\n\t\t\tthis._frameHeight = o.height;\n\t\t\tthis._regX = o.regX||0;\n\t\t\tthis._regY = o.regY||0;\n\t\t\tthis._spacing = o.spacing||0;\n\t\t\tthis._margin = o.margin||0;\n\t\t\tthis._numFrames = o.count;\n\t\t\tif (this._loadCount == 0) { this._calculateFrames(); }\n\t\t}\n\n\t\t// parse animations:\n\t\tthis._animations = [];\n\t\tif ((o=data.animations) != null) {\n\t\t\tthis._data = {};\n\t\t\tvar name;\n\t\t\tfor (name in o) {\n\t\t\t\tvar anim = {name:name};\n\t\t\t\tvar obj = o[name];\n\t\t\t\tif (typeof obj == \"number\") { // single frame\n\t\t\t\t\ta = anim.frames = [obj];\n\t\t\t\t} else if (Array.isArray(obj)) { // simple\n\t\t\t\t\tif (obj.length == 1) { anim.frames = [obj[0]]; }\n\t\t\t\t\telse {\n\t\t\t\t\t\tanim.speed = obj[3];\n\t\t\t\t\t\tanim.next = obj[2];\n\t\t\t\t\t\ta = anim.frames = [];\n\t\t\t\t\t\tfor (i=obj[0];i<=obj[1];i++) {\n\t\t\t\t\t\t\ta.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else { // complex\n\t\t\t\t\tanim.speed = obj.speed;\n\t\t\t\t\tanim.next = obj.next;\n\t\t\t\t\tvar frames = obj.frames;\n\t\t\t\t\ta = anim.frames = (typeof frames == \"number\") ? [frames] : frames.slice(0);\n\t\t\t\t}\n\t\t\t\tif (anim.next === true || anim.next === undefined) { anim.next = name; } // loop\n\t\t\t\tif (anim.next === false || (a.length < 2 && anim.next == name)) { anim.next = null; } // stop\n\t\t\t\tif (!anim.speed) { anim.speed = 1; }\n\t\t\t\tthis._animations.push(name);\n\t\t\t\tthis._data[name] = anim;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleImageLoad\n\t * @protected\n\t **/\n\tp._handleImageLoad = function(src) {\n\t\tif (--this._loadCount == 0) {\n\t\t\tthis._calculateFrames();\n\t\t\tthis.complete = true;\n\t\t\tthis.dispatchEvent(\"complete\");\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleImageError\n\t * @protected\n\t */\n\tp._handleImageError = function (src) {\n\t\tvar errorEvent = new createjs.Event(\"error\");\n\t\terrorEvent.src = src;\n\t\tthis.dispatchEvent(errorEvent);\n\n\t\t// Complete is still dispatched.\n\t\tif (--this._loadCount == 0) {\n\t\t\tthis.dispatchEvent(\"complete\");\n\t\t}\n\t};\n\n\t/**\n\t * @method _calculateFrames\n\t * @protected\n\t **/\n\tp._calculateFrames = function() {\n\t\tif (this._frames || this._frameWidth == 0) { return; }\n\n\t\tthis._frames = [];\n\n\t\tvar maxFrames = this._numFrames || 100000; // if we go over this, something is wrong.\n\t\tvar frameCount = 0, frameWidth = this._frameWidth, frameHeight = this._frameHeight;\n\t\tvar spacing = this._spacing, margin = this._margin;\n\t\t\n\t\timgLoop:\n\t\tfor (var i=0, imgs=this._images; i<imgs.length; i++) {\n\t\t\tvar img = imgs[i], imgW = img.width, imgH = img.height;\n\n\t\t\tvar y = margin;\n\t\t\twhile (y <= imgH-margin-frameHeight) {\n\t\t\t\tvar x = margin;\n\t\t\t\twhile (x <= imgW-margin-frameWidth) {\n\t\t\t\t\tif (frameCount >= maxFrames) { break imgLoop; }\n\t\t\t\t\tframeCount++;\n\t\t\t\t\tthis._frames.push({\n\t\t\t\t\t\t\timage: img,\n\t\t\t\t\t\t\trect: new createjs.Rectangle(x, y, frameWidth, frameHeight),\n\t\t\t\t\t\t\tregX: this._regX,\n\t\t\t\t\t\t\tregY: this._regY\n\t\t\t\t\t\t});\n\t\t\t\t\tx += frameWidth+spacing;\n\t\t\t\t}\n\t\t\t\ty += frameHeight+spacing;\n\t\t\t}\n\t\t}\n\t\tthis._numFrames = frameCount;\n\t};\n\n\n\tcreatejs.SpriteSheet = createjs.promote(SpriteSheet, \"EventDispatcher\");\n}());\n\n//##############################################################################\n// Graphics.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The Graphics class exposes an easy to use API for generating vector drawing instructions and drawing them to a\n\t * specified context. Note that you can use Graphics without any dependency on the EaselJS framework by calling {{#crossLink \"Graphics/draw\"}}{{/crossLink}}\n\t * directly, or it can be used with the {{#crossLink \"Shape\"}}{{/crossLink}} object to draw vector graphics within the\n\t * context of an EaselJS display list.\n\t *\n\t * There are two approaches to working with Graphics object: calling methods on a Graphics instance (the \"Graphics API\"), or\n\t * instantiating Graphics command objects and adding them to the graphics queue via {{#crossLink \"Graphics/append\"}}{{/crossLink}}.\n\t * The former abstracts the latter, simplifying beginning and ending paths, fills, and strokes.\n\t *\n\t *      var g = new createjs.Graphics();\n\t *      g.setStrokeStyle(1);\n\t *      g.beginStroke(\"#000000\");\n\t *      g.beginFill(\"red\");\n\t *      g.drawCircle(0,0,30);\n\t *\n\t * All drawing methods in Graphics return the Graphics instance, so they can be chained together. For example,\n\t * the following line of code would generate the instructions to draw a rectangle with a red stroke and blue fill:\n\t *\n\t *      myGraphics.beginStroke(\"red\").beginFill(\"blue\").drawRect(20, 20, 100, 50);\n\t *\n\t * Each graphics API call generates a command object (see below). The last command to be created can be accessed via\n\t * {{#crossLink \"Graphics/command:property\"}}{{/crossLink}}:\n\t *\n\t *      var fillCommand = myGraphics.beginFill(\"red\").command;\n\t *      // ... later, update the fill style/color:\n\t *      fillCommand.style = \"blue\";\n\t *      // or change it to a bitmap fill:\n\t *      fillCommand.bitmap(myImage);\n\t *\n\t * For more direct control of rendering, you can instantiate and append command objects to the graphics queue directly. In this case, you\n\t * need to manage path creation manually, and ensure that fill/stroke is applied to a defined path:\n\t *\n\t *      // start a new path. Graphics.beginCmd is a reusable BeginPath instance:\n\t *      myGraphics.append(createjs.Graphics.beginCmd);\n\t *      // we need to define the path before applying the fill:\n\t *      var circle = new createjs.Graphics.Circle(0,0,30);\n\t *      myGraphics.append(circle);\n\t *      // fill the path we just defined:\n\t *      var fill = new createjs.Graphics.Fill(\"red\");\n\t *      myGraphics.append(fill);\n\t *\n\t * These approaches can be used together, for example to insert a custom command:\n\t *\n\t *      myGraphics.beginFill(\"red\");\n\t *      var customCommand = new CustomSpiralCommand(etc);\n\t *      myGraphics.append(customCommand);\n\t *      myGraphics.beginFill(\"blue\");\n\t *      myGraphics.drawCircle(0, 0, 30);\n\t *\n\t * See {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more info on creating custom commands.\n\t *\n\t * <h4>Tiny API</h4>\n\t * The Graphics class also includes a \"tiny API\", which is one or two-letter methods that are shortcuts for all of the\n\t * Graphics methods. These methods are great for creating compact instructions, and is used by the Toolkit for CreateJS\n\t * to generate readable code. All tiny methods are marked as protected, so you can view them by enabling protected\n\t * descriptions in the docs.\n\t *\n\t * <table>\n\t *     <tr><td><b>Tiny</b></td><td><b>Method</b></td><td><b>Tiny</b></td><td><b>Method</b></td></tr>\n\t *     <tr><td>mt</td><td>{{#crossLink \"Graphics/moveTo\"}}{{/crossLink}} </td>\n\t *     <td>lt</td> <td>{{#crossLink \"Graphics/lineTo\"}}{{/crossLink}}</td></tr>\n\t *     <tr><td>a/at</td><td>{{#crossLink \"Graphics/arc\"}}{{/crossLink}} / {{#crossLink \"Graphics/arcTo\"}}{{/crossLink}} </td>\n\t *     <td>bt</td><td>{{#crossLink \"Graphics/bezierCurveTo\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>qt</td><td>{{#crossLink \"Graphics/quadraticCurveTo\"}}{{/crossLink}} (also curveTo)</td>\n\t *     <td>r</td><td>{{#crossLink \"Graphics/rect\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>cp</td><td>{{#crossLink \"Graphics/closePath\"}}{{/crossLink}} </td>\n\t *     <td>c</td><td>{{#crossLink \"Graphics/clear\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>f</td><td>{{#crossLink \"Graphics/beginFill\"}}{{/crossLink}} </td>\n\t *     <td>lf</td><td>{{#crossLink \"Graphics/beginLinearGradientFill\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>rf</td><td>{{#crossLink \"Graphics/beginRadialGradientFill\"}}{{/crossLink}} </td>\n\t *     <td>bf</td><td>{{#crossLink \"Graphics/beginBitmapFill\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>ef</td><td>{{#crossLink \"Graphics/endFill\"}}{{/crossLink}} </td>\n\t *     <td>ss / sd</td><td>{{#crossLink \"Graphics/setStrokeStyle\"}}{{/crossLink}} / {{#crossLink \"Graphics/setStrokeDash\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>s</td><td>{{#crossLink \"Graphics/beginStroke\"}}{{/crossLink}} </td>\n\t *     <td>ls</td><td>{{#crossLink \"Graphics/beginLinearGradientStroke\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>rs</td><td>{{#crossLink \"Graphics/beginRadialGradientStroke\"}}{{/crossLink}} </td>\n\t *     <td>bs</td><td>{{#crossLink \"Graphics/beginBitmapStroke\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>es</td><td>{{#crossLink \"Graphics/endStroke\"}}{{/crossLink}} </td>\n\t *     <td>dr</td><td>{{#crossLink \"Graphics/drawRect\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>rr</td><td>{{#crossLink \"Graphics/drawRoundRect\"}}{{/crossLink}} </td>\n\t *     <td>rc</td><td>{{#crossLink \"Graphics/drawRoundRectComplex\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>dc</td><td>{{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}} </td>\n\t *     <td>de</td><td>{{#crossLink \"Graphics/drawEllipse\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>dp</td><td>{{#crossLink \"Graphics/drawPolyStar\"}}{{/crossLink}} </td>\n\t *     <td>p</td><td>{{#crossLink \"Graphics/decodePath\"}}{{/crossLink}} </td></tr>\n\t * </table>\n\t *\n\t * Here is the above example, using the tiny API instead.\n\t *\n\t *      myGraphics.s(\"red\").f(\"blue\").r(20, 20, 100, 50);\n\t *\n\t * @class Graphics\n\t * @constructor\n\t **/\n\tfunction Graphics() {\n\n\n\t// public properties\n\t\t/**\n\t\t * Holds a reference to the last command that was created or appended. For example, you could retain a reference\n\t\t * to a Fill command in order to dynamically update the color later by using:\n\t\t *\n\t\t * \t\tvar myFill = myGraphics.beginFill(\"red\").command;\n\t\t * \t\t// update color later:\n\t\t * \t\tmyFill.style = \"yellow\";\n\t\t *\n\t\t * @property command\n\t\t * @type Object\n\t\t **/\n\t\tthis.command = null;\n\n\n\t// private properties\n\t\t/**\n\t\t * @property _stroke\n\t\t * @protected\n\t\t * @type {Stroke}\n\t\t **/\n\t\tthis._stroke = null;\n\n\t\t/**\n\t\t * @property _strokeStyle\n\t\t * @protected\n\t\t * @type {StrokeStyle}\n\t\t **/\n\t\tthis._strokeStyle = null;\n\t\t\n\t\t/**\n\t\t * @property _oldStrokeStyle\n\t\t * @protected\n\t\t * @type {StrokeStyle}\n\t\t **/\n\t\tthis._oldStrokeStyle = null;\n\t\t\n\t\t/**\n\t\t * @property _strokeDash\n\t\t * @protected\n\t\t * @type {StrokeDash}\n\t\t **/\n\t\tthis._strokeDash = null;\n\t\t\n\t\t/**\n\t\t * @property _oldStrokeDash\n\t\t * @protected\n\t\t * @type {StrokeDash}\n\t\t **/\n\t\tthis._oldStrokeDash = null;\n\n\t\t/**\n\t\t * @property _strokeIgnoreScale\n\t\t * @protected\n\t\t * @type Boolean\n\t\t **/\n\t\tthis._strokeIgnoreScale = false;\n\n\t\t/**\n\t\t * @property _fill\n\t\t * @protected\n\t\t * @type {Fill}\n\t\t **/\n\t\tthis._fill = null;\n\n\t\t/**\n\t\t * @property _instructions\n\t\t * @protected\n\t\t * @type {Array}\n\t\t **/\n\t\tthis._instructions = [];\n\n\t\t/**\n\t\t * Indicates the last instruction index that was committed.\n\t\t * @property _commitIndex\n\t\t * @protected\n\t\t * @type {Number}\n\t\t **/\n\t\tthis._commitIndex = 0;\n\n\t\t/**\n\t\t * Uncommitted instructions.\n\t\t * @property _activeInstructions\n\t\t * @protected\n\t\t * @type {Array}\n\t\t **/\n\t\tthis._activeInstructions = [];\n\n\t\t/**\n\t\t * This indicates that there have been changes to the activeInstruction list since the last updateInstructions call.\n\t\t * @property _dirty\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t **/\n\t\tthis._dirty = false;\n\n\t\t/**\n\t\t * Index to draw from if a store operation has happened.\n\t\t * @property _storeIndex\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._storeIndex = 0;\n\n\t// setup:\n\t\tthis.clear();\n\t}\n\tvar p = Graphics.prototype;\n\tvar G = Graphics; // shortcut\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// static public methods:\n\t/**\n\t * Returns a CSS compatible color string based on the specified RGB numeric color values in the format\n\t * \"rgba(255,255,255,1.0)\", or if alpha is null then in the format \"rgb(255,255,255)\". For example,\n\t *\n\t *      createjs.Graphics.getRGB(50, 100, 150, 0.5);\n\t *      // Returns \"rgba(50,100,150,0.5)\"\n\t *\n\t * It also supports passing a single hex color value as the first param, and an optional alpha value as the second\n\t * param. For example,\n\t *\n\t *      createjs.Graphics.getRGB(0xFF00FF, 0.2);\n\t *      // Returns \"rgba(255,0,255,0.2)\"\n\t *\n\t * @method getRGB\n\t * @static\n\t * @param {Number} r The red component for the color, between 0 and 0xFF (255).\n\t * @param {Number} g The green component for the color, between 0 and 0xFF (255).\n\t * @param {Number} b The blue component for the color, between 0 and 0xFF (255).\n\t * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.\n\t * @return {String} A CSS compatible color string based on the specified RGB numeric color values in the format\n\t * \"rgba(255,255,255,1.0)\", or if alpha is null then in the format \"rgb(255,255,255)\".\n\t **/\n\tGraphics.getRGB = function(r, g, b, alpha) {\n\t\tif (r != null && b == null) {\n\t\t\talpha = g;\n\t\t\tb = r&0xFF;\n\t\t\tg = r>>8&0xFF;\n\t\t\tr = r>>16&0xFF;\n\t\t}\n\t\tif (alpha == null) {\n\t\t\treturn \"rgb(\"+r+\",\"+g+\",\"+b+\")\";\n\t\t} else {\n\t\t\treturn \"rgba(\"+r+\",\"+g+\",\"+b+\",\"+alpha+\")\";\n\t\t}\n\t};\n\n\t/**\n\t * Returns a CSS compatible color string based on the specified HSL numeric color values in the format \"hsla(360,100,100,1.0)\",\n\t * or if alpha is null then in the format \"hsl(360,100,100)\".\n\t *\n\t *      createjs.Graphics.getHSL(150, 100, 70);\n\t *      // Returns \"hsl(150,100,70)\"\n\t *\n\t * @method getHSL\n\t * @static\n\t * @param {Number} hue The hue component for the color, between 0 and 360.\n\t * @param {Number} saturation The saturation component for the color, between 0 and 100.\n\t * @param {Number} lightness The lightness component for the color, between 0 and 100.\n\t * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.\n\t * @return {String} A CSS compatible color string based on the specified HSL numeric color values in the format\n\t * \"hsla(360,100,100,1.0)\", or if alpha is null then in the format \"hsl(360,100,100)\".\n\t **/\n\tGraphics.getHSL = function(hue, saturation, lightness, alpha) {\n\t\tif (alpha == null) {\n\t\t\treturn \"hsl(\"+(hue%360)+\",\"+saturation+\"%,\"+lightness+\"%)\";\n\t\t} else {\n\t\t\treturn \"hsla(\"+(hue%360)+\",\"+saturation+\"%,\"+lightness+\"%,\"+alpha+\")\";\n\t\t}\n\t};\n\n\n// static properties:\n\t/**\n\t * A reusable instance of {{#crossLink \"Graphics/BeginPath\"}}{{/crossLink}} to avoid\n\t * unnecessary instantiation.\n\t * @property beginCmd\n\t * @type {Graphics.BeginPath}\n\t * @static\n\t **/\n\t // defined at the bottom of this file.\n\n\t/**\n\t * Map of Base64 characters to values. Used by {{#crossLink \"Graphics/decodePath\"}}{{/crossLink}}.\n\t * @property BASE_64\n\t * @static\n\t * @final\n\t * @readonly\n\t * @type {Object}\n\t **/\n\tGraphics.BASE_64 = {\"A\":0,\"B\":1,\"C\":2,\"D\":3,\"E\":4,\"F\":5,\"G\":6,\"H\":7,\"I\":8,\"J\":9,\"K\":10,\"L\":11,\"M\":12,\"N\":13,\"O\":14,\"P\":15,\"Q\":16,\"R\":17,\"S\":18,\"T\":19,\"U\":20,\"V\":21,\"W\":22,\"X\":23,\"Y\":24,\"Z\":25,\"a\":26,\"b\":27,\"c\":28,\"d\":29,\"e\":30,\"f\":31,\"g\":32,\"h\":33,\"i\":34,\"j\":35,\"k\":36,\"l\":37,\"m\":38,\"n\":39,\"o\":40,\"p\":41,\"q\":42,\"r\":43,\"s\":44,\"t\":45,\"u\":46,\"v\":47,\"w\":48,\"x\":49,\"y\":50,\"z\":51,\"0\":52,\"1\":53,\"2\":54,\"3\":55,\"4\":56,\"5\":57,\"6\":58,\"7\":59,\"8\":60,\"9\":61,\"+\":62,\"/\":63};\n\n\t/**\n\t * Maps numeric values for the caps parameter of {{#crossLink \"Graphics/setStrokeStyle\"}}{{/crossLink}} to\n\t * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to\n\t * \"butt\", 1 to \"round\", and 2 to \"square\".\n\t * For example, to set the line caps to \"square\":\n\t *\n\t *      myGraphics.ss(16, 2);\n\t *\n\t * @property STROKE_CAPS_MAP\n\t * @static\n\t * @final\n\t * @readonly\n\t * @type {Array}\n\t **/\n\tGraphics.STROKE_CAPS_MAP = [\"butt\", \"round\", \"square\"];\n\n\t/**\n\t * Maps numeric values for the joints parameter of {{#crossLink \"Graphics/setStrokeStyle\"}}{{/crossLink}} to\n\t * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to\n\t * \"miter\", 1 to \"round\", and 2 to \"bevel\".\n\t * For example, to set the line joints to \"bevel\":\n\t *\n\t *      myGraphics.ss(16, 0, 2);\n\t *\n\t * @property STROKE_JOINTS_MAP\n\t * @static\n\t * @final\n\t * @readonly\n\t * @type {Array}\n\t **/\n\tGraphics.STROKE_JOINTS_MAP = [\"miter\", \"round\", \"bevel\"];\n\n\t/**\n\t * @property _ctx\n\t * @static\n\t * @protected\n\t * @type {CanvasRenderingContext2D}\n\t **/\n\tvar canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"));\n\tif (canvas.getContext) {\n\t\tGraphics._ctx = canvas.getContext(\"2d\");\n\t\tcanvas.width = canvas.height = 1;\n\t}\n\n\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"Graphics/instructions:property\"}}{{/crossLink}} property instead.\n\t * @method getInstructions\n\t * @return {Array}\n\t * @deprecated\n\t **/\n\tp.getInstructions = function() {\n\t\tthis._updateInstructions();\n\t\treturn this._instructions;\n\t};\n\n\t/**\n\t * Returns the graphics instructions array. Each entry is a graphics command object (ex. Graphics.Fill, Graphics.Rect)\n\t * Modifying the returned array directly is not recommended, and is likely to result in unexpected behaviour.\n\t *\n\t * This property is mainly intended for introspection of the instructions (ex. for graphics export).\n\t * @property instructions\n\t * @type {Array}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tinstructions: { get: p.getInstructions }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Returns true if this Graphics instance has no drawing commands.\n\t * @method isEmpty\n\t * @return {Boolean} Returns true if this Graphics instance has no drawing commands.\n\t **/\n\tp.isEmpty = function() {\n\t\treturn !(this._instructions.length || this._activeInstructions.length);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Object} data Optional data that is passed to graphics command exec methods. When called from a Shape instance, the shape passes itself as the data parameter. This can be used by custom graphic commands to insert contextual data.\n\t **/\n\tp.draw = function(ctx, data) {\n\t\tthis._updateInstructions();\n\t\tvar instr = this._instructions;\n\t\tfor (var i=this._storeIndex, l=instr.length; i<l; i++) {\n\t\t\tinstr[i].exec(ctx, data);\n\t\t}\n\t};\n\n\t/**\n\t * Draws only the path described for this Graphics instance, skipping any non-path instructions, including fill and\n\t * stroke descriptions. Used for <code>DisplayObject.mask</code> to draw the clipping path, for example.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method drawAsPath\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t **/\n\tp.drawAsPath = function(ctx) {\n\t\tthis._updateInstructions();\n\t\tvar instr, instrs = this._instructions;\n\t\tfor (var i=this._storeIndex, l=instrs.length; i<l; i++) {\n\t\t\t// the first command is always a beginPath command.\n\t\t\tif ((instr = instrs[i]).path !== false) { instr.exec(ctx); }\n\t\t}\n\t};\n\n\n// public methods that map directly to context 2D calls:\n\t/**\n\t * Moves the drawing point to the specified position. A tiny API method \"mt\" also exists.\n\t * @method moveTo\n\t * @param {Number} x The x coordinate the drawing point should move to.\n\t * @param {Number} y The y coordinate the drawing point should move to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).\n\t * @chainable\n\t **/\n\tp.moveTo = function(x, y) {\n\t\treturn this.append(new G.MoveTo(x,y), true);\n\t};\n\n\t/**\n\t * Draws a line from the current drawing point to the specified position, which become the new current drawing\n\t * point. Note that you *must* call {{#crossLink \"Graphics/moveTo\"}}{{/crossLink}} before the first `lineTo()`.\n\t * A tiny API method \"lt\" also exists.\n\t *\n\t * For detailed information, read the\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#complex-shapes-(paths)\">\n\t * whatwg spec</a>.\n\t * @method lineTo\n\t * @param {Number} x The x coordinate the drawing point should draw to.\n\t * @param {Number} y The y coordinate the drawing point should draw to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.lineTo = function(x, y) {\n\t\treturn this.append(new G.LineTo(x,y));\n\t};\n\n\t/**\n\t * Draws an arc with the specified control points and radius.  For detailed information, read the\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arcto\">\n\t * whatwg spec</a>. A tiny API method \"at\" also exists.\n\t * @method arcTo\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} x2\n\t * @param {Number} y2\n\t * @param {Number} radius\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.arcTo = function(x1, y1, x2, y2, radius) {\n\t\treturn this.append(new G.ArcTo(x1, y1, x2, y2, radius));\n\t};\n\n\t/**\n\t * Draws an arc defined by the radius, startAngle and endAngle arguments, centered at the position (x, y). For\n\t * example, to draw a full circle with a radius of 20 centered at (100, 100):\n\t *\n\t *      arc(100, 100, 20, 0, Math.PI*2);\n\t *\n\t * For detailed information, read the\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc\">whatwg spec</a>.\n\t * A tiny API method \"a\" also exists.\n\t * @method arc\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} startAngle Measured in radians.\n\t * @param {Number} endAngle Measured in radians.\n\t * @param {Boolean} anticlockwise\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {\n\t\treturn this.append(new G.Arc(x, y, radius, startAngle, endAngle, anticlockwise));\n\t};\n\n\t/**\n\t * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy). For detailed\n\t * information, read the <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto\">\n\t * whatwg spec</a>. A tiny API method \"qt\" also exists.\n\t * @method quadraticCurveTo\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.quadraticCurveTo = function(cpx, cpy, x, y) {\n\t\treturn this.append(new G.QuadraticCurveTo(cpx, cpy, x, y));\n\t};\n\n\t/**\n\t * Draws a bezier curve from the current drawing point to (x, y) using the control points (cp1x, cp1y) and (cp2x,\n\t * cp2y). For detailed information, read the\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-beziercurveto\">\n\t * whatwg spec</a>. A tiny API method \"bt\" also exists.\n\t * @method bezierCurveTo\n\t * @param {Number} cp1x\n\t * @param {Number} cp1y\n\t * @param {Number} cp2x\n\t * @param {Number} cp2y\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n\t\treturn this.append(new G.BezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y));\n\t};\n\n\t/**\n\t * Draws a rectangle at (x, y) with the specified width and height using the current fill and/or stroke.\n\t * For detailed information, read the\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-rect\">\n\t * whatwg spec</a>. A tiny API method \"r\" also exists.\n\t * @method rect\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.rect = function(x, y, w, h) {\n\t\treturn this.append(new G.Rect(x, y, w, h));\n\t};\n\n\t/**\n\t * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified\n\t * since the fill or stroke was last set. A tiny API method \"cp\" also exists.\n\t * @method closePath\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.closePath = function() {\n\t\treturn this._activeInstructions.length ? this.append(new G.ClosePath()) : this;\n\t};\n\n\n// public methods that roughly map to Flash graphics APIs:\n\t/**\n\t * Clears all drawing instructions, effectively resetting this Graphics instance. Any line and fill styles will need\n\t * to be redefined to draw shapes following a clear call. A tiny API method \"c\" also exists.\n\t * @method clear\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.clear = function() {\n\t\tthis._instructions.length = this._activeInstructions.length = this._commitIndex = 0;\n\t\tthis._strokeStyle = this._oldStrokeStyle = this._stroke = this._fill = this._strokeDash = this._oldStrokeDash = null;\n\t\tthis._dirty = this._strokeIgnoreScale = false;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Begins a fill with the specified color. This ends the current sub-path. A tiny API method \"f\" also exists.\n\t * @method beginFill\n\t * @param {String} color A CSS compatible color value (ex. \"red\", \"#FF0000\", or \"rgba(255,0,0,0.5)\"). Setting to\n\t * null will result in no fill.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginFill = function(color) {\n\t\treturn this._setFill(color ? new G.Fill(color) : null);\n\t};\n\n\t/**\n\t * Begins a linear gradient fill defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For\n\t * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a\n\t * square to display it:\n\t *\n\t *      myGraphics.beginLinearGradientFill([\"#000\",\"#FFF\"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);\n\t *\n\t * A tiny API method \"lf\" also exists.\n\t * @method beginLinearGradientFill\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define a gradient\n\t * drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw\n\t * the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginLinearGradientFill = function(colors, ratios, x0, y0, x1, y1) {\n\t\treturn this._setFill(new G.Fill().linearGradient(colors, ratios, x0, y0, x1, y1));\n\t};\n\n\t/**\n\t * Begins a radial gradient fill. This ends the current sub-path. For example, the following code defines a red to\n\t * blue radial gradient centered at (100, 100), with a radius of 50, and draws a circle to display it:\n\t *\n\t *      myGraphics.beginRadialGradientFill([\"#F00\",\"#00F\"], [0, 1], 100, 100, 0, 100, 100, 50).drawCircle(100, 100, 50);\n\t *\n\t * A tiny API method \"rf\" also exists.\n\t * @method beginRadialGradientFill\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginRadialGradientFill = function(colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\treturn this._setFill(new G.Fill().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));\n\t};\n\n\t/**\n\t * Begins a pattern fill using the specified image. This ends the current sub-path. A tiny API method \"bf\" also\n\t * exists.\n\t * @method beginBitmapFill\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.\n\t * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of \"repeat\",\n\t * \"repeat-x\", \"repeat-y\", or \"no-repeat\". Defaults to \"repeat\". Note that Firefox does not support \"repeat-x\" or\n\t * \"repeat-y\" (latest tests were in FF 20.0), and will default to \"repeat\".\n\t * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation\n\t * will be applied relative to the parent transform.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginBitmapFill = function(image, repetition, matrix) {\n\t\treturn this._setFill(new G.Fill(null,matrix).bitmap(image, repetition));\n\t};\n\n\t/**\n\t * Ends the current sub-path, and begins a new one with no fill. Functionally identical to <code>beginFill(null)</code>.\n\t * A tiny API method \"ef\" also exists.\n\t * @method endFill\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.endFill = function() {\n\t\treturn this.beginFill();\n\t};\n\n\t/**\n\t * Sets the stroke style. Like all drawing methods, this can be chained, so you can define\n\t * the stroke style and color in a single line of code like so:\n\t *\n\t * \tmyGraphics.setStrokeStyle(8,\"round\").beginStroke(\"#F00\");\n\t *\n\t * A tiny API method \"ss\" also exists.\n\t * @method setStrokeStyle\n\t * @param {Number} thickness The width of the stroke.\n\t * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,\n\t * round, or square. Defaults to \"butt\". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with\n\t * the tiny API.\n\t * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.\n\t * One of bevel, round, or miter. Defaults to \"miter\". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)\n\t * for use with the tiny API.\n\t * @param {Number} [miterLimit=10] If joints is set to \"miter\", then you can specify a miter limit ratio which\n\t * controls at what point a mitered joint will be clipped.\n\t * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless\n\t * of active transformations.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.setStrokeStyle = function(thickness, caps, joints, miterLimit, ignoreScale) {\n\t\tthis._updateInstructions(true);\n\t\tthis._strokeStyle = this.command = new G.StrokeStyle(thickness, caps, joints, miterLimit, ignoreScale);\n\n\t\t// ignoreScale lives on Stroke, not StrokeStyle, so we do a little trickery:\n\t\tif (this._stroke) { this._stroke.ignoreScale = ignoreScale; }\n\t\tthis._strokeIgnoreScale = ignoreScale;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Sets or clears the stroke dash pattern.\n\t *\n\t * \tmyGraphics.setStrokeDash([20, 10], 0);\n\t *\n\t * A tiny API method `sd` also exists.\n\t * @method setStrokeDash\n\t * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.\n\t * For example, `[20,10]` would create a pattern of 20 pixel lines with 10 pixel gaps between them.\n\t * Passing null or an empty array will clear the existing stroke dash.\n\t * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a \"marching ants\" effect.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.setStrokeDash = function(segments, offset) {\n\t\tthis._updateInstructions(true);\n\t\tthis._strokeDash = this.command = new G.StrokeDash(segments, offset);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Begins a stroke with the specified color. This ends the current sub-path. A tiny API method \"s\" also exists.\n\t * @method beginStroke\n\t * @param {String} color A CSS compatible color value (ex. \"#FF0000\", \"red\", or \"rgba(255,0,0,0.5)\"). Setting to\n\t * null will result in no stroke.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginStroke = function(color) {\n\t\treturn this._setStroke(color ? new G.Stroke(color) : null);\n\t};\n\n\t/**\n\t * Begins a linear gradient stroke defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For\n\t * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a\n\t * square to display it:\n\t *\n\t *      myGraphics.setStrokeStyle(10).\n\t *          beginLinearGradientStroke([\"#000\",\"#FFF\"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);\n\t *\n\t * A tiny API method \"ls\" also exists.\n\t * @method beginLinearGradientStroke\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginLinearGradientStroke = function(colors, ratios, x0, y0, x1, y1) {\n\t\treturn this._setStroke(new G.Stroke().linearGradient(colors, ratios, x0, y0, x1, y1));\n\t};\n\n\t/**\n\t * Begins a radial gradient stroke. This ends the current sub-path. For example, the following code defines a red to\n\t * blue radial gradient centered at (100, 100), with a radius of 50, and draws a rectangle to display it:\n\t *\n\t *      myGraphics.setStrokeStyle(10)\n\t *          .beginRadialGradientStroke([\"#F00\",\"#00F\"], [0, 1], 100, 100, 0, 100, 100, 50)\n\t *          .drawRect(50, 90, 150, 110);\n\t *\n\t * A tiny API method \"rs\" also exists.\n\t * @method beginRadialGradientStroke\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color\n\t * to 100%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginRadialGradientStroke = function(colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\treturn this._setStroke(new G.Stroke().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));\n\t};\n\n\t/**\n\t * Begins a pattern fill using the specified image. This ends the current sub-path. Note that unlike bitmap fills,\n\t * strokes do not currently support a matrix parameter due to limitations in the canvas API. A tiny API method \"bs\"\n\t * also exists.\n\t * @method beginBitmapStroke\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.\n\t * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of\n\t * \"repeat\", \"repeat-x\", \"repeat-y\", or \"no-repeat\". Defaults to \"repeat\".\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginBitmapStroke = function(image, repetition) {\n\t\t// NOTE: matrix is not supported for stroke because transforms on strokes also affect the drawn stroke width.\n\t\treturn this._setStroke(new G.Stroke().bitmap(image, repetition));\n\t};\n\n\t/**\n\t * Ends the current sub-path, and begins a new one with no stroke. Functionally identical to <code>beginStroke(null)</code>.\n\t * A tiny API method \"es\" also exists.\n\t * @method endStroke\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.endStroke = function() {\n\t\treturn this.beginStroke();\n\t};\n\n\t/**\n\t * Maps the familiar ActionScript <code>curveTo()</code> method to the functionally similar {{#crossLink \"Graphics/quadraticCurveTo\"}}{{/crossLink}}\n\t * method.\n\t * @method quadraticCurveTo\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.curveTo = p.quadraticCurveTo;\n\n\t/**\n\t *\n\t * Maps the familiar ActionScript <code>drawRect()</code> method to the functionally similar {{#crossLink \"Graphics/rect\"}}{{/crossLink}}\n\t * method.\n\t * @method drawRect\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawRect = p.rect;\n\n\t/**\n\t * Draws a rounded rectangle with all corners with the specified radius.\n\t * @method drawRoundRect\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t * @param {Number} radius Corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawRoundRect = function(x, y, w, h, radius) {\n\t\treturn this.drawRoundRectComplex(x, y, w, h, radius, radius, radius, radius);\n\t};\n\n\t/**\n\t * Draws a rounded rectangle with different corner radii. Supports positive and negative corner radii. A tiny API\n\t * method \"rc\" also exists.\n\t * @method drawRoundRectComplex\n\t * @param {Number} x The horizontal coordinate to draw the round rect.\n\t * @param {Number} y The vertical coordinate to draw the round rect.\n\t * @param {Number} w The width of the round rect.\n\t * @param {Number} h The height of the round rect.\n\t * @param {Number} radiusTL Top left corner radius.\n\t * @param {Number} radiusTR Top right corner radius.\n\t * @param {Number} radiusBR Bottom right corner radius.\n\t * @param {Number} radiusBL Bottom left corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawRoundRectComplex = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {\n\t\treturn this.append(new G.RoundRect(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL));\n\t};\n\n\t/**\n\t * Draws a circle with the specified radius at (x, y).\n\t *\n\t *      var g = new createjs.Graphics();\n\t *\t    g.setStrokeStyle(1);\n\t *\t    g.beginStroke(createjs.Graphics.getRGB(0,0,0));\n\t *\t    g.beginFill(createjs.Graphics.getRGB(255,0,0));\n\t *\t    g.drawCircle(0,0,3);\n\t *\n\t *\t    var s = new createjs.Shape(g);\n\t *\t\ts.x = 100;\n\t *\t\ts.y = 100;\n\t *\n\t *\t    stage.addChild(s);\n\t *\t    stage.update();\n\t *\n\t * A tiny API method \"dc\" also exists.\n\t * @method drawCircle\n\t * @param {Number} x x coordinate center point of circle.\n\t * @param {Number} y y coordinate center point of circle.\n\t * @param {Number} radius Radius of circle.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawCircle = function(x, y, radius) {\n\t\treturn this.append(new G.Circle(x, y, radius));\n\t};\n\n\t/**\n\t * Draws an ellipse (oval) with a specified width (w) and height (h). Similar to {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}},\n\t * except the width and height can be different. A tiny API method \"de\" also exists.\n\t * @method drawEllipse\n\t * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}}\n\t * which draws from center.\n\t * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}}\n\t * which draws from the center.\n\t * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this\n\t * number.\n\t * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawEllipse = function(x, y, w, h) {\n\t\treturn this.append(new G.Ellipse(x, y, w, h));\n\t};\n\n\t/**\n\t * Draws a star if pointSize is greater than 0, or a regular polygon if pointSize is 0 with the specified number of\n\t * points. For example, the following code will draw a familiar 5 pointed star shape centered at 100, 100 and with a\n\t * radius of 50:\n\t *\n\t *      myGraphics.beginFill(\"#FF0\").drawPolyStar(100, 100, 50, 5, 0.6, -90);\n\t *      // Note: -90 makes the first point vertical\n\t *\n\t * A tiny API method \"dp\" also exists.\n\t *\n\t * @method drawPolyStar\n\t * @param {Number} x Position of the center of the shape.\n\t * @param {Number} y Position of the center of the shape.\n\t * @param {Number} radius The outer radius of the shape.\n\t * @param {Number} sides The number of points on the star or sides on the polygon.\n\t * @param {Number} pointSize The depth or \"pointy-ness\" of the star points. A pointSize of 0 will draw a regular\n\t * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.\n\t * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point\n\t * directly to the right of the center.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawPolyStar = function(x, y, radius, sides, pointSize, angle) {\n\t\treturn this.append(new G.PolyStar(x, y, radius, sides, pointSize, angle));\n\t};\n\n\t// TODO: deprecated.\n\t/**\n\t * Removed in favour of using custom command objects with {{#crossLink \"Graphics/append\"}}{{/crossLink}}.\n\t * @method inject\n\t * @deprecated\n\t **/\n\n\t/**\n\t * Appends a graphics command object to the graphics queue. Command objects expose an \"exec\" method\n\t * that accepts two parameters: the Context2D to operate on, and an arbitrary data object passed into\n\t * {{#crossLink \"Graphics/draw\"}}{{/crossLink}}. The latter will usually be the Shape instance that called draw.\n\t *\n\t * This method is used internally by Graphics methods, such as drawCircle, but can also be used directly to insert\n\t * built-in or custom graphics commands. For example:\n\t *\n\t * \t\t// attach data to our shape, so we can access it during the draw:\n\t * \t\tmyShape.color = \"red\";\n\t *\n\t * \t\t// append a Circle command object:\n\t * \t\tmyShape.graphics.append(new createjs.Graphics.Circle(50, 50, 30));\n\t *\n\t * \t\t// append a custom command object with an exec method that sets the fill style\n\t * \t\t// based on the shape's data, and then fills the circle.\n\t * \t\tmyShape.graphics.append({exec:function(ctx, shape) {\n\t * \t\t\tctx.fillStyle = shape.color;\n\t * \t\t\tctx.fill();\n\t * \t\t}});\n\t *\n\t * @method append\n\t * @param {Object} command A graphics command object exposing an \"exec\" method.\n\t * @param {boolean} clean The clean param is primarily for internal use. A value of true indicates that a command does not generate a path that should be stroked or filled.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.append = function(command, clean) {\n\t\tthis._activeInstructions.push(command);\n\t\tthis.command = command;\n\t\tif (!clean) { this._dirty = true; }\n\t\treturn this;\n\t};\n\n\t/**\n\t * Decodes a compact encoded path string into a series of draw instructions.\n\t * This format is not intended to be human readable, and is meant for use by authoring tools.\n\t * The format uses a base64 character set, with each character representing 6 bits, to define a series of draw\n\t * commands.\n\t *\n\t * Each command is comprised of a single \"header\" character followed by a variable number of alternating x and y\n\t * position values. Reading the header bits from left to right (most to least significant): bits 1 to 3 specify the\n\t * type of operation (0-moveTo, 1-lineTo, 2-quadraticCurveTo, 3-bezierCurveTo, 4-closePath, 5-7 unused). Bit 4\n\t * indicates whether position values use 12 bits (2 characters) or 18 bits (3 characters), with a one indicating the\n\t * latter. Bits 5 and 6 are currently unused.\n\t *\n\t * Following the header is a series of 0 (closePath), 2 (moveTo, lineTo), 4 (quadraticCurveTo), or 6 (bezierCurveTo)\n\t * parameters. These parameters are alternating x/y positions represented by 2 or 3 characters (as indicated by the\n\t * 4th bit in the command char). These characters consist of a 1 bit sign (1 is negative, 0 is positive), followed\n\t * by an 11 (2 char) or 17 (3 char) bit integer value. All position values are in tenths of a pixel. Except in the\n\t * case of move operations which are absolute, this value is a delta from the previous x or y position (as\n\t * appropriate).\n\t *\n\t * For example, the string \"A3cAAMAu4AAA\" represents a line starting at -150,0 and ending at 150,0.\n\t * <br />A - bits 000000. First 3 bits (000) indicate a moveTo operation. 4th bit (0) indicates 2 chars per\n\t * parameter.\n\t * <br />n0 - 110111011100. Absolute x position of -150.0px. First bit indicates a negative value, remaining bits\n\t * indicate 1500 tenths of a pixel.\n\t * <br />AA - 000000000000. Absolute y position of 0.\n\t * <br />I - 001100. First 3 bits (001) indicate a lineTo operation. 4th bit (1) indicates 3 chars per parameter.\n\t * <br />Au4 - 000000101110111000. An x delta of 300.0px, which is added to the previous x value of -150.0px to\n\t * provide an absolute position of +150.0px.\n\t * <br />AAA - 000000000000000000. A y delta value of 0.\n\t *\n\t * A tiny API method \"p\" also exists.\n\t * @method decodePath\n\t * @param {String} str The path string to decode.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.decodePath = function(str) {\n\t\tvar instructions = [this.moveTo, this.lineTo, this.quadraticCurveTo, this.bezierCurveTo, this.closePath];\n\t\tvar paramCount = [2, 2, 4, 6, 0];\n\t\tvar i=0, l=str.length;\n\t\tvar params = [];\n\t\tvar x=0, y=0;\n\t\tvar base64 = Graphics.BASE_64;\n\n\t\twhile (i<l) {\n\t\t\tvar c = str.charAt(i);\n\t\t\tvar n = base64[c];\n\t\t\tvar fi = n>>3; // highest order bits 1-3 code for operation.\n\t\t\tvar f = instructions[fi];\n\t\t\t// check that we have a valid instruction & that the unused bits are empty:\n\t\t\tif (!f || (n&3)) { throw(\"bad path data (@\"+i+\"): \"+c); }\n\t\t\tvar pl = paramCount[fi];\n\t\t\tif (!fi) { x=y=0; } // move operations reset the position.\n\t\t\tparams.length = 0;\n\t\t\ti++;\n\t\t\tvar charCount = (n>>2&1)+2;  // 4th header bit indicates number size for this operation.\n\t\t\tfor (var p=0; p<pl; p++) {\n\t\t\t\tvar num = base64[str.charAt(i)];\n\t\t\t\tvar sign = (num>>5) ? -1 : 1;\n\t\t\t\tnum = ((num&31)<<6)|(base64[str.charAt(i+1)]);\n\t\t\t\tif (charCount == 3) { num = (num<<6)|(base64[str.charAt(i+2)]); }\n\t\t\t\tnum = sign*num/10;\n\t\t\t\tif (p%2) { x = (num += x); }\n\t\t\t\telse { y = (num += y); }\n\t\t\t\tparams[p] = num;\n\t\t\t\ti += charCount;\n\t\t\t}\n\t\t\tf.apply(this,params);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Stores all graphics commands so they won't be executed in future draws. Calling store() a second time adds to\n\t * the existing store. This also affects `drawAsPath()`.\n\t *\n\t * This is useful in cases where you are creating vector graphics in an iterative manner (ex. generative art), so\n\t * that only new graphics need to be drawn (which can provide huge performance benefits), but you wish to retain all\n\t * of the vector instructions for later use (ex. scaling, modifying, or exporting).\n\t *\n\t * Note that calling store() will force the active path (if any) to be ended in a manner similar to changing\n\t * the fill or stroke.\n\t *\n\t * For example, consider a application where the user draws lines with the mouse. As each line segment (or collection of\n\t * segments) are added to a Shape, it can be rasterized using {{#crossLink \"DisplayObject/updateCache\"}}{{/crossLink}},\n\t * and then stored, so that it can be redrawn at a different scale when the application is resized, or exported to SVG.\n\t *\n\t * \t// set up cache:\n\t * \tmyShape.cache(0,0,500,500,scale);\n\t *\n\t * \t// when the user drags, draw a new line:\n\t * \tmyShape.graphics.moveTo(oldX,oldY).lineTo(newX,newY);\n\t * \t// then draw it into the existing cache:\n\t * \tmyShape.updateCache(\"source-over\");\n\t * \t// store the new line, so it isn't redrawn next time:\n\t * \tmyShape.store();\n\t *\n\t * \t// then, when the window resizes, we can re-render at a different scale:\n\t * \t// first, unstore all our lines:\n\t * \tmyShape.unstore();\n\t * \t// then cache using the new scale:\n\t * \tmyShape.cache(0,0,500,500,newScale);\n\t * \t// finally, store the existing commands again:\n\t * \tmyShape.store();\n\t *\n\t * @method store\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.store = function() {\n\t\tthis._updateInstructions(true);\n\t\tthis._storeIndex = this._instructions.length;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Unstores any graphics commands that were previously stored using {{#crossLink \"Graphics/store\"}}{{/crossLink}}\n\t * so that they will be executed in subsequent draw calls.\n\t *\n\t * @method unstore\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.unstore = function() {\n\t\tthis._storeIndex = 0;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns a clone of this Graphics instance. Note that the individual command objects are not cloned.\n\t * @method clone\n\t * @return {Graphics} A clone of the current Graphics instance.\n\t **/\n\tp.clone = function() {\n\t\tvar o = new Graphics();\n\t\to.command = this.command;\n\t\to._stroke = this._stroke;\n\t\to._strokeStyle = this._strokeStyle;\n\t\to._strokeDash = this._strokeDash;\n\t\to._strokeIgnoreScale = this._strokeIgnoreScale;\n\t\to._fill = this._fill;\n\t\to._instructions = this._instructions.slice();\n\t\to._commitIndex = this._commitIndex;\n\t\to._activeInstructions = this._activeInstructions.slice();\n\t\to._dirty = this._dirty;\n\t\to._storeIndex = this._storeIndex;\n\t\treturn o;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Graphics]\";\n\t};\n\n\n// tiny API:\n\t/**\n\t * Shortcut to moveTo.\n\t * @method mt\n\t * @param {Number} x The x coordinate the drawing point should move to.\n\t * @param {Number} y The y coordinate the drawing point should move to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).\n\t * @chainable\n\t * @protected\n\t **/\n\tp.mt = p.moveTo;\n\n\t/**\n\t * Shortcut to lineTo.\n\t * @method lt\n\t * @param {Number} x The x coordinate the drawing point should draw to.\n\t * @param {Number} y The y coordinate the drawing point should draw to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.lt = p.lineTo;\n\n\t/**\n\t * Shortcut to arcTo.\n\t * @method at\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} x2\n\t * @param {Number} y2\n\t * @param {Number} radius\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.at = p.arcTo;\n\n\t/**\n\t * Shortcut to bezierCurveTo.\n\t * @method bt\n\t * @param {Number} cp1x\n\t * @param {Number} cp1y\n\t * @param {Number} cp2x\n\t * @param {Number} cp2y\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.bt = p.bezierCurveTo;\n\n\t/**\n\t * Shortcut to quadraticCurveTo / curveTo.\n\t * @method qt\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @protected\n\t * @chainable\n\t **/\n\tp.qt = p.quadraticCurveTo;\n\n\t/**\n\t * Shortcut to arc.\n\t * @method a\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} startAngle Measured in radians.\n\t * @param {Number} endAngle Measured in radians.\n\t * @param {Boolean} anticlockwise\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @protected\n\t * @chainable\n\t **/\n\tp.a = p.arc;\n\n\t/**\n\t * Shortcut to rect.\n\t * @method r\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.r = p.rect;\n\n\t/**\n\t * Shortcut to closePath.\n\t * @method cp\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.cp = p.closePath;\n\n\t/**\n\t * Shortcut to clear.\n\t * @method c\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.c = p.clear;\n\n\t/**\n\t * Shortcut to beginFill.\n\t * @method f\n\t * @param {String} color A CSS compatible color value (ex. \"red\", \"#FF0000\", or \"rgba(255,0,0,0.5)\"). Setting to\n\t * null will result in no fill.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.f = p.beginFill;\n\n\t/**\n\t * Shortcut to beginLinearGradientFill.\n\t * @method lf\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define a gradient\n\t * drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw\n\t * the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.lf = p.beginLinearGradientFill;\n\n\t/**\n\t * Shortcut to beginRadialGradientFill.\n\t * @method rf\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rf = p.beginRadialGradientFill;\n\n\t/**\n\t * Shortcut to beginBitmapFill.\n\t * @method bf\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern.\n\t * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of \"repeat\",\n\t * \"repeat-x\", \"repeat-y\", or \"no-repeat\". Defaults to \"repeat\". Note that Firefox does not support \"repeat-x\" or\n\t * \"repeat-y\" (latest tests were in FF 20.0), and will default to \"repeat\".\n\t * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation\n\t * will be applied relative to the parent transform.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.bf = p.beginBitmapFill;\n\n\t/**\n\t * Shortcut to endFill.\n\t * @method ef\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.ef = p.endFill;\n\n\t/**\n\t * Shortcut to setStrokeStyle.\n\t * @method ss\n\t * @param {Number} thickness The width of the stroke.\n\t * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,\n\t * round, or square. Defaults to \"butt\". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with\n\t * the tiny API.\n\t * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.\n\t * One of bevel, round, or miter. Defaults to \"miter\". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)\n\t * for use with the tiny API.\n\t * @param {Number} [miterLimit=10] If joints is set to \"miter\", then you can specify a miter limit ratio which\n\t * controls at what point a mitered joint will be clipped.\n\t * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless\n\t * of active transformations.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.ss = p.setStrokeStyle;\n\t\n\t/**\n\t * Shortcut to setStrokeDash.\n\t * @method sd\n\t * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.\n\t * For example, [20,10] would create a pattern of 20 pixel lines with 10 pixel gaps between them.\n\t * Passing null or an empty array will clear any existing dash.\n\t * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a \"marching ants\" effect.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.sd = p.setStrokeDash;\n\n\t/**\n\t * Shortcut to beginStroke.\n\t * @method s\n\t * @param {String} color A CSS compatible color value (ex. \"#FF0000\", \"red\", or \"rgba(255,0,0,0.5)\"). Setting to\n\t * null will result in no stroke.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.s = p.beginStroke;\n\n\t/**\n\t * Shortcut to beginLinearGradientStroke.\n\t * @method ls\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.ls = p.beginLinearGradientStroke;\n\n\t/**\n\t * Shortcut to beginRadialGradientStroke.\n\t * @method rs\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color\n\t * to 100%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rs = p.beginRadialGradientStroke;\n\n\t/**\n\t * Shortcut to beginBitmapStroke.\n\t * @method bs\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern.\n\t * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of\n\t * \"repeat\", \"repeat-x\", \"repeat-y\", or \"no-repeat\". Defaults to \"repeat\".\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.bs = p.beginBitmapStroke;\n\n\t/**\n\t * Shortcut to endStroke.\n\t * @method es\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.es = p.endStroke;\n\n\t/**\n\t * Shortcut to drawRect.\n\t * @method dr\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.dr = p.drawRect;\n\n\t/**\n\t * Shortcut to drawRoundRect.\n\t * @method rr\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t * @param {Number} radius Corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rr = p.drawRoundRect;\n\n\t/**\n\t * Shortcut to drawRoundRectComplex.\n\t * @method rc\n\t * @param {Number} x The horizontal coordinate to draw the round rect.\n\t * @param {Number} y The vertical coordinate to draw the round rect.\n\t * @param {Number} w The width of the round rect.\n\t * @param {Number} h The height of the round rect.\n\t * @param {Number} radiusTL Top left corner radius.\n\t * @param {Number} radiusTR Top right corner radius.\n\t * @param {Number} radiusBR Bottom right corner radius.\n\t * @param {Number} radiusBL Bottom left corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rc = p.drawRoundRectComplex;\n\n\t/**\n\t * Shortcut to drawCircle.\n\t * @method dc\n\t * @param {Number} x x coordinate center point of circle.\n\t * @param {Number} y y coordinate center point of circle.\n\t * @param {Number} radius Radius of circle.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.dc = p.drawCircle;\n\n\t/**\n\t * Shortcut to drawEllipse.\n\t * @method de\n\t * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}}\n\t * which draws from center.\n\t * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}}\n\t * which draws from the center.\n\t * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this\n\t * number.\n\t * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.de = p.drawEllipse;\n\n\t/**\n\t * Shortcut to drawPolyStar.\n\t * @method dp\n\t * @param {Number} x Position of the center of the shape.\n\t * @param {Number} y Position of the center of the shape.\n\t * @param {Number} radius The outer radius of the shape.\n\t * @param {Number} sides The number of points on the star or sides on the polygon.\n\t * @param {Number} pointSize The depth or \"pointy-ness\" of the star points. A pointSize of 0 will draw a regular\n\t * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.\n\t * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point\n\t * directly to the right of the center.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.dp = p.drawPolyStar;\n\n\t/**\n\t * Shortcut to decodePath.\n\t * @method p\n\t * @param {String} str The path string to decode.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.p = p.decodePath;\n\n\n// private methods:\n\t/**\n\t * @method _updateInstructions\n\t * @param commit\n\t * @protected\n\t **/\n\tp._updateInstructions = function(commit) {\n\t\tvar instr = this._instructions, active = this._activeInstructions, commitIndex = this._commitIndex;\n\n\t\tif (this._dirty && active.length) {\n\t\t\tinstr.length = commitIndex; // remove old, uncommitted commands\n\t\t\tinstr.push(Graphics.beginCmd);\n\n\t\t\tvar l = active.length, ll = instr.length;\n\t\t\tinstr.length = ll+l;\n\t\t\tfor (var i=0; i<l; i++) { instr[i+ll] = active[i]; }\n\n\t\t\tif (this._fill) { instr.push(this._fill); }\n\t\t\tif (this._stroke) {\n\t\t\t\t// doesn't need to be re-applied if it hasn't changed.\n\t\t\t\tif (this._strokeDash !== this._oldStrokeDash) {\n\t\t\t\t\tthis._oldStrokeDash = this._strokeDash;\n\t\t\t\t\tinstr.push(this._strokeDash);\n\t\t\t\t}\n\t\t\t\tif (this._strokeStyle !== this._oldStrokeStyle) {\n\t\t\t\t\tthis._oldStrokeStyle = this._strokeStyle;\n\t\t\t\t\tinstr.push(this._strokeStyle);\n\t\t\t\t}\n\t\t\t\tinstr.push(this._stroke);\n\t\t\t}\n\n\t\t\tthis._dirty = false;\n\t\t}\n\n\t\tif (commit) {\n\t\t\tactive.length = 0;\n\t\t\tthis._commitIndex = instr.length;\n\t\t}\n\t};\n\n\t/**\n\t * @method _setFill\n\t * @param fill\n\t * @protected\n\t **/\n\tp._setFill = function(fill) {\n\t\tthis._updateInstructions(true);\n\t\tthis.command = this._fill = fill;\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method _setStroke\n\t * @param stroke\n\t * @protected\n\t **/\n\tp._setStroke = function(stroke) {\n\t\tthis._updateInstructions(true);\n\t\tif (this.command = this._stroke = stroke) {\n\t\t\tstroke.ignoreScale = this._strokeIgnoreScale;\n\t\t}\n\t\treturn this;\n\t};\n\n// Command Objects:\n\t/**\n\t * @namespace Graphics\n\t */\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/lineTo\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information. See {{#crossLink \"Graphics\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class LineTo\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.LineTo = function(x, y) {\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.lineTo(this.x,this.y); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/moveTo\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class MoveTo\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx\n\t */\n\t(G.MoveTo = function(x, y) {\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.moveTo(this.x, this.y); };\n\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/arcTo\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class ArcTo\n\t * @constructor\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} x2\n\t * @param {Number} y2\n\t * @param {Number} radius\n\t **/\n\t/**\n\t * @property x1\n\t * @type Number\n\t */\n\t/**\n\t * @property y1\n\t * @type Number\n\t */\n\t/**\n\t * @property x2\n\t * @type Number\n\t */\n\t/**\n\t * @property y2\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.ArcTo = function(x1, y1, x2, y2, radius) {\n\t\tthis.x1 = x1; this.y1 = y1;\n\t\tthis.x2 = x2; this.y2 = y2;\n\t\tthis.radius = radius;\n\t}).prototype.exec = function(ctx) { ctx.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/arc\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Arc\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} startAngle\n\t * @param {Number} endAngle\n\t * @param {Number} anticlockwise\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * @property startAngle\n\t * @type Number\n\t */\n\t/**\n\t * @property endAngle\n\t * @type Number\n\t */\n\t/**\n\t * @property anticlockwise\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.radius = radius;\n\t\tthis.startAngle = startAngle; this.endAngle = endAngle;\n\t\tthis.anticlockwise = !!anticlockwise;\n\t}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/quadraticCurveTo\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class QuadraticCurveTo\n\t * @constructor\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property cpx\n\t * @type Number\n\t */\n\t/**\n\t * @property cpy\n\t * @type Number\n\t */\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.QuadraticCurveTo = function(cpx, cpy, x, y) {\n\t\tthis.cpx = cpx; this.cpy = cpy;\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.quadraticCurveTo(this.cpx, this.cpy, this.x, this.y); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/bezierCurveTo\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class BezierCurveTo\n\t * @constructor\n\t * @param {Number} cp1x\n\t * @param {Number} cp1y\n\t * @param {Number} cp2x\n\t * @param {Number} cp2y\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property cp1x\n\t * @type Number\n\t */\n\t/**\n\t * @property cp1y\n\t * @type Number\n\t */\n\t/**\n\t * @property cp2x\n\t * @type Number\n\t */\n\t/**\n\t * @property cp2y\n\t * @type Number\n\t */\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.BezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n\t\tthis.cp1x = cp1x; this.cp1y = cp1y;\n\t\tthis.cp2x = cp2x; this.cp2y = cp2y;\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.bezierCurveTo(this.cp1x, this.cp1y, this.cp2x, this.cp2y, this.x, this.y); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/rect\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Rect\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property w\n\t * @type Number\n\t */\n\t/**\n\t * @property h\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Rect = function(x, y, w, h) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.w = w; this.h = h;\n\t}).prototype.exec = function(ctx) { ctx.rect(this.x, this.y, this.w, this.h); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/closePath\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class ClosePath\n\t * @constructor\n\t **/\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.ClosePath = function() {\n\t}).prototype.exec = function(ctx) { ctx.closePath(); };\n\n\t/**\n\t * Graphics command object to begin a new path. See {{#crossLink \"Graphics\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class BeginPath\n\t * @constructor\n\t **/\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.BeginPath = function() {\n\t}).prototype.exec = function(ctx) { ctx.beginPath(); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/beginFill\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Fill\n\t * @constructor\n\t * @param {Object} style A valid Context2D fillStyle.\n\t * @param {Matrix2D} matrix\n\t **/\n\t/**\n\t * A valid Context2D fillStyle.\n\t * @property style\n\t * @type Object\n\t */\n\t/**\n\t * @property matrix\n\t * @type Matrix2D\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\tp = (G.Fill = function(style, matrix) {\n\t\tthis.style = style;\n\t\tthis.matrix = matrix;\n\t}).prototype;\n\tp.exec = function(ctx) {\n\t\tif (!this.style) { return; }\n\t\tctx.fillStyle = this.style;\n\t\tvar mtx = this.matrix;\n\t\tif (mtx) { ctx.save(); ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty); }\n\t\tctx.fill();\n\t\tif (mtx) { ctx.restore(); }\n\t};\n\t/**\n\t * Creates a linear gradient style and assigns it to {{#crossLink \"Fill/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginLinearGradientFill\"}}{{/crossLink}} for more information.\n\t * @method linearGradient\n\t * @param {Array} colors\n\t *\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @return {Fill} Returns this Fill object for chaining or assignment.\n\t */\n\tp.linearGradient = function(colors, ratios, x0, y0, x1, y1) {\n\t\tvar o = this.style =  Graphics._ctx.createLinearGradient(x0, y0, x1, y1);\n\t\tfor (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }\n\t\to.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, x1:x1, y1:y1, type:\"linear\"};\n\t\treturn this;\n\t};\n\t/**\n\t * Creates a radial gradient style and assigns it to {{#crossLink \"Fill/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginRadialGradientFill\"}}{{/crossLink}} for more information.\n\t * @method radialGradient\n\t * @param {Array} colors\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} r0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} r1\n\t * @return {Fill} Returns this Fill object for chaining or assignment.\n\t */\n\tp.radialGradient = function(colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\tvar o = this.style =  Graphics._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);\n\t\tfor (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }\n\t\to.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, r0:r0, x1:x1, y1:y1, r1:r1, type:\"radial\"};\n\t\treturn this;\n\t};\n\t/**\n\t * Creates a bitmap fill style and assigns it to the {{#crossLink \"Fill/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginBitmapFill\"}}{{/crossLink}} for more information.\n\t * @method bitmap\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image  Must be loaded prior to creating a bitmap fill, or the fill will be empty.\n\t * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.\n\t * @return {Fill} Returns this Fill object for chaining or assignment.\n\t */\n\tp.bitmap = function(image, repetition) {\n\t\tif (image.naturalWidth || image.getContext || image.readyState >= 2) {\n\t\t\tvar o = this.style = Graphics._ctx.createPattern(image, repetition || \"\");\n\t\t\to.props = {image: image, repetition: repetition, type: \"bitmap\"};\n\t\t}\n\t\treturn this;\n\t};\n\tp.path = false;\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/beginStroke\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Stroke\n\t * @constructor\n\t * @param {Object} style A valid Context2D fillStyle.\n\t * @param {Boolean} ignoreScale\n\t **/\n\t/**\n\t * A valid Context2D strokeStyle.\n\t * @property style\n\t * @type Object\n\t */\n\t/**\n\t * @property ignoreScale\n\t * @type Boolean\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\tp = (G.Stroke = function(style, ignoreScale) {\n\t\tthis.style = style;\n\t\tthis.ignoreScale = ignoreScale;\n\t}).prototype;\n\tp.exec = function(ctx) {\n\t\tif (!this.style) { return; }\n\t\tctx.strokeStyle = this.style;\n\t\tif (this.ignoreScale) { ctx.save(); ctx.setTransform(1,0,0,1,0,0); }\n\t\tctx.stroke();\n\t\tif (this.ignoreScale) { ctx.restore(); }\n\t};\n\t/**\n\t * Creates a linear gradient style and assigns it to {{#crossLink \"Stroke/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginLinearGradientStroke\"}}{{/crossLink}} for more information.\n\t * @method linearGradient\n\t * @param {Array} colors\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @return {Fill} Returns this Stroke object for chaining or assignment.\n\t */\n\tp.linearGradient = G.Fill.prototype.linearGradient;\n\t/**\n\t * Creates a radial gradient style and assigns it to {{#crossLink \"Stroke/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginRadialGradientStroke\"}}{{/crossLink}} for more information.\n\t * @method radialGradient\n\t * @param {Array} colors\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} r0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} r1\n\t * @return {Fill} Returns this Stroke object for chaining or assignment.\n\t */\n\tp.radialGradient = G.Fill.prototype.radialGradient;\n\t/**\n\t * Creates a bitmap fill style and assigns it to {{#crossLink \"Stroke/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginBitmapStroke\"}}{{/crossLink}} for more information.\n\t * @method bitmap\n\t * @param {HTMLImageElement} image\n\t * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.\n\t * @return {Fill} Returns this Stroke object for chaining or assignment.\n\t */\n\tp.bitmap = G.Fill.prototype.bitmap;\n\tp.path = false;\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/setStrokeStyle\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class StrokeStyle\n\t * @constructor\n\t * @param {Number} width\n\t * @param {String} [caps=butt]\n\t * @param {String} [joints=miter]\n\t * @param {Number} [miterLimit=10]\n\t * @param {Boolean} [ignoreScale=false]\n\t **/\n\t/**\n\t * @property width\n\t * @type Number\n\t */\n\t/**\n\t * One of: butt, round, square\n\t * @property caps\n\t * @type String\n\t */\n\t/**\n\t * One of: round, bevel, miter\n\t * @property joints\n\t * @type String\n\t */\n\t/**\n\t * @property miterLimit\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\tp = (G.StrokeStyle = function(width, caps, joints, miterLimit, ignoreScale) {\n\t\tthis.width = width;\n\t\tthis.caps = caps;\n\t\tthis.joints = joints;\n\t\tthis.miterLimit = miterLimit;\n\t\tthis.ignoreScale = ignoreScale;\n\t}).prototype;\n\tp.exec = function(ctx) {\n\t\tctx.lineWidth = (this.width == null ? \"1\" : this.width);\n\t\tctx.lineCap = (this.caps == null ? \"butt\" : (isNaN(this.caps) ? this.caps : Graphics.STROKE_CAPS_MAP[this.caps]));\n\t\tctx.lineJoin = (this.joints == null ? \"miter\" : (isNaN(this.joints) ? this.joints : Graphics.STROKE_JOINTS_MAP[this.joints]));\n\t\tctx.miterLimit = (this.miterLimit == null ? \"10\" : this.miterLimit);\n\t\tctx.ignoreScale = (this.ignoreScale == null ? false : this.ignoreScale);\n\t};\n\tp.path = false;\n\t\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/setStrokeDash\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class StrokeDash\n\t * @constructor\n\t * @param {Array} [segments]\n\t * @param {Number} [offset=0]\n\t **/\n\t/**\n\t * @property segments\n\t * @type Array\n\t */\n\t/**\n\t * @property offset\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.StrokeDash = function(segments, offset) {\n\t\tthis.segments = segments;\n\t\tthis.offset = offset||0;\n\t}).prototype.exec = function(ctx) {\n\t\tif (ctx.setLineDash) { // feature detection.\n\t\t\tctx.setLineDash(this.segments|| G.StrokeDash.EMPTY_SEGMENTS); // instead of [] to reduce churn.\n\t\t\tctx.lineDashOffset = this.offset||0;\n\t\t}\n\t};\n\t/**\n\t * The default value for segments (ie. no dash).\n\t * @property EMPTY_SEGMENTS\n\t * @static\n\t * @final\n\t * @readonly\n\t * @protected\n\t * @type {Array}\n\t **/\n\tG.StrokeDash.EMPTY_SEGMENTS = [];\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/drawRoundRectComplex\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class RoundRect\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t * @param {Number} radiusTL\n\t * @param {Number} radiusTR\n\t * @param {Number} radiusBR\n\t * @param {Number} radiusBL\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property w\n\t * @type Number\n\t */\n\t/**\n\t * @property h\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusTL\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusTR\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusBR\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusBL\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.RoundRect = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.w = w; this.h = h;\n\t\tthis.radiusTL = radiusTL; this.radiusTR = radiusTR;\n\t\tthis.radiusBR = radiusBR; this.radiusBL = radiusBL;\n\t}).prototype.exec = function(ctx) {\n\t\tvar max = (w<h?w:h)/2;\n\t\tvar mTL=0, mTR=0, mBR=0, mBL=0;\n\t\tvar x = this.x, y = this.y, w = this.w, h = this.h;\n\t\tvar rTL = this.radiusTL, rTR = this.radiusTR, rBR = this.radiusBR, rBL = this.radiusBL;\n\n\t\tif (rTL < 0) { rTL *= (mTL=-1); }\n\t\tif (rTL > max) { rTL = max; }\n\t\tif (rTR < 0) { rTR *= (mTR=-1); }\n\t\tif (rTR > max) { rTR = max; }\n\t\tif (rBR < 0) { rBR *= (mBR=-1); }\n\t\tif (rBR > max) { rBR = max; }\n\t\tif (rBL < 0) { rBL *= (mBL=-1); }\n\t\tif (rBL > max) { rBL = max; }\n\n\t\tctx.moveTo(x+w-rTR, y);\n\t\tctx.arcTo(x+w+rTR*mTR, y-rTR*mTR, x+w, y+rTR, rTR);\n\t\tctx.lineTo(x+w, y+h-rBR);\n\t\tctx.arcTo(x+w+rBR*mBR, y+h+rBR*mBR, x+w-rBR, y+h, rBR);\n\t\tctx.lineTo(x+rBL, y+h);\n\t\tctx.arcTo(x-rBL*mBL, y+h+rBL*mBL, x, y+h-rBL, rBL);\n\t\tctx.lineTo(x, y+rTL);\n\t\tctx.arcTo(x-rTL*mTL, y-rTL*mTL, x+rTL, y, rTL);\n\t\tctx.closePath();\n\t};\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Circle\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Circle = function(x, y, radius) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.radius = radius;\n\t}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/drawEllipse\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Ellipse\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property w\n\t * @type Number\n\t */\n\t/**\n\t * @property h\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Ellipse = function(x, y, w, h) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.w = w; this.h = h;\n\t}).prototype.exec = function(ctx) {\n\t\tvar x = this.x, y = this.y;\n\t\tvar w = this.w, h = this.h;\n\n\t\tvar k = 0.5522848;\n\t\tvar ox = (w / 2) * k;\n\t\tvar oy = (h / 2) * k;\n\t\tvar xe = x + w;\n\t\tvar ye = y + h;\n\t\tvar xm = x + w / 2;\n\t\tvar ym = y + h / 2;\n\n\t\tctx.moveTo(x, ym);\n\t\tctx.bezierCurveTo(x, ym-oy, xm-ox, y, xm, y);\n\t\tctx.bezierCurveTo(xm+ox, y, xe, ym-oy, xe, ym);\n\t\tctx.bezierCurveTo(xe, ym+oy, xm+ox, ye, xm, ye);\n\t\tctx.bezierCurveTo(xm-ox, ye, x, ym+oy, x, ym);\n\t};\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/drawPolyStar\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class PolyStar\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} sides\n\t * @param {Number} pointSize\n\t * @param {Number} angle\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * @property sides\n\t * @type Number\n\t */\n\t/**\n\t * @property pointSize\n\t * @type Number\n\t */\n\t/**\n\t * @property angle\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.PolyStar = function(x, y, radius, sides, pointSize, angle) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.radius = radius;\n\t\tthis.sides = sides;\n\t\tthis.pointSize = pointSize;\n\t\tthis.angle = angle;\n\t}).prototype.exec = function(ctx) {\n\t\tvar x = this.x, y = this.y;\n\t\tvar radius = this.radius;\n\t\tvar angle = (this.angle||0)/180*Math.PI;\n\t\tvar sides = this.sides;\n\t\tvar ps = 1-(this.pointSize||0);\n\t\tvar a = Math.PI/sides;\n\n\t\tctx.moveTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);\n\t\tfor (var i=0; i<sides; i++) {\n\t\t\tangle += a;\n\t\t\tif (ps != 1) {\n\t\t\t\tctx.lineTo(x+Math.cos(angle)*radius*ps, y+Math.sin(angle)*radius*ps);\n\t\t\t}\n\t\t\tangle += a;\n\t\t\tctx.lineTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);\n\t\t}\n\t\tctx.closePath();\n\t};\n\n\t// docced above.\n\tGraphics.beginCmd = new G.BeginPath(); // so we don't have to instantiate multiple instances.\n\n\n\tcreatejs.Graphics = Graphics;\n}());\n\n//##############################################################################\n// DisplayObject.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * DisplayObject is an abstract class that should not be constructed directly. Instead construct subclasses such as\n\t * {{#crossLink \"Container\"}}{{/crossLink}}, {{#crossLink \"Bitmap\"}}{{/crossLink}}, and {{#crossLink \"Shape\"}}{{/crossLink}}.\n\t * DisplayObject is the base class for all display classes in the EaselJS library. It defines the core properties and\n\t * methods that are shared between all display objects, such as transformation properties (x, y, scaleX, scaleY, etc),\n\t * caching, and mouse handlers.\n\t * @class DisplayObject\n\t * @extends EventDispatcher\n\t * @constructor\n\t **/\n\tfunction DisplayObject() {\n\t\tthis.EventDispatcher_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The alpha (transparency) for this display object. 0 is fully transparent, 1 is fully opaque.\n\t\t * @property alpha\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis.alpha = 1;\n\t\n\t\t/**\n\t\t * If a cache is active, this returns the canvas that holds the cached version of this display object. See {{#crossLink \"cache\"}}{{/crossLink}}\n\t\t * for more information.\n\t\t * @property cacheCanvas\n\t\t * @type {HTMLCanvasElement | Object}\n\t\t * @default null\n\t\t * @readonly\n\t\t **/\n\t\tthis.cacheCanvas = null;\n\t\n\t\t/**\n\t\t * Returns an ID number that uniquely identifies the current cache for this display object. This can be used to\n\t\t * determine if the cache has changed since a previous check.\n\t\t * @property cacheID\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.cacheID = 0;\n\t\n\t\t/**\n\t\t * Unique ID for this display object. Makes display objects easier for some uses.\n\t\t * @property id\n\t\t * @type {Number}\n\t\t * @default -1\n\t\t **/\n\t\tthis.id = createjs.UID.get();\n\t\n\t\t/**\n\t\t * Indicates whether to include this object when running mouse interactions. Setting this to `false` for children\n\t\t * of a {{#crossLink \"Container\"}}{{/crossLink}} will cause events on the Container to not fire when that child is\n\t\t * clicked. Setting this property to `false` does not prevent the {{#crossLink \"Container/getObjectsUnderPoint\"}}{{/crossLink}}\n\t\t * method from returning the child.\n\t\t *\n\t\t * <strong>Note:</strong> In EaselJS 0.7.0, the mouseEnabled property will not work properly with nested Containers. Please\n\t\t * check out the latest NEXT version in <a href=\"https://github.com/CreateJS/EaselJS/tree/master/lib\">GitHub</a> for an updated version with this issue resolved. The fix will be\n\t\t * provided in the next release of EaselJS.\n\t\t * @property mouseEnabled\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t **/\n\t\tthis.mouseEnabled = true;\n\t\t\n\t\t/**\n\t\t * If false, the tick will not run on this display object (or its children). This can provide some performance benefits.\n\t\t * In addition to preventing the \"tick\" event from being dispatched, it will also prevent tick related updates\n\t\t * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).\n\t\t * @property tickEnabled\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.tickEnabled = true;\n\t\n\t\t/**\n\t\t * An optional name for this display object. Included in {{#crossLink \"DisplayObject/toString\"}}{{/crossLink}} . Useful for\n\t\t * debugging.\n\t\t * @property name\n\t\t * @type {String}\n\t\t * @default null\n\t\t **/\n\t\tthis.name = null;\n\t\n\t\t/**\n\t\t * A reference to the {{#crossLink \"Container\"}}{{/crossLink}} or {{#crossLink \"Stage\"}}{{/crossLink}} object that\n\t\t * contains this display object, or null if it has not been added\n\t\t * to one.\n\t\t * @property parent\n\t\t * @final\n\t\t * @type {Container}\n\t\t * @default null\n\t\t * @readonly\n\t\t **/\n\t\tthis.parent = null;\n\t\n\t\t/**\n\t\t * The left offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate\n\t\t * around its center, you would set regX and {{#crossLink \"DisplayObject/regY:property\"}}{{/crossLink}} to 50.\n\t\t * @property regX\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.regX = 0;\n\t\n\t\t/**\n\t\t * The y offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate around\n\t\t * its center, you would set {{#crossLink \"DisplayObject/regX:property\"}}{{/crossLink}} and regY to 50.\n\t\t * @property regY\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.regY = 0;\n\t\n\t\t/**\n\t\t * The rotation in degrees for this display object.\n\t\t * @property rotation\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.rotation = 0;\n\t\n\t\t/**\n\t\t * The factor to stretch this display object horizontally. For example, setting scaleX to 2 will stretch the display\n\t\t * object to twice its nominal width. To horizontally flip an object, set the scale to a negative number.\n\t\t * @property scaleX\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis.scaleX = 1;\n\t\n\t\t/**\n\t\t * The factor to stretch this display object vertically. For example, setting scaleY to 0.5 will stretch the display\n\t\t * object to half its nominal height. To vertically flip an object, set the scale to a negative number.\n\t\t * @property scaleY\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis.scaleY = 1;\n\t\n\t\t/**\n\t\t * The factor to skew this display object horizontally.\n\t\t * @property skewX\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.skewX = 0;\n\t\n\t\t/**\n\t\t * The factor to skew this display object vertically.\n\t\t * @property skewY\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.skewY = 0;\n\t\n\t\t/**\n\t\t * A shadow object that defines the shadow to render on this display object. Set to `null` to remove a shadow. If\n\t\t * null, this property is inherited from the parent container.\n\t\t * @property shadow\n\t\t * @type {Shadow}\n\t\t * @default null\n\t\t **/\n\t\tthis.shadow = null;\n\t\n\t\t/**\n\t\t * Indicates whether this display object should be rendered to the canvas and included when running the Stage\n\t\t * {{#crossLink \"Stage/getObjectsUnderPoint\"}}{{/crossLink}} method.\n\t\t * @property visible\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t **/\n\t\tthis.visible = true;\n\t\n\t\t/**\n\t\t * The x (horizontal) position of the display object, relative to its parent.\n\t\t * @property x\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.x = 0;\n\t\n\t\t/** The y (vertical) position of the display object, relative to its parent.\n\t\t * @property y\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.y = 0;\n\t\t\n\t\t/**\n\t\t * If set, defines the transformation for this display object, overriding all other transformation properties\n\t\t * (x, y, rotation, scale, skew).\n\t\t * @property transformMatrix\n\t\t * @type {Matrix2D}\n\t\t * @default null\n\t\t **/\n\t\tthis.transformMatrix = null;\n\t\t\n\t\t/**\n\t\t * The composite operation indicates how the pixels of this display object will be composited with the elements\n\t\t * behind it. If `null`, this property is inherited from the parent container. For more information, read the\n\t\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing\">\n\t\t * whatwg spec on compositing</a>.\n\t\t * @property compositeOperation\n\t\t * @type {String}\n\t\t * @default null\n\t\t **/\n\t\tthis.compositeOperation = null;\n\t\n\t\t/**\n\t\t * Indicates whether the display object should be drawn to a whole pixel when\n\t\t * {{#crossLink \"Stage/snapToPixelEnabled\"}}{{/crossLink}} is true. To enable/disable snapping on whole\n\t\t * categories of display objects, set this value on the prototype (Ex. Text.prototype.snapToPixel = true).\n\t\t * @property snapToPixel\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t **/\n\t\tthis.snapToPixel = true;\n\t\n\t\t/**\n\t\t * An array of Filter objects to apply to this display object. Filters are only applied / updated when {{#crossLink \"cache\"}}{{/crossLink}}\n\t\t * or {{#crossLink \"updateCache\"}}{{/crossLink}} is called on the display object, and only apply to the area that is\n\t\t * cached.\n\t\t * @property filters\n\t\t * @type {Array}\n\t\t * @default null\n\t\t **/\n\t\tthis.filters = null;\n\t\t\n\t\t/**\n\t\t * A Shape instance that defines a vector mask (clipping path) for this display object.  The shape's transformation\n\t\t * will be applied relative to the display object's parent coordinates (as if it were a child of the parent).\n\t\t * @property mask\n\t\t * @type {Shape}\n\t\t * @default null\n\t\t */\n\t\tthis.mask = null;\n\t\t\n\t\t/**\n\t\t * A display object that will be tested when checking mouse interactions or testing {{#crossLink \"Container/getObjectsUnderPoint\"}}{{/crossLink}}.\n\t\t * The hit area will have its transformation applied relative to this display object's coordinate space (as though\n\t\t * the hit test object were a child of this display object and relative to its regX/Y). The hitArea will be tested\n\t\t * using only its own `alpha` value regardless of the alpha value on the target display object, or the target's\n\t\t * ancestors (parents).\n\t\t * \n\t\t * If set on a {{#crossLink \"Container\"}}{{/crossLink}}, children of the Container will not receive mouse events.\n\t\t * This is similar to setting {{#crossLink \"mouseChildren\"}}{{/crossLink}} to false.\n\t\t *\n\t\t * Note that hitArea is NOT currently used by the `hitTest()` method, nor is it supported for {{#crossLink \"Stage\"}}{{/crossLink}}.\n\t\t * @property hitArea\n\t\t * @type {DisplayObject}\n\t\t * @default null\n\t\t */\n\t\tthis.hitArea = null;\n\t\t\n\t\t/**\n\t\t * A CSS cursor (ex. \"pointer\", \"help\", \"text\", etc) that will be displayed when the user hovers over this display\n\t\t * object. You must enable mouseover events using the {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}} method to\n\t\t * use this property. Setting a non-null cursor on a Container will override the cursor set on its descendants.\n\t\t * @property cursor\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.cursor = null;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @property _cacheOffsetX\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._cacheOffsetX = 0;\n\t\n\t\t/**\n\t\t * @property _cacheOffsetY\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._cacheOffsetY = 0;\n\t\t\n\t\t/**\n\t\t * @property _filterOffsetX\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._filterOffsetX = 0;\n\t\t\n\t\t/**\n\t\t * @property _filterOffsetY\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._filterOffsetY = 0;\n\t\t\n\t\t/**\n\t\t * @property _cacheScale\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis._cacheScale = 1;\n\t\n\t\t/**\n\t\t* @property _cacheDataURLID\n\t\t* @protected\n\t\t* @type {Number}\n\t\t* @default 0\n\t\t*/\n\t\tthis._cacheDataURLID = 0;\n\t\t\n\t\t/**\n\t\t* @property _cacheDataURL\n\t\t* @protected\n\t\t* @type {String}\n\t\t* @default null\n\t\t*/\n\t\tthis._cacheDataURL = null;\n\t\n\t\t/**\n\t\t * @property _props\n\t\t * @protected\n\t\t * @type {DisplayObject}\n\t\t * @default null\n\t\t **/\n\t\tthis._props = new createjs.DisplayProps();\n\t\n\t\t/**\n\t\t * @property _rectangle\n\t\t * @protected\n\t\t * @type {Rectangle}\n\t\t * @default null\n\t\t **/\n\t\tthis._rectangle = new createjs.Rectangle();\n\t\n\t\t/**\n\t\t * @property _bounds\n\t\t * @protected\n\t\t * @type {Rectangle}\n\t\t * @default null\n\t\t **/\n\t\tthis._bounds = null;\n\t}\n\tvar p = createjs.extend(DisplayObject, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n// static properties:\n\t/**\n\t * Listing of mouse event names. Used in _hasMouseEventListener.\n\t * @property _MOUSE_EVENTS\n\t * @protected\n\t * @static\n\t * @type {Array}\n\t **/\n\tDisplayObject._MOUSE_EVENTS = [\"click\",\"dblclick\",\"mousedown\",\"mouseout\",\"mouseover\",\"pressmove\",\"pressup\",\"rollout\",\"rollover\"];\n\n\t/**\n\t * Suppresses errors generated when using features like hitTest, mouse events, and {{#crossLink \"getObjectsUnderPoint\"}}{{/crossLink}}\n\t * with cross domain content.\n\t * @property suppressCrossDomainErrors\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tDisplayObject.suppressCrossDomainErrors = false;\n\t\n\t/**\n\t * @property _snapToPixelEnabled\n\t * @protected\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tDisplayObject._snapToPixelEnabled = false; // stage.snapToPixelEnabled is temporarily copied here during a draw to provide global access.\n\n\t/**\n\t * @property _hitTestCanvas\n\t * @type {HTMLCanvasElement | Object}\n\t * @static\n\t * @protected\n\t **/\n\t/**\n\t * @property _hitTestContext\n\t * @type {CanvasRenderingContext2D}\n\t * @static\n\t * @protected\n\t **/\n\tvar canvas = createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"); // prevent errors on load in browsers without canvas.\n\tif (canvas.getContext) {\n\t\tDisplayObject._hitTestCanvas = canvas;\n\t\tDisplayObject._hitTestContext = canvas.getContext(\"2d\");\n\t\tcanvas.width = canvas.height = 1;\n\t}\n\n\t/**\n\t * @property _nextCacheID\n\t * @type {Number}\n\t * @static\n\t * @protected\n\t **/\n\tDisplayObject._nextCacheID = 1;\n\n\n// events:\n\t/**\n\t * Dispatched when the user presses their left mouse button over the display object. See the \n\t * {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event mousedown\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched when the user presses their left mouse button and then releases it while over the display object.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event click\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched when the user double clicks their left mouse button over this display object.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event dblclick\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched when the user's mouse enters this display object. This event must be enabled using \n\t * {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}}. See also {{#crossLink \"DisplayObject/rollover:event\"}}{{/crossLink}}.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event mouseover\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the user's mouse leaves this display object. This event must be enabled using \n\t * {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}}. See also {{#crossLink \"DisplayObject/rollout:event\"}}{{/crossLink}}.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event mouseout\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * This event is similar to {{#crossLink \"DisplayObject/mouseover:event\"}}{{/crossLink}}, with the following\n\t * differences: it does not bubble, and it considers {{#crossLink \"Container\"}}{{/crossLink}} instances as an\n\t * aggregate of their content.\n\t * \n\t * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over\n\t * shapeA and then directly on to shapeB. With a listener for {{#crossLink \"mouseover:event\"}}{{/crossLink}} on\n\t * myContainer, two events would be received, each targeting a child element:<OL>\n\t * <LI>when the mouse enters shapeA (target=shapeA)</LI>\n\t * <LI>when the mouse enters shapeB (target=shapeB)</LI>\n\t * </OL>\n\t * However, with a listener for \"rollover\" instead, only a single event is received when the mouse first enters\n\t * the aggregate myContainer content (target=myContainer).\n\t * \n\t * This event must be enabled using {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}}.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event rollover\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * This event is similar to {{#crossLink \"DisplayObject/mouseout:event\"}}{{/crossLink}}, with the following\n\t * differences: it does not bubble, and it considers {{#crossLink \"Container\"}}{{/crossLink}} instances as an\n\t * aggregate of their content.\n\t * \n\t * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over\n\t * shapeA, then directly on to shapeB, then off both. With a listener for {{#crossLink \"mouseout:event\"}}{{/crossLink}}\n\t * on myContainer, two events would be received, each targeting a child element:<OL>\n\t * <LI>when the mouse leaves shapeA (target=shapeA)</LI>\n\t * <LI>when the mouse leaves shapeB (target=shapeB)</LI>\n\t * </OL>\n\t * However, with a listener for \"rollout\" instead, only a single event is received when the mouse leaves\n\t * the aggregate myContainer content (target=myContainer).\n\t * \n\t * This event must be enabled using {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}}.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event rollout\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * After a {{#crossLink \"DisplayObject/mousedown:event\"}}{{/crossLink}} occurs on a display object, a pressmove\n\t * event will be generated on that object whenever the mouse moves until the mouse press is released. This can be\n\t * useful for dragging and similar operations.\n\t * @event pressmove\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * After a {{#crossLink \"DisplayObject/mousedown:event\"}}{{/crossLink}} occurs on a display object, a pressup event\n\t * will be generated on that object when that mouse press is released. This can be useful for dragging and similar\n\t * operations.\n\t * @event pressup\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched when the display object is added to a parent container.\n\t * @event added\n\t */\n\t \n\t/**\n\t * Dispatched when the display object is removed from its parent container.\n\t * @event removed\n\t */\n\t \n\t/**\n\t * Dispatched on each display object on a stage whenever the stage updates. This occurs immediately before the\n\t * rendering (draw) pass. When {{#crossLink \"Stage/update\"}}{{/crossLink}} is called, first all display objects on\n\t * the stage dispatch the tick event, then all of the display objects are drawn to stage. Children will have their\n\t * {{#crossLink \"tick:event\"}}{{/crossLink}} event dispatched in order of their depth prior to the event being\n\t * dispatched on their parent.\n\t * @event tick\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Array} params An array containing any arguments that were passed to the Stage.update() method. For\n\t *      example if you called stage.update(\"hello\"), then the params would be [\"hello\"].\n\t * @since 0.6.0\n\t */\n\t\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"DisplayObject/stage:property\"}}{{/crossLink}} property instead.\n\t * @method getStage\n\t * @return {Stage}\n\t * @deprecated\n\t **/\n\tp.getStage = function() {\n\t\t// uses dynamic access to avoid circular dependencies;\n\t\tvar o = this, _Stage = createjs[\"Stage\"];\n\t\twhile (o.parent) { o = o.parent; }\n\t\tif (o instanceof _Stage) { return o; }\n\t\treturn null;\n\t};\n\n\t/**\n\t * Returns the Stage instance that this display object will be rendered on, or null if it has not been added to one.\n\t * @property stage\n\t * @type {Stage}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tstage: { get: p.getStage }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns <code>true</code> if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,\n\t * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).\n\t * @return {Boolean}\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tvar cacheCanvas = this.cacheCanvas;\n\t\tif (ignoreCache || !cacheCanvas) { return false; }\n\t\tvar scale = this._cacheScale;\n\t\tctx.drawImage(cacheCanvas, this._cacheOffsetX+this._filterOffsetX, this._cacheOffsetY+this._filterOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * Applies this display object's transformation, alpha, globalCompositeOperation, clipping path (mask), and shadow\n\t * to the specified context. This is typically called prior to {{#crossLink \"DisplayObject/draw\"}}{{/crossLink}}.\n\t * @method updateContext\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D to update.\n\t **/\n\tp.updateContext = function(ctx) {\n\t\tvar o=this, mask=o.mask, mtx= o._props.matrix;\n\t\t\n\t\tif (mask && mask.graphics && !mask.graphics.isEmpty()) {\n\t\t\tmask.getMatrix(mtx);\n\t\t\tctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n\t\t\t\n\t\t\tmask.graphics.drawAsPath(ctx);\n\t\t\tctx.clip();\n\t\t\t\n\t\t\tmtx.invert();\n\t\t\tctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n\t\t}\n\t\t\n\t\tthis.getMatrix(mtx);\n\t\tvar tx = mtx.tx, ty = mtx.ty;\n\t\tif (DisplayObject._snapToPixelEnabled && o.snapToPixel) {\n\t\t\ttx = tx + (tx < 0 ? -0.5 : 0.5) | 0;\n\t\t\tty = ty + (ty < 0 ? -0.5 : 0.5) | 0;\n\t\t}\n\t\tctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, tx, ty);\n\t\tctx.globalAlpha *= o.alpha;\n\t\tif (o.compositeOperation) { ctx.globalCompositeOperation = o.compositeOperation; }\n\t\tif (o.shadow) { this._applyShadow(ctx, o.shadow); }\n\t};\n\n\t/**\n\t * Draws the display object into a new canvas, which is then used for subsequent draws. For complex content\n\t * that does not change frequently (ex. a Container with many children that do not move, or a complex vector Shape),\n\t * this can provide for much faster rendering because the content does not need to be re-rendered each tick. The\n\t * cached display object can be moved, rotated, faded, etc freely, however if its content changes, you must\n\t * manually update the cache by calling <code>updateCache()</code> or <code>cache()</code> again. You must specify\n\t * the cache area via the x, y, w, and h parameters. This defines the rectangle that will be rendered and cached\n\t * using this display object's coordinates.\n\t *\n\t * <h4>Example</h4>\n\t * For example if you defined a Shape that drew a circle at 0, 0 with a radius of 25:\n\t *\n\t *      var shape = new createjs.Shape();\n\t *      shape.graphics.beginFill(\"#ff0000\").drawCircle(0, 0, 25);\n\t *      myShape.cache(-25, -25, 50, 50);\n\t *\n\t * Note that filters need to be defined <em>before</em> the cache is applied. Check out the {{#crossLink \"Filter\"}}{{/crossLink}}\n\t * class for more information. Some filters (ex. BlurFilter) will not work as expected in conjunction with the scale param.\n\t * \n\t * Usually, the resulting cacheCanvas will have the dimensions width*scale by height*scale, however some filters (ex. BlurFilter)\n\t * will add padding to the canvas dimensions.\n\t *\n\t * @method cache\n\t * @param {Number} x The x coordinate origin for the cache region.\n\t * @param {Number} y The y coordinate origin for the cache region.\n\t * @param {Number} width The width of the cache region.\n\t * @param {Number} height The height of the cache region.\n\t * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape using\n\t * \tmyShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and rotate\n\t * \tcached elements with greater fidelity. Default is 1.\n\t **/\n\tp.cache = function(x, y, width, height, scale) {\n\t\t// draw to canvas.\n\t\tscale = scale||1;\n\t\tif (!this.cacheCanvas) { this.cacheCanvas = createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"); }\n\t\tthis._cacheWidth = width;\n\t\tthis._cacheHeight = height;\n\t\tthis._cacheOffsetX = x;\n\t\tthis._cacheOffsetY = y;\n\t\tthis._cacheScale = scale;\n\t\tthis.updateCache();\n\t};\n\n\t/**\n\t * Redraws the display object to its cache. Calling updateCache without an active cache will throw an error.\n\t * If compositeOperation is null the current cache will be cleared prior to drawing. Otherwise the display object\n\t * will be drawn over the existing cache using the specified compositeOperation.\n\t *\n\t * <h4>Example</h4>\n\t * Clear the current graphics of a cached shape, draw some new instructions, and then update the cache. The new line\n\t * will be drawn on top of the old one.\n\t *\n\t *      // Not shown: Creating the shape, and caching it.\n\t *      shapeInstance.clear();\n\t *      shapeInstance.setStrokeStyle(3).beginStroke(\"#ff0000\").moveTo(100, 100).lineTo(200,200);\n\t *      shapeInstance.updateCache();\n\t *\n\t * @method updateCache\n\t * @param {String} compositeOperation The compositeOperation to use, or null to clear the cache and redraw it.\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing\">\n\t * whatwg spec on compositing</a>.\n\t **/\n\tp.updateCache = function(compositeOperation) {\n\t\tvar cacheCanvas = this.cacheCanvas;\n\t\tif (!cacheCanvas) { throw \"cache() must be called before updateCache()\"; }\n\t\tvar scale = this._cacheScale, offX = this._cacheOffsetX*scale, offY = this._cacheOffsetY*scale;\n\t\tvar w = this._cacheWidth, h = this._cacheHeight, ctx = cacheCanvas.getContext(\"2d\");\n\t\t\n\t\tvar fBounds = this._getFilterBounds();\n\t\toffX += (this._filterOffsetX = fBounds.x);\n\t\toffY += (this._filterOffsetY = fBounds.y);\n\t\t\n\t\tw = Math.ceil(w*scale) + fBounds.width;\n\t\th = Math.ceil(h*scale) + fBounds.height;\n\t\tif (w != cacheCanvas.width || h != cacheCanvas.height) {\n\t\t\t// TODO: it would be nice to preserve the content if there is a compositeOperation.\n\t\t\tcacheCanvas.width = w;\n\t\t\tcacheCanvas.height = h;\n\t\t} else if (!compositeOperation) {\n\t\t\tctx.clearRect(0, 0, w+1, h+1);\n\t\t}\n\t\t\n\t\tctx.save();\n\t\tctx.globalCompositeOperation = compositeOperation;\n\t\tctx.setTransform(scale, 0, 0, scale, -offX, -offY);\n\t\tthis.draw(ctx, true);\n\t\t// TODO: filters and cache scale don't play well together at present.\n\t\tthis._applyFilters();\n\t\tctx.restore();\n\t\tthis.cacheID = DisplayObject._nextCacheID++;\n\t};\n\n\t/**\n\t * Clears the current cache. See {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}} for more information.\n\t * @method uncache\n\t **/\n\tp.uncache = function() {\n\t\tthis._cacheDataURL = this.cacheCanvas = null;\n\t\tthis.cacheID = this._cacheOffsetX = this._cacheOffsetY = this._filterOffsetX = this._filterOffsetY = 0;\n\t\tthis._cacheScale = 1;\n\t};\n\t\n\t/**\n\t * Returns a data URL for the cache, or null if this display object is not cached.\n\t * Uses cacheID to ensure a new data URL is not generated if the cache has not changed.\n\t * @method getCacheDataURL\n\t * @return {String} The image data url for the cache.\n\t **/\n\tp.getCacheDataURL = function() {\n\t\tif (!this.cacheCanvas) { return null; }\n\t\tif (this.cacheID != this._cacheDataURLID) { this._cacheDataURL = this.cacheCanvas.toDataURL(); }\n\t\treturn this._cacheDataURL;\n\t};\n\n\t/**\n\t * Transforms the specified x and y position from the coordinate space of the display object\n\t * to the global (stage) coordinate space. For example, this could be used to position an HTML label\n\t * over a specific point on a nested display object. Returns a Point instance with x and y properties\n\t * correlating to the transformed coordinates on the stage.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.x = 300;\n\t *      displayObject.y = 200;\n\t *      stage.addChild(displayObject);\n\t *      var point = displayObject.localToGlobal(100, 100);\n\t *      // Results in x=400, y=300\n\t *\n\t * @method localToGlobal\n\t * @param {Number} x The x position in the source display object to transform.\n\t * @param {Number} y The y position in the source display object to transform.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. \n\t * @return {Point} A Point instance with x and y properties correlating to the transformed coordinates\n\t * on the stage.\n\t **/\n\tp.localToGlobal = function(x, y, pt) {\n\t\treturn this.getConcatenatedMatrix(this._props.matrix).transformPoint(x,y, pt||new createjs.Point());\n\t};\n\n\t/**\n\t * Transforms the specified x and y position from the global (stage) coordinate space to the\n\t * coordinate space of the display object. For example, this could be used to determine\n\t * the current mouse position within the display object. Returns a Point instance with x and y properties\n\t * correlating to the transformed position in the display object's coordinate space.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.x = 300;\n\t *      displayObject.y = 200;\n\t *      stage.addChild(displayObject);\n\t *      var point = displayObject.globalToLocal(100, 100);\n\t *      // Results in x=-200, y=-100\n\t *\n\t * @method globalToLocal\n\t * @param {Number} x The x position on the stage to transform.\n\t * @param {Number} y The y position on the stage to transform.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. \n\t * @return {Point} A Point instance with x and y properties correlating to the transformed position in the\n\t * display object's coordinate space.\n\t **/\n\tp.globalToLocal = function(x, y, pt) {\n\t\treturn this.getConcatenatedMatrix(this._props.matrix).invert().transformPoint(x,y, pt||new createjs.Point());\n\t};\n\n\t/**\n\t * Transforms the specified x and y position from the coordinate space of this display object to the coordinate\n\t * space of the target display object. Returns a Point instance with x and y properties correlating to the\n\t * transformed position in the target's coordinate space. Effectively the same as using the following code with\n\t * {{#crossLink \"DisplayObject/localToGlobal\"}}{{/crossLink}} and {{#crossLink \"DisplayObject/globalToLocal\"}}{{/crossLink}}.\n\t *\n\t *      var pt = this.localToGlobal(x, y);\n\t *      pt = target.globalToLocal(pt.x, pt.y);\n\t *\n\t * @method localToLocal\n\t * @param {Number} x The x position in the source display object to transform.\n\t * @param {Number} y The y position on the source display object to transform.\n\t * @param {DisplayObject} target The target display object to which the coordinates will be transformed.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. \n\t * @return {Point} Returns a Point instance with x and y properties correlating to the transformed position\n\t * in the target's coordinate space.\n\t **/\n\tp.localToLocal = function(x, y, target, pt) {\n\t\tpt = this.localToGlobal(x, y, pt);\n\t\treturn target.globalToLocal(pt.x, pt.y, pt);\n\t};\n\n\t/**\n\t * Shortcut method to quickly set the transform properties on the display object. All parameters are optional.\n\t * Omitted parameters will have the default value set.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.setTransform(100, 100, 2, 2);\n\t *\n\t * @method setTransform\n\t * @param {Number} [x=0] The horizontal translation (x position) in pixels\n\t * @param {Number} [y=0] The vertical translation (y position) in pixels\n\t * @param {Number} [scaleX=1] The horizontal scale, as a percentage of 1\n\t * @param {Number} [scaleY=1] the vertical scale, as a percentage of 1\n\t * @param {Number} [rotation=0] The rotation, in degrees\n\t * @param {Number} [skewX=0] The horizontal skew factor\n\t * @param {Number} [skewY=0] The vertical skew factor\n\t * @param {Number} [regX=0] The horizontal registration point in pixels\n\t * @param {Number} [regY=0] The vertical registration point in pixels\n\t * @return {DisplayObject} Returns this instance. Useful for chaining commands.\n\t * @chainable\n\t*/\n\tp.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.scaleX = scaleX == null ? 1 : scaleX;\n\t\tthis.scaleY = scaleY == null ? 1 : scaleY;\n\t\tthis.rotation = rotation || 0;\n\t\tthis.skewX = skewX || 0;\n\t\tthis.skewY = skewY || 0;\n\t\tthis.regX = regX || 0;\n\t\tthis.regY = regY || 0;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a matrix based on this object's current transform.\n\t * @method getMatrix\n\t * @param {Matrix2D} matrix Optional. A Matrix2D object to populate with the calculated values. If null, a new\n\t * Matrix object is returned.\n\t * @return {Matrix2D} A matrix representing this display object's transform.\n\t **/\n\tp.getMatrix = function(matrix) {\n\t\tvar o = this, mtx = matrix&&matrix.identity() || new createjs.Matrix2D();\n\t\treturn o.transformMatrix ?  mtx.copy(o.transformMatrix) : mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);\n\t};\n\t\n\t/**\n\t * Generates a Matrix2D object representing the combined transform of the display object and all of its\n\t * parent Containers up to the highest level ancestor (usually the {{#crossLink \"Stage\"}}{{/crossLink}}). This can\n\t * be used to transform positions between coordinate spaces, such as with {{#crossLink \"DisplayObject/localToGlobal\"}}{{/crossLink}}\n\t * and {{#crossLink \"DisplayObject/globalToLocal\"}}{{/crossLink}}.\n\t * @method getConcatenatedMatrix\n\t * @param {Matrix2D} [matrix] A {{#crossLink \"Matrix2D\"}}{{/crossLink}} object to populate with the calculated values.\n\t * If null, a new Matrix2D object is returned.\n\t * @return {Matrix2D} The combined matrix.\n\t **/\n\tp.getConcatenatedMatrix = function(matrix) {\n\t\tvar o = this, mtx = this.getMatrix(matrix);\n\t\twhile (o = o.parent) {\n\t\t\tmtx.prependMatrix(o.getMatrix(o._props.matrix));\n\t\t}\n\t\treturn mtx;\n\t};\n\t\n\t/**\n\t * Generates a DisplayProps object representing the combined display properties of the  object and all of its\n\t * parent Containers up to the highest level ancestor (usually the {{#crossLink \"Stage\"}}{{/crossLink}}).\n\t * @method getConcatenatedDisplayProps\n\t * @param {DisplayProps} [props] A {{#crossLink \"DisplayProps\"}}{{/crossLink}} object to populate with the calculated values.\n\t * If null, a new DisplayProps object is returned.\n\t * @return {DisplayProps} The combined display properties.\n\t **/\n\tp.getConcatenatedDisplayProps = function(props) {\n\t\tprops = props ? props.identity() : new createjs.DisplayProps();\n\t\tvar o = this, mtx = o.getMatrix(props.matrix); \n\t\tdo {\n\t\t\tprops.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation);\n\t\t\t\n\t\t\t// we do this to avoid problems with the matrix being used for both operations when o._props.matrix is passed in as the props param.\n\t\t\t// this could be simplified (ie. just done as part of the prepend above) if we switched to using a pool.\n\t\t\tif (o != this) { mtx.prependMatrix(o.getMatrix(o._props.matrix)); }\n\t\t} while (o = o.parent);\n\t\treturn props;\n\t};\n\n\t/**\n\t * Tests whether the display object intersects the specified point in <em>local</em> coordinates (ie. draws a pixel\n\t * with alpha > 0 at the specified position). This ignores the alpha, shadow, hitArea, mask, and compositeOperation\n\t * of the display object.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tvar myShape = new createjs.Shape();\n\t * \t\tmyShape.graphics.beginFill(\"red\").drawRect(100, 100, 20, 50);\n\t *\n\t * \t\tconsole.log(myShape.hitTest(10,10); // false\n\t * \t\tconsole.log(myShape.hitTest(110, 25); // true\n\t *\n\t * Note that to use Stage coordinates (such as {{#crossLink \"Stage/mouseX:property\"}}{{/crossLink}}), they must\n\t * first be converted to local coordinates:\n\t *\n\t *      stage.addEventListener(\"stagemousedown\", handleMouseDown);\n\t *      function handleMouseDown(event) {\n\t *      \tvar p = myShape.globalToLocal(stage.mouseX, stage.mouseY);\n\t *          var hit = myShape.hitTest(p.x, p.y);\n\t *      }\n\t *\n\t * Shape-to-shape collision is not currently supported by EaselJS.\n\t *\n\t * @method hitTest\n\t * @param {Number} x The x position to check in the display object's local coordinates.\n\t * @param {Number} y The y position to check in the display object's local coordinates.\n\t * @return {Boolean} A Boolean indicating whether a visible portion of the DisplayObject intersect the specified\n\t * local Point.\n\t*/\n\tp.hitTest = function(x, y) {\n\t\tvar ctx = DisplayObject._hitTestContext;\n\t\tctx.setTransform(1, 0, 0, 1, -x, -y);\n\t\tthis.draw(ctx);\n\n\t\tvar hit = this._testHit(ctx);\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, 2, 2);\n\t\treturn hit;\n\t};\n\t\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var myGraphics = new createjs.Graphics().beginFill(\"#ff0000\").drawCircle(0, 0, 25);\n\t *      var shape = stage.addChild(new createjs.Shape()).set({graphics:myGraphics, x:100, y:100, alpha:0.5});\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.\n\t * @return {DisplayObject} Returns the instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a rectangle representing this object's bounds in its local coordinate system (ie. with no transformation).\n\t * Objects that have been cached will return the bounds of the cache.\n\t * \n\t * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use \n\t * {{#crossLink \"DisplayObject/setBounds\"}}{{/crossLink}} so that they are included when calculating Container\n\t * bounds.\n\t * \n\t * <table>\n\t * \t<tr><td><b>All</b></td><td>\n\t * \t\tAll display objects support setting bounds manually using setBounds(). Likewise, display objects that\n\t * \t\thave been cached using cache() will return the bounds of their cache. Manual and cache bounds will override\n\t * \t\tthe automatic calculations listed below.\n\t * \t</td></tr>\n\t * \t<tr><td><b>Bitmap</b></td><td>\n\t * \t\tReturns the width and height of the sourceRect (if specified) or image, extending from (x=0,y=0).\n\t * \t</td></tr>\n\t * \t<tr><td><b>Sprite</b></td><td>\n\t * \t\tReturns the bounds of the current frame. May have non-zero x/y if a frame registration point was specified\n\t * \t\tin the spritesheet data. See also {{#crossLink \"SpriteSheet/getFrameBounds\"}}{{/crossLink}}\n\t * \t</td></tr>\n\t * \t<tr><td><b>Container</b></td><td>\n\t * \t\tReturns the aggregate (combined) bounds of all children that return a non-null value from getBounds().\n\t * \t</td></tr>\n\t * \t<tr><td><b>Shape</b></td><td>\n\t * \t\tDoes not currently support automatic bounds calculations. Use setBounds() to manually define bounds.\n\t * \t</td></tr>\n\t * \t<tr><td><b>Text</b></td><td>\n\t * \t\tReturns approximate bounds. Horizontal values (x/width) are quite accurate, but vertical values (y/height) are\n\t * \t\tnot, especially when using textBaseline values other than \"top\".\n\t * \t</td></tr>\n\t * \t<tr><td><b>BitmapText</b></td><td>\n\t * \t\tReturns approximate bounds. Values will be more accurate if spritesheet frame registration points are close\n\t * \t\tto (x=0,y=0).\n\t * \t</td></tr>\n\t* </table>\n\t * \n\t * Bounds can be expensive to calculate for some objects (ex. text, or containers with many children), and\n\t * are recalculated each time you call getBounds(). You can prevent recalculation on static objects by setting the\n\t * bounds explicitly:\n\t * \n\t * \tvar bounds = obj.getBounds();\n\t * \tobj.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);\n\t * \t// getBounds will now use the set values, instead of recalculating\n\t * \n\t * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its\n\t * values if you need to retain it.\n\t * \n\t * \tvar myBounds = obj.getBounds().clone();\n\t * \t// OR:\n\t * \tmyRect.copy(obj.getBounds());\n\t * \n\t * @method getBounds\n\t * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this\n\t * object.\n\t **/\n\tp.getBounds = function() {\n\t\tif (this._bounds) { return this._rectangle.copy(this._bounds); }\n\t\tvar cacheCanvas = this.cacheCanvas;\n\t\tif (cacheCanvas) {\n\t\t\tvar scale = this._cacheScale;\n\t\t\treturn this._rectangle.setValues(this._cacheOffsetX, this._cacheOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);\n\t\t}\n\t\treturn null;\n\t};\n\t\n\t/**\n\t * Returns a rectangle representing this object's bounds in its parent's coordinate system (ie. with transformations applied).\n\t * Objects that have been cached will return the transformed bounds of the cache.\n\t * \n\t * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use \n\t * {{#crossLink \"DisplayObject/setBounds\"}}{{/crossLink}} so that they are included when calculating Container\n\t * bounds.\n\t * \n\t * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its\n\t * values if you need to retain it.\n\t * \n\t * Container instances calculate aggregate bounds for all children that return bounds via getBounds.\n\t * @method getTransformedBounds\n\t * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this object.\n\t **/\n\tp.getTransformedBounds = function() {\n\t\treturn this._getBounds();\n\t};\n\t\n\t/**\n\t * Allows you to manually specify the bounds of an object that either cannot calculate their own bounds (ex. Shape &\n\t * Text) for future reference, or so the object can be included in Container bounds. Manually set bounds will always\n\t * override calculated bounds.\n\t * \n\t * The bounds should be specified in the object's local (untransformed) coordinates. For example, a Shape instance\n\t * with a 25px radius circle centered at 0,0 would have bounds of (-25, -25, 50, 50).\n\t * @method setBounds\n\t * @param {Number} x The x origin of the bounds. Pass null to remove the manual bounds.\n\t * @param {Number} y The y origin of the bounds.\n\t * @param {Number} width The width of the bounds.\n\t * @param {Number} height The height of the bounds.\n\t **/\n\tp.setBounds = function(x, y, width, height) {\n\t\tif (x == null) { this._bounds = x; }\n\t\tthis._bounds = (this._bounds || new createjs.Rectangle()).setValues(x, y, width, height);\n\t};\n\n\t/**\n\t * Returns a clone of this DisplayObject. Some properties that are specific to this instance's current context are\n\t * reverted to their defaults (for example .parent). Caches are not maintained across clones, and some elements\n\t * are copied by reference (masks, individual filter instances, hit area)\n\t * @method clone\n\t * @return {DisplayObject} A clone of the current DisplayObject instance.\n\t **/\n\tp.clone = function() {\n\t\treturn this._cloneProps(new DisplayObject());\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[DisplayObject (name=\"+  this.name +\")]\";\n\t};\n\n\n// private methods:\n\t// separated so it can be used more easily in subclasses:\n\t/**\n\t * @method _cloneProps\n\t * @param {DisplayObject} o The DisplayObject instance which will have properties from the current DisplayObject\n\t * instance copied into.\n\t * @return {DisplayObject} o\n\t * @protected\n\t **/\n\tp._cloneProps = function(o) {\n\t\to.alpha = this.alpha;\n\t\to.mouseEnabled = this.mouseEnabled;\n\t\to.tickEnabled = this.tickEnabled;\n\t\to.name = this.name;\n\t\to.regX = this.regX;\n\t\to.regY = this.regY;\n\t\to.rotation = this.rotation;\n\t\to.scaleX = this.scaleX;\n\t\to.scaleY = this.scaleY;\n\t\to.shadow = this.shadow;\n\t\to.skewX = this.skewX;\n\t\to.skewY = this.skewY;\n\t\to.visible = this.visible;\n\t\to.x  = this.x;\n\t\to.y = this.y;\n\t\to.compositeOperation = this.compositeOperation;\n\t\to.snapToPixel = this.snapToPixel;\n\t\to.filters = this.filters==null?null:this.filters.slice(0);\n\t\to.mask = this.mask;\n\t\to.hitArea = this.hitArea;\n\t\to.cursor = this.cursor;\n\t\to._bounds = this._bounds;\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _applyShadow\n\t * @protected\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {Shadow} shadow\n\t **/\n\tp._applyShadow = function(ctx, shadow) {\n\t\tshadow = shadow || Shadow.identity;\n\t\tctx.shadowColor = shadow.color;\n\t\tctx.shadowOffsetX = shadow.offsetX;\n\t\tctx.shadowOffsetY = shadow.offsetY;\n\t\tctx.shadowBlur = shadow.blur;\n\t};\n\t\n\t\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * @protected\n\t **/\n\tp._tick = function(evtObj) {\n\t\t// because tick can be really performance sensitive, check for listeners before calling dispatchEvent.\n\t\tvar ls = this._listeners;\n\t\tif (ls && ls[\"tick\"]) {\n\t\t\t// reset & reuse the event object to avoid construction / GC costs:\n\t\t\tevtObj.target = null;\n\t\t\tevtObj.propagationStopped = evtObj.immediatePropagationStopped = false;\n\t\t\tthis.dispatchEvent(evtObj);\n\t\t}\n\t};\n\n\t/**\n\t * @method _testHit\n\t * @protected\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @return {Boolean}\n\t **/\n\tp._testHit = function(ctx) {\n\t\ttry {\n\t\t\tvar hit = ctx.getImageData(0, 0, 1, 1).data[3] > 1;\n\t\t} catch (e) {\n\t\t\tif (!DisplayObject.suppressCrossDomainErrors) {\n\t\t\t\tthrow \"An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.\";\n\t\t\t}\n\t\t}\n\t\treturn hit;\n\t};\n\n\t/**\n\t * @method _applyFilters\n\t * @protected\n\t **/\n\tp._applyFilters = function() {\n\t\tif (!this.filters || this.filters.length == 0 || !this.cacheCanvas) { return; }\n\t\tvar l = this.filters.length;\n\t\tvar ctx = this.cacheCanvas.getContext(\"2d\");\n\t\tvar w = this.cacheCanvas.width;\n\t\tvar h = this.cacheCanvas.height;\n\t\tfor (var i=0; i<l; i++) {\n\t\t\tthis.filters[i].applyFilter(ctx, 0, 0, w, h);\n\t\t}\n\t};\n\t\n\t/**\n\t * @method _getFilterBounds\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getFilterBounds = function(rect) {\n\t\tvar l, filters = this.filters, bounds = this._rectangle.setValues(0,0,0,0);\n\t\tif (!filters || !(l=filters.length)) { return bounds; }\n\t\t\n\t\tfor (var i=0; i<l; i++) {\n\t\t\tvar f = this.filters[i];\n\t\t\tf.getBounds&&f.getBounds(bounds);\n\t\t}\n\t\treturn bounds;\n\t};\n\t\n\t/**\n\t * @method _getBounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform If true, does not apply this object's transform.\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getBounds = function(matrix, ignoreTransform){\n\t\treturn this._transformBounds(this.getBounds(), matrix, ignoreTransform);\n\t};\n\t\n\t/**\n\t * @method _transformBounds\n\t * @param {Rectangle} bounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._transformBounds = function(bounds, matrix, ignoreTransform) {\n\t\tif (!bounds) { return bounds; }\n\t\tvar x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height, mtx = this._props.matrix;\n\t\tmtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);\n\t\t\n\t\tif (x || y) { mtx.appendTransform(0,0,1,1,0,0,0,-x,-y); } // TODO: simplify this.\n\t\tif (matrix) { mtx.prependMatrix(matrix); }\n\t\t\n\t\tvar x_a = width*mtx.a, x_b = width*mtx.b;\n\t\tvar y_c = height*mtx.c, y_d = height*mtx.d;\n\t\tvar tx = mtx.tx, ty = mtx.ty;\n\t\t\n\t\tvar minX = tx, maxX = tx, minY = ty, maxY = ty;\n\n\t\tif ((x = x_a + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }\n\t\tif ((x = x_a + y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }\n\t\tif ((x = y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }\n\t\t\n\t\tif ((y = x_b + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }\n\t\tif ((y = x_b + y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }\n\t\tif ((y = y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }\n\t\t\n\t\treturn bounds.setValues(minX, minY, maxX-minX, maxY-minY);\n\t};\n\t\n\t/**\n\t * Indicates whether the display object has any mouse event listeners or a cursor.\n\t * @method _isMouseOpaque\n\t * @return {Boolean}\n\t * @protected\n\t **/\n\tp._hasMouseEventListener = function() {\n\t\tvar evts = DisplayObject._MOUSE_EVENTS;\n\t\tfor (var i= 0, l=evts.length; i<l; i++) {\n\t\t\tif (this.hasEventListener(evts[i])) { return true; }\n\t\t}\n\t\treturn !!this.cursor;\n\t};\n\n\tcreatejs.DisplayObject = createjs.promote(DisplayObject, \"EventDispatcher\");\n}());\n\n//##############################################################################\n// Container.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\t\n\n// constructor:\n/**\n * A Container is a nestable display list that allows you to work with compound display elements. For  example you could\n * group arm, leg, torso and head {{#crossLink \"Bitmap\"}}{{/crossLink}} instances together into a Person Container, and\n * transform them as a group, while still being able to move the individual parts relative to each other. Children of\n * containers have their <code>transform</code> and <code>alpha</code> properties concatenated with their parent\n * Container.\n *\n * For example, a {{#crossLink \"Shape\"}}{{/crossLink}} with x=100 and alpha=0.5, placed in a Container with <code>x=50</code>\n * and <code>alpha=0.7</code> will be rendered to the canvas at <code>x=150</code> and <code>alpha=0.35</code>.\n * Containers have some overhead, so you generally shouldn't create a Container to hold a single child.\n *\n * <h4>Example</h4>\n *\n *      var container = new createjs.Container();\n *      container.addChild(bitmapInstance, shapeInstance);\n *      container.x = 100;\n *\n * @class Container\n * @extends DisplayObject\n * @constructor\n **/\n\tfunction Container() {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The array of children in the display list. You should usually use the child management methods such as\n\t\t * {{#crossLink \"Container/addChild\"}}{{/crossLink}}, {{#crossLink \"Container/removeChild\"}}{{/crossLink}},\n\t\t * {{#crossLink \"Container/swapChildren\"}}{{/crossLink}}, etc, rather than accessing this directly, but it is\n\t\t * included for advanced uses.\n\t\t * @property children\n\t\t * @type Array\n\t\t * @default null\n\t\t **/\n\t\tthis.children = [];\n\t\t\n\t\t/**\n\t\t * Indicates whether the children of this container are independently enabled for mouse/pointer interaction.\n\t\t * If false, the children will be aggregated under the container - for example, a click on a child shape would\n\t\t * trigger a click event on the container.\n\t\t * @property mouseChildren\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.mouseChildren = true;\n\t\t\n\t\t/**\n\t\t * If false, the tick will not be propagated to children of this Container. This can provide some performance benefits.\n\t\t * In addition to preventing the \"tick\" event from being dispatched, it will also prevent tick related updates\n\t\t * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).\n\t\t * @property tickChildren\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.tickChildren = true;\n\t}\n\tvar p = createjs.extend(Container, createjs.DisplayObject);\n\t\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"Container/numChildren:property\"}}{{/crossLink}} property instead.\n\t * @method getNumChildren\n\t * @return {Number}\n\t * @deprecated\n\t **/\n\tp.getNumChildren = function() {\n\t\treturn this.children.length;\n\t};\n\n\t/**\n\t * Returns the number of children in the container.\n\t * @property numChildren\n\t * @type {Number}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tnumChildren: { get: p.getNumChildren }\n\t\t});\n\t} catch (e) {}\n\t\n\n// public methods:\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink \"Utility Methods/extends\"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = Container; // TODO: deprecated.\n\t\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || this.children.length;\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\t\n\t\t// this ensures we don't have issues with display list changes that occur during a draw:\n\t\tvar list = this.children.slice();\n\t\tfor (var i=0,l=list.length; i<l; i++) {\n\t\t\tvar child = list[i];\n\t\t\tif (!child.isVisible()) { continue; }\n\t\t\t\n\t\t\t// draw the child:\n\t\t\tctx.save();\n\t\t\tchild.updateContext(ctx);\n\t\t\tchild.draw(ctx);\n\t\t\tctx.restore();\n\t\t}\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * Adds a child to the top of the display list.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tcontainer.addChild(bitmapInstance);\n\t *\n\t * You can also add multiple children at once:\n\t *\n\t * \t\tcontainer.addChild(bitmapInstance, shapeInstance, textInstance);\n\t *\n\t * @method addChild\n\t * @param {DisplayObject} child The display object to add.\n\t * @return {DisplayObject} The child that was added, or the last child if multiple children were added.\n\t **/\n\tp.addChild = function(child) {\n\t\tif (child == null) { return child; }\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tfor (var i=0; i<l; i++) { this.addChild(arguments[i]); }\n\t\t\treturn arguments[l-1];\n\t\t}\n\t\tif (child.parent) { child.parent.removeChild(child); }\n\t\tchild.parent = this;\n\t\tthis.children.push(child);\n\t\tchild.dispatchEvent(\"added\");\n\t\treturn child;\n\t};\n\n\t/**\n\t * Adds a child to the display list at the specified index, bumping children at equal or greater indexes up one, and\n\t * setting its parent to this Container.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      addChildAt(child1, index);\n\t *\n\t * You can also add multiple children, such as:\n\t *\n\t *      addChildAt(child1, child2, ..., index);\n\t *\n\t * The index must be between 0 and numChildren. For example, to add myShape under otherShape in the display list,\n\t * you could use:\n\t *\n\t *      container.addChildAt(myShape, container.getChildIndex(otherShape));\n\t *\n\t * This would also bump otherShape's index up by one. Fails silently if the index is out of range.\n\t *\n\t * @method addChildAt\n\t * @param {DisplayObject} child The display object to add.\n\t * @param {Number} index The index to add the child at.\n\t * @return {DisplayObject} Returns the last child that was added, or the last child if multiple children were added.\n\t **/\n\tp.addChildAt = function(child, index) {\n\t\tvar l = arguments.length;\n\t\tvar indx = arguments[l-1]; // can't use the same name as the index param or it replaces arguments[1]\n\t\tif (indx < 0 || indx > this.children.length) { return arguments[l-2]; }\n\t\tif (l > 2) {\n\t\t\tfor (var i=0; i<l-1; i++) { this.addChildAt(arguments[i], indx+i); }\n\t\t\treturn arguments[l-2];\n\t\t}\n\t\tif (child.parent) { child.parent.removeChild(child); }\n\t\tchild.parent = this;\n\t\tthis.children.splice(index, 0, child);\n\t\tchild.dispatchEvent(\"added\");\n\t\treturn child;\n\t};\n\n\t/**\n\t * Removes the specified child from the display list. Note that it is faster to use removeChildAt() if the index is\n\t * already known.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      container.removeChild(child);\n\t *\n\t * You can also remove multiple children:\n\t *\n\t *      removeChild(child1, child2, ...);\n\t *\n\t * Returns true if the child (or children) was removed, or false if it was not in the display list.\n\t * @method removeChild\n\t * @param {DisplayObject} child The child to remove.\n\t * @return {Boolean} true if the child (or children) was removed, or false if it was not in the display list.\n\t **/\n\tp.removeChild = function(child) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tvar good = true;\n\t\t\tfor (var i=0; i<l; i++) { good = good && this.removeChild(arguments[i]); }\n\t\t\treturn good;\n\t\t}\n\t\treturn this.removeChildAt(createjs.indexOf(this.children, child));\n\t};\n\n\t/**\n\t * Removes the child at the specified index from the display list, and sets its parent to null.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      container.removeChildAt(2);\n\t *\n\t * You can also remove multiple children:\n\t *\n\t *      container.removeChild(2, 7, ...)\n\t *\n\t * Returns true if the child (or children) was removed, or false if any index was out of range.\n\t * @method removeChildAt\n\t * @param {Number} index The index of the child to remove.\n\t * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.\n\t **/\n\tp.removeChildAt = function(index) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tvar a = [];\n\t\t\tfor (var i=0; i<l; i++) { a[i] = arguments[i]; }\n\t\t\ta.sort(function(a, b) { return b-a; });\n\t\t\tvar good = true;\n\t\t\tfor (var i=0; i<l; i++) { good = good && this.removeChildAt(a[i]); }\n\t\t\treturn good;\n\t\t}\n\t\tif (index < 0 || index > this.children.length-1) { return false; }\n\t\tvar child = this.children[index];\n\t\tif (child) { child.parent = null; }\n\t\tthis.children.splice(index, 1);\n\t\tchild.dispatchEvent(\"removed\");\n\t\treturn true;\n\t};\n\n\t/**\n\t * Removes all children from the display list.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \tcontainer.removeAllChildren();\n\t *\n\t * @method removeAllChildren\n\t **/\n\tp.removeAllChildren = function() {\n\t\tvar kids = this.children;\n\t\twhile (kids.length) { this.removeChildAt(0); }\n\t};\n\n\t/**\n\t * Returns the child at the specified index.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      container.getChildAt(2);\n\t *\n\t * @method getChildAt\n\t * @param {Number} index The index of the child to return.\n\t * @return {DisplayObject} The child at the specified index. Returns null if there is no child at the index.\n\t **/\n\tp.getChildAt = function(index) {\n\t\treturn this.children[index];\n\t};\n\t\n\t/**\n\t * Returns the child with the specified name.\n\t * @method getChildByName\n\t * @param {String} name The name of the child to return.\n\t * @return {DisplayObject} The child with the specified name.\n\t **/\n\tp.getChildByName = function(name) {\n\t\tvar kids = this.children;\n\t\tfor (var i=0,l=kids.length;i<l;i++) {\n\t\t\tif(kids[i].name == name) { return kids[i]; }\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Performs an array sort operation on the child list.\n\t *\n\t * <h4>Example: Display children with a higher y in front.</h4>\n\t * \n\t *      var sortFunction = function(obj1, obj2, options) {\n\t *          if (obj1.y > obj2.y) { return 1; }\n\t *          if (obj1.y < obj2.y) { return -1; }\n\t *          return 0;\n\t *      }\n\t *      container.sortChildren(sortFunction);\n\t *\n\t * @method sortChildren\n\t * @param {Function} sortFunction the function to use to sort the child list. See JavaScript's <code>Array.sort</code>\n\t * documentation for details.\n\t **/\n\tp.sortChildren = function(sortFunction) {\n\t\tthis.children.sort(sortFunction);\n\t};\n\n\t/**\n\t * Returns the index of the specified child in the display list, or -1 if it is not in the display list.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var index = container.getChildIndex(child);\n\t *\n\t * @method getChildIndex\n\t * @param {DisplayObject} child The child to return the index of.\n\t * @return {Number} The index of the specified child. -1 if the child is not found.\n\t **/\n\tp.getChildIndex = function(child) {\n\t\treturn createjs.indexOf(this.children, child);\n\t};\n\t\n\t/**\n\t * Swaps the children at the specified indexes. Fails silently if either index is out of range.\n\t * @method swapChildrenAt\n\t * @param {Number} index1\n\t * @param {Number} index2\n\t **/\n\tp.swapChildrenAt = function(index1, index2) {\n\t\tvar kids = this.children;\n\t\tvar o1 = kids[index1];\n\t\tvar o2 = kids[index2];\n\t\tif (!o1 || !o2) { return; }\n\t\tkids[index1] = o2;\n\t\tkids[index2] = o1;\n\t};\n\t\n\t/**\n\t * Swaps the specified children's depth in the display list. Fails silently if either child is not a child of this\n\t * Container.\n\t * @method swapChildren\n\t * @param {DisplayObject} child1\n\t * @param {DisplayObject} child2\n\t **/\n\tp.swapChildren = function(child1, child2) {\n\t\tvar kids = this.children;\n\t\tvar index1,index2;\n\t\tfor (var i=0,l=kids.length;i<l;i++) {\n\t\t\tif (kids[i] == child1) { index1 = i; }\n\t\t\tif (kids[i] == child2) { index2 = i; }\n\t\t\tif (index1 != null && index2 != null) { break; }\n\t\t}\n\t\tif (i==l) { return; } // TODO: throw error?\n\t\tkids[index1] = child2;\n\t\tkids[index2] = child1;\n\t};\n\t\n\t/**\n\t * Changes the depth of the specified child. Fails silently if the child is not a child of this container, or the index is out of range.\n\t * @param {DisplayObject} child\n\t * @param {Number} index  \n\t * @method setChildIndex\n\t **/\n\tp.setChildIndex = function(child, index) {\n\t\tvar kids = this.children, l=kids.length;\n\t\tif (child.parent != this || index < 0 || index >= l) { return; }\n\t\tfor (var i=0;i<l;i++) {\n\t\t\tif (kids[i] == child) { break; }\n\t\t}\n\t\tif (i==l || i == index) { return; }\n\t\tkids.splice(i,1);\n\t\tkids.splice(index,0,child);\n\t};\n\n\t/**\n\t * Returns true if the specified display object either is this container or is a descendent (child, grandchild, etc)\n\t * of this container.\n\t * @method contains\n\t * @param {DisplayObject} child The DisplayObject to be checked.\n\t * @return {Boolean} true if the specified display object either is this container or is a descendent.\n\t **/\n\tp.contains = function(child) {\n\t\twhile (child) {\n\t\t\tif (child == this) { return true; }\n\t\t\tchild = child.parent;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Tests whether the display object intersects the specified local point (ie. draws a pixel with alpha > 0 at the\n\t * specified position). This ignores the alpha, shadow and compositeOperation of the display object, and all\n\t * transform properties including regX/Y.\n\t * @method hitTest\n\t * @param {Number} x The x position to check in the display object's local coordinates.\n\t * @param {Number} y The y position to check in the display object's local coordinates.\n\t * @return {Boolean} A Boolean indicating whether there is a visible section of a DisplayObject that overlaps the specified\n\t * coordinates.\n\t **/\n\tp.hitTest = function(x, y) {\n\t\t// TODO: optimize to use the fast cache check where possible.\n\t\treturn (this.getObjectUnderPoint(x, y) != null);\n\t};\n\n\t/**\n\t * Returns an array of all display objects under the specified coordinates that are in this container's display\n\t * list. This routine ignores any display objects with {{#crossLink \"DisplayObject/mouseEnabled:property\"}}{{/crossLink}}\n\t * set to `false`. The array will be sorted in order of visual depth, with the top-most display object at index 0.\n\t * This uses shape based hit detection, and can be an expensive operation to run, so it is best to use it carefully.\n\t * For example, if testing for objects under the mouse, test on tick (instead of on {{#crossLink \"DisplayObject/mousemove:event\"}}{{/crossLink}}),\n\t * and only if the mouse's position has changed.\n\t * \n\t * <ul>\n\t *     <li>By default (mode=0) this method evaluates all display objects.</li>\n\t *     <li>By setting the `mode` parameter to `1`, the {{#crossLink \"DisplayObject/mouseEnabled:property\"}}{{/crossLink}}\n\t * \t\tand {{#crossLink \"mouseChildren:property\"}}{{/crossLink}} properties will be respected.</li>\n\t * \t   <li>Setting the `mode` to `2` additionally excludes display objects that do not have active mouse event\n\t * \t   \tlisteners or a {{#crossLink \"DisplayObject:cursor:property\"}}{{/crossLink}} property. That is, only objects\n\t * \t   \tthat would normally intercept mouse interaction will be included. This can significantly improve performance\n\t * \t   \tin some cases by reducing the number of display objects that need to be tested.</li>\n\t * </li>\n\t * \n\t * This method accounts for both {{#crossLink \"DisplayObject/hitArea:property\"}}{{/crossLink}} and {{#crossLink \"DisplayObject/mask:property\"}}{{/crossLink}}.\n\t * @method getObjectsUnderPoint\n\t * @param {Number} x The x position in the container to test.\n\t * @param {Number} y The y position in the container to test.\n\t * @param {Number} [mode=0] The mode to use to determine which display objects to include. 0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.\n\t * @return {Array} An Array of DisplayObjects under the specified coordinates.\n\t **/\n\tp.getObjectsUnderPoint = function(x, y, mode) {\n\t\tvar arr = [];\n\t\tvar pt = this.localToGlobal(x, y);\n\t\tthis._getObjectsUnderPoint(pt.x, pt.y, arr, mode>0, mode==1);\n\t\treturn arr;\n\t};\n\n\t/**\n\t * Similar to {{#crossLink \"Container/getObjectsUnderPoint\"}}{{/crossLink}}, but returns only the top-most display\n\t * object. This runs significantly faster than <code>getObjectsUnderPoint()</code>, but is still potentially an expensive\n\t * operation. See {{#crossLink \"Container/getObjectsUnderPoint\"}}{{/crossLink}} for more information.\n\t * @method getObjectUnderPoint\n\t * @param {Number} x The x position in the container to test.\n\t * @param {Number} y The y position in the container to test.\n\t * @param {Number} mode The mode to use to determine which display objects to include.  0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.\n\t * @return {DisplayObject} The top-most display object under the specified coordinates.\n\t **/\n\tp.getObjectUnderPoint = function(x, y, mode) {\n\t\tvar pt = this.localToGlobal(x, y);\n\t\treturn this._getObjectsUnderPoint(pt.x, pt.y, null, mode>0, mode==1);\n\t};\n\t\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getBounds = function() {\n\t\treturn this._getBounds(null, true);\n\t};\n\t\n\t\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getTransformedBounds = function() {\n\t\treturn this._getBounds();\n\t};\n\n\t/**\n\t * Returns a clone of this Container. Some properties that are specific to this instance's current context are\n\t * reverted to their defaults (for example .parent).\n\t * @method clone\n\t * @param {Boolean} [recursive=false] If true, all of the descendants of this container will be cloned recursively. If false, the\n\t * properties of the container will be cloned, but the new instance will not have any children.\n\t * @return {Container} A clone of the current Container instance.\n\t **/\n\tp.clone = function(recursive) {\n\t\tvar o = this._cloneProps(new Container());\n\t\tif (recursive) { this._cloneChildren(o); }\n\t\treturn o;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Container (name=\"+  this.name +\")]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * @protected\n\t **/\n\tp._tick = function(evtObj) {\n\t\tif (this.tickChildren) {\n\t\t\tfor (var i=this.children.length-1; i>=0; i--) {\n\t\t\t\tvar child = this.children[i];\n\t\t\t\tif (child.tickEnabled && child._tick) { child._tick(evtObj); }\n\t\t\t}\n\t\t}\n\t\tthis.DisplayObject__tick(evtObj);\n\t};\n\t\n\t/**\n\t * Recursively clones all children of this container, and adds them to the target container.\n\t * @method cloneChildren\n\t * @protected\n\t * @param {Container} o The target container.\n\t **/\n\tp._cloneChildren = function(o) {\n\t\tif (o.children.length) { o.removeAllChildren(); }\n\t\tvar arr = o.children;\n\t\tfor (var i=0, l=this.children.length; i<l; i++) {\n\t\t\tvar clone = this.children[i].clone(true);\n\t\t\tclone.parent = o;\n\t\t\tarr.push(clone);\n\t\t}\n\t};\n\n\t/**\n\t * @method _getObjectsUnderPoint\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Array} arr\n\t * @param {Boolean} mouse If true, it will respect mouse interaction properties like mouseEnabled, mouseChildren, and active listeners.\n\t * @param {Boolean} activeListener If true, there is an active mouse event listener on a parent object.\n\t * @param {Number} currentDepth Indicates the current depth of the search.\n\t * @return {DisplayObject}\n\t * @protected\n\t **/\n\tp._getObjectsUnderPoint = function(x, y, arr, mouse, activeListener, currentDepth) {\n\t\tcurrentDepth = currentDepth || 0;\n\t\tif (!currentDepth && !this._testMask(this, x, y)) { return null; }\n\t\tvar mtx, ctx = createjs.DisplayObject._hitTestContext;\n\t\tactiveListener = activeListener || (mouse&&this._hasMouseEventListener());\n\n\t\t// draw children one at a time, and check if we get a hit:\n\t\tvar children = this.children, l = children.length;\n\t\tfor (var i=l-1; i>=0; i--) {\n\t\t\tvar child = children[i];\n\t\t\tvar hitArea = child.hitArea;\n\t\t\tif (!child.visible || (!hitArea && !child.isVisible()) || (mouse && !child.mouseEnabled)) { continue; }\n\t\t\tif (!hitArea && !this._testMask(child, x, y)) { continue; }\n\t\t\t\n\t\t\t// if a child container has a hitArea then we only need to check its hitArea, so we can treat it as a normal DO:\n\t\t\tif (!hitArea && child instanceof Container) {\n\t\t\t\tvar result = child._getObjectsUnderPoint(x, y, arr, mouse, activeListener, currentDepth+1);\n\t\t\t\tif (!arr && result) { return (mouse && !this.mouseChildren) ? this : result; }\n\t\t\t} else {\n\t\t\t\tif (mouse && !activeListener && !child._hasMouseEventListener()) { continue; }\n\t\t\t\t\n\t\t\t\t// TODO: can we pass displayProps forward, to avoid having to calculate this backwards every time? It's kind of a mixed bag. When we're only hunting for DOs with event listeners, it may not make sense.\n\t\t\t\tvar props = child.getConcatenatedDisplayProps(child._props);\n\t\t\t\tmtx = props.matrix;\n\t\t\t\t\n\t\t\t\tif (hitArea) {\n\t\t\t\t\tmtx.appendMatrix(hitArea.getMatrix(hitArea._props.matrix));\n\t\t\t\t\tprops.alpha = hitArea.alpha;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tctx.globalAlpha = props.alpha;\n\t\t\t\tctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);\n\t\t\t\t(hitArea||child).draw(ctx);\n\t\t\t\tif (!this._testHit(ctx)) { continue; }\n\t\t\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\t\t\tctx.clearRect(0, 0, 2, 2);\n\t\t\t\tif (arr) { arr.push(child); }\n\t\t\t\telse { return (mouse && !this.mouseChildren) ? this : child; }\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\t\n\t/**\n\t * @method _testMask\n\t * @param {DisplayObject} target\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Boolean} Indicates whether the x/y is within the masked region.\n\t * @protected\n\t **/\n\tp._testMask = function(target, x, y) {\n\t\tvar mask = target.mask;\n\t\tif (!mask || !mask.graphics || mask.graphics.isEmpty()) { return true; }\n\t\t\n\t\tvar mtx = this._props.matrix, parent = target.parent;\n\t\tmtx = parent ? parent.getConcatenatedMatrix(mtx) : mtx.identity();\n\t\tmtx = mask.getMatrix(mask._props.matrix).prependMatrix(mtx);\n\t\t\n\t\tvar ctx = createjs.DisplayObject._hitTestContext;\n\t\tctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);\n\t\t\n\t\t// draw the mask as a solid fill:\n\t\tmask.graphics.drawAsPath(ctx);\n\t\tctx.fillStyle = \"#000\";\n\t\tctx.fill();\n\t\t\n\t\tif (!this._testHit(ctx)) { return false; }\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, 2, 2);\n\t\t\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * @method _getBounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform If true, does not apply this object's transform.\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getBounds = function(matrix, ignoreTransform) {\n\t\tvar bounds = this.DisplayObject_getBounds();\n\t\tif (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }\n\t\t\n\t\tvar mtx = this._props.matrix;\n\t\tmtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);\n\t\tif (matrix) { mtx.prependMatrix(matrix); }\n\t\t\n\t\tvar l = this.children.length, rect=null;\n\t\tfor (var i=0; i<l; i++) {\n\t\t\tvar child = this.children[i];\n\t\t\tif (!child.visible || !(bounds = child._getBounds(mtx))) { continue; }\n\t\t\tif (rect) { rect.extend(bounds.x, bounds.y, bounds.width, bounds.height); }\n\t\t\telse { rect = bounds.clone(); }\n\t\t}\n\t\treturn rect;\n\t};\n\n\n\tcreatejs.Container = createjs.promote(Container, \"DisplayObject\");\n}());\n\n//##############################################################################\n// Stage.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * A stage is the root level {{#crossLink \"Container\"}}{{/crossLink}} for a display list. Each time its {{#crossLink \"Stage/tick\"}}{{/crossLink}}\n\t * method is called, it will render its display list to its target canvas.\n\t *\n\t * <h4>Example</h4>\n\t * This example creates a stage, adds a child to it, then uses {{#crossLink \"Ticker\"}}{{/crossLink}} to update the child\n\t * and redraw the stage using {{#crossLink \"Stage/update\"}}{{/crossLink}}.\n\t *\n\t *      var stage = new createjs.Stage(\"canvasElementId\");\n\t *      var image = new createjs.Bitmap(\"imagePath.png\");\n\t *      stage.addChild(image);\n\t *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n\t *      function handleTick(event) {\n\t *          image.x += 10;\n\t *          stage.update();\n\t *      }\n\t *\n\t * @class Stage\n\t * @extends Container\n\t * @constructor\n\t * @param {HTMLCanvasElement | String | Object} canvas A canvas object that the Stage will render to, or the string id\n\t * of a canvas object in the current document.\n\t **/\n\tfunction Stage(canvas) {\n\t\tthis.Container_constructor();\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * Indicates whether the stage should automatically clear the canvas before each render. You can set this to <code>false</code>\n\t\t * to manually control clearing (for generative art, or when pointing multiple stages at the same canvas for\n\t\t * example).\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *      var stage = new createjs.Stage(\"canvasId\");\n\t\t *      stage.autoClear = false;\n\t\t *\n\t\t * @property autoClear\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.autoClear = true;\n\t\n\t\t/**\n\t\t * The canvas the stage will render to. Multiple stages can share a single canvas, but you must disable autoClear for all but the\n\t\t * first stage that will be ticked (or they will clear each other's render).\n\t\t *\n\t\t * When changing the canvas property you must disable the events on the old canvas, and enable events on the\n\t\t * new canvas or mouse events will not work as expected. For example:\n\t\t *\n\t\t *      myStage.enableDOMEvents(false);\n\t\t *      myStage.canvas = anotherCanvas;\n\t\t *      myStage.enableDOMEvents(true);\n\t\t *\n\t\t * @property canvas\n\t\t * @type HTMLCanvasElement | Object\n\t\t **/\n\t\tthis.canvas = (typeof canvas == \"string\") ? document.getElementById(canvas) : canvas;\n\t\n\t\t/**\n\t\t * The current mouse X position on the canvas. If the mouse leaves the canvas, this will indicate the most recent\n\t\t * position over the canvas, and mouseInBounds will be set to false.\n\t\t * @property mouseX\n\t\t * @type Number\n\t\t * @readonly\n\t\t **/\n\t\tthis.mouseX = 0;\n\t\n\t\t/**\n\t\t * The current mouse Y position on the canvas. If the mouse leaves the canvas, this will indicate the most recent\n\t\t * position over the canvas, and mouseInBounds will be set to false.\n\t\t * @property mouseY\n\t\t * @type Number\n\t\t * @readonly\n\t\t **/\n\t\tthis.mouseY = 0;\n\t\n\t\t/**\n\t\t * Specifies the area of the stage to affect when calling update. This can be use to selectively\n\t\t * re-draw specific regions of the canvas. If null, the whole canvas area is drawn.\n\t\t * @property drawRect\n\t\t * @type {Rectangle}\n\t\t */\n\t\tthis.drawRect = null;\n\t\n\t\t/**\n\t\t * Indicates whether display objects should be rendered on whole pixels. You can set the\n\t\t * {{#crossLink \"DisplayObject/snapToPixel\"}}{{/crossLink}} property of\n\t\t * display objects to false to enable/disable this behaviour on a per instance basis.\n\t\t * @property snapToPixelEnabled\n\t\t * @type Boolean\n\t\t * @default false\n\t\t **/\n\t\tthis.snapToPixelEnabled = false;\n\t\n\t\t/**\n\t\t * Indicates whether the mouse is currently within the bounds of the canvas.\n\t\t * @property mouseInBounds\n\t\t * @type Boolean\n\t\t * @default false\n\t\t **/\n\t\tthis.mouseInBounds = false;\n\t\n\t\t/**\n\t\t * If true, tick callbacks will be called on all display objects on the stage prior to rendering to the canvas.\n\t\t * @property tickOnUpdate\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.tickOnUpdate = true;\n\t\n\t\t/**\n\t\t * If true, mouse move events will continue to be called when the mouse leaves the target canvas. See\n\t\t * {{#crossLink \"Stage/mouseInBounds:property\"}}{{/crossLink}}, and {{#crossLink \"MouseEvent\"}}{{/crossLink}}\n\t\t * x/y/rawX/rawY.\n\t\t * @property mouseMoveOutside\n\t\t * @type Boolean\n\t\t * @default false\n\t\t **/\n\t\tthis.mouseMoveOutside = false;\n\t\t\n\t\t\n\t\t/**\n\t\t * Prevents selection of other elements in the html page if the user clicks and drags, or double clicks on the canvas.\n\t\t * This works by calling `preventDefault()` on any mousedown events (or touch equivalent) originating on the canvas.\n\t\t * @property preventSelection\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.preventSelection = true;\n\t\n\t\t/**\n\t\t * The hitArea property is not supported for Stage.\n\t\t * @property hitArea\n\t\t * @type {DisplayObject}\n\t\t * @default null\n\t\t */\n\t\t \n\t\t \n\t// private properties:\n\t\t/**\n\t\t * Holds objects with data for each active pointer id. Each object has the following properties:\n\t\t * x, y, event, target, overTarget, overX, overY, inBounds, posEvtObj (native event that last updated position)\n\t\t * @property _pointerData\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._pointerData = {};\n\t\n\t\t/**\n\t\t * Number of active pointers.\n\t\t * @property _pointerCount\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._pointerCount = 0;\n\t\n\t\t/**\n\t\t * The ID of the primary pointer.\n\t\t * @property _primaryPointerID\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._primaryPointerID = null;\n\t\n\t\t/**\n\t\t * @property _mouseOverIntervalID\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._mouseOverIntervalID = null;\n\t\t\n\t\t/**\n\t\t * @property _nextStage\n\t\t * @protected\n\t\t * @type Stage\n\t\t **/\n\t\tthis._nextStage = null;\n\t\t\n\t\t/**\n\t\t * @property _prevStage\n\t\t * @protected\n\t\t * @type Stage\n\t\t **/\n\t\tthis._prevStage = null;\n\t\t\n\t\t\n\t// initialize:\n\t\tthis.enableDOMEvents(true);\n\t}\n\tvar p = createjs.extend(Stage, createjs.Container);\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// events:\n\t/**\n\t * Dispatched when the user moves the mouse over the canvas.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event stagemousemove\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the user presses their left mouse button on the canvas. See the {{#crossLink \"MouseEvent\"}}{{/crossLink}}\n\t * class for a listing of event properties.\n\t * @event stagemousedown\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the user the user presses somewhere on the stage, then releases the mouse button anywhere that the page can detect it (this varies slightly between browsers).\n\t * You can use {{#crossLink \"Stage/mouseInBounds:property\"}}{{/crossLink}} to check whether the mouse is currently within the stage bounds.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event stagemouseup\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the mouse moves from within the canvas area (mouseInBounds == true) to outside it (mouseInBounds == false).\n\t * This is currently only dispatched for mouse input (not touch). See the {{#crossLink \"MouseEvent\"}}{{/crossLink}}\n\t * class for a listing of event properties.\n\t * @event mouseleave\n\t * @since 0.7.0\n\t */\n\n\t/**\n\t * Dispatched when the mouse moves into the canvas area (mouseInBounds == false) from outside it (mouseInBounds == true).\n\t * This is currently only dispatched for mouse input (not touch). See the {{#crossLink \"MouseEvent\"}}{{/crossLink}}\n\t * class for a listing of event properties.\n\t * @event mouseenter\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately before the tick event is propagated through the display list.\n\t * You can call preventDefault on the event object to cancel propagating the tick event.\n\t * @event tickstart\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately after the tick event is propagated through the display list. Does not fire if\n\t * tickOnUpdate is false. Precedes the \"drawstart\" event.\n\t * @event tickend\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately before the canvas is cleared and the display list is drawn to it.\n\t * You can call preventDefault on the event object to cancel the draw.\n\t * @event drawstart\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately after the display list is drawn to the canvas and the canvas context is restored.\n\t * @event drawend\n\t * @since 0.7.0\n\t */\n\n\t \n// getter / setters:\n\t/**\n\t * Specifies a target stage that will have mouse / touch interactions relayed to it after this stage handles them.\n\t * This can be useful in cases where you have multiple layered canvases and want user interactions\n\t * events to pass through. For example, this would relay mouse events from topStage to bottomStage:\n\t *\n\t *      topStage.nextStage = bottomStage;\n\t *\n\t * To disable relaying, set nextStage to null.\n\t * \n\t * MouseOver, MouseOut, RollOver, and RollOut interactions are also passed through using the mouse over settings\n\t * of the top-most stage, but are only processed if the target stage has mouse over interactions enabled.\n\t * Considerations when using roll over in relay targets:<OL>\n\t * <LI> The top-most (first) stage must have mouse over interactions enabled (via enableMouseOver)</LI>\n\t * <LI> All stages that wish to participate in mouse over interaction must enable them via enableMouseOver</LI>\n\t * <LI> All relay targets will share the frequency value of the top-most stage</LI>\n\t * </OL>\n\t * To illustrate, in this example the targetStage would process mouse over interactions at 10hz (despite passing\n\t * 30 as it's desired frequency):\n\t * \ttopStage.nextStage = targetStage;\n\t * \ttopStage.enableMouseOver(10);\n\t * \ttargetStage.enableMouseOver(30);\n\t * \n\t * If the target stage's canvas is completely covered by this stage's canvas, you may also want to disable its\n\t * DOM events using:\n\t * \n\t *\ttargetStage.enableDOMEvents(false);\n\t * \n\t * @property nextStage\n\t * @type {Stage}\n\t **/\n\tp._get_nextStage = function() {\n\t\treturn this._nextStage;\n\t};\n\tp._set_nextStage = function(value) {\n\t\tif (this._nextStage) { this._nextStage._prevStage = null; }\n\t\tif (value) { value._prevStage = this; }\n\t\tthis._nextStage = value;\n\t};\n\t\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tnextStage: { get: p._get_nextStage, set: p._set_nextStage }\n\t\t});\n\t} catch (e) {} // TODO: use Log\n\n\n// public methods:\n\t/**\n\t * Each time the update method is called, the stage will call {{#crossLink \"Stage/tick\"}}{{/crossLink}}\n\t * unless {{#crossLink \"Stage/tickOnUpdate:property\"}}{{/crossLink}} is set to false,\n\t * and then render the display list to the canvas.\n\t *\n\t * @method update\n\t * @param {Object} [props] Props object to pass to `tick()`. Should usually be a {{#crossLink \"Ticker\"}}{{/crossLink}} event object, or similar object with a delta property.\n\t **/\n\tp.update = function(props) {\n\t\tif (!this.canvas) { return; }\n\t\tif (this.tickOnUpdate) { this.tick(props); }\n\t\tif (this.dispatchEvent(\"drawstart\", false, true) === false) { return; }\n\t\tcreatejs.DisplayObject._snapToPixelEnabled = this.snapToPixelEnabled;\n\t\tvar r = this.drawRect, ctx = this.canvas.getContext(\"2d\");\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tif (this.autoClear) {\n\t\t\tif (r) { ctx.clearRect(r.x, r.y, r.width, r.height); }\n\t\t\telse { ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1); }\n\t\t}\n\t\tctx.save();\n\t\tif (this.drawRect) {\n\t\t\tctx.beginPath();\n\t\t\tctx.rect(r.x, r.y, r.width, r.height);\n\t\t\tctx.clip();\n\t\t}\n\t\tthis.updateContext(ctx);\n\t\tthis.draw(ctx, false);\n\t\tctx.restore();\n\t\tthis.dispatchEvent(\"drawend\");\n\t};\n\t\n\t/**\n\t * Propagates a tick event through the display list. This is automatically called by {{#crossLink \"Stage/update\"}}{{/crossLink}}\n\t * unless {{#crossLink \"Stage/tickOnUpdate:property\"}}{{/crossLink}} is set to false.\n\t *\n\t * If a props object is passed to `tick()`, then all of its properties will be copied to the event object that is\n\t * propagated to listeners.\n\t *\n\t * Some time-based features in EaselJS (for example {{#crossLink \"Sprite/framerate\"}}{{/crossLink}} require that\n\t * a {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}} event object (or equivalent object with a delta property) be\n\t * passed as the `props` parameter to `tick()`. For example:\n\t *\n\t * \tTicker.on(\"tick\", handleTick);\n\t * \tfunction handleTick(evtObj) {\n\t * \t\t// clone the event object from Ticker, and add some custom data to it:\n\t * \t\tvar evt = evtObj.clone().set({greeting:\"hello\", name:\"world\"});\n\t * \t\t\n\t * \t\t// pass it to stage.update():\n\t * \t\tmyStage.update(evt); // subsequently calls tick() with the same param\n\t * \t}\n\t * \t\n\t * \t// ...\n\t * \tmyDisplayObject.on(\"tick\", handleDisplayObjectTick);\n\t * \tfunction handleDisplayObjectTick(evt) {\n\t * \t\tconsole.log(evt.delta); // the delta property from the Ticker tick event object\n\t * \t\tconsole.log(evt.greeting, evt.name); // custom data: \"hello world\"\n\t * \t}\n\t * \n\t * @method tick\n\t * @param {Object} [props] An object with properties that should be copied to the event object. Should usually be a Ticker event object, or similar object with a delta property.\n\t **/\n\tp.tick = function(props) {\n\t\tif (!this.tickEnabled || this.dispatchEvent(\"tickstart\", false, true) === false) { return; }\n\t\tvar evtObj = new createjs.Event(\"tick\");\n\t\tif (props) {\n\t\t\tfor (var n in props) {\n\t\t\t\tif (props.hasOwnProperty(n)) { evtObj[n] = props[n]; }\n\t\t\t}\n\t\t}\n\t\tthis._tick(evtObj);\n\t\tthis.dispatchEvent(\"tickend\");\n\t};\n\n\t/**\n\t * Default event handler that calls the Stage {{#crossLink \"Stage/update\"}}{{/crossLink}} method when a {{#crossLink \"DisplayObject/tick:event\"}}{{/crossLink}}\n\t * event is received. This allows you to register a Stage instance as a event listener on {{#crossLink \"Ticker\"}}{{/crossLink}}\n\t * directly, using:\n\t *\n\t *      Ticker.addEventListener(\"tick\", myStage\");\n\t *\n\t * Note that if you subscribe to ticks using this pattern, then the tick event object will be passed through to\n\t * display object tick handlers, instead of <code>delta</code> and <code>paused</code> parameters.\n\t * @property handleEvent\n\t * @type Function\n\t **/\n\tp.handleEvent = function(evt) {\n\t\tif (evt.type == \"tick\") { this.update(evt); }\n\t};\n\n\t/**\n\t * Clears the target canvas. Useful if {{#crossLink \"Stage/autoClear:property\"}}{{/crossLink}} is set to `false`.\n\t * @method clear\n\t **/\n\tp.clear = function() {\n\t\tif (!this.canvas) { return; }\n\t\tvar ctx = this.canvas.getContext(\"2d\");\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1);\n\t};\n\n\t/**\n\t * Returns a data url that contains a Base64-encoded image of the contents of the stage. The returned data url can\n\t * be specified as the src value of an image element.\n\t * @method toDataURL\n\t * @param {String} [backgroundColor] The background color to be used for the generated image. Any valid CSS color\n\t * value is allowed. The default value is a transparent background.\n\t * @param {String} [mimeType=\"image/png\"] The MIME type of the image format to be create. The default is \"image/png\". If an unknown MIME type\n\t * is passed in, or if the browser does not support the specified MIME type, the default value will be used.\n\t * @return {String} a Base64 encoded image.\n\t **/\n\tp.toDataURL = function(backgroundColor, mimeType) {\n\t\tvar data, ctx = this.canvas.getContext('2d'), w = this.canvas.width, h = this.canvas.height;\n\n\t\tif (backgroundColor) {\n\t\t\tdata = ctx.getImageData(0, 0, w, h);\n\t\t\tvar compositeOperation = ctx.globalCompositeOperation;\n\t\t\tctx.globalCompositeOperation = \"destination-over\";\n\t\t\t\n\t\t\tctx.fillStyle = backgroundColor;\n\t\t\tctx.fillRect(0, 0, w, h);\n\t\t}\n\n\t\tvar dataURL = this.canvas.toDataURL(mimeType||\"image/png\");\n\n\t\tif(backgroundColor) {\n\t\t\tctx.putImageData(data, 0, 0);\n\t\t\tctx.globalCompositeOperation = compositeOperation;\n\t\t}\n\n\t\treturn dataURL;\n\t};\n\n\t/**\n\t * Enables or disables (by passing a frequency of 0) mouse over ({{#crossLink \"DisplayObject/mouseover:event\"}}{{/crossLink}}\n\t * and {{#crossLink \"DisplayObject/mouseout:event\"}}{{/crossLink}}) and roll over events ({{#crossLink \"DisplayObject/rollover:event\"}}{{/crossLink}}\n\t * and {{#crossLink \"DisplayObject/rollout:event\"}}{{/crossLink}}) for this stage's display list. These events can\n\t * be expensive to generate, so they are disabled by default. The frequency of the events can be controlled\n\t * independently of mouse move events via the optional `frequency` parameter.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var stage = new createjs.Stage(\"canvasId\");\n\t *      stage.enableMouseOver(10); // 10 updates per second\n\t *\n\t * @method enableMouseOver\n\t * @param {Number} [frequency=20] Optional param specifying the maximum number of times per second to broadcast\n\t * mouse over/out events. Set to 0 to disable mouse over events completely. Maximum is 50. A lower frequency is less\n\t * responsive, but uses less CPU.\n\t **/\n\tp.enableMouseOver = function(frequency) {\n\t\tif (this._mouseOverIntervalID) {\n\t\t\tclearInterval(this._mouseOverIntervalID);\n\t\t\tthis._mouseOverIntervalID = null;\n\t\t\tif (frequency == 0) {\n\t\t\t\tthis._testMouseOver(true);\n\t\t\t}\n\t\t}\n\t\tif (frequency == null) { frequency = 20; }\n\t\telse if (frequency <= 0) { return; }\n\t\tvar o = this;\n\t\tthis._mouseOverIntervalID = setInterval(function(){ o._testMouseOver(); }, 1000/Math.min(50,frequency));\n\t};\n\n\t/**\n\t * Enables or disables the event listeners that stage adds to DOM elements (window, document and canvas). It is good\n\t * practice to disable events when disposing of a Stage instance, otherwise the stage will continue to receive\n\t * events from the page.\n\t *\n\t * When changing the canvas property you must disable the events on the old canvas, and enable events on the\n\t * new canvas or mouse events will not work as expected. For example:\n\t *\n\t *      myStage.enableDOMEvents(false);\n\t *      myStage.canvas = anotherCanvas;\n\t *      myStage.enableDOMEvents(true);\n\t *\n\t * @method enableDOMEvents\n\t * @param {Boolean} [enable=true] Indicates whether to enable or disable the events. Default is true.\n\t **/\n\tp.enableDOMEvents = function(enable) {\n\t\tif (enable == null) { enable = true; }\n\t\tvar n, o, ls = this._eventListeners;\n\t\tif (!enable && ls) {\n\t\t\tfor (n in ls) {\n\t\t\t\to = ls[n];\n\t\t\t\to.t.removeEventListener(n, o.f, false);\n\t\t\t}\n\t\t\tthis._eventListeners = null;\n\t\t} else if (enable && !ls && this.canvas) {\n\t\t\tvar t = window.addEventListener ? window : document;\n\t\t\tvar _this = this;\n\t\t\tls = this._eventListeners = {};\n\t\t\tls[\"mouseup\"] = {t:t, f:function(e) { _this._handleMouseUp(e)} };\n\t\t\tls[\"mousemove\"] = {t:t, f:function(e) { _this._handleMouseMove(e)} };\n\t\t\tls[\"dblclick\"] = {t:this.canvas, f:function(e) { _this._handleDoubleClick(e)} };\n\t\t\tls[\"mousedown\"] = {t:this.canvas, f:function(e) { _this._handleMouseDown(e)} };\n\n\t\t\tfor (n in ls) {\n\t\t\t\to = ls[n];\n\t\t\t\to.t.addEventListener(n, o.f, false);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Stage instances cannot be cloned.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\tthrow(\"Stage cannot be cloned.\");\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Stage (name=\"+  this.name +\")]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _getElementRect\n\t * @protected\n\t * @param {HTMLElement} e\n\t **/\n\tp._getElementRect = function(e) {\n\t\tvar bounds;\n\t\ttry { bounds = e.getBoundingClientRect(); } // this can fail on disconnected DOM elements in IE9\n\t\tcatch (err) { bounds = {top: e.offsetTop, left: e.offsetLeft, width:e.offsetWidth, height:e.offsetHeight}; }\n\n\t\tvar offX = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0);\n\t\tvar offY = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop  || document.body.clientTop  || 0);\n\n\t\tvar styles = window.getComputedStyle ? getComputedStyle(e,null) : e.currentStyle; // IE <9 compatibility.\n\t\tvar padL = parseInt(styles.paddingLeft)+parseInt(styles.borderLeftWidth);\n\t\tvar padT = parseInt(styles.paddingTop)+parseInt(styles.borderTopWidth);\n\t\tvar padR = parseInt(styles.paddingRight)+parseInt(styles.borderRightWidth);\n\t\tvar padB = parseInt(styles.paddingBottom)+parseInt(styles.borderBottomWidth);\n\n\t\t// note: in some browsers bounds properties are read only.\n\t\treturn {\n\t\t\tleft: bounds.left+offX+padL,\n\t\t\tright: bounds.right+offX-padR,\n\t\t\ttop: bounds.top+offY+padT,\n\t\t\tbottom: bounds.bottom+offY-padB\n\t\t}\n\t};\n\n\t/**\n\t * @method _getPointerData\n\t * @protected\n\t * @param {Number} id\n\t **/\n\tp._getPointerData = function(id) {\n\t\tvar data = this._pointerData[id];\n\t\tif (!data) { data = this._pointerData[id] = {x:0,y:0}; }\n\t\treturn data;\n\t};\n\n\t/**\n\t * @method _handleMouseMove\n\t * @protected\n\t * @param {MouseEvent} e\n\t **/\n\tp._handleMouseMove = function(e) {\n\t\tif(!e){ e = window.event; }\n\t\tthis._handlePointerMove(-1, e, e.pageX, e.pageY);\n\t};\n\n\t/**\n\t * @method _handlePointerMove\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Number} pageX\n\t * @param {Number} pageY\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handlePointerMove = function(id, e, pageX, pageY, owner) {\n\t\tif (this._prevStage && owner === undefined) { return; } // redundant listener.\n\t\tif (!this.canvas) { return; }\n\t\tvar nextStage=this._nextStage, o=this._getPointerData(id);\n\n\t\tvar inBounds = o.inBounds;\n\t\tthis._updatePointerPosition(id, e, pageX, pageY);\n\t\tif (inBounds || o.inBounds || this.mouseMoveOutside) {\n\t\t\tif (id === -1 && o.inBounds == !inBounds) {\n\t\t\t\tthis._dispatchMouseEvent(this, (inBounds ? \"mouseleave\" : \"mouseenter\"), false, id, o, e);\n\t\t\t}\n\t\t\t\n\t\t\tthis._dispatchMouseEvent(this, \"stagemousemove\", false, id, o, e);\n\t\t\tthis._dispatchMouseEvent(o.target, \"pressmove\", true, id, o, e);\n\t\t}\n\t\t\n\t\tnextStage&&nextStage._handlePointerMove(id, e, pageX, pageY, null);\n\t};\n\n\t/**\n\t * @method _updatePointerPosition\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Number} pageX\n\t * @param {Number} pageY\n\t **/\n\tp._updatePointerPosition = function(id, e, pageX, pageY) {\n\t\tvar rect = this._getElementRect(this.canvas);\n\t\tpageX -= rect.left;\n\t\tpageY -= rect.top;\n\n\t\tvar w = this.canvas.width;\n\t\tvar h = this.canvas.height;\n\t\tpageX /= (rect.right-rect.left)/w;\n\t\tpageY /= (rect.bottom-rect.top)/h;\n\t\tvar o = this._getPointerData(id);\n\t\tif (o.inBounds = (pageX >= 0 && pageY >= 0 && pageX <= w-1 && pageY <= h-1)) {\n\t\t\to.x = pageX;\n\t\t\to.y = pageY;\n\t\t} else if (this.mouseMoveOutside) {\n\t\t\to.x = pageX < 0 ? 0 : (pageX > w-1 ? w-1 : pageX);\n\t\t\to.y = pageY < 0 ? 0 : (pageY > h-1 ? h-1 : pageY);\n\t\t}\n\n\t\to.posEvtObj = e;\n\t\to.rawX = pageX;\n\t\to.rawY = pageY;\n\n\t\tif (id === this._primaryPointerID || id === -1) {\n\t\t\tthis.mouseX = o.x;\n\t\t\tthis.mouseY = o.y;\n\t\t\tthis.mouseInBounds = o.inBounds;\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleMouseUp\n\t * @protected\n\t * @param {MouseEvent} e\n\t **/\n\tp._handleMouseUp = function(e) {\n\t\tthis._handlePointerUp(-1, e, false);\n\t};\n\n\t/**\n\t * @method _handlePointerUp\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Boolean} clear\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handlePointerUp = function(id, e, clear, owner) {\n\t\tvar nextStage = this._nextStage, o = this._getPointerData(id);\n\t\tif (this._prevStage && owner === undefined) { return; } // redundant listener.\n\t\t\n\t\tvar target=null, oTarget = o.target;\n\t\tif (!owner && (oTarget || nextStage)) { target = this._getObjectsUnderPoint(o.x, o.y, null, true); }\n\t\t\n\t\tif (o.down) { this._dispatchMouseEvent(this, \"stagemouseup\", false, id, o, e, target); o.down = false; }\n\t\t\n\t\tif (target == oTarget) { this._dispatchMouseEvent(oTarget, \"click\", true, id, o, e); }\n\t\tthis._dispatchMouseEvent(oTarget, \"pressup\", true, id, o, e);\n\t\t\n\t\tif (clear) {\n\t\t\tif (id==this._primaryPointerID) { this._primaryPointerID = null; }\n\t\t\tdelete(this._pointerData[id]);\n\t\t} else { o.target = null; }\n\t\t\n\t\tnextStage&&nextStage._handlePointerUp(id, e, clear, owner || target && this);\n\t};\n\n\t/**\n\t * @method _handleMouseDown\n\t * @protected\n\t * @param {MouseEvent} e\n\t **/\n\tp._handleMouseDown = function(e) {\n\t\tthis._handlePointerDown(-1, e, e.pageX, e.pageY);\n\t};\n\n\t/**\n\t * @method _handlePointerDown\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Number} pageX\n\t * @param {Number} pageY\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handlePointerDown = function(id, e, pageX, pageY, owner) {\n\t\tif (this.preventSelection) { e.preventDefault(); }\n\t\tif (this._primaryPointerID == null || id === -1) { this._primaryPointerID = id; } // mouse always takes over.\n\t\t\n\t\tif (pageY != null) { this._updatePointerPosition(id, e, pageX, pageY); }\n\t\tvar target = null, nextStage = this._nextStage, o = this._getPointerData(id);\n\t\tif (!owner) { target = o.target = this._getObjectsUnderPoint(o.x, o.y, null, true); }\n\n\t\tif (o.inBounds) { this._dispatchMouseEvent(this, \"stagemousedown\", false, id, o, e, target); o.down = true; }\n\t\tthis._dispatchMouseEvent(target, \"mousedown\", true, id, o, e);\n\t\t\n\t\tnextStage&&nextStage._handlePointerDown(id, e, pageX, pageY, owner || target && this);\n\t};\n\n\t/**\n\t * @method _testMouseOver\n\t * @param {Boolean} clear If true, clears the mouseover / rollover (ie. no target)\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t * @param {Stage} eventTarget The stage that the cursor is actively over.\n\t * @protected\n\t **/\n\tp._testMouseOver = function(clear, owner, eventTarget) {\n\t\tif (this._prevStage && owner === undefined) { return; } // redundant listener.\n\t\t\n\t\tvar nextStage = this._nextStage;\n\t\tif (!this._mouseOverIntervalID) {\n\t\t\t// not enabled for mouseover, but should still relay the event.\n\t\t\tnextStage&&nextStage._testMouseOver(clear, owner, eventTarget);\n\t\t\treturn;\n\t\t}\n\t\tvar o = this._getPointerData(-1);\n\t\t// only update if the mouse position has changed. This provides a lot of optimization, but has some trade-offs.\n\t\tif (!o || (!clear && this.mouseX == this._mouseOverX && this.mouseY == this._mouseOverY && this.mouseInBounds)) { return; }\n\t\t\n\t\tvar e = o.posEvtObj;\n\t\tvar isEventTarget = eventTarget || e&&(e.target == this.canvas);\n\t\tvar target=null, common = -1, cursor=\"\", t, i, l;\n\t\t\n\t\tif (!owner && (clear || this.mouseInBounds && isEventTarget)) {\n\t\t\ttarget = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, true);\n\t\t\tthis._mouseOverX = this.mouseX;\n\t\t\tthis._mouseOverY = this.mouseY;\n\t\t}\n\n\t\tvar oldList = this._mouseOverTarget||[];\n\t\tvar oldTarget = oldList[oldList.length-1];\n\t\tvar list = this._mouseOverTarget = [];\n\n\t\t// generate ancestor list and check for cursor:\n\t\tt = target;\n\t\twhile (t) {\n\t\t\tlist.unshift(t);\n\t\t\tif (!cursor) { cursor = t.cursor; }\n\t\t\tt = t.parent;\n\t\t}\n\t\tthis.canvas.style.cursor = cursor;\n\t\tif (!owner && eventTarget) { eventTarget.canvas.style.cursor = cursor; }\n\n\t\t// find common ancestor:\n\t\tfor (i=0,l=list.length; i<l; i++) {\n\t\t\tif (list[i] != oldList[i]) { break; }\n\t\t\tcommon = i;\n\t\t}\n\n\t\tif (oldTarget != target) {\n\t\t\tthis._dispatchMouseEvent(oldTarget, \"mouseout\", true, -1, o, e, target);\n\t\t}\n\n\t\tfor (i=oldList.length-1; i>common; i--) {\n\t\t\tthis._dispatchMouseEvent(oldList[i], \"rollout\", false, -1, o, e, target);\n\t\t}\n\n\t\tfor (i=list.length-1; i>common; i--) {\n\t\t\tthis._dispatchMouseEvent(list[i], \"rollover\", false, -1, o, e, oldTarget);\n\t\t}\n\n\t\tif (oldTarget != target) {\n\t\t\tthis._dispatchMouseEvent(target, \"mouseover\", true, -1, o, e, oldTarget);\n\t\t}\n\t\t\n\t\tnextStage&&nextStage._testMouseOver(clear, owner || target && this, eventTarget || isEventTarget && this);\n\t};\n\n\t/**\n\t * @method _handleDoubleClick\n\t * @protected\n\t * @param {MouseEvent} e\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handleDoubleClick = function(e, owner) {\n\t\tvar target=null, nextStage=this._nextStage, o=this._getPointerData(-1);\n\t\tif (!owner) {\n\t\t\ttarget = this._getObjectsUnderPoint(o.x, o.y, null, true);\n\t\t\tthis._dispatchMouseEvent(target, \"dblclick\", true, -1, o, e);\n\t\t}\n\t\tnextStage&&nextStage._handleDoubleClick(e, owner || target && this);\n\t};\n\n\t/**\n\t * @method _dispatchMouseEvent\n\t * @protected\n\t * @param {DisplayObject} target\n\t * @param {String} type\n\t * @param {Boolean} bubbles\n\t * @param {Number} pointerId\n\t * @param {Object} o\n\t * @param {MouseEvent} [nativeEvent]\n\t * @param {DisplayObject} [relatedTarget]\n\t **/\n\tp._dispatchMouseEvent = function(target, type, bubbles, pointerId, o, nativeEvent, relatedTarget) {\n\t\t// TODO: might be worth either reusing MouseEvent instances, or adding a willTrigger method to avoid GC.\n\t\tif (!target || (!bubbles && !target.hasEventListener(type))) { return; }\n\t\t/*\n\t\t// TODO: account for stage transformations?\n\t\tthis._mtx = this.getConcatenatedMatrix(this._mtx).invert();\n\t\tvar pt = this._mtx.transformPoint(o.x, o.y);\n\t\tvar evt = new createjs.MouseEvent(type, bubbles, false, pt.x, pt.y, nativeEvent, pointerId, pointerId==this._primaryPointerID || pointerId==-1, o.rawX, o.rawY);\n\t\t*/\n\t\tvar evt = new createjs.MouseEvent(type, bubbles, false, o.x, o.y, nativeEvent, pointerId, pointerId === this._primaryPointerID || pointerId === -1, o.rawX, o.rawY, relatedTarget);\n\t\ttarget.dispatchEvent(evt);\n\t};\n\n\n\tcreatejs.Stage = createjs.promote(Stage, \"Container\");\n}());\n\n//##############################################################################\n// Bitmap.js\n//##############################################################################\n\n(function() {\n\t\n\t/**\n\t * A Bitmap represents an Image, Canvas, or Video in the display list. A Bitmap can be instantiated using an existing\n\t * HTML element, or a string.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var bitmap = new createjs.Bitmap(\"imagePath.jpg\");\n\t *\n\t * <strong>Notes:</strong>\n\t * <ol>\n\t *     <li>When a string path or image tag that is not yet loaded is used, the stage may need to be redrawn before it\n\t *      will be displayed.</li>\n\t *     <li>Bitmaps with an SVG source currently will not respect an alpha value other than 0 or 1. To get around this,\n\t *     the Bitmap can be cached.</li>\n\t *     <li>Bitmaps with an SVG source will taint the canvas with cross-origin data, which prevents interactivity. This\n\t *     happens in all browsers except recent Firefox builds.</li>\n\t *     <li>Images loaded cross-origin will throw cross-origin security errors when interacted with using a mouse, using\n\t *     methods such as `getObjectUnderPoint`, or using filters, or caching. You can get around this by setting\n\t *     `crossOrigin` flags on your images before passing them to EaselJS, eg: `img.crossOrigin=\"Anonymous\";`</li>\n\t * </ol>\n\t *\n\t * @class Bitmap\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} imageOrUri The source object or URI to an image to\n\t * display. This can be either an Image, Canvas, or Video object, or a string URI to an image file to load and use.\n\t * If it is a URI, a new Image object will be constructed and assigned to the .image property.\n\t **/\n\tfunction Bitmap(imageOrUri) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The image to render. This can be an Image, a Canvas, or a Video. Not all browsers (especially\n\t\t * mobile browsers) support drawing video to a canvas.\n\t\t * @property image\n\t\t * @type HTMLImageElement | HTMLCanvasElement | HTMLVideoElement\n\t\t **/\n\t\tif (typeof imageOrUri == \"string\") {\n\t\t\tthis.image = document.createElement(\"img\");\n\t\t\tthis.image.src = imageOrUri;\n\t\t} else {\n\t\t\tthis.image = imageOrUri;\n\t\t}\n\t\n\t\t/**\n\t\t * Specifies an area of the source image to draw. If omitted, the whole image will be drawn.\n\t\t * Note that video sources must have a width / height set to work correctly with `sourceRect`.\n\t\t * @property sourceRect\n\t\t * @type Rectangle\n\t\t * @default null\n\t\t */\n\t\tthis.sourceRect = null;\n\t}\n\tvar p = createjs.extend(Bitmap, createjs.DisplayObject);\n\t\n\t\n// public methods:\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink \"Utility Methods/extends\"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = Bitmap; // TODO: deprecated.\n\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar image = this.image;\n\t\tvar hasContent = this.cacheCanvas || (image && (image.naturalWidth || image.getContext || image.readyState >= 2));\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t * @return {Boolean}\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache) || !this.image) { return true; }\n\t\tvar img = this.image, rect = this.sourceRect;\n\t\tif (rect) {\n\t\t\t// some browsers choke on out of bound values, so we'll fix them:\n\t\t\tvar x1 = rect.x, y1 = rect.y, x2 = x1 + rect.width, y2 = y1 + rect.height, x = 0, y = 0, w = img.width, h = img.height;\n\t\t\tif (x1 < 0) { x -= x1; x1 = 0; }\n\t\t\tif (x2 > w) { x2 = w; }\n\t\t\tif (y1 < 0) { y -= y1; y1 = 0; }\n\t\t\tif (y2 > h) { y2 = h; }\n\t\t\tctx.drawImage(img, x1, y1, x2-x1, y2-y1, x, y, x2-x1, y2-y1);\n\t\t} else {\n\t\t\tctx.drawImage(img, 0, 0);\n\t\t}\n\t\treturn true;\n\t};\n\t\n\t//Note, the doc sections below document using the specified APIs (from DisplayObject)  from\n\t//Bitmap. This is why they have no method implementations.\n\t\n\t/**\n\t * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t * You should <b>not</b> cache Bitmap instances as it can degrade performance.\n\t *\n\t * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>\n\t * To see the API for caching, please visit the DisplayObject {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}}\n\t * method.\n\t * @method cache\n\t **/\n\t\n\t/**\n\t * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t * You should <b>not</b> cache Bitmap instances as it can degrade performance.\n\t *\n\t * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>\n\t * To see the API for caching, please visit the DisplayObject {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}}\n\t * method.\n\t * @method updateCache\n\t **/\n\t\n\t/**\n\t * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t * You should <b>not</b> cache Bitmap instances as it can degrade performance.\n\t *\n\t * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>\n\t * To see the API for caching, please visit the DisplayObject {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}}\n\t * method.\n\t * @method uncache\n\t **/\n\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getBounds = function() {\n\t\tvar rect = this.DisplayObject_getBounds();\n\t\tif (rect) { return rect; }\n\t\tvar image = this.image, o = this.sourceRect || image;\n\t\tvar hasContent = (image && (image.naturalWidth || image.getContext || image.readyState >= 2));\n\t\treturn hasContent ? this._rectangle.setValues(0, 0, o.width, o.height) : null;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Bitmap instance.\n\t * @method clone\n\t * @return {Bitmap} a clone of the Bitmap instance.\n\t **/\n\tp.clone = function() {\n\t\tvar o = new Bitmap(this.image);\n\t\tif (this.sourceRect) { o.sourceRect = this.sourceRect.clone(); }\n\t\tthis._cloneProps(o);\n\t\treturn o;\n\t};\n\t\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Bitmap (name=\"+  this.name +\")]\";\n\t};\n\n\t\n\tcreatejs.Bitmap = createjs.promote(Bitmap, \"DisplayObject\");\n}());\n\n//##############################################################################\n// Sprite.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Displays a frame or sequence of frames (ie. an animation) from a SpriteSheet instance. A sprite sheet is a series of\n\t * images (usually animation frames) combined into a single image. For example, an animation consisting of 8 100x100\n\t * images could be combined into a 400x200 sprite sheet (4 frames across by 2 high). You can display individual frames,\n\t * play frames as an animation, and even sequence animations together.\n\t *\n\t * See the {{#crossLink \"SpriteSheet\"}}{{/crossLink}} class for more information on setting up frames and animations.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var instance = new createjs.Sprite(spriteSheet);\n\t *      instance.gotoAndStop(\"frameName\");\n\t *\n\t * Until {{#crossLink \"Sprite/gotoAndStop\"}}{{/crossLink}} or {{#crossLink \"Sprite/gotoAndPlay\"}}{{/crossLink}} is called,\n\t * only the first defined frame defined in the sprite sheet will be displayed.\n\t *\n\t * @class Sprite\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {SpriteSheet} spriteSheet The SpriteSheet instance to play back. This includes the source image(s), frame\n\t * dimensions, and frame data. See {{#crossLink \"SpriteSheet\"}}{{/crossLink}} for more information.\n\t * @param {String|Number} [frameOrAnimation] The frame number or animation to play initially.\n\t **/\n\tfunction Sprite(spriteSheet, frameOrAnimation) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The frame index that will be drawn when draw is called. Note that with some {{#crossLink \"SpriteSheet\"}}{{/crossLink}}\n\t\t * definitions, this will advance non-sequentially. This will always be an integer value.\n\t\t * @property currentFrame\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @readonly\n\t\t **/\n\t\tthis.currentFrame = 0;\n\t\n\t\t/**\n\t\t * Returns the name of the currently playing animation.\n\t\t * @property currentAnimation\n\t\t * @type {String}\n\t\t * @final\n\t\t * @readonly\n\t\t **/\n\t\tthis.currentAnimation = null;\n\t\n\t\t/**\n\t\t * Prevents the animation from advancing each tick automatically. For example, you could create a sprite\n\t\t * sheet of icons, set paused to true, and display the appropriate icon by setting <code>currentFrame</code>.\n\t\t * @property paused\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t **/\n\t\tthis.paused = true;\n\t\n\t\t/**\n\t\t * The SpriteSheet instance to play back. This includes the source image, frame dimensions, and frame\n\t\t * data. See {{#crossLink \"SpriteSheet\"}}{{/crossLink}} for more information.\n\t\t * @property spriteSheet\n\t\t * @type {SpriteSheet}\n\t\t * @readonly\n\t\t **/\n\t\tthis.spriteSheet = spriteSheet;\n\t\n\t\t/**\n\t\t * Specifies the current frame index within the currently playing animation. When playing normally, this will increase\n\t\t * from 0 to n-1, where n is the number of frames in the current animation.\n\t\t *\n\t\t * This could be a non-integer value if\n\t\t * using time-based playback (see {{#crossLink \"Sprite/framerate\"}}{{/crossLink}}, or if the animation's speed is\n\t\t * not an integer.\n\t\t * @property currentAnimationFrame\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.currentAnimationFrame = 0;\n\t\n\t\t/**\n\t\t * By default Sprite instances advance one frame per tick. Specifying a framerate for the Sprite (or its related\n\t\t * SpriteSheet) will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n\t\t * framerate.\n\t\t *\n\t\t * For example, if a Sprite with a framerate of 10 is placed on a Stage being updated at 40fps, then the Sprite will\n\t\t * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\n\t\t * vary slightly between frames.\n\t\t *\n\t\t * This feature is dependent on the tick event object (or an object with an appropriate \"delta\" property) being\n\t\t * passed into {{#crossLink \"Stage/update\"}}{{/crossLink}}.\n\t\t * @property framerate\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.framerate = 0;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * Current animation object.\n\t\t * @property _animation\n\t\t * @protected\n\t\t * @type {Object}\n\t\t * @default null\n\t\t **/\n\t\tthis._animation = null;\n\t\n\t\t/**\n\t\t * Current frame index.\n\t\t * @property _currentFrame\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default null\n\t\t **/\n\t\tthis._currentFrame = null;\n\t\t\n\t\t/**\n\t\t * Skips the next auto advance. Used by gotoAndPlay to avoid immediately jumping to the next frame\n\t\t * @property _skipAdvance\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t **/\n\t\tthis._skipAdvance = false;\n\t\t\n\t\t\n\t\tif (frameOrAnimation != null) { this.gotoAndPlay(frameOrAnimation); }\n\t}\n\tvar p = createjs.extend(Sprite, createjs.DisplayObject);\n\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink \"Utility Methods/extends\"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = Sprite; // TODO: Deprecated. This is for backwards support of FlashCC spritesheet export.\n\n\n// events:\n\t/**\n\t * Dispatched when an animation reaches its ends.\n\t * @event animationend\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {String} name The name of the animation that just ended.\n\t * @param {String} next The name of the next animation that will be played, or null. This will be the same as name if the animation is looping.\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched any time the current frame changes. For example, this could be due to automatic advancement on a tick,\n\t * or calling gotoAndPlay() or gotoAndStop().\n\t * @event change\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t */\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || this.spriteSheet.complete;\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\tthis._normalizeFrame();\n\t\tvar o = this.spriteSheet.getFrame(this._currentFrame|0);\n\t\tif (!o) { return false; }\n\t\tvar rect = o.rect;\n\t\tif (rect.width && rect.height) { ctx.drawImage(o.image, rect.x, rect.y, rect.width, rect.height, -o.regX, -o.regY, rect.width, rect.height); }\n\t\treturn true;\n\t};\n\n\t//Note, the doc sections below document using the specified APIs (from DisplayObject)  from\n\t//Bitmap. This is why they have no method implementations.\n\n\t/**\n\t * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.\n\t * You should not cache Sprite instances as it can degrade performance.\n\t * @method cache\n\t **/\n\n\t/**\n\t * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.\n\t * You should not cache Sprite instances as it can degrade performance.\n\t * @method updateCache\n\t **/\n\n\t/**\n\t * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.\n\t * You should not cache Sprite instances as it can degrade performance.\n\t * @method uncache\n\t **/\n\n\t/**\n\t * Play (unpause) the current animation. The Sprite will be paused if either {{#crossLink \"Sprite/stop\"}}{{/crossLink}}\n\t * or {{#crossLink \"Sprite/gotoAndStop\"}}{{/crossLink}} is called. Single frame animations will remain\n\t * unchanged.\n\t * @method play\n\t **/\n\tp.play = function() {\n\t\tthis.paused = false;\n\t};\n\n\t/**\n\t * Stop playing a running animation. The Sprite will be playing if {{#crossLink \"Sprite/gotoAndPlay\"}}{{/crossLink}}\n\t * is called. Note that calling {{#crossLink \"Sprite/gotoAndPlay\"}}{{/crossLink}} or {{#crossLink \"Sprite/play\"}}{{/crossLink}}\n\t * will resume playback.\n\t * @method stop\n\t **/\n\tp.stop = function() {\n\t\tthis.paused = true;\n\t};\n\n\t/**\n\t * Sets paused to false and plays the specified animation name, named frame, or frame number.\n\t * @method gotoAndPlay\n\t * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to\n\t * and begin playing.\n\t **/\n\tp.gotoAndPlay = function(frameOrAnimation) {\n\t\tthis.paused = false;\n\t\tthis._skipAdvance = true;\n\t\tthis._goto(frameOrAnimation);\n\t};\n\n\t/**\n\t * Sets paused to true and seeks to the specified animation name, named frame, or frame number.\n\t * @method gotoAndStop\n\t * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to\n\t * and stop.\n\t **/\n\tp.gotoAndStop = function(frameOrAnimation) {\n\t\tthis.paused = true;\n\t\tthis._goto(frameOrAnimation);\n\t};\n\n\t/**\n\t * Advances the playhead. This occurs automatically each tick by default.\n\t * @param [time] {Number} The amount of time in ms to advance by. Only applicable if framerate is set on the Sprite\n\t * or its SpriteSheet.\n\t * @method advance\n\t*/\n\tp.advance = function(time) {\n\t\tvar fps = this.framerate || this.spriteSheet.framerate;\n\t\tvar t = (fps && time != null) ? time/(1000/fps) : 1;\n\t\tthis._normalizeFrame(t);\n\t};\n\t\n\t/**\n\t * Returns a {{#crossLink \"Rectangle\"}}{{/crossLink}} instance defining the bounds of the current frame relative to\n\t * the origin. For example, a 90 x 70 frame with <code>regX=50</code> and <code>regY=40</code> would return a\n\t * rectangle with [x=-50, y=-40, width=90, height=70]. This ignores transformations on the display object.\n\t *\n\t * Also see the SpriteSheet {{#crossLink \"SpriteSheet/getFrameBounds\"}}{{/crossLink}} method.\n\t * @method getBounds\n\t * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully\n\t * loaded.\n\t **/\n\tp.getBounds = function() {\n\t\t// TODO: should this normalizeFrame?\n\t\treturn this.DisplayObject_getBounds() || this.spriteSheet.getFrameBounds(this.currentFrame, this._rectangle);\n\t};\n\n\t/**\n\t * Returns a clone of the Sprite instance. Note that the same SpriteSheet is shared between cloned\n\t * instances.\n\t * @method clone\n\t * @return {Sprite} a clone of the Sprite instance.\n\t **/\n\tp.clone = function() {\n\t\treturn this._cloneProps(new Sprite(this.spriteSheet));\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Sprite (name=\"+  this.name +\")]\";\n\t};\n\n// private methods:\n\t/**\n\t * @method _cloneProps\n\t * @param {Sprite} o\n\t * @return {Sprite} o\n\t * @protected\n\t **/\n\tp._cloneProps = function(o) {\n\t\tthis.DisplayObject__cloneProps(o);\n\t\to.currentFrame = this.currentFrame;\n\t\to.currentAnimation = this.currentAnimation;\n\t\to.paused = this.paused;\n\t\to.currentAnimationFrame = this.currentAnimationFrame;\n\t\to.framerate = this.framerate;\n\t\t\n\t\to._animation = this._animation;\n\t\to._currentFrame = this._currentFrame;\n\t\to._skipAdvance = this._skipAdvance;\n\t\treturn o;\n\t};\n\t\n\t/**\n\t * Advances the <code>currentFrame</code> if paused is not true. This is called automatically when the {{#crossLink \"Stage\"}}{{/crossLink}}\n\t * ticks.\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * @protected\n\t * @method _tick\n\t **/\n\tp._tick = function(evtObj) {\n\t\tif (!this.paused) {\n\t\t\tif (!this._skipAdvance) { this.advance(evtObj&&evtObj.delta); }\n\t\t\tthis._skipAdvance = false;\n\t\t}\n\t\tthis.DisplayObject__tick(evtObj);\n\t};\n\n\n\t/**\n\t * Normalizes the current frame, advancing animations and dispatching callbacks as appropriate.\n\t * @protected\n\t * @method _normalizeFrame\n\t **/\n\tp._normalizeFrame = function(frameDelta) {\n\t\tframeDelta = frameDelta || 0;\n\t\tvar animation = this._animation;\n\t\tvar paused = this.paused;\n\t\tvar frame = this._currentFrame;\n\t\tvar l;\n\t\t\n\t\tif (animation) {\n\t\t\tvar speed = animation.speed || 1;\n\t\t\tvar animFrame = this.currentAnimationFrame;\n\t\t\tl = animation.frames.length;\n\t\t\tif (animFrame + frameDelta * speed >= l) {\n\t\t\t\tvar next = animation.next;\n\t\t\t\tif (this._dispatchAnimationEnd(animation, frame, paused, next, l - 1)) {\n\t\t\t\t\t// something changed in the event stack, so we shouldn't make any more changes here.\n\t\t\t\t\treturn;\n\t\t\t\t} else if (next) {\n\t\t\t\t\t// sequence. Automatically calls _normalizeFrame again with the remaining frames.\n\t\t\t\t\treturn this._goto(next, frameDelta - (l - animFrame) / speed);\n\t\t\t\t} else {\n\t\t\t\t\t// end.\n\t\t\t\t\tthis.paused = true;\n\t\t\t\t\tanimFrame = animation.frames.length - 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tanimFrame += frameDelta * speed;\n\t\t\t}\n\t\t\tthis.currentAnimationFrame = animFrame;\n\t\t\tthis._currentFrame = animation.frames[animFrame | 0]\n\t\t} else {\n\t\t\tframe = (this._currentFrame += frameDelta);\n\t\t\tl = this.spriteSheet.getNumFrames();\n\t\t\tif (frame >= l && l > 0) {\n\t\t\t\tif (!this._dispatchAnimationEnd(animation, frame, paused, l - 1)) {\n\t\t\t\t\t// looped.\n\t\t\t\t\tif ((this._currentFrame -= l) >= l) { return this._normalizeFrame(); }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tframe = this._currentFrame | 0;\n\t\tif (this.currentFrame != frame) {\n\t\t\tthis.currentFrame = frame;\n\t\t\tthis.dispatchEvent(\"change\");\n\t\t}\n\t};\n\n\t/**\n\t * Dispatches the \"animationend\" event. Returns true if a handler changed the animation (ex. calling {{#crossLink \"Sprite/stop\"}}{{/crossLink}},\n\t * {{#crossLink \"Sprite/gotoAndPlay\"}}{{/crossLink}}, etc.)\n\t * @property _dispatchAnimationEnd\n\t * @private\n\t * @type {Function}\n\t **/\n\tp._dispatchAnimationEnd = function(animation, frame, paused, next, end) {\n\t\tvar name = animation ? animation.name : null;\n\t\tif (this.hasEventListener(\"animationend\")) {\n\t\t\tvar evt = new createjs.Event(\"animationend\");\n\t\t\tevt.name = name;\n\t\t\tevt.next = next;\n\t\t\tthis.dispatchEvent(evt);\n\t\t}\n\t\t// did the animation get changed in the event stack?:\n\t\tvar changed = (this._animation != animation || this._currentFrame != frame);\n\t\t// if the animation hasn't changed, but the sprite was paused, then we want to stick to the last frame:\n\t\tif (!changed && !paused && this.paused) { this.currentAnimationFrame = end; changed = true; }\n\t\treturn changed;\n\t};\n\n\t/**\n\t * Moves the playhead to the specified frame number or animation.\n\t * @method _goto\n\t * @param {String|Number} frameOrAnimation The frame number or animation that the playhead should move to.\n\t * @param {Boolean} [frame] The frame of the animation to go to. Defaults to 0.\n\t * @protected\n\t **/\n\tp._goto = function(frameOrAnimation, frame) {\n\t\tthis.currentAnimationFrame = 0;\n\t\tif (isNaN(frameOrAnimation)) {\n\t\t\tvar data = this.spriteSheet.getAnimation(frameOrAnimation);\n\t\t\tif (data) {\n\t\t\t\tthis._animation = data;\n\t\t\t\tthis.currentAnimation = frameOrAnimation;\n\t\t\t\tthis._normalizeFrame(frame);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.currentAnimation = this._animation = null;\n\t\t\tthis._currentFrame = frameOrAnimation;\n\t\t\tthis._normalizeFrame();\n\t\t}\n\t};\n\n\n\tcreatejs.Sprite = createjs.promote(Sprite, \"DisplayObject\");\n}());\n\n//##############################################################################\n// Shape.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * A Shape allows you to display vector art in the display list. It composites a {{#crossLink \"Graphics\"}}{{/crossLink}}\n\t * instance which exposes all of the vector drawing methods. The Graphics instance can be shared between multiple Shape\n\t * instances to display the same vector graphics with different positions or transforms.\n\t *\n\t * If the vector art will not\n\t * change between draws, you may want to use the {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}} method to reduce the\n\t * rendering cost.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var graphics = new createjs.Graphics().beginFill(\"#ff0000\").drawRect(0, 0, 100, 100);\n\t *      var shape = new createjs.Shape(graphics);\n\t *\n\t *      //Alternatively use can also use the graphics property of the Shape class to renderer the same as above.\n\t *      var shape = new createjs.Shape();\n\t *      shape.graphics.beginFill(\"#ff0000\").drawRect(0, 0, 100, 100);\n\t *\n\t * @class Shape\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {Graphics} graphics Optional. The graphics instance to display. If null, a new Graphics instance will be created.\n\t **/\n\tfunction Shape(graphics) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The graphics instance to display.\n\t\t * @property graphics\n\t\t * @type Graphics\n\t\t **/\n\t\tthis.graphics = graphics ? graphics : new createjs.Graphics();\n\t}\n\tvar p = createjs.extend(Shape, createjs.DisplayObject);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the Shape would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the Shape would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || (this.graphics && !this.graphics.isEmpty());\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the Shape into the specified context ignoring its visible, alpha, shadow, and transform. Returns true if\n\t * the draw was handled (useful for overriding functionality).\n\t *\n\t * <i>NOTE: This method is mainly for internal use, though it may be useful for advanced uses.</i>\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,\n\t * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).\n\t * @return {Boolean}\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\tthis.graphics.draw(ctx, this);\n\t\treturn true;\n\t};\n\n\t/**\n\t * Returns a clone of this Shape. Some properties that are specific to this instance's current context are reverted to\n\t * their defaults (for example .parent).\n\t * @method clone\n\t * @param {Boolean} recursive If true, this Shape's {{#crossLink \"Graphics\"}}{{/crossLink}} instance will also be\n\t * cloned. If false, the Graphics instance will be shared with the new Shape.\n\t **/\n\tp.clone = function(recursive) {\n\t\tvar g = (recursive && this.graphics) ? this.graphics.clone() : this.graphics;\n\t\treturn  this._cloneProps(new Shape(g));\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Shape (name=\"+  this.name +\")]\";\n\t};\n\n\n\tcreatejs.Shape = createjs.promote(Shape, \"DisplayObject\");\n}());\n\n//##############################################################################\n// Text.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Display one or more lines of dynamic text (not user editable) in the display list. Line wrapping support (using the\n\t * lineWidth) is very basic, wrapping on spaces and tabs only. Note that as an alternative to Text, you can position HTML\n\t * text above or below the canvas relative to items in the display list using the {{#crossLink \"DisplayObject/localToGlobal\"}}{{/crossLink}}\n\t * method, or using {{#crossLink \"DOMElement\"}}{{/crossLink}}.\n\t *\n\t * <b>Please note that Text does not support HTML text, and can only display one font style at a time.</b> To use\n\t * multiple font styles, you will need to create multiple text instances, and position them manually.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var text = new createjs.Text(\"Hello World\", \"20px Arial\", \"#ff7700\");\n\t *      text.x = 100;\n\t *      text.textBaseline = \"alphabetic\";\n\t *\n\t * CreateJS Text supports web fonts (the same rules as Canvas). The font must be loaded and supported by the browser\n\t * before it can be displayed.\n\t *\n\t * <strong>Note:</strong> Text can be expensive to generate, so cache instances where possible. Be aware that not all\n\t * browsers will render Text exactly the same.\n\t * @class Text\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {String} [text] The text to display.\n\t * @param {String} [font] The font style to use. Any valid value for the CSS font attribute is acceptable (ex. \"bold\n\t * 36px Arial\").\n\t * @param {String} [color] The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex.\n\t * \"#F00\", \"red\", or \"#FF0000\").\n\t **/\n\tfunction Text(text, font, color) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The text to display.\n\t\t * @property text\n\t\t * @type String\n\t\t **/\n\t\tthis.text = text;\n\t\n\t\t/**\n\t\t * The font style to use. Any valid value for the CSS font attribute is acceptable (ex. \"bold 36px Arial\").\n\t\t * @property font\n\t\t * @type String\n\t\t **/\n\t\tthis.font = font;\n\t\n\t\t/**\n\t\t * The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex. \"#F00\"). Default is \"#000\".\n\t\t * It will also accept valid canvas fillStyle values.\n\t\t * @property color\n\t\t * @type String\n\t\t **/\n\t\tthis.color = color;\n\t\n\t\t/**\n\t\t * The horizontal text alignment. Any of \"start\", \"end\", \"left\", \"right\", and \"center\". For detailed\n\t\t * information view the\n\t\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles\">\n\t\t * whatwg spec</a>. Default is \"left\".\n\t\t * @property textAlign\n\t\t * @type String\n\t\t **/\n\t\tthis.textAlign = \"left\";\n\t\n\t\t/**\n\t\t * The vertical alignment point on the font. Any of \"top\", \"hanging\", \"middle\", \"alphabetic\", \"ideographic\", or\n\t\t * \"bottom\". For detailed information view the <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles\">\n\t\t * whatwg spec</a>. Default is \"top\".\n\t\t * @property textBaseline\n\t\t * @type String\n\t\t*/\n\t\tthis.textBaseline = \"top\";\n\t\n\t\t/**\n\t\t * The maximum width to draw the text. If maxWidth is specified (not null), the text will be condensed or\n\t\t * shrunk to make it fit in this width. For detailed information view the\n\t\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles\">\n\t\t * whatwg spec</a>.\n\t\t * @property maxWidth\n\t\t * @type Number\n\t\t*/\n\t\tthis.maxWidth = null;\n\t\n\t\t/**\n\t\t * If greater than 0, the text will be drawn as a stroke (outline) of the specified width.\n\t\t * @property outline\n\t\t * @type Number\n\t\t **/\n\t\tthis.outline = 0;\n\t\n\t\t/**\n\t\t * Indicates the line height (vertical distance between baselines) for multi-line text. If null or 0,\n\t\t * the value of getMeasuredLineHeight is used.\n\t\t * @property lineHeight\n\t\t * @type Number\n\t\t **/\n\t\tthis.lineHeight = 0;\n\t\n\t\t/**\n\t\t * Indicates the maximum width for a line of text before it is wrapped to multiple lines. If null,\n\t\t * the text will not be wrapped.\n\t\t * @property lineWidth\n\t\t * @type Number\n\t\t **/\n\t\tthis.lineWidth = null;\n\t}\n\tvar p = createjs.extend(Text, createjs.DisplayObject);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\t\n// static properties:\n\t/**\n\t * @property _workingContext\n\t * @type CanvasRenderingContext2D\n\t * @private\n\t **/\n\tvar canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"));\n\tif (canvas.getContext) { Text._workingContext = canvas.getContext(\"2d\"); canvas.width = canvas.height = 1; }\n\t\n\t\n// constants:\n\t/**\n\t * Lookup table for the ratio to offset bounds x calculations based on the textAlign property.\n\t * @property H_OFFSETS\n\t * @type Object\n\t * @protected\n\t * @static\n\t **/\n\tText.H_OFFSETS = {start: 0, left: 0, center: -0.5, end: -1, right: -1};\n\t\n\t/**\n\t * Lookup table for the ratio to offset bounds y calculations based on the textBaseline property.\n\t * @property H_OFFSETS\n\t * @type Object\n\t * @protected\n\t * @static\n\t **/\n\tText.V_OFFSETS = {top: 0, hanging: -0.01, middle: -0.4, alphabetic: -0.8, ideographic: -0.85, bottom: -1};\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || (this.text != null && this.text !== \"\");\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the Text into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\n\t\tvar col = this.color || \"#000\";\n\t\tif (this.outline) { ctx.strokeStyle = col; ctx.lineWidth = this.outline*1; }\n\t\telse { ctx.fillStyle = col; }\n\t\t\n\t\tthis._drawText(this._prepContext(ctx));\n\t\treturn true;\n\t};\n\n\t/**\n\t * Returns the measured, untransformed width of the text without wrapping. Use getBounds for a more robust value.\n\t * @method getMeasuredWidth\n\t * @return {Number} The measured, untransformed width of the text.\n\t **/\n\tp.getMeasuredWidth = function() {\n\t\treturn this._getMeasuredWidth(this.text);\n\t};\n\n\t/**\n\t * Returns an approximate line height of the text, ignoring the lineHeight property. This is based on the measured\n\t * width of a \"M\" character multiplied by 1.2, which provides an approximate line height for most fonts.\n\t * @method getMeasuredLineHeight\n\t * @return {Number} an approximate line height of the text, ignoring the lineHeight property. This is\n\t * based on the measured width of a \"M\" character multiplied by 1.2, which approximates em for most fonts.\n\t **/\n\tp.getMeasuredLineHeight = function() {\n\t\treturn this._getMeasuredWidth(\"M\")*1.2;\n\t};\n\n\t/**\n\t * Returns the approximate height of multi-line text by multiplying the number of lines against either the\n\t * <code>lineHeight</code> (if specified) or {{#crossLink \"Text/getMeasuredLineHeight\"}}{{/crossLink}}. Note that\n\t * this operation requires the text flowing logic to run, which has an associated CPU cost.\n\t * @method getMeasuredHeight\n\t * @return {Number} The approximate height of the untransformed multi-line text.\n\t **/\n\tp.getMeasuredHeight = function() {\n\t\treturn this._drawText(null,{}).height;\n\t};\n\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getBounds = function() {\n\t\tvar rect = this.DisplayObject_getBounds();\n\t\tif (rect) { return rect; }\n\t\tif (this.text == null || this.text === \"\") { return null; }\n\t\tvar o = this._drawText(null, {});\n\t\tvar w = (this.maxWidth && this.maxWidth < o.width) ? this.maxWidth : o.width;\n\t\tvar x = w * Text.H_OFFSETS[this.textAlign||\"left\"];\n\t\tvar lineHeight = this.lineHeight||this.getMeasuredLineHeight();\n\t\tvar y = lineHeight * Text.V_OFFSETS[this.textBaseline||\"top\"];\n\t\treturn this._rectangle.setValues(x, y, w, o.height);\n\t};\n\t\n\t/**\n\t * Returns an object with width, height, and lines properties. The width and height are the visual width and height\n\t * of the drawn text. The lines property contains an array of strings, one for\n\t * each line of text that will be drawn, accounting for line breaks and wrapping. These strings have trailing\n\t * whitespace removed.\n\t * @method getMetrics\n\t * @return {Object} An object with width, height, and lines properties.\n\t **/\n\tp.getMetrics = function() {\n\t\tvar o = {lines:[]};\n\t\to.lineHeight = this.lineHeight || this.getMeasuredLineHeight();\n\t\to.vOffset = o.lineHeight * Text.V_OFFSETS[this.textBaseline||\"top\"];\n\t\treturn this._drawText(null, o, o.lines);\n\t};\n\n\t/**\n\t * Returns a clone of the Text instance.\n\t * @method clone\n\t * @return {Text} a clone of the Text instance.\n\t **/\n\tp.clone = function() {\n\t\treturn this._cloneProps(new Text(this.text, this.font, this.color));\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Text (text=\"+  (this.text.length > 20 ? this.text.substr(0, 17)+\"...\" : this.text) +\")]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _cloneProps\n\t * @param {Text} o\n\t * @protected\n\t * @return {Text} o\n\t **/\n\tp._cloneProps = function(o) {\n\t\tthis.DisplayObject__cloneProps(o);\n\t\to.textAlign = this.textAlign;\n\t\to.textBaseline = this.textBaseline;\n\t\to.maxWidth = this.maxWidth;\n\t\to.outline = this.outline;\n\t\to.lineHeight = this.lineHeight;\n\t\to.lineWidth = this.lineWidth;\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _getWorkingContext\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @return {CanvasRenderingContext2D}\n\t * @protected\n\t **/\n\tp._prepContext = function(ctx) {\n\t\tctx.font = this.font||\"10px sans-serif\";\n\t\tctx.textAlign = this.textAlign||\"left\";\n\t\tctx.textBaseline = this.textBaseline||\"top\";\n\t\treturn ctx;\n\t};\n\n\t/**\n\t * Draws multiline text.\n\t * @method _drawText\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {Object} o\n\t * @param {Array} lines\n\t * @return {Object}\n\t * @protected\n\t **/\n\tp._drawText = function(ctx, o, lines) {\n\t\tvar paint = !!ctx;\n\t\tif (!paint) {\n\t\t\tctx = Text._workingContext;\n\t\t\tctx.save();\n\t\t\tthis._prepContext(ctx);\n\t\t}\n\t\tvar lineHeight = this.lineHeight||this.getMeasuredLineHeight();\n\t\t\n\t\tvar maxW = 0, count = 0;\n\t\tvar hardLines = String(this.text).split(/(?:\\r\\n|\\r|\\n)/);\n\t\tfor (var i=0, l=hardLines.length; i<l; i++) {\n\t\t\tvar str = hardLines[i];\n\t\t\tvar w = null;\n\t\t\t\n\t\t\tif (this.lineWidth != null && (w = ctx.measureText(str).width) > this.lineWidth) {\n\t\t\t\t// text wrapping:\n\t\t\t\tvar words = str.split(/(\\s)/);\n\t\t\t\tstr = words[0];\n\t\t\t\tw = ctx.measureText(str).width;\n\t\t\t\t\n\t\t\t\tfor (var j=1, jl=words.length; j<jl; j+=2) {\n\t\t\t\t\t// Line needs to wrap:\n\t\t\t\t\tvar wordW = ctx.measureText(words[j] + words[j+1]).width;\n\t\t\t\t\tif (w + wordW > this.lineWidth) {\n\t\t\t\t\t\tif (paint) { this._drawTextLine(ctx, str, count*lineHeight); }\n\t\t\t\t\t\tif (lines) { lines.push(str); }\n\t\t\t\t\t\tif (w > maxW) { maxW = w; }\n\t\t\t\t\t\tstr = words[j+1];\n\t\t\t\t\t\tw = ctx.measureText(str).width;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr += words[j] + words[j+1];\n\t\t\t\t\t\tw += wordW;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (paint) { this._drawTextLine(ctx, str, count*lineHeight); }\n\t\t\tif (lines) { lines.push(str); }\n\t\t\tif (o && w == null) { w = ctx.measureText(str).width; }\n\t\t\tif (w > maxW) { maxW = w; }\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tif (o) {\n\t\t\to.width = maxW;\n\t\t\to.height = count*lineHeight;\n\t\t}\n\t\tif (!paint) { ctx.restore(); }\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _drawTextLine\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {String} text\n\t * @param {Number} y\n\t * @protected\n\t **/\n\tp._drawTextLine = function(ctx, text, y) {\n\t\t// Chrome 17 will fail to draw the text if the last param is included but null, so we feed it a large value instead:\n\t\tif (this.outline) { ctx.strokeText(text, 0, y, this.maxWidth||0xFFFF); }\n\t\telse { ctx.fillText(text, 0, y, this.maxWidth||0xFFFF); }\n\t};\n\t\n\t\n\t/**\n\t * @method _getMeasuredWidth\n\t * @param {String} text\n\t * @protected\n\t **/\n\tp._getMeasuredWidth = function(text) {\n\t\tvar ctx = Text._workingContext;\n\t\tctx.save();\n\t\tvar w = this._prepContext(ctx).measureText(text).width;\n\t\tctx.restore();\n\t\treturn w;\n\t};\n\n\n\tcreatejs.Text = createjs.promote(Text, \"DisplayObject\");\n}());\n\n//##############################################################################\n// BitmapText.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Displays text using bitmap glyphs defined in a sprite sheet. Multi-line text is supported\n\t * using new line characters, but automatic wrapping is not supported. See the \n\t * {{#crossLink \"BitmapText/spriteSheet:property\"}}{{/crossLink}}\n\t * property for more information on defining glyphs.\n\t * \n\t * <strong>Important:</strong> BitmapText extends Container, but is not designed to be used as one.\n\t * As such, methods like addChild and removeChild are disabled.\n\t * @class BitmapText\n\t * @extends DisplayObject\n\t * @param {String} [text=\"\"] The text to display.\n\t * @param {SpriteSheet} [spriteSheet=null] The spritesheet that defines the character glyphs.\n\t * @constructor\n\t **/\n\tfunction BitmapText(text, spriteSheet) {\n\t\tthis.Container_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The text to display.\n\t\t * @property text\n\t\t * @type String\n\t\t * @default \"\"\n\t\t **/\n\t\tthis.text = text||\"\";\n\t\t\n\t\t/**\n\t\t * A SpriteSheet instance that defines the glyphs for this bitmap text. Each glyph/character\n\t\t * should have a single frame animation defined in the sprite sheet named the same as\n\t\t * corresponding character. For example, the following animation definition:\n\t\t *\n\t\t * \t\t\"A\": {frames: [0]}\n\t\t *\n\t\t * would indicate that the frame at index 0 of the spritesheet should be drawn for the \"A\" character. The short form\n\t\t * is also acceptable:\n\t\t * \n\t\t * \t\t\"A\": 0\n\t\t *\n\t\t * Note that if a character in the text is not found in the sprite sheet, it will also\n\t\t * try to use the alternate case (upper or lower).\n\t\t *\n\t\t * See SpriteSheet for more information on defining sprite sheet data.\n\t\t * @property spriteSheet\n\t\t * @type SpriteSheet\n\t\t * @default null\n\t\t **/\n\t\tthis.spriteSheet = spriteSheet;\n\t\n\t\t/**\n\t\t * The height of each line of text. If 0, then it will use a line height calculated\n\t\t * by checking for the height of the \"1\", \"T\", or \"L\" character (in that order). If\n\t\t * those characters are not defined, it will use the height of the first frame of the\n\t\t * sprite sheet.\n\t\t * @property lineHeight\n\t\t * @type Number\n\t\t * @default 0\n\t\t **/\n\t\tthis.lineHeight = 0;\n\t\n\t\t/**\n\t\t * This spacing (in pixels) will be added after each character in the output.\n\t\t * @property letterSpacing\n\t\t * @type Number\n\t\t * @default 0\n\t\t **/\n\t\tthis.letterSpacing = 0;\n\t\n\t\t/**\n\t\t * If a space character is not defined in the sprite sheet, then empty pixels equal to\n\t\t * spaceWidth will be inserted instead. If 0, then it will use a value calculated\n\t\t * by checking for the width of the \"1\", \"l\", \"E\", or \"A\" character (in that order). If\n\t\t * those characters are not defined, it will use the width of the first frame of the\n\t\t * sprite sheet.\n\t\t * @property spaceWidth\n\t\t * @type Number\n\t\t * @default 0\n\t\t **/\n\t\tthis.spaceWidth = 0;\n\t\t\n\t\t\n\t// private properties:\n\t \t/**\n\t\t * @property _oldProps\n\t\t * @type Object\n\t\t * @protected\n\t\t **/\n\t\tthis._oldProps = {text:0,spriteSheet:0,lineHeight:0,letterSpacing:0,spaceWidth:0};\n\t}\n\tvar p = createjs.extend(BitmapText, createjs.Container);\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n// static properties:\n\t/**\n\t * BitmapText uses Sprite instances to draw text. To reduce the creation and destruction of instances (and thus garbage collection), it maintains\n\t * an internal object pool of sprite instances to reuse. Increasing this value can cause more sprites to be\n\t * retained, slightly increasing memory use, but reducing instantiation.\n\t * @property maxPoolSize\n\t * @type Number\n\t * @static\n\t * @default 100\n\t **/\n\tBitmapText.maxPoolSize = 100;\n\t\n\t/**\n\t * Sprite object pool.\n\t * @type {Array}\n\t * @static\n\t * @private\n\t */\n\tBitmapText._spritePool = [];\n\n\t\n// public methods:\n\t/**\n\t * Docced in superclass.\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return; }\n\t\tthis._updateText();\n\t\tthis.Container_draw(ctx, ignoreCache);\n\t};\n\t\n\t/**\n\t * Docced in superclass.\n\t **/\n\tp.getBounds = function() {\n\t\tthis._updateText();\n\t\treturn this.Container_getBounds();\n\t};\n\t\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || (this.spriteSheet && this.spriteSheet.complete && this.text);\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX !== 0 && this.scaleY !== 0 && hasContent);\n\t};\n\t\n\tp.clone = function() {\n\t\treturn this._cloneProps(new BitmapText(this.text, this.spriteSheet));\n\t};\n\t\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method addChild\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method addChildAt\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method removeChild\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method removeChildAt\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method removeAllChildren\n\t **/\n\tp.addChild = p.addChildAt = p.removeChild = p.removeChildAt = p.removeAllChildren = function() {};\n\n\n// private methods:\n \t/**\n\t * @method _cloneProps\n\t * @param {BitmapText} o\n\t * @return {BitmapText} o\n\t * @protected\n\t **/\n\tp._cloneProps = function(o) {\n\t\tthis.Container__cloneProps(o);\n\t\to.lineHeight = this.lineHeight;\n\t\to.letterSpacing = this.letterSpacing;\n\t\to.spaceWidth = this.spaceWidth;\n\t\treturn o;\n\t};\n\t\n\t/**\n\t * @method _getFrameIndex\n\t * @param {String} character\n\t * @param {SpriteSheet} spriteSheet\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._getFrameIndex = function(character, spriteSheet) {\n\t\tvar c, o = spriteSheet.getAnimation(character);\n\t\tif (!o) {\n\t\t\t(character != (c = character.toUpperCase())) || (character != (c = character.toLowerCase())) || (c=null);\n\t\t\tif (c) { o = spriteSheet.getAnimation(c); }\n\t\t}\n\t\treturn o && o.frames[0];\n\t};\n\t\n\t/**\n\t * @method _getFrame\n\t * @param {String} character\n\t * @param {SpriteSheet} spriteSheet\n\t * @return {Object}\n\t * @protected\n\t **/\n\tp._getFrame = function(character, spriteSheet) {\n\t\tvar index = this._getFrameIndex(character, spriteSheet);\n\t\treturn index == null ? index : spriteSheet.getFrame(index);\n\t};\n\t\n\t/**\n\t * @method _getLineHeight\n\t * @param {SpriteSheet} ss\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._getLineHeight = function(ss) {\n\t\tvar frame = this._getFrame(\"1\",ss) || this._getFrame(\"T\",ss) || this._getFrame(\"L\",ss) || ss.getFrame(0);\n\t\treturn frame ? frame.rect.height : 1;\n\t};\n\t/**\n\t * @method _getSpaceWidth\n\t * @param {SpriteSheet} ss\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._getSpaceWidth = function(ss) {\n\t\tvar frame = this._getFrame(\"1\",ss) || this._getFrame(\"l\",ss) || this._getFrame(\"e\",ss) || this._getFrame(\"a\",ss) || ss.getFrame(0);\n\t\treturn frame ? frame.rect.width : 1;\n\t};\n\t\n\t/**\n\t * @method _drawText\n\t * @protected\n\t **/\n\tp._updateText = function() {\n\t\tvar x=0, y=0, o=this._oldProps, change=false, spaceW=this.spaceWidth, lineH=this.lineHeight, ss=this.spriteSheet;\n\t\tvar pool=BitmapText._spritePool, kids=this.children, childIndex=0, numKids=kids.length, sprite;\n\t\t\n\t\tfor (var n in o) {\n\t\t\tif (o[n] != this[n]) {\n\t\t\t\to[n] = this[n];\n\t\t\t\tchange = true;\n\t\t\t}\n\t\t}\n\t\tif (!change) { return; }\n\t\t\n\t\tvar hasSpace = !!this._getFrame(\" \", ss);\n\t\tif (!hasSpace && !spaceW) { spaceW = this._getSpaceWidth(ss); }\n\t\tif (!lineH) { lineH = this._getLineHeight(ss); }\n\t\t\n\t\tfor(var i=0, l=this.text.length; i<l; i++) {\n\t\t\tvar character = this.text.charAt(i);\n\t\t\tif (character == \" \" && !hasSpace) {\n\t\t\t\tx += spaceW;\n\t\t\t\tcontinue;\n\t\t\t} else if (character==\"\\n\" || character==\"\\r\") {\n\t\t\t\tif (character==\"\\r\" && this.text.charAt(i+1) == \"\\n\") { i++; } // crlf\n\t\t\t\tx = 0;\n\t\t\t\ty += lineH;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar index = this._getFrameIndex(character, ss);\n\t\t\tif (index == null) { continue; }\n\t\t\t\n\t\t\tif (childIndex < numKids) {\n\t\t\t\tsprite = kids[childIndex];\n\t\t\t} else {\n\t\t\t\tkids.push(sprite = pool.length ? pool.pop() : new createjs.Sprite());\n\t\t\t\tsprite.parent = this;\n\t\t\t\tnumKids++;\n\t\t\t}\n\t\t\tsprite.spriteSheet = ss;\n\t\t\tsprite.gotoAndStop(index);\n\t\t\tsprite.x = x;\n\t\t\tsprite.y = y;\n\t\t\tchildIndex++;\n\t\t\t\n\t\t\tx += sprite.getBounds().width + this.letterSpacing;\n\t\t}\n\t\twhile (numKids > childIndex) {\n\t\t\t // faster than removeChild.\n\t\t\tpool.push(sprite = kids.pop());\n\t\t\tsprite.parent = null;\n\t\t\tnumKids--;\n\t\t}\n\t\tif (pool.length > BitmapText.maxPoolSize) { pool.length = BitmapText.maxPoolSize; }\n\t};\n\n\n\tcreatejs.BitmapText = createjs.promote(BitmapText, \"Container\");\n}());\n\n//##############################################################################\n// MovieClip.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The MovieClip class associates a TweenJS Timeline with an EaselJS {{#crossLink \"Container\"}}{{/crossLink}}. It allows\n\t * you to create objects which encapsulate timeline animations, state changes, and synched actions. Due to the\n\t * complexities inherent in correctly setting up a MovieClip, it is largely intended for tool output and is not included\n\t * in the main EaselJS library.\n\t *\n\t * Currently MovieClip only works properly if it is tick based (as opposed to time based) though some concessions have\n\t * been made to support time-based timelines in the future.\n\t *\n\t * <h4>Example</h4>\n\t * This example animates two shapes back and forth. The grey shape starts on the left, but we jump to a mid-point in\n\t * the animation using {{#crossLink \"MovieClip/gotoAndPlay\"}}{{/crossLink}}.\n\t *\n\t *      var stage = new createjs.Stage(\"canvas\");\n\t *      createjs.Ticker.addEventListener(\"tick\", stage);\n\t *\n\t *      var mc = new createjs.MovieClip(null, 0, true, {start:20});\n\t *      stage.addChild(mc);\n\t *\n\t *      var child1 = new createjs.Shape(\n\t *          new createjs.Graphics().beginFill(\"#999999\")\n\t *              .drawCircle(30,30,30));\n\t *      var child2 = new createjs.Shape(\n\t *          new createjs.Graphics().beginFill(\"#5a9cfb\")\n\t *              .drawCircle(30,30,30));\n\t *\n\t *      mc.timeline.addTween(\n\t *          createjs.Tween.get(child1)\n\t *              .to({x:0}).to({x:60}, 50).to({x:0}, 50));\n\t *      mc.timeline.addTween(\n\t *          createjs.Tween.get(child2)\n\t *              .to({x:60}).to({x:0}, 50).to({x:60}, 50));\n\t *\n\t *      mc.gotoAndPlay(\"start\");\n\t *\n\t * It is recommended to use <code>tween.to()</code> to animate and set properties (use no duration to have it set\n\t * immediately), and the <code>tween.wait()</code> method to create delays between animations. Note that using the\n\t * <code>tween.set()</code> method to affect properties will likely not provide the desired result.\n\t *\n\t * @class MovieClip\n\t * @main MovieClip\n\t * @extends Container\n\t * @constructor\n\t * @param {String} [mode=independent] Initial value for the mode property. One of {{#crossLink \"MovieClip/INDEPENDENT:property\"}}{{/crossLink}},\n\t * {{#crossLink \"MovieClip/SINGLE_FRAME:property\"}}{{/crossLink}}, or {{#crossLink \"MovieClip/SYNCHED:property\"}}{{/crossLink}}.\n\t * The default is {{#crossLink \"MovieClip/INDEPENDENT:property\"}}{{/crossLink}}.\n\t * @param {Number} [startPosition=0] Initial value for the {{#crossLink \"MovieClip/startPosition:property\"}}{{/crossLink}}\n\t * property.\n\t * @param {Boolean} [loop=true] Initial value for the {{#crossLink \"MovieClip/loop:property\"}}{{/crossLink}}\n\t * property. The default is `true`.\n\t * @param {Object} [labels=null] A hash of labels to pass to the {{#crossLink \"MovieClip/timeline:property\"}}{{/crossLink}}\n\t * instance associated with this MovieClip. Labels only need to be passed if they need to be used.\n\t **/\n\tfunction MovieClip(mode, startPosition, loop, labels) {\n\t\tthis.Container_constructor();\n\t\t!MovieClip.inited&&MovieClip.init(); // static init\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * Controls how this MovieClip advances its time. Must be one of 0 (INDEPENDENT), 1 (SINGLE_FRAME), or 2 (SYNCHED).\n\t\t * See each constant for a description of the behaviour.\n\t\t * @property mode\n\t\t * @type String\n\t\t * @default null\n\t\t **/\n\t\tthis.mode = mode||MovieClip.INDEPENDENT;\n\t\n\t\t/**\n\t\t * Specifies what the first frame to play in this movieclip, or the only frame to display if mode is SINGLE_FRAME.\n\t\t * @property startPosition\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.startPosition = startPosition || 0;\n\t\n\t\t/**\n\t\t * Indicates whether this MovieClip should loop when it reaches the end of its timeline.\n\t\t * @property loop\n\t\t * @type Boolean\n\t\t * @default true\n\t\t */\n\t\tthis.loop = loop;\n\t\n\t\t/**\n\t\t * The current frame of the movieclip.\n\t\t * @property currentFrame\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.currentFrame = 0;\n\t\n\t\t/**\n\t\t * The TweenJS Timeline that is associated with this MovieClip. This is created automatically when the MovieClip\n\t\t * instance is initialized. Animations are created by adding <a href=\"http://tweenjs.com\">TweenJS</a> Tween\n\t\t * instances to the timeline.\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *      var tween = createjs.Tween.get(target).to({x:0}).to({x:100}, 30);\n\t\t *      var mc = new createjs.MovieClip();\n\t\t *      mc.timeline.addTween(tween);\n\t\t *\n\t\t * Elements can be added and removed from the timeline by toggling an \"_off\" property\n\t\t * using the <code>tweenInstance.to()</code> method. Note that using <code>Tween.set</code> is not recommended to\n\t\t * create MovieClip animations. The following example will toggle the target off on frame 0, and then back on for\n\t\t * frame 1. You can use the \"visible\" property to achieve the same effect.\n\t\t *\n\t\t *      var tween = createjs.Tween.get(target).to({_off:false})\n\t\t *          .wait(1).to({_off:true})\n\t\t *          .wait(1).to({_off:false});\n\t\t *\n\t\t * @property timeline\n\t\t * @type Timeline\n\t\t * @default null\n\t\t */\n\t\tthis.timeline = new createjs.Timeline(null, labels, {paused:true, position:startPosition, useTicks:true});\n\t\n\t\t/**\n\t\t * If true, the MovieClip's position will not advance when ticked.\n\t\t * @property paused\n\t\t * @type Boolean\n\t\t * @default false\n\t\t */\n\t\tthis.paused = false;\n\t\n\t\t/**\n\t\t * If true, actions in this MovieClip's tweens will be run when the playhead advances.\n\t\t * @property actionsEnabled\n\t\t * @type Boolean\n\t\t * @default true\n\t\t */\n\t\tthis.actionsEnabled = true;\n\t\n\t\t/**\n\t\t * If true, the MovieClip will automatically be reset to its first frame whenever the timeline adds\n\t\t * it back onto the display list. This only applies to MovieClip instances with mode=INDEPENDENT.\n\t\t * <br><br>\n\t\t * For example, if you had a character animation with a \"body\" child MovieClip instance\n\t\t * with different costumes on each frame, you could set body.autoReset = false, so that\n\t\t * you can manually change the frame it is on, without worrying that it will be reset\n\t\t * automatically.\n\t\t * @property autoReset\n\t\t * @type Boolean\n\t\t * @default true\n\t\t */\n\t\tthis.autoReset = true;\n\t\t\n\t\t/**\n\t\t * An array of bounds for each frame in the MovieClip. This is mainly intended for tool output.\n\t\t * @property frameBounds\n\t\t * @type Array\n\t\t * @default null\n\t\t */\n\t\tthis.frameBounds = this.frameBounds||null; // TODO: Deprecated. This is for backwards support of FlashCC\n\t\t\n\t\t/**\n\t\t * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\n\t\t * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n\t\t * framerate.\n\t\t *\n\t\t * For example, if a MovieClip with a framerate of 10 is placed on a Stage being updated at 40fps, then the MovieClip will\n\t\t * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\n\t\t * vary slightly between frames.\n\t\t *\n\t\t * This feature is dependent on the tick event object (or an object with an appropriate \"delta\" property) being\n\t\t * passed into {{#crossLink \"Stage/update\"}}{{/crossLink}}.\n\t\t * @property framerate\n\t\t * @type {Number}\n\t\t * @default null\n\t\t **/\n\t\tthis.framerate = null;\n\t\t\n\t\t\n\t// private properties:\n\t\t/**\n\t\t * @property _synchOffset\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._synchOffset = 0;\n\t\n\t\t/**\n\t\t * @property _prevPos\n\t\t * @type Number\n\t\t * @default -1\n\t\t * @private\n\t\t */\n\t\tthis._prevPos = -1; // TODO: evaluate using a ._reset Boolean prop instead of -1.\n\t\n\t\t/**\n\t\t * @property _prevPosition\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._prevPosition = 0;\n\t\n\t\t/**\n\t\t * The time remaining from the previous tick, only applicable when .framerate is set.\n\t\t * @property _t\n\t\t * @type Number\n\t\t * @private\n\t\t */\n\t\tthis._t = 0;\n\t\n\t\t/**\n\t\t * List of display objects that are actively being managed by the MovieClip.\n\t\t * @property _managed\n\t\t * @type Object\n\t\t * @private\n\t\t */\n\t\tthis._managed = {};\n\t}\n\tvar p = createjs.extend(MovieClip, createjs.Container);\n\n\n// constants:\n\t/**\n\t * The MovieClip will advance independently of its parent, even if its parent is paused.\n\t * This is the default mode.\n\t * @property INDEPENDENT\n\t * @static\n\t * @type String\n\t * @default \"independent\"\n\t * @readonly\n\t **/\n\tMovieClip.INDEPENDENT = \"independent\";\n\n\t/**\n\t * The MovieClip will only display a single frame (as determined by the startPosition property).\n\t * @property SINGLE_FRAME\n\t * @static\n\t * @type String\n\t * @default \"single\"\n\t * @readonly\n\t **/\n\tMovieClip.SINGLE_FRAME = \"single\";\n\n\t/**\n\t * The MovieClip will be advanced only when its parent advances and will be synched to the position of\n\t * the parent MovieClip.\n\t * @property SYNCHED\n\t * @static\n\t * @type String\n\t * @default \"synched\"\n\t * @readonly\n\t **/\n\tMovieClip.SYNCHED = \"synched\";\n\t\n\t\n// static properties:\n\tMovieClip.inited = false;\n\t\n\t\n// static methods:\n\tMovieClip.init = function() {\n\t\tif (MovieClip.inited) { return; }\n\t\t// plugins introduce some overhead to Tween, so we only install this if an MC is instantiated.\n\t\tMovieClipPlugin.install();\n\t\tMovieClip.inited = true;\n\t};\n\t\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"MovieClip/labels:property\"}}{{/crossLink}} property instead.\n\t * @method getLabels\n\t * @return {Array}\n\t * @deprecated\n\t **/\n\tp.getLabels = function() {\n\t\treturn this.timeline.getLabels();\n\t};\n\t\n\t/**\n\t * Use the {{#crossLink \"MovieClip/currentLabel:property\"}}{{/crossLink}} property instead.\n\t * @method getCurrentLabel\n\t * @return {String}\n\t * @deprecated\n\t **/\n\tp.getCurrentLabel = function() {\n\t\tthis._updateTimeline();\n\t\treturn this.timeline.getCurrentLabel();\n\t};\n\t\n\t/**\n\t * Use the {{#crossLink \"MovieClip/duration:property\"}}{{/crossLink}} property instead.\n\t * @method getDuration\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp.getDuration = function() {\n\t\treturn this.timeline.duration;\n\t};\n\n\t/**\n\t * Returns an array of objects with label and position (aka frame) properties, sorted by position.\n\t * Shortcut to TweenJS: Timeline.getLabels();\n\t * @property labels\n\t * @type {Array}\n\t * @readonly\n\t **/\n\t\n\t/**\n\t * Returns the name of the label on or immediately before the current frame. See TweenJS: Timeline.getCurrentLabel()\n\t * for more information.\n\t * @property currentLabel\n\t * @type {String}\n\t * @readonly\n\t **/\n\t\n\t/**\n\t * Returns the duration of this MovieClip in seconds or ticks. Identical to {{#crossLink \"MovieClip/duration:property\"}}{{/crossLink}}\n\t * and provided for Flash API compatibility.\n\t * @property totalFrames\n\t * @type {Number}\n\t * @readonly\n\t **/\n\t\n\t/**\n\t * Returns the duration of this MovieClip in seconds or ticks.\n\t * @property duration\n\t * @type {Number}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tlabels: { get: p.getLabels },\n\t\t\tcurrentLabel: { get: p.getCurrentLabel },\n\t\t\ttotalFrames: { get: p.getDuration },\n\t\t\tduration: { get: p.getDuration }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink \"Utility Methods/extends\"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = MovieClip; // TODO: Deprecated. This is for backwards support of FlashCC\n\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\t// children are placed in draw, so we can't determine if we have content.\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\t// draw to cache first:\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\tthis._updateTimeline();\n\t\tthis.Container_draw(ctx, ignoreCache);\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * Sets paused to false.\n\t * @method play\n\t **/\n\tp.play = function() {\n\t\tthis.paused = false;\n\t};\n\t\n\t/**\n\t * Sets paused to true.\n\t * @method stop\n\t **/\n\tp.stop = function() {\n\t\tthis.paused = true;\n\t};\n\t\n\t/**\n\t * Advances this movie clip to the specified position or label and sets paused to false.\n\t * @method gotoAndPlay\n\t * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n\t **/\n\tp.gotoAndPlay = function(positionOrLabel) {\n\t\tthis.paused = false;\n\t\tthis._goto(positionOrLabel);\n\t};\n\t\n\t/**\n\t * Advances this movie clip to the specified position or label and sets paused to true.\n\t * @method gotoAndStop\n\t * @param {String|Number} positionOrLabel The animation or frame name to go to.\n\t **/\n\tp.gotoAndStop = function(positionOrLabel) {\n\t\tthis.paused = true;\n\t\tthis._goto(positionOrLabel);\n\t};\n\t\n\t/**\n\t * Advances the playhead. This occurs automatically each tick by default.\n\t * @param [time] {Number} The amount of time in ms to advance by. Only applicable if framerate is set.\n\t * @method advance\n\t*/\n\tp.advance = function(time) {\n\t\t// TODO: should we worry at all about clips who change their own modes via frame scripts?\n\t\tvar independent = MovieClip.INDEPENDENT;\n\t\tif (this.mode != independent) { return; }\n\t\t\n\t\tvar o=this, fps = o.framerate;\n\t\twhile ((o = o.parent) && fps == null) {\n\t\t\tif (o.mode == independent) { fps = o._framerate; }\n\t\t}\n\t\tthis._framerate = fps;\n\t\t\n\t\tvar t = (fps != null && fps != -1 && time != null) ? time/(1000/fps) + this._t : 1;\n\t\tvar frames = t|0;\n\t\tthis._t = t-frames; // leftover time\n\t\t\n\t\twhile (!this.paused && frames--) {\n\t\t\tthis._prevPosition = (this._prevPos < 0) ? 0 : this._prevPosition+1;\n\t\t\tthis._updateTimeline();\n\t\t}\n\t};\n\t\n\t/**\n\t * MovieClip instances cannot be cloned.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\t// TODO: add support for this? Need to clone the Timeline & retarget tweens - pretty complex.\n\t\tthrow(\"MovieClip cannot be cloned.\")\n\t};\n\t\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[MovieClip (name=\"+  this.name +\")]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * function.\n\t * @protected\n\t **/\n\tp._tick = function(evtObj) {\n\t\tthis.advance(evtObj&&evtObj.delta);\n\t\tthis.Container__tick(evtObj);\n\t};\n\t\n\t/**\n\t * @method _goto\n\t * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n\t * @protected\n\t **/\n\tp._goto = function(positionOrLabel) {\n\t\tvar pos = this.timeline.resolve(positionOrLabel);\n\t\tif (pos == null) { return; }\n\t\t// prevent _updateTimeline from overwriting the new position because of a reset:\n\t\tif (this._prevPos == -1) { this._prevPos = NaN; }\n\t\tthis._prevPosition = pos;\n\t\tthis._t = 0;\n\t\tthis._updateTimeline();\n\t};\n\t\n\t/**\n\t * @method _reset\n\t * @private\n\t **/\n\tp._reset = function() {\n\t\tthis._prevPos = -1;\n\t\tthis._t = this.currentFrame = 0;\n\t\tthis.paused = false;\n\t};\n\t\n\t/**\n\t * @method _updateTimeline\n\t * @protected\n\t **/\n\tp._updateTimeline = function() {\n\t\tvar tl = this.timeline;\n\t\tvar synched = this.mode != MovieClip.INDEPENDENT;\n\t\ttl.loop = (this.loop==null) ? true : this.loop;\n\t\t\n\t\tvar pos = synched ? this.startPosition + (this.mode==MovieClip.SINGLE_FRAME?0:this._synchOffset) : (this._prevPos < 0 ? 0 : this._prevPosition);\n\t\tvar mode = synched || !this.actionsEnabled ? createjs.Tween.NONE : null;\n\t\t\n\t\t// pre-assign currentFrame so it is available to frame scripts:\n\t\tthis.currentFrame = tl._calcPosition(pos);\n\t\t\n\t\t// update timeline position, ignoring actions if this is a graphic.\n\t\ttl.setPosition(pos, mode);\n\n\t\tthis._prevPosition = tl._prevPosition;\n\t\tif (this._prevPos == tl._prevPos) { return; }\n\t\tthis.currentFrame = this._prevPos = tl._prevPos;\n\n\t\tfor (var n in this._managed) { this._managed[n] = 1; }\n\n\t\tvar tweens = tl._tweens;\n\t\tfor (var i=0, l=tweens.length; i<l; i++) {\n\t\t\tvar tween = tweens[i];\n\t\t\tvar target = tween._target;\n\t\t\tif (target == this || tween.passive) { continue; } // TODO: this assumes actions tween has this as the target. Valid?\n\t\t\tvar offset = tween._stepPosition;\n\n\t\t\tif (target instanceof createjs.DisplayObject) {\n\t\t\t\t// motion tween.\n\t\t\t\tthis._addManagedChild(target, offset);\n\t\t\t} else {\n\t\t\t\t// state tween.\n\t\t\t\tthis._setState(target.state, offset);\n\t\t\t}\n\t\t}\n\n\t\tvar kids = this.children;\n\t\tfor (i=kids.length-1; i>=0; i--) {\n\t\t\tvar id = kids[i].id;\n\t\t\tif (this._managed[id] == 1) {\n\t\t\t\tthis.removeChildAt(i);\n\t\t\t\tdelete(this._managed[id]);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _setState\n\t * @param {Array} state\n\t * @param {Number} offset\n\t * @protected\n\t **/\n\tp._setState = function(state, offset) {\n\t\tif (!state) { return; }\n\t\tfor (var i=state.length-1;i>=0;i--) {\n\t\t\tvar o = state[i];\n\t\t\tvar target = o.t;\n\t\t\tvar props = o.p;\n\t\t\tfor (var n in props) { target[n] = props[n]; }\n\t\t\tthis._addManagedChild(target, offset);\n\t\t}\n\t};\n\n\t/**\n\t * Adds a child to the timeline, and sets it up as a managed child.\n\t * @method _addManagedChild\n\t * @param {MovieClip} child The child MovieClip to manage\n\t * @param {Number} offset\n\t * @private\n\t **/\n\tp._addManagedChild = function(child, offset) {\n\t\tif (child._off) { return; }\n\t\tthis.addChildAt(child,0);\n\n\t\tif (child instanceof MovieClip) {\n\t\t\tchild._synchOffset = offset;\n\t\t\t// TODO: this does not precisely match Flash. Flash loses track of the clip if it is renamed or removed from the timeline, which causes it to reset.\n\t\t\tif (child.mode == MovieClip.INDEPENDENT && child.autoReset && !this._managed[child.id]) { child._reset(); }\n\t\t}\n\t\tthis._managed[child.id] = 2;\n\t};\n\t\n\t/**\n\t * @method _getBounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getBounds = function(matrix, ignoreTransform) {\n\t\tvar bounds = this.DisplayObject_getBounds();\n\t\tif (!bounds) {\n\t\t\tthis._updateTimeline();\n\t\t\tif (this.frameBounds) { bounds = this._rectangle.copy(this.frameBounds[this.currentFrame]); }\n\t\t}\n\t\tif (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }\n\t\treturn this.Container__getBounds(matrix, ignoreTransform);\n\t};\n\n\n\tcreatejs.MovieClip = createjs.promote(MovieClip, \"Container\");\n\n\n\n// MovieClipPlugin for TweenJS:\n\t/**\n\t * This plugin works with <a href=\"http://tweenjs.com\" target=\"_blank\">TweenJS</a> to prevent the startPosition\n\t * property from tweening.\n\t * @private\n\t * @class MovieClipPlugin\n\t * @constructor\n\t **/\n\tfunction MovieClipPlugin() {\n\t\tthrow(\"MovieClipPlugin cannot be instantiated.\")\n\t}\n\t\n\t/**\n\t * @method priority\n\t * @private\n\t **/\n\tMovieClipPlugin.priority = 100; // very high priority, should run first\n\n\t/**\n\t * @method install\n\t * @private\n\t **/\n\tMovieClipPlugin.install = function() {\n\t\tcreatejs.Tween.installPlugin(MovieClipPlugin, [\"startPosition\"]);\n\t};\n\t\n\t/**\n\t * @method init\n\t * @param {Tween} tween\n\t * @param {String} prop\n\t * @param {String|Number|Boolean} value\n\t * @private\n\t **/\n\tMovieClipPlugin.init = function(tween, prop, value) {\n\t\treturn value;\n\t};\n\t\n\t/**\n\t * @method step\n\t * @private\n\t **/\n\tMovieClipPlugin.step = function() {\n\t\t// unused.\n\t};\n\n\t/**\n\t * @method tween\n\t * @param {Tween} tween\n\t * @param {String} prop\n\t * @param {String | Number | Boolean} value\n\t * @param {Array} startValues\n\t * @param {Array} endValues\n\t * @param {Number} ratio\n\t * @param {Object} wait\n\t * @param {Object} end\n\t * @return {*}\n\t */\n\tMovieClipPlugin.tween = function(tween, prop, value, startValues, endValues, ratio, wait, end) {\n\t\tif (!(tween.target instanceof MovieClip)) { return value; }\n\t\treturn (ratio == 1 ? endValues[prop] : startValues[prop]);\n\t};\n\n}());\n\n//##############################################################################\n// SpriteSheetUtils.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\t\n\t\n// constructor:\n\t/**\n\t * The SpriteSheetUtils class is a collection of static methods for working with {{#crossLink \"SpriteSheet\"}}{{/crossLink}}s.\n\t * A sprite sheet is a series of images (usually animation frames) combined into a single image on a regular grid. For\n\t * example, an animation consisting of 8 100x100 images could be combined into a 400x200 sprite sheet (4 frames across\n\t * by 2 high). The SpriteSheetUtils class uses a static interface and should not be instantiated.\n\t * @class SpriteSheetUtils\n\t * @static\n\t **/\n\tfunction SpriteSheetUtils() {\n\t\tthrow \"SpriteSheetUtils cannot be instantiated\";\n\t}\n\n\n// private static properties:\n\t/**\n\t * @property _workingCanvas\n\t * @static\n\t * @type HTMLCanvasElement | Object\n\t * @protected\n\t*/\n\t/**\n\t * @property _workingContext\n\t * @static\n\t * @type CanvasRenderingContext2D\n\t * @protected\n\t*/\n\tvar canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"));\n\tif (canvas.getContext) {\n\t\tSpriteSheetUtils._workingCanvas = canvas;\n\t\tSpriteSheetUtils._workingContext = canvas.getContext(\"2d\");\n\t\tcanvas.width = canvas.height = 1;\n\t}\n\n\n// public static methods:\n\t/**\n\t * <b>This is an experimental method, and may be buggy. Please report issues.</b><br/><br/>\n\t * Extends the existing sprite sheet by flipping the original frames horizontally, vertically, or both,\n\t * and adding appropriate animation & frame data. The flipped animations will have a suffix added to their names\n\t * (_h, _v, _hv as appropriate). Make sure the sprite sheet images are fully loaded before using this method.\n\t * <br/><br/>\n\t * For example:<br/>\n\t * SpriteSheetUtils.addFlippedFrames(mySpriteSheet, true, true);\n\t * The above would add frames that are flipped horizontally AND frames that are flipped vertically.\n\t * <br/><br/>\n\t * Note that you can also flip any display object by setting its scaleX or scaleY to a negative value. On some\n\t * browsers (especially those without hardware accelerated canvas) this can result in slightly degraded performance,\n\t * which is why addFlippedFrames is available.\n\t * @method addFlippedFrames\n\t * @static\n\t * @param {SpriteSheet} spriteSheet\n\t * @param {Boolean} horizontal If true, horizontally flipped frames will be added.\n\t * @param {Boolean} vertical If true, vertically flipped frames will be added.\n\t * @param {Boolean} both If true, frames that are flipped both horizontally and vertically will be added.\n\t * @deprecated Modern browsers perform better when flipping via a transform (ex. scaleX=-1) rendering this obsolete.\n\t **/\n\tSpriteSheetUtils.addFlippedFrames = function(spriteSheet, horizontal, vertical, both) {\n\t\tif (!horizontal && !vertical && !both) { return; }\n\n\t\tvar count = 0;\n\t\tif (horizontal) { SpriteSheetUtils._flip(spriteSheet,++count,true,false); }\n\t\tif (vertical) { SpriteSheetUtils._flip(spriteSheet,++count,false,true); }\n\t\tif (both) { SpriteSheetUtils._flip(spriteSheet,++count,true,true); }\n\t};\n\n\t/**\n\t * Returns a single frame of the specified sprite sheet as a new PNG image. An example of when this may be useful is\n\t * to use a spritesheet frame as the source for a bitmap fill.\n\t *\n\t * <strong>WARNING:</strong> In almost all cases it is better to display a single frame using a {{#crossLink \"Sprite\"}}{{/crossLink}}\n\t * with a {{#crossLink \"Sprite/gotoAndStop\"}}{{/crossLink}} call than it is to slice out a frame using this\n\t * method and display it with a Bitmap instance. You can also crop an image using the {{#crossLink \"Bitmap/sourceRect\"}}{{/crossLink}}\n\t * property of {{#crossLink \"Bitmap\"}}{{/crossLink}}.\n\t *\n\t * The extractFrame method may cause cross-domain warnings since it accesses pixels directly on the canvas.\n\t * @method extractFrame\n\t * @static\n\t * @param {SpriteSheet} spriteSheet The SpriteSheet instance to extract a frame from.\n\t * @param {Number|String} frameOrAnimation The frame number or animation name to extract. If an animation\n\t * name is specified, only the first frame of the animation will be extracted.\n\t * @return {HTMLImageElement} a single frame of the specified sprite sheet as a new PNG image.\n\t*/\n\tSpriteSheetUtils.extractFrame = function(spriteSheet, frameOrAnimation) {\n\t\tif (isNaN(frameOrAnimation)) {\n\t\t\tframeOrAnimation = spriteSheet.getAnimation(frameOrAnimation).frames[0];\n\t\t}\n\t\tvar data = spriteSheet.getFrame(frameOrAnimation);\n\t\tif (!data) { return null; }\n\t\tvar r = data.rect;\n\t\tvar canvas = SpriteSheetUtils._workingCanvas;\n\t\tcanvas.width = r.width;\n\t\tcanvas.height = r.height;\n\t\tSpriteSheetUtils._workingContext.drawImage(data.image, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);\n\t\tvar img = document.createElement(\"img\");\n\t\timg.src = canvas.toDataURL(\"image/png\");\n\t\treturn img;\n\t};\n\n\t/**\n\t * Merges the rgb channels of one image with the alpha channel of another. This can be used to combine a compressed\n\t * JPEG image containing color data with a PNG32 monochromatic image containing alpha data. With certain types of\n\t * images (those with detail that lend itself to JPEG compression) this can provide significant file size savings\n\t * versus a single RGBA PNG32. This method is very fast (generally on the order of 1-2 ms to run).\n\t * @method mergeAlpha\n\t * @static\n\t * @param {HTMLImageElement} rbgImage The image (or canvas) containing the RGB channels to use.\n\t * @param {HTMLImageElement} alphaImage The image (or canvas) containing the alpha channel to use.\n\t * @param {HTMLCanvasElement} canvas Optional. If specified, this canvas will be used and returned. If not, a new canvas will be created.\n\t * @return {HTMLCanvasElement} A canvas with the combined image data. This can be used as a source for Bitmap or SpriteSheet.\n\t * @deprecated Tools such as ImageAlpha generally provide better results. This will be moved to sandbox in the future.\n\t*/\n\tSpriteSheetUtils.mergeAlpha = function(rgbImage, alphaImage, canvas) {\n\t\tif (!canvas) { canvas = createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"); }\n\t\tcanvas.width = Math.max(alphaImage.width, rgbImage.width);\n\t\tcanvas.height = Math.max(alphaImage.height, rgbImage.height);\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tctx.save();\n\t\tctx.drawImage(rgbImage,0,0);\n\t\tctx.globalCompositeOperation = \"destination-in\";\n\t\tctx.drawImage(alphaImage,0,0);\n\t\tctx.restore();\n\t\treturn canvas;\n\t};\n\n\n// private static methods:\n\tSpriteSheetUtils._flip = function(spriteSheet, count, h, v) {\n\t\tvar imgs = spriteSheet._images;\n\t\tvar canvas = SpriteSheetUtils._workingCanvas;\n\t\tvar ctx = SpriteSheetUtils._workingContext;\n\t\tvar il = imgs.length/count;\n\t\tfor (var i=0;i<il;i++) {\n\t\t\tvar src = imgs[i];\n\t\t\tsrc.__tmp = i; // a bit hacky, but faster than doing indexOf below.\n\t\t\tctx.setTransform(1,0,0,1,0,0);\n\t\t\tctx.clearRect(0,0,canvas.width+1,canvas.height+1);\n\t\t\tcanvas.width = src.width;\n\t\t\tcanvas.height = src.height;\n\t\t\tctx.setTransform(h?-1:1, 0, 0, v?-1:1, h?src.width:0, v?src.height:0);\n\t\t\tctx.drawImage(src,0,0);\n\t\t\tvar img = document.createElement(\"img\");\n\t\t\timg.src = canvas.toDataURL(\"image/png\");\n\t\t\t// work around a strange bug in Safari:\n\t\t\timg.width = src.width;\n\t\t\timg.height = src.height;\n\t\t\timgs.push(img);\n\t\t}\n\n\t\tvar frames = spriteSheet._frames;\n\t\tvar fl = frames.length/count;\n\t\tfor (i=0;i<fl;i++) {\n\t\t\tsrc = frames[i];\n\t\t\tvar rect = src.rect.clone();\n\t\t\timg = imgs[src.image.__tmp+il*count];\n\n\t\t\tvar frame = {image:img,rect:rect,regX:src.regX,regY:src.regY};\n\t\t\tif (h) {\n\t\t\t\trect.x = img.width-rect.x-rect.width; // update rect\n\t\t\t\tframe.regX = rect.width-src.regX; // update registration point\n\t\t\t}\n\t\t\tif (v) {\n\t\t\t\trect.y = img.height-rect.y-rect.height;  // update rect\n\t\t\t\tframe.regY = rect.height-src.regY; // update registration point\n\t\t\t}\n\t\t\tframes.push(frame);\n\t\t}\n\n\t\tvar sfx = \"_\"+(h?\"h\":\"\")+(v?\"v\":\"\");\n\t\tvar names = spriteSheet._animations;\n\t\tvar data = spriteSheet._data;\n\t\tvar al = names.length/count;\n\t\tfor (i=0;i<al;i++) {\n\t\t\tvar name = names[i];\n\t\t\tsrc = data[name];\n\t\t\tvar anim = {name:name+sfx,speed:src.speed,next:src.next,frames:[]};\n\t\t\tif (src.next) { anim.next += sfx; }\n\t\t\tframes = src.frames;\n\t\t\tfor (var j=0,l=frames.length;j<l;j++) {\n\t\t\t\tanim.frames.push(frames[j]+fl*count);\n\t\t\t}\n\t\t\tdata[anim.name] = anim;\n\t\t\tnames.push(anim.name);\n\t\t}\n\t};\n\n\n\tcreatejs.SpriteSheetUtils = SpriteSheetUtils;\n}());\n\n//##############################################################################\n// SpriteSheetBuilder.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The SpriteSheetBuilder allows you to generate {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instances at run time\n\t * from any display object. This can allow you to maintain your assets as vector graphics (for low file size), and\n\t * render them at run time as SpriteSheets for better performance.\n\t *\n\t * SpriteSheets can be built either synchronously, or asynchronously, so that large SpriteSheets can be generated\n\t * without locking the UI.\n\t *\n\t * Note that the \"images\" used in the generated SpriteSheet are actually canvas elements, and that they will be\n\t * sized to the nearest power of 2 up to the value of {{#crossLink \"SpriteSheetBuilder/maxWidth:property\"}}{{/crossLink}}\n\t * or {{#crossLink \"SpriteSheetBuilder/maxHeight:property\"}}{{/crossLink}}.\n\t * @class SpriteSheetBuilder\n\t * @param {Number} [framerate=0] The {{#crossLink \"SpriteSheet/framerate:property\"}}{{/crossLink}} of\n\t * {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instances that are created.\n\t * @extends EventDispatcher\n\t * @constructor\n\t **/\n\tfunction SpriteSheetBuilder(framerate) {\n\t\tthis.EventDispatcher_constructor();\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The maximum width for the images (not individual frames) in the generated SpriteSheet. It is recommended to\n\t\t * use a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max\n\t\t * dimensions, then additional images will be created as needed.\n\t\t * @property maxWidth\n\t\t * @type Number\n\t\t * @default 2048\n\t\t*/\n\t\tthis.maxWidth = 2048;\n\t\n\t\t/**\n\t\t * The maximum height for the images (not individual frames) in the generated SpriteSheet. It is recommended to\n\t\t * use a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max\n\t\t * dimensions, then additional images will be created as needed.\n\t\t * @property maxHeight\n\t\t * @type Number\n\t\t * @default 2048\n\t\t **/\n\t\tthis.maxHeight = 2048;\n\t\n\t\t/**\n\t\t * The SpriteSheet that was generated. This will be null before a build is completed successfully.\n\t\t * @property spriteSheet\n\t\t * @type SpriteSheet\n\t\t **/\n\t\tthis.spriteSheet = null;\n\t\n\t\t/**\n\t\t * The scale to apply when drawing all frames to the SpriteSheet. This is multiplied against any scale specified\n\t\t * in the addFrame call. This can be used, for example, to generate a SpriteSheet at run time that is tailored\n\t\t * to the a specific device resolution (ex. tablet vs mobile).\n\t\t * @property scale\n\t\t * @type Number\n\t\t * @default 1\n\t\t **/\n\t\tthis.scale = 1;\n\t\n\t\t/**\n\t\t* The padding to use between frames. This is helpful to preserve antialiasing on drawn vector content.\n\t\t* @property padding\n\t\t* @type Number\n\t\t* @default 1\n\t\t**/\n\t\tthis.padding = 1;\n\t\n\t\t/**\n\t\t * A number from 0.01 to 0.99 that indicates what percentage of time the builder can use. This can be\n\t\t * thought of as the number of seconds per second the builder will use. For example, with a timeSlice value of 0.3,\n\t\t * the builder will run 20 times per second, using approximately 15ms per build (30% of available time, or 0.3s per second).\n\t\t * Defaults to 0.3.\n\t\t * @property timeSlice\n\t\t * @type Number\n\t\t * @default 0.3\n\t\t **/\n\t\tthis.timeSlice = 0.3;\n\t\n\t\t/**\n\t\t * A value between 0 and 1 that indicates the progress of a build, or -1 if a build has not\n\t\t * been initiated.\n\t\t * @property progress\n\t\t * @type Number\n\t\t * @default -1\n\t\t * @readonly\n\t\t */\n\t\tthis.progress = -1;\n\n\t\t/**\n\t\t * A {{#crossLink \"SpriteSheet/framerate:property\"}}{{/crossLink}} value that will be passed to new {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instances that are\n\t\t * created. If no framerate is specified (or it is 0), then SpriteSheets will use the {{#crossLink \"Ticker\"}}{{/crossLink}}\n\t\t * framerate.\n\t\t * @property framerate\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.framerate = framerate || 0;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @property _frames\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._frames = [];\n\t\n\t\t/**\n\t\t * @property _animations\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._animations = {};\n\t\n\t\t/**\n\t\t * @property _data\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._data = null;\n\t\n\t\t/**\n\t\t * @property _nextFrameIndex\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._nextFrameIndex = 0;\n\t\n\t\t/**\n\t\t * @property _index\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._index = 0;\n\t\n\t\t/**\n\t\t * @property _timerID\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._timerID = null;\n\t\n\t\t/**\n\t\t * @property _scale\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._scale = 1;\n\t}\n\tvar p = createjs.extend(SpriteSheetBuilder, createjs.EventDispatcher);\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// constants:\n\tSpriteSheetBuilder.ERR_DIMENSIONS = \"frame dimensions exceed max spritesheet dimensions\";\n\tSpriteSheetBuilder.ERR_RUNNING = \"a build is already running\";\n\n// events:\n\t/**\n\t * Dispatched when a build completes.\n\t * @event complete\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when an asynchronous build has progress.\n\t * @event progress\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Number} progress The current progress value (0-1).\n\t * @since 0.6.0\n\t */\n\n\n// public methods:\n\t/**\n\t * Adds a frame to the {{#crossLink \"SpriteSheet\"}}{{/crossLink}}. Note that the frame will not be drawn until you\n\t * call {{#crossLink \"SpriteSheetBuilder/build\"}}{{/crossLink}} method. The optional setup params allow you to have\n\t * a function run immediately before the draw occurs. For example, this allows you to add a single source multiple\n\t * times, but manipulate it or its children to change it to generate different frames.\n\t *\n\t * Note that the source's transformations (x, y, scale, rotate, alpha) will be ignored, except for regX/Y. To apply\n\t * transforms to a source object and have them captured in the SpriteSheet, simply place it into a {{#crossLink \"Container\"}}{{/crossLink}}\n\t * and pass in the Container as the source.\n\t * @method addFrame\n\t * @param {DisplayObject} source The source {{#crossLink \"DisplayObject\"}}{{/crossLink}}  to draw as the frame.\n\t * @param {Rectangle} [sourceRect] A {{#crossLink \"Rectangle\"}}{{/crossLink}} defining the portion of the\n\t * source to draw to the frame. If not specified, it will look for a `getBounds` method, bounds property, or\n\t * `nominalBounds` property on the source to use. If one is not found, the frame will be skipped.\n\t * @param {Number} [scale=1] Optional. The scale to draw this frame at. Default is 1.\n\t * @param {Function} [setupFunction] A function to call immediately before drawing this frame. It will be called with two parameters: the source, and setupData.\n\t * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.\n\t * @return {Number} The index of the frame that was just added, or null if a sourceRect could not be determined.\n\t **/\n\tp.addFrame = function(source, sourceRect, scale, setupFunction, setupData) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tvar rect = sourceRect||source.bounds||source.nominalBounds;\n\t\tif (!rect&&source.getBounds) { rect = source.getBounds(); }\n\t\tif (!rect) { return null; }\n\t\tscale = scale||1;\n\t\treturn this._frames.push({source:source, sourceRect:rect, scale:scale, funct:setupFunction, data:setupData, index:this._frames.length, height:rect.height*scale})-1;\n\t};\n\n\t/**\n\t * Adds an animation that will be included in the created {{#crossLink \"SpriteSheet\"}}{{/crossLink}}.\n\t * @method addAnimation\n\t * @param {String} name The name for the animation.\n\t * @param {Array} frames An array of frame indexes that comprise the animation. Ex. [3,6,5] would describe an animation\n\t * that played frame indexes 3, 6, and 5 in that order.\n\t * @param {String} [next] Specifies the name of the animation to continue to after this animation ends. You can\n\t * also pass false to have the animation stop when it ends. By default it will loop to the start of the same animation.\n\t * @param {Number} [speed] Specifies a frame advance speed for this animation. For example, a value of 0.5 would\n\t * cause the animation to advance every second tick. Note that earlier versions used `frequency` instead, which had\n\t * the opposite effect.\n\t **/\n\tp.addAnimation = function(name, frames, next, speed) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tthis._animations[name] = {frames:frames, next:next, speed:speed};\n\t};\n\n\t/**\n\t * This will take a {{#crossLink \"MovieClip\"}}{{/crossLink}} instance, and add its frames and labels to this\n\t * builder. Labels will be added as an animation running from the label index to the next label. For example, if\n\t * there is a label named \"foo\" at frame 0 and a label named \"bar\" at frame 10, in a MovieClip with 15 frames, it\n\t * will add an animation named \"foo\" that runs from frame index 0 to 9, and an animation named \"bar\" that runs from\n\t * frame index 10 to 14.\n\t *\n\t * Note that this will iterate through the full MovieClip with {{#crossLink \"MovieClip/actionsEnabled:property\"}}{{/crossLink}}\n\t * set to `false`, ending on the last frame.\n\t * @method addMovieClip\n\t * @param {MovieClip} source The source MovieClip instance to add to the SpriteSheet.\n\t * @param {Rectangle} [sourceRect] A {{#crossLink \"Rectangle\"}}{{/crossLink}} defining the portion of the source to\n\t * draw to the frame. If not specified, it will look for a {{#crossLink \"DisplayObject/getBounds\"}}{{/crossLink}}\n\t * method, `frameBounds` Array, `bounds` property, or `nominalBounds` property on the source to use. If one is not\n\t * found, the MovieClip will be skipped.\n\t * @param {Number} [scale=1] The scale to draw the movie clip at.\n\t * @param {Function} [setupFunction] A function to call immediately before drawing each frame. It will be called\n\t * with three parameters: the source, setupData, and the frame index.\n\t * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.\n\t * @param {Function} [labelFunction] This method will be called for each MovieClip label that is added with four\n\t * parameters: the label name, the source MovieClip instance, the starting frame index (in the movieclip timeline)\n\t * and the end index. It must return a new name for the label/animation, or `false` to exclude the label.\n\t **/\n\tp.addMovieClip = function(source, sourceRect, scale, setupFunction, setupData, labelFunction) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tvar rects = source.frameBounds;\n\t\tvar rect = sourceRect||source.bounds||source.nominalBounds;\n\t\tif (!rect&&source.getBounds) { rect = source.getBounds(); }\n\t\tif (!rect && !rects) { return; }\n\n\t\tvar i, l, baseFrameIndex = this._frames.length;\n\t\tvar duration = source.timeline.duration;\n\t\tfor (i=0; i<duration; i++) {\n\t\t\tvar r = (rects&&rects[i]) ? rects[i] : rect;\n\t\t\tthis.addFrame(source, r, scale, this._setupMovieClipFrame, {i:i, f:setupFunction, d:setupData});\n\t\t}\n\t\tvar labels = source.timeline._labels;\n\t\tvar lbls = [];\n\t\tfor (var n in labels) {\n\t\t\tlbls.push({index:labels[n], label:n});\n\t\t}\n\t\tif (lbls.length) {\n\t\t\tlbls.sort(function(a,b){ return a.index-b.index; });\n\t\t\tfor (i=0,l=lbls.length; i<l; i++) {\n\t\t\t\tvar label = lbls[i].label;\n\t\t\t\tvar start = baseFrameIndex+lbls[i].index;\n\t\t\t\tvar end = baseFrameIndex+((i == l-1) ? duration : lbls[i+1].index);\n\t\t\t\tvar frames = [];\n\t\t\t\tfor (var j=start; j<end; j++) { frames.push(j); }\n\t\t\t\tif (labelFunction) {\n\t\t\t\t\tlabel = labelFunction(label, source, start, end);\n\t\t\t\t\tif (!label) { continue; }\n\t\t\t\t}\n\t\t\t\tthis.addAnimation(label, frames, true); // for now, this loops all animations.\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Builds a {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instance based on the current frames.\n\t * @method build\n\t * @return {SpriteSheet} The created SpriteSheet instance, or null if a build is already running or an error\n\t * occurred.\n\t **/\n\tp.build = function() {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tthis._startBuild();\n\t\twhile (this._drawNext()) {}\n\t\tthis._endBuild();\n\t\treturn this.spriteSheet;\n\t};\n\n\t/**\n\t * Asynchronously builds a {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instance based on the current frames. It will\n\t * run 20 times per second, using an amount of time defined by `timeSlice`. When it is complete it will call the\n\t * specified callback.\n\t * @method buildAsync\n\t * @param {Number} [timeSlice] Sets the timeSlice property on this instance.\n\t **/\n\tp.buildAsync = function(timeSlice) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tthis.timeSlice = timeSlice;\n\t\tthis._startBuild();\n\t\tvar _this = this;\n\t\tthis._timerID = setTimeout(function() { _this._run(); }, 50-Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50);\n\t};\n\n\t/**\n\t * Stops the current asynchronous build.\n\t * @method stopAsync\n\t **/\n\tp.stopAsync = function() {\n\t\tclearTimeout(this._timerID);\n\t\tthis._data = null;\n\t};\n\n\t/**\n\t * SpriteSheetBuilder instances cannot be cloned.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\tthrow(\"SpriteSheetBuilder cannot be cloned.\");\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[SpriteSheetBuilder]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _startBuild\n\t * @protected\n\t **/\n\tp._startBuild = function() {\n\t\tvar pad = this.padding||0;\n\t\tthis.progress = 0;\n\t\tthis.spriteSheet = null;\n\t\tthis._index = 0;\n\t\tthis._scale = this.scale;\n\t\tvar dataFrames = [];\n\t\tthis._data = {\n\t\t\timages: [],\n\t\t\tframes: dataFrames,\n\t\t\tframerate: this.framerate,\n\t\t\tanimations: this._animations // TODO: should we \"clone\" _animations in case someone adds more animations after a build?\n\t\t};\n\n\t\tvar frames = this._frames.slice();\n\t\tframes.sort(function(a,b) { return (a.height<=b.height) ? -1 : 1; });\n\n\t\tif (frames[frames.length-1].height+pad*2 > this.maxHeight) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }\n\t\tvar y=0, x=0;\n\t\tvar img = 0;\n\t\twhile (frames.length) {\n\t\t\tvar o = this._fillRow(frames, y, img, dataFrames, pad);\n\t\t\tif (o.w > x) { x = o.w; }\n\t\t\ty += o.h;\n\t\t\tif (!o.h || !frames.length) {\n\t\t\t\tvar canvas = createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\");\n\t\t\t\tcanvas.width = this._getSize(x,this.maxWidth);\n\t\t\t\tcanvas.height = this._getSize(y,this.maxHeight);\n\t\t\t\tthis._data.images[img] = canvas;\n\t\t\t\tif (!o.h) {\n\t\t\t\t\tx=y=0;\n\t\t\t\t\timg++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/**\n\t * @method _setupMovieClipFrame\n\t * @protected\n\t * @return {Number} The width & height of the row.\n\t **/\n\tp._setupMovieClipFrame = function(source, data) {\n\t\tvar ae = source.actionsEnabled;\n\t\tsource.actionsEnabled = false;\n\t\tsource.gotoAndStop(data.i);\n\t\tsource.actionsEnabled = ae;\n\t\tdata.f&&data.f(source, data.d, data.i);\n\t};\n\n\t/**\n\t * @method _getSize\n\t * @protected\n\t * @return {Number} The width & height of the row.\n\t **/\n\tp._getSize = function(size,max) {\n\t\tvar pow = 4;\n\t\twhile (Math.pow(2,++pow) < size){}\n\t\treturn Math.min(max,Math.pow(2,pow));\n\t};\n\n\t/**\n\t * @method _fillRow\n\t * @param {Array} frames\n\t * @param {Number} y\n\t * @param {HTMLImageElement} img\n\t * @param {Object} dataFrames\n\t * @param {Number} pad\n\t * @protected\n\t * @return {Number} The width & height of the row.\n\t **/\n\tp._fillRow = function(frames, y, img, dataFrames, pad) {\n\t\tvar w = this.maxWidth;\n\t\tvar maxH = this.maxHeight;\n\t\ty += pad;\n\t\tvar h = maxH-y;\n\t\tvar x = pad;\n\t\tvar height = 0;\n\t\tfor (var i=frames.length-1; i>=0; i--) {\n\t\t\tvar frame = frames[i];\n\t\t\tvar sc = this._scale*frame.scale;\n\t\t\tvar rect = frame.sourceRect;\n\t\t\tvar source = frame.source;\n\t\t\tvar rx = Math.floor(sc*rect.x-pad);\n\t\t\tvar ry = Math.floor(sc*rect.y-pad);\n\t\t\tvar rh = Math.ceil(sc*rect.height+pad*2);\n\t\t\tvar rw = Math.ceil(sc*rect.width+pad*2);\n\t\t\tif (rw > w) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }\n\t\t\tif (rh > h || x+rw > w) { continue; }\n\t\t\tframe.img = img;\n\t\t\tframe.rect = new createjs.Rectangle(x,y,rw,rh);\n\t\t\theight = height || rh;\n\t\t\tframes.splice(i,1);\n\t\t\tdataFrames[frame.index] = [x,y,rw,rh,img,Math.round(-rx+sc*source.regX-pad),Math.round(-ry+sc*source.regY-pad)];\n\t\t\tx += rw;\n\t\t}\n\t\treturn {w:x, h:height};\n\t};\n\n\t/**\n\t * @method _endBuild\n\t * @protected\n\t **/\n\tp._endBuild = function() {\n\t\tthis.spriteSheet = new createjs.SpriteSheet(this._data);\n\t\tthis._data = null;\n\t\tthis.progress = 1;\n\t\tthis.dispatchEvent(\"complete\");\n\t};\n\n\t/**\n\t * @method _run\n\t * @protected\n\t **/\n\tp._run = function() {\n\t\tvar ts = Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50;\n\t\tvar t = (new Date()).getTime()+ts;\n\t\tvar complete = false;\n\t\twhile (t > (new Date()).getTime()) {\n\t\t\tif (!this._drawNext()) { complete = true; break; }\n\t\t}\n\t\tif (complete) {\n\t\t\tthis._endBuild();\n\t\t} else {\n\t\t\tvar _this = this;\n\t\t\tthis._timerID = setTimeout(function() { _this._run(); }, 50-ts);\n\t\t}\n\t\tvar p = this.progress = this._index/this._frames.length;\n\t\tif (this.hasEventListener(\"progress\")) {\n\t\t\tvar evt = new createjs.Event(\"progress\");\n\t\t\tevt.progress = p;\n\t\t\tthis.dispatchEvent(evt);\n\t\t}\n\t};\n\n\t/**\n\t * @method _drawNext\n\t * @protected\n\t * @return Boolean Returns false if this is the last draw.\n\t **/\n\tp._drawNext = function() {\n\t\tvar frame = this._frames[this._index];\n\t\tvar sc = frame.scale*this._scale;\n\t\tvar rect = frame.rect;\n\t\tvar sourceRect = frame.sourceRect;\n\t\tvar canvas = this._data.images[frame.img];\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tframe.funct&&frame.funct(frame.source, frame.data);\n\t\tctx.save();\n\t\tctx.beginPath();\n\t\tctx.rect(rect.x, rect.y, rect.width, rect.height);\n\t\tctx.clip();\n\t\tctx.translate(Math.ceil(rect.x-sourceRect.x*sc), Math.ceil(rect.y-sourceRect.y*sc));\n\t\tctx.scale(sc,sc);\n\t\tframe.source.draw(ctx); // display object will draw itself.\n\t\tctx.restore();\n\t\treturn (++this._index) < this._frames.length;\n\t};\n\n\n\tcreatejs.SpriteSheetBuilder = createjs.promote(SpriteSheetBuilder, \"EventDispatcher\");\n}());\n\n//##############################################################################\n// DOMElement.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * <b>This class is still experimental, and more advanced use is likely to be buggy. Please report bugs.</b>\n\t *\n\t * A DOMElement allows you to associate a HTMLElement with the display list. It will be transformed\n\t * within the DOM as though it is child of the {{#crossLink \"Container\"}}{{/crossLink}} it is added to. However, it is\n\t * not rendered to canvas, and as such will retain whatever z-index it has relative to the canvas (ie. it will be\n\t * drawn in front of or behind the canvas).\n\t *\n\t * The position of a DOMElement is relative to their parent node in the DOM. It is recommended that\n\t * the DOM Object be added to a div that also contains the canvas so that they share the same position\n\t * on the page.\n\t *\n\t * DOMElement is useful for positioning HTML elements over top of canvas content, and for elements\n\t * that you want to display outside the bounds of the canvas. For example, a tooltip with rich HTML\n\t * content.\n\t *\n\t * <h4>Mouse Interaction</h4>\n\t *\n\t * DOMElement instances are not full EaselJS display objects, and do not participate in EaselJS mouse\n\t * events or support methods like hitTest. To get mouse events from a DOMElement, you must instead add handlers to\n\t * the htmlElement (note, this does not support EventDispatcher)\n\t *\n\t *      var domElement = new createjs.DOMElement(htmlElement);\n\t *      domElement.htmlElement.onclick = function() {\n\t *          console.log(\"clicked\");\n\t *      }\n\t *\n\t * @class DOMElement\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {HTMLElement} htmlElement A reference or id for the DOM element to manage.\n\t */\n\tfunction DOMElement(htmlElement) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\tif (typeof(htmlElement)==\"string\") { htmlElement = document.getElementById(htmlElement); }\n\t\tthis.mouseEnabled = false;\n\t\t\n\t\tvar style = htmlElement.style;\n\t\tstyle.position = \"absolute\";\n\t\tstyle.transformOrigin = style.WebkitTransformOrigin = style.msTransformOrigin = style.MozTransformOrigin = style.OTransformOrigin = \"0% 0%\";\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The DOM object to manage.\n\t\t * @property htmlElement\n\t\t * @type HTMLElement\n\t\t */\n\t\tthis.htmlElement = htmlElement;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @property _oldMtx\n\t\t * @type Matrix2D\n\t\t * @protected\n\t\t */\n\t\tthis._oldProps = null;\n\t}\n\tvar p = createjs.extend(DOMElement, createjs.DisplayObject);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t */\n\tp.isVisible = function() {\n\t\treturn this.htmlElement != null;\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t * @return {Boolean}\n\t */\n\tp.draw = function(ctx, ignoreCache) {\n\t\t// this relies on the _tick method because draw isn't called if the parent is not visible.\n\t\t// the actual update happens in _handleDrawEnd\n\t\treturn true;\n\t};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method cache\n\t */\n\tp.cache = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method uncache\n\t */\n\tp.uncache = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method updateCache\n\t */\n\tp.updateCache = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method hitTest\n\t */\n\tp.hitTest = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method localToGlobal\n\t */\n\tp.localToGlobal = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method globalToLocal\n\t */\n\tp.globalToLocal = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method localToLocal\n\t */\n\tp.localToLocal = function() {};\n\n\t/**\n\t * DOMElement cannot be cloned. Throws an error.\n\t * @method clone\n\t */\n\tp.clone = function() {\n\t\tthrow(\"DOMElement cannot be cloned.\")\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t */\n\tp.toString = function() {\n\t\treturn \"[DOMElement (name=\"+  this.name +\")]\";\n\t};\n\n\t/**\n     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n\t * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n\t * @event click\n\t */\n\n     /**\n     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n \t * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n\t * @event dblClick\n\t */\n\n     /**\n      * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n \t  * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n\t  * @event mousedown\n\t  */\n\n     /**\n      * The HTMLElement can listen for the mouseover event, not the DOMElement instance.\n      * Since DOMElement instances are not full EaselJS display objects and do not participate in EaselJS mouse events.\n      * @event mouseover\n\t  */\n\n     /**\n      * Not applicable to DOMElement.\n\t  * @event tick\n\t  */\n\n\n// private methods:\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * function.\n\t * @protected\n\t */\n\tp._tick = function(evtObj) {\n\t\tvar stage = this.getStage();\n\t\tstage&&stage.on(\"drawend\", this._handleDrawEnd, this, true);\n\t\tthis.DisplayObject__tick(evtObj);\n\t};\n\t\n\t/**\n\t * @method _handleDrawEnd\n\t * @param {Event} evt\n\t * @protected\n\t */\n\tp._handleDrawEnd = function(evt) {\n\t\tvar o = this.htmlElement;\n\t\tif (!o) { return; }\n\t\tvar style = o.style;\n\t\t\n\t\tvar props = this.getConcatenatedDisplayProps(this._props), mtx = props.matrix;\n\t\t\n\t\tvar visibility = props.visible ? \"visible\" : \"hidden\";\n\t\tif (visibility != style.visibility) { style.visibility = visibility; }\n\t\tif (!props.visible) { return; }\n\t\t\n\t\tvar oldProps = this._oldProps, oldMtx = oldProps&&oldProps.matrix;\n\t\tvar n = 10000; // precision\n\t\t\n\t\tif (!oldMtx || !oldMtx.equals(mtx)) {\n\t\t\tvar str = \"matrix(\" + (mtx.a*n|0)/n +\",\"+ (mtx.b*n|0)/n +\",\"+ (mtx.c*n|0)/n +\",\"+ (mtx.d*n|0)/n +\",\"+ (mtx.tx+0.5|0);\n\t\t\tstyle.transform = style.WebkitTransform = style.OTransform = style.msTransform = str +\",\"+ (mtx.ty+0.5|0) +\")\";\n\t\t\tstyle.MozTransform = str +\"px,\"+ (mtx.ty+0.5|0) +\"px)\";\n\t\t\tif (!oldProps) { oldProps = this._oldProps = new createjs.DisplayProps(true, NaN); }\n\t\t\toldProps.matrix.copy(mtx);\n\t\t}\n\t\t\n\t\tif (oldProps.alpha != props.alpha) {\n\t\t\tstyle.opacity = \"\"+(props.alpha*n|0)/n;\n\t\t\toldProps.alpha = props.alpha;\n\t\t}\n\t};\n\n\n\tcreatejs.DOMElement = createjs.promote(DOMElement, \"DisplayObject\");\n}());\n\n//##############################################################################\n// Filter.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Base class that all filters should inherit from. Filters need to be applied to objects that have been cached using\n\t * the {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}} method. If an object changes, please cache it again, or use\n\t * {{#crossLink \"DisplayObject/updateCache\"}}{{/crossLink}}. Note that the filters must be applied before caching.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myInstance.filters = [\n\t *          new createjs.ColorFilter(0, 0, 0, 1, 255, 0, 0),\n\t *          new createjs.BlurFilter(5, 5, 10)\n\t *      ];\n\t *      myInstance.cache(0,0, 100, 100);\n\t *\n\t * Note that each filter can implement a {{#crossLink \"Filter/getBounds\"}}{{/crossLink}} method, which returns the\n\t * margins that need to be applied in order to fully display the filter. For example, the {{#crossLink \"BlurFilter\"}}{{/crossLink}}\n\t * will cause an object to feather outwards, resulting in a margin around the shape.\n\t *\n\t * <h4>EaselJS Filters</h4>\n\t * EaselJS comes with a number of pre-built filters:\n\t * <ul><li>{{#crossLink \"AlphaMapFilter\"}}{{/crossLink}} : Map a greyscale image to the alpha channel of a display object</li>\n\t *      <li>{{#crossLink \"AlphaMaskFilter\"}}{{/crossLink}}: Map an image's alpha channel to the alpha channel of a display object</li>\n\t *      <li>{{#crossLink \"BlurFilter\"}}{{/crossLink}}: Apply vertical and horizontal blur to a display object</li>\n\t *      <li>{{#crossLink \"ColorFilter\"}}{{/crossLink}}: Color transform a display object</li>\n\t *      <li>{{#crossLink \"ColorMatrixFilter\"}}{{/crossLink}}: Transform an image using a {{#crossLink \"ColorMatrix\"}}{{/crossLink}}</li>\n\t * </ul>\n\t *\n\t * @class Filter\n\t * @constructor\n\t **/\n\tfunction Filter() {}\n\tvar p = Filter.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// public methods:\n\t/**\n\t * Provides padding values for this filter. That is, how much the filter will extend the visual bounds of an object it is applied to.\n\t * @method getBounds\n\t * @param {Rectangle} [rect] If specified, the provided Rectangle instance will be expanded by the padding amounts and returned.\n\t * @return {Rectangle} If a `rect` param was provided, it is returned. If not, either a new rectangle with the padding values, or null if no padding is required for this filter.\n\t **/\n\tp.getBounds = function(rect) {\n\t\treturn rect;\n\t};\n\n\t/**\n\t * Applies the filter to the specified context.\n\t * @method applyFilter\n\t * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.\n\t * @param {Number} x The x position to use for the source rect.\n\t * @param {Number} y The y position to use for the source rect.\n\t * @param {Number} width The width to use for the source rect.\n\t * @param {Number} height The height to use for the source rect.\n\t * @param {CanvasRenderingContext2D} [targetCtx] The 2D context to draw the result to. Defaults to the context passed to ctx.\n\t * @param {Number} [targetX] The x position to draw the result to. Defaults to the value passed to x.\n\t * @param {Number} [targetY] The y position to draw the result to. Defaults to the value passed to y.\n\t * @return {Boolean} If the filter was applied successfully.\n\t **/\n\tp.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {\n\t\t// this is the default behaviour because most filters access pixel data. It is overridden when not needed.\n\t\ttargetCtx = targetCtx || ctx;\n\t\tif (targetX == null) { targetX = x; }\n\t\tif (targetY == null) { targetY = y; }\n\t\ttry {\n\t\t\tvar imageData = ctx.getImageData(x, y, width, height);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._applyFilter(imageData)) {\n\t\t\ttargetCtx.putImageData(imageData, targetX, targetY);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Filter]\";\n\t};\n\n\t/**\n\t * Returns a clone of this Filter instance.\n\t * @method clone\n\t * @return {Filter} A clone of the current Filter instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Filter();\n\t};\n\t\n// private methods:\n\t/**\n\t * @method _applyFilter\n\t * @param {ImageData} imageData Target ImageData instance.\n\t * @return {Boolean}\n\t **/\n\tp._applyFilter = function(imageData) { return true; };\n\n\n\tcreatejs.Filter = Filter;\n}());\n\n//##############################################################################\n// BlurFilter.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Applies a box blur to DisplayObjects. Note that this filter is fairly CPU intensive, particularly if the quality is\n\t * set higher than 1.\n\t *\n\t * <h4>Example</h4>\n\t * This example creates a red circle, and then applies a 5 pixel blur to it. It uses the {{#crossLink \"Filter/getBounds\"}}{{/crossLink}}\n\t * method to account for the spread that the blur causes.\n\t *\n\t *      var shape = new createjs.Shape().set({x:100,y:100});\n\t *      shape.graphics.beginFill(\"#ff0000\").drawCircle(0,0,50);\n\t *\n\t *      var blurFilter = new createjs.BlurFilter(5, 5, 1);\n\t *      shape.filters = [blurFilter];\n\t *      var bounds = blurFilter.getBounds();\n\t *\n\t *      shape.cache(-50+bounds.x, -50+bounds.y, 100+bounds.width, 100+bounds.height);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for an more information on applying filters.\n\t * @class BlurFilter\n\t * @extends Filter\n\t * @constructor\n\t * @param {Number} [blurX=0] The horizontal blur radius in pixels.\n\t * @param {Number} [blurY=0] The vertical blur radius in pixels.\n\t * @param {Number} [quality=1] The number of blur iterations.\n\t **/\n\tfunction BlurFilter( blurX, blurY, quality) {\n\t\tif ( isNaN(blurX) || blurX < 0 ) blurX = 0;\n\t\tif ( isNaN(blurY) || blurY < 0 ) blurY = 0;\n\t\tif ( isNaN(quality) || quality < 1  ) quality = 1;\n\n\n\t\t// public properties:\n\t\t/**\n\t\t * Horizontal blur radius in pixels\n\t\t * @property blurX\n\t\t * @default 0\n\t\t * @type Number\n\t\t **/\n\t\tthis.blurX = blurX | 0;\n\n\t\t/**\n\t\t * Vertical blur radius in pixels\n\t\t * @property blurY\n\t\t * @default 0\n\t\t * @type Number\n\t\t **/\n\t\tthis.blurY = blurY | 0;\n\n\t\t/**\n\t\t * Number of blur iterations. For example, a value of 1 will produce a rough blur. A value of 2 will produce a\n\t\t * smoother blur, but take twice as long to run.\n\t\t * @property quality\n\t\t * @default 1\n\t\t * @type Number\n\t\t **/\n\t\tthis.quality = quality | 0;\n\t}\n\tvar p = createjs.extend(BlurFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// constants:\n\t/**\n\t * Array of multiply values for blur calculations.\n\t * @property MUL_TABLE\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tBlurFilter.MUL_TABLE = [1, 171, 205, 293, 57, 373, 79, 137, 241, 27, 391, 357, 41, 19, 283, 265, 497, 469, 443, 421, 25, 191, 365, 349, 335, 161, 155, 149, 9, 278, 269, 261, 505, 245, 475, 231, 449, 437, 213, 415, 405, 395, 193, 377, 369, 361, 353, 345, 169, 331, 325, 319, 313, 307, 301, 37, 145, 285, 281, 69, 271, 267, 263, 259, 509, 501, 493, 243, 479, 118, 465, 459, 113, 446, 55, 435, 429, 423, 209, 413, 51, 403, 199, 393, 97, 3, 379, 375, 371, 367, 363, 359, 355, 351, 347, 43, 85, 337, 333, 165, 327, 323, 5, 317, 157, 311, 77, 305, 303, 75, 297, 294, 73, 289, 287, 71, 141, 279, 277, 275, 68, 135, 67, 133, 33, 262, 260, 129, 511, 507, 503, 499, 495, 491, 61, 121, 481, 477, 237, 235, 467, 232, 115, 457, 227, 451, 7, 445, 221, 439, 218, 433, 215, 427, 425, 211, 419, 417, 207, 411, 409, 203, 202, 401, 399, 396, 197, 49, 389, 387, 385, 383, 95, 189, 47, 187, 93, 185, 23, 183, 91, 181, 45, 179, 89, 177, 11, 175, 87, 173, 345, 343, 341, 339, 337, 21, 167, 83, 331, 329, 327, 163, 81, 323, 321, 319, 159, 79, 315, 313, 39, 155, 309, 307, 153, 305, 303, 151, 75, 299, 149, 37, 295, 147, 73, 291, 145, 289, 287, 143, 285, 71, 141, 281, 35, 279, 139, 69, 275, 137, 273, 17, 271, 135, 269, 267, 133, 265, 33, 263, 131, 261, 130, 259, 129, 257, 1];\n\n\t/**\n\t * Array of shift values for blur calculations.\n\t * @property SHG_TABLE\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tBlurFilter.SHG_TABLE = [0, 9, 10, 11, 9, 12, 10, 11, 12, 9, 13, 13, 10, 9, 13, 13, 14, 14, 14, 14, 10, 13, 14, 14, 14, 13, 13, 13, 9, 14, 14, 14, 15, 14, 15, 14, 15, 15, 14, 15, 15, 15, 14, 15, 15, 15, 15, 15, 14, 15, 15, 15, 15, 15, 15, 12, 14, 15, 15, 13, 15, 15, 15, 15, 16, 16, 16, 15, 16, 14, 16, 16, 14, 16, 13, 16, 16, 16, 15, 16, 13, 16, 15, 16, 14, 9, 16, 16, 16, 16, 16, 16, 16, 16, 16, 13, 14, 16, 16, 15, 16, 16, 10, 16, 15, 16, 14, 16, 16, 14, 16, 16, 14, 16, 16, 14, 15, 16, 16, 16, 14, 15, 14, 15, 13, 16, 16, 15, 17, 17, 17, 17, 17, 17, 14, 15, 17, 17, 16, 16, 17, 16, 15, 17, 16, 17, 11, 17, 16, 17, 16, 17, 16, 17, 17, 16, 17, 17, 16, 17, 17, 16, 16, 17, 17, 17, 16, 14, 17, 17, 17, 17, 15, 16, 14, 16, 15, 16, 13, 16, 15, 16, 14, 16, 15, 16, 12, 16, 15, 16, 17, 17, 17, 17, 17, 13, 16, 15, 17, 17, 17, 16, 15, 17, 17, 17, 16, 15, 17, 17, 14, 16, 17, 17, 16, 17, 17, 16, 15, 17, 16, 14, 17, 16, 15, 17, 16, 17, 17, 16, 17, 15, 16, 17, 14, 17, 16, 15, 17, 16, 17, 13, 17, 16, 17, 17, 16, 17, 14, 17, 16, 17, 16, 17, 16, 17, 9];\n\n// public methods:\n\t/** docced in super class **/\n\tp.getBounds = function (rect) {\n\t\tvar x = this.blurX|0, y = this.blurY| 0;\n\t\tif (x <= 0 && y <= 0) { return rect; }\n\t\tvar q = Math.pow(this.quality, 0.2);\n\t\treturn (rect || new createjs.Rectangle()).pad(x*q+1,y*q+1,x*q+1,y*q+1);\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function() {\n\t\treturn new BlurFilter(this.blurX, this.blurY, this.quality);\n\t};\n\n\t/** docced in super class **/\n\tp.toString = function() {\n\t\treturn \"[BlurFilter]\";\n\t};\n\n\n// private methods:\n\n\t/** docced in super class **/\n\tp._applyFilter = function (imageData) {\n\n\t\tvar radiusX = this.blurX >> 1;\n\t\tif (isNaN(radiusX) || radiusX < 0) return false;\n\t\tvar radiusY = this.blurY >> 1;\n\t\tif (isNaN(radiusY) || radiusY < 0) return false;\n\t\tif (radiusX == 0 && radiusY == 0) return false;\n\n\t\tvar iterations = this.quality;\n\t\tif (isNaN(iterations) || iterations < 1) iterations = 1;\n\t\titerations |= 0;\n\t\tif (iterations > 3) iterations = 3;\n\t\tif (iterations < 1) iterations = 1;\n\n\t\tvar px = imageData.data;\n\t\tvar x=0, y=0, i=0, p=0, yp=0, yi=0, yw=0, r=0, g=0, b=0, a=0, pr=0, pg=0, pb=0, pa=0;\n\n\t\tvar divx = (radiusX + radiusX + 1) | 0;\n\t\tvar divy = (radiusY + radiusY + 1) | 0;\n\t\tvar w = imageData.width | 0;\n\t\tvar h = imageData.height | 0;\n\n\t\tvar w1 = (w - 1) | 0;\n\t\tvar h1 = (h - 1) | 0;\n\t\tvar rxp1 = (radiusX + 1) | 0;\n\t\tvar ryp1 = (radiusY + 1) | 0;\n\n\t\tvar ssx = {r:0,b:0,g:0,a:0};\n\t\tvar sx = ssx;\n\t\tfor ( i = 1; i < divx; i++ )\n\t\t{\n\t\t\tsx = sx.n = {r:0,b:0,g:0,a:0};\n\t\t}\n\t\tsx.n = ssx;\n\n\t\tvar ssy = {r:0,b:0,g:0,a:0};\n\t\tvar sy = ssy;\n\t\tfor ( i = 1; i < divy; i++ )\n\t\t{\n\t\t\tsy = sy.n = {r:0,b:0,g:0,a:0};\n\t\t}\n\t\tsy.n = ssy;\n\n\t\tvar si = null;\n\n\n\t\tvar mtx = BlurFilter.MUL_TABLE[radiusX] | 0;\n\t\tvar stx = BlurFilter.SHG_TABLE[radiusX] | 0;\n\t\tvar mty = BlurFilter.MUL_TABLE[radiusY] | 0;\n\t\tvar sty = BlurFilter.SHG_TABLE[radiusY] | 0;\n\n\t\twhile (iterations-- > 0) {\n\n\t\t\tyw = yi = 0;\n\t\t\tvar ms = mtx;\n\t\t\tvar ss = stx;\n\t\t\tfor (y = h; --y > -1;) {\n\t\t\t\tr = rxp1 * (pr = px[(yi) | 0]);\n\t\t\t\tg = rxp1 * (pg = px[(yi + 1) | 0]);\n\t\t\t\tb = rxp1 * (pb = px[(yi + 2) | 0]);\n\t\t\t\ta = rxp1 * (pa = px[(yi + 3) | 0]);\n\n\t\t\t\tsx = ssx;\n\n\t\t\t\tfor( i = rxp1; --i > -1; )\n\t\t\t\t{\n\t\t\t\t\tsx.r = pr;\n\t\t\t\t\tsx.g = pg;\n\t\t\t\t\tsx.b = pb;\n\t\t\t\t\tsx.a = pa;\n\t\t\t\t\tsx = sx.n;\n\t\t\t\t}\n\n\t\t\t\tfor( i = 1; i < rxp1; i++ )\n\t\t\t\t{\n\t\t\t\t\tp = (yi + ((w1 < i ? w1 : i) << 2)) | 0;\n\t\t\t\t\tr += ( sx.r = px[p]);\n\t\t\t\t\tg += ( sx.g = px[p+1]);\n\t\t\t\t\tb += ( sx.b = px[p+2]);\n\t\t\t\t\ta += ( sx.a = px[p+3]);\n\n\t\t\t\t\tsx = sx.n;\n\t\t\t\t}\n\n\t\t\t\tsi = ssx;\n\t\t\t\tfor ( x = 0; x < w; x++ )\n\t\t\t\t{\n\t\t\t\t\tpx[yi++] = (r * ms) >>> ss;\n\t\t\t\t\tpx[yi++] = (g * ms) >>> ss;\n\t\t\t\t\tpx[yi++] = (b * ms) >>> ss;\n\t\t\t\t\tpx[yi++] = (a * ms) >>> ss;\n\n\t\t\t\t\tp = ((yw + ((p = x + radiusX + 1) < w1 ? p : w1)) << 2);\n\n\t\t\t\t\tr -= si.r - ( si.r = px[p]);\n\t\t\t\t\tg -= si.g - ( si.g = px[p+1]);\n\t\t\t\t\tb -= si.b - ( si.b = px[p+2]);\n\t\t\t\t\ta -= si.a - ( si.a = px[p+3]);\n\n\t\t\t\t\tsi = si.n;\n\n\t\t\t\t}\n\t\t\t\tyw += w;\n\t\t\t}\n\n\t\t\tms = mty;\n\t\t\tss = sty;\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tyi = (x << 2) | 0;\n\n\t\t\t\tr = (ryp1 * (pr = px[yi])) | 0;\n\t\t\t\tg = (ryp1 * (pg = px[(yi + 1) | 0])) | 0;\n\t\t\t\tb = (ryp1 * (pb = px[(yi + 2) | 0])) | 0;\n\t\t\t\ta = (ryp1 * (pa = px[(yi + 3) | 0])) | 0;\n\n\t\t\t\tsy = ssy;\n\t\t\t\tfor( i = 0; i < ryp1; i++ )\n\t\t\t\t{\n\t\t\t\t\tsy.r = pr;\n\t\t\t\t\tsy.g = pg;\n\t\t\t\t\tsy.b = pb;\n\t\t\t\t\tsy.a = pa;\n\t\t\t\t\tsy = sy.n;\n\t\t\t\t}\n\n\t\t\t\typ = w;\n\n\t\t\t\tfor( i = 1; i <= radiusY; i++ )\n\t\t\t\t{\n\t\t\t\t\tyi = ( yp + x ) << 2;\n\n\t\t\t\t\tr += ( sy.r = px[yi]);\n\t\t\t\t\tg += ( sy.g = px[yi+1]);\n\t\t\t\t\tb += ( sy.b = px[yi+2]);\n\t\t\t\t\ta += ( sy.a = px[yi+3]);\n\n\t\t\t\t\tsy = sy.n;\n\n\t\t\t\t\tif( i < h1 )\n\t\t\t\t\t{\n\t\t\t\t\t\typ += w;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tyi = x;\n\t\t\t\tsi = ssy;\n\t\t\t\tif ( iterations > 0 )\n\t\t\t\t{\n\t\t\t\t\tfor ( y = 0; y < h; y++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tp = yi << 2;\n\t\t\t\t\t\tpx[p+3] = pa =(a * ms) >>> ss;\n\t\t\t\t\t\tif ( pa > 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpx[p]   = ((r * ms) >>> ss );\n\t\t\t\t\t\t\tpx[p+1] = ((g * ms) >>> ss );\n\t\t\t\t\t\t\tpx[p+2] = ((b * ms) >>> ss );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpx[p] = px[p+1] = px[p+2] = 0\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tp = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;\n\n\t\t\t\t\t\tr -= si.r - ( si.r = px[p]);\n\t\t\t\t\t\tg -= si.g - ( si.g = px[p+1]);\n\t\t\t\t\t\tb -= si.b - ( si.b = px[p+2]);\n\t\t\t\t\t\ta -= si.a - ( si.a = px[p+3]);\n\n\t\t\t\t\t\tsi = si.n;\n\n\t\t\t\t\t\tyi += w;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( y = 0; y < h; y++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tp = yi << 2;\n\t\t\t\t\t\tpx[p+3] = pa =(a * ms) >>> ss;\n\t\t\t\t\t\tif ( pa > 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpa = 255 / pa;\n\t\t\t\t\t\t\tpx[p]   = ((r * ms) >>> ss ) * pa;\n\t\t\t\t\t\t\tpx[p+1] = ((g * ms) >>> ss ) * pa;\n\t\t\t\t\t\t\tpx[p+2] = ((b * ms) >>> ss ) * pa;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpx[p] = px[p+1] = px[p+2] = 0\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tp = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;\n\n\t\t\t\t\t\tr -= si.r - ( si.r = px[p]);\n\t\t\t\t\t\tg -= si.g - ( si.g = px[p+1]);\n\t\t\t\t\t\tb -= si.b - ( si.b = px[p+2]);\n\t\t\t\t\t\ta -= si.a - ( si.a = px[p+3]);\n\n\t\t\t\t\t\tsi = si.n;\n\n\t\t\t\t\t\tyi += w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn true;\n\t};\n\n\tcreatejs.BlurFilter = createjs.promote(BlurFilter, \"Filter\");\n}());\n\n//##############################################################################\n// AlphaMapFilter.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\t\n\t\n// constructor:\n\t/**\n\t * Applies a greyscale alpha map image (or canvas) to the target, such that the alpha channel of the result will\n\t * be copied from the red channel of the map, and the RGB channels will be copied from the target.\n\t *\n\t * Generally, it is recommended that you use {{#crossLink \"AlphaMaskFilter\"}}{{/crossLink}}, because it has much\n\t * better performance.\n\t *\n\t * <h4>Example</h4>\n\t * This example draws a red->blue box, caches it, and then uses the cache canvas as an alpha map on a 100x100 image.\n\t *\n\t *       var box = new createjs.Shape();\n\t *       box.graphics.beginLinearGradientFill([\"#ff0000\", \"#0000ff\"], [0, 1], 0, 0, 0, 100)\n\t *       box.graphics.drawRect(0, 0, 100, 100);\n\t *       box.cache(0, 0, 100, 100);\n\t *\n\t *       var bmp = new createjs.Bitmap(\"path/to/image.jpg\");\n\t *       bmp.filters = [\n\t *           new createjs.AlphaMapFilter(box.cacheCanvas)\n\t *       ];\n\t *       bmp.cache(0, 0, 100, 100);\n\t *       stage.addChild(bmp);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for more information on applying filters.\n\t * @class AlphaMapFilter\n\t * @extends Filter\n\t * @constructor\n\t * @param {HTMLImageElement|HTMLCanvasElement} alphaMap The greyscale image (or canvas) to use as the alpha value for the\n\t * result. This should be exactly the same dimensions as the target.\n\t **/\n\tfunction AlphaMapFilter(alphaMap) {\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The greyscale image (or canvas) to use as the alpha value for the result. This should be exactly the same\n\t\t * dimensions as the target.\n\t\t * @property alphaMap\n\t\t * @type HTMLImageElement|HTMLCanvasElement\n\t\t **/\n\t\tthis.alphaMap = alphaMap;\n\t\t\n\t\t\n\t// private properties:\n\t\t/**\n\t\t * @property _alphaMap\n\t\t * @protected\n\t\t * @type HTMLImageElement|HTMLCanvasElement\n\t\t **/\n\t\tthis._alphaMap = null;\n\t\t\n\t\t/**\n\t\t * @property _mapData\n\t\t * @protected\n\t\t * @type Uint8ClampedArray\n\t\t **/\n\t\tthis._mapData = null;\n\t}\n\tvar p = createjs.extend(AlphaMapFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/** docced in super class **/\n\tp.clone = function () {\n\t\tvar o = new AlphaMapFilter(this.alphaMap);\n\t\to._alphaMap = this._alphaMap;\n\t\to._mapData = this._mapData;\n\t\treturn o;\n\t};\n\n\t/** docced in super class **/\n\tp.toString = function () {\n\t\treturn \"[AlphaMapFilter]\";\n\t};\n\n\n// private methods:\n\t/** docced in super class **/\n\tp._applyFilter = function (imageData) {\n\t\tif (!this.alphaMap) { return true; }\n\t\tif (!this._prepAlphaMap()) { return false; }\n\t\t\n\t\t// TODO: update to support scenarios where the target has different dimensions.\n\t\tvar data = imageData.data;\n\t\tvar map = this._mapData;\n\t\tfor(var i=0, l=data.length; i<l; i += 4) { data[i + 3] = map[i] || 0; }\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t * @method _prepAlphaMap\n\t * @protected\n\t **/\n\tp._prepAlphaMap = function () {\n\t\tif (!this.alphaMap) { return false; }\n\t\tif (this.alphaMap == this._alphaMap && this._mapData) { return true; }\n\n\t\tthis._mapData = null;\n\t\tvar map = this._alphaMap = this.alphaMap;\n\t\tvar canvas = map;\n\t\tvar ctx;\n\t\tif (map instanceof HTMLCanvasElement) {\n\t\t\tctx = canvas.getContext(\"2d\");\n\t\t} else {\n\t\t\tcanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement(\"canvas\");\n\t\t\tcanvas.width = map.width;\n\t\t\tcanvas.height = map.height;\n\t\t\tctx = canvas.getContext(\"2d\");\n\t\t\tctx.drawImage(map, 0, 0);\n\t\t}\n\n\t\ttry {\n\t\t\tvar imgData = ctx.getImageData(0, 0, map.width, map.height);\n\t\t} catch (e) {\n\t\t\t//if (!this.suppressCrossDomainErrors) throw new Error(\"unable to access local image data: \" + e);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis._mapData = imgData.data;\n\t\treturn true;\n\t};\n\n\n\tcreatejs.AlphaMapFilter = createjs.promote(AlphaMapFilter, \"Filter\");\n}());\n\n//##############################################################################\n// AlphaMaskFilter.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Applies the alpha from the mask image (or canvas) to the target, such that the alpha channel of the result will\n\t * be derived from the mask, and the RGB channels will be copied from the target. This can be used, for example, to\n\t * apply an alpha mask to a display object. This can also be used to combine a JPG compressed RGB image with a PNG32\n\t * alpha mask, which can result in a much smaller file size than a single PNG32 containing ARGB.\n\t *\n\t * <b>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters correctly.</b>\n\t *\n\t * <h4>Example</h4>\n\t * This example draws a gradient box, then caches it and uses the \"cacheCanvas\" as the alpha mask on a 100x100 image.\n\t *\n\t *      var box = new createjs.Shape();\n\t *      box.graphics.beginLinearGradientFill([\"#000000\", \"rgba(0, 0, 0, 0)\"], [0, 1], 0, 0, 100, 100)\n\t *      box.graphics.drawRect(0, 0, 100, 100);\n\t *      box.cache(0, 0, 100, 100);\n\t *\n\t *      var bmp = new createjs.Bitmap(\"path/to/image.jpg\");\n\t *      bmp.filters = [\n\t *          new createjs.AlphaMaskFilter(box.cacheCanvas)\n\t *      ];\n\t *      bmp.cache(0, 0, 100, 100);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for more information on applying filters.\n\t * @class AlphaMaskFilter\n\t * @extends Filter\n\t * @constructor\n\t * @param {HTMLImageElement|HTMLCanvasElement} mask\n\t **/\n\tfunction AlphaMaskFilter(mask) {\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The image (or canvas) to use as the mask.\n\t\t * @property mask\n\t\t * @type HTMLImageElement|HTMLCanvasElement\n\t\t **/\n\t\tthis.mask = mask;\n\t}\n\tvar p = createjs.extend(AlphaMaskFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\n// public methods:\n\t/**\n\t * Applies the filter to the specified context.\n\t *\n\t * <strong>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters\n\t * correctly.</strong>\n\t * @method applyFilter\n\t * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.\n\t * @param {Number} x The x position to use for the source rect.\n\t * @param {Number} y The y position to use for the source rect.\n\t * @param {Number} width The width to use for the source rect.\n\t * @param {Number} height The height to use for the source rect.\n\t * @param {CanvasRenderingContext2D} [targetCtx] NOT SUPPORTED IN THIS FILTER. The 2D context to draw the result to. Defaults to the context passed to ctx.\n\t * @param {Number} [targetX] NOT SUPPORTED IN THIS FILTER. The x position to draw the result to. Defaults to the value passed to x.\n\t * @param {Number} [targetY] NOT SUPPORTED IN THIS FILTER. The y position to draw the result to. Defaults to the value passed to y.\n\t * @return {Boolean} If the filter was applied successfully.\n\t **/\n\tp.applyFilter = function (ctx, x, y, width, height, targetCtx, targetX, targetY) {\n\t\tif (!this.mask) { return true; }\n\t\ttargetCtx = targetCtx || ctx;\n\t\tif (targetX == null) { targetX = x; }\n\t\tif (targetY == null) { targetY = y; }\n\n\t\ttargetCtx.save();\n\t\tif (ctx != targetCtx) {\n\t\t\t// TODO: support targetCtx and targetX/Y\n\t\t\t// clearRect, then draw the ctx in?\n\t\t\treturn false;\n\t\t}\n\n\t\ttargetCtx.globalCompositeOperation = \"destination-in\";\n\t\ttargetCtx.drawImage(this.mask, targetX, targetY);\n\t\ttargetCtx.restore();\n\t\treturn true;\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function () {\n\t\treturn new AlphaMaskFilter(this.mask);\n\t};\n\n\t/** docced in super class **/\n\tp.toString = function () {\n\t\treturn \"[AlphaMaskFilter]\";\n\t};\n\n\n\tcreatejs.AlphaMaskFilter = createjs.promote(AlphaMaskFilter, \"Filter\");\n}());\n\n//##############################################################################\n// ColorFilter.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Applies a color transform to DisplayObjects.\n\t *\n\t * <h4>Example</h4>\n\t * This example draws a red circle, and then transforms it to Blue. This is accomplished by multiplying all the channels\n\t * to 0 (except alpha, which is set to 1), and then adding 255 to the blue channel.\n\t *\n\t *      var shape = new createjs.Shape().set({x:100,y:100});\n\t *      shape.graphics.beginFill(\"#ff0000\").drawCircle(0,0,50);\n\t *\n\t *      shape.filters = [\n\t *          new createjs.ColorFilter(0,0,0,1, 0,0,255,0)\n\t *      ];\n\t *      shape.cache(-50, -50, 100, 100);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for an more information on applying filters.\n\t * @class ColorFilter\n\t * @param {Number} [redMultiplier=1] The amount to multiply against the red channel. This is a range between 0 and 1.\n\t * @param {Number} [greenMultiplier=1] The amount to multiply against the green channel. This is a range between 0 and 1.\n\t * @param {Number} [blueMultiplier=1] The amount to multiply against the blue channel. This is a range between 0 and 1.\n\t * @param {Number} [alphaMultiplier=1] The amount to multiply against the alpha channel. This is a range between 0 and 1.\n\t * @param {Number} [redOffset=0] The amount to add to the red channel after it has been multiplied. This is a range\n\t * between -255 and 255.\n\t * @param {Number} [greenOffset=0] The amount to add to the green channel after it has been multiplied. This is a range\n\t  * between -255 and 255.\n\t * @param {Number} [blueOffset=0] The amount to add to the blue channel after it has been multiplied. This is a range\n\t  * between -255 and 255.\n\t * @param {Number} [alphaOffset=0] The amount to add to the alpha channel after it has been multiplied. This is a range\n\t  * between -255 and 255.\n\t * @constructor\n\t * @extends Filter\n\t **/\n\tfunction ColorFilter(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {\n\t\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * Red channel multiplier.\n\t\t * @property redMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.redMultiplier = redMultiplier != null ? redMultiplier : 1;\n\t\n\t\t/**\n\t\t * Green channel multiplier.\n\t\t * @property greenMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.greenMultiplier = greenMultiplier != null ? greenMultiplier : 1;\n\t\n\t\t/**\n\t\t * Blue channel multiplier.\n\t\t * @property blueMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.blueMultiplier = blueMultiplier != null ? blueMultiplier : 1;\n\t\n\t\t/**\n\t\t * Alpha channel multiplier.\n\t\t * @property alphaMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.alphaMultiplier = alphaMultiplier != null ? alphaMultiplier : 1;\n\t\n\t\t/**\n\t\t * Red channel offset (added to value).\n\t\t * @property redOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.redOffset = redOffset || 0;\n\t\n\t\t/**\n\t\t * Green channel offset (added to value).\n\t\t * @property greenOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.greenOffset = greenOffset || 0;\n\t\n\t\t/**\n\t\t * Blue channel offset (added to value).\n\t\t * @property blueOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.blueOffset = blueOffset || 0;\n\t\n\t\t/**\n\t\t * Alpha channel offset (added to value).\n\t\t * @property alphaOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.alphaOffset = alphaOffset || 0;\n\t}\n\tvar p = createjs.extend(ColorFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/** docced in super class **/\n\tp.toString = function() {\n\t\treturn \"[ColorFilter]\";\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function() {\n\t\treturn new ColorFilter(this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier, this.redOffset, this.greenOffset, this.blueOffset, this.alphaOffset);\n\t};\n\t\n\n// private methods:\n\t/** docced in super class **/\n\tp._applyFilter = function(imageData) {\n\t\tvar data = imageData.data;\n\t\tvar l = data.length;\n\t\tfor (var i=0; i<l; i+=4) {\n\t\t\tdata[i] = data[i]*this.redMultiplier+this.redOffset;\n\t\t\tdata[i+1] = data[i+1]*this.greenMultiplier+this.greenOffset;\n\t\t\tdata[i+2] = data[i+2]*this.blueMultiplier+this.blueOffset;\n\t\t\tdata[i+3] = data[i+3]*this.alphaMultiplier+this.alphaOffset;\n\t\t}\n\t\treturn true;\n\t};\n\n\n\tcreatejs.ColorFilter = createjs.promote(ColorFilter, \"Filter\");\n}());\n\n//##############################################################################\n// ColorMatrix.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Provides helper functions for assembling a matrix for use with the {{#crossLink \"ColorMatrixFilter\"}}{{/crossLink}}.\n\t * Most methods return the instance to facilitate chained calls.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myColorMatrix.adjustHue(20).adjustBrightness(50);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for an example of how to apply filters, or {{#crossLink \"ColorMatrixFilter\"}}{{/crossLink}}\n\t * for an example of how to use ColorMatrix to change a DisplayObject's color.\n\t * @class ColorMatrix\n\t * @param {Number} brightness\n\t * @param {Number} contrast\n\t * @param {Number} saturation\n\t * @param {Number} hue\n\t * @constructor\n\t **/\n\tfunction ColorMatrix(brightness, contrast, saturation, hue) {\n\t\tthis.setColor(brightness, contrast, saturation, hue);\n\t}\n\tvar p = ColorMatrix.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// constants:\n\t/**\n\t * Array of delta values for contrast calculations.\n\t * @property DELTA_INDEX\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tColorMatrix.DELTA_INDEX = [\n\t\t0,    0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1,  0.11,\n\t\t0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24,\n\t\t0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42,\n\t\t0.44, 0.46, 0.48, 0.5,  0.53, 0.56, 0.59, 0.62, 0.65, 0.68,\n\t\t0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98,\n\t\t1.0,  1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54,\n\t\t1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0,  2.12, 2.25,\n\t\t2.37, 2.50, 2.62, 2.75, 2.87, 3.0,  3.2,  3.4,  3.6,  3.8,\n\t\t4.0,  4.3,  4.7,  4.9,  5.0,  5.5,  6.0,  6.5,  6.8,  7.0,\n\t\t7.3,  7.5,  7.8,  8.0,  8.4,  8.7,  9.0,  9.4,  9.6,  9.8,\n\t\t10.0\n\t];\n\n\t/**\n\t * Identity matrix values.\n\t * @property IDENTITY_MATRIX\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tColorMatrix.IDENTITY_MATRIX = [\n\t\t1,0,0,0,0,\n\t\t0,1,0,0,0,\n\t\t0,0,1,0,0,\n\t\t0,0,0,1,0,\n\t\t0,0,0,0,1\n\t];\n\n\t/**\n\t * The constant length of a color matrix.\n\t * @property LENGTH\n\t * @type Number\n\t * @protected\n\t * @static\n\t **/\n\tColorMatrix.LENGTH = ColorMatrix.IDENTITY_MATRIX.length;\n\n\n// public methods:\n\t/**\n\t * Resets the instance with the specified values.\n\t * @method setColor\n\t * @param {Number} brightness\n\t * @param {Number} contrast\n\t * @param {Number} saturation\n\t * @param {Number} hue\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tp.setColor = function(brightness,contrast,saturation,hue) {\n\t\treturn this.reset().adjustColor(brightness,contrast,saturation,hue);\n\t};\n\n\t/**\n\t * Resets the matrix to identity values.\n\t * @method reset\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tp.reset = function() {\n\t\treturn this.copy(ColorMatrix.IDENTITY_MATRIX);\n\t};\n\n\t/**\n\t * Shortcut method to adjust brightness, contrast, saturation and hue.\n\t * Equivalent to calling adjustHue(hue), adjustContrast(contrast),\n\t * adjustBrightness(brightness), adjustSaturation(saturation), in that order.\n\t * @method adjustColor\n\t * @param {Number} brightness\n\t * @param {Number} contrast\n\t * @param {Number} saturation\n\t * @param {Number} hue\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustColor = function(brightness,contrast,saturation,hue) {\n\t\tthis.adjustHue(hue);\n\t\tthis.adjustContrast(contrast);\n\t\tthis.adjustBrightness(brightness);\n\t\treturn this.adjustSaturation(saturation);\n\t};\n\n\t/**\n\t * Adjusts the brightness of pixel color by adding the specified value to the red, green and blue channels.\n\t * Positive values will make the image brighter, negative values will make it darker.\n\t * @method adjustBrightness\n\t * @param {Number} value A value between -255 & 255 that will be added to the RGB channels.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustBrightness = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,255);\n\t\tthis._multiplyMatrix([\n\t\t\t1,0,0,0,value,\n\t\t\t0,1,0,0,value,\n\t\t\t0,0,1,0,value,\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Adjusts the contrast of pixel color.\n\t * Positive values will increase contrast, negative values will decrease contrast.\n\t * @method adjustContrast\n\t * @param {Number} value A value between -100 & 100.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustContrast = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,100);\n\t\tvar x;\n\t\tif (value<0) {\n\t\t\tx = 127+value/100*127;\n\t\t} else {\n\t\t\tx = value%1;\n\t\t\tif (x == 0) {\n\t\t\t\tx = ColorMatrix.DELTA_INDEX[value];\n\t\t\t} else {\n\t\t\t\tx = ColorMatrix.DELTA_INDEX[(value<<0)]*(1-x)+ColorMatrix.DELTA_INDEX[(value<<0)+1]*x; // use linear interpolation for more granularity.\n\t\t\t}\n\t\t\tx = x*127+127;\n\t\t}\n\t\tthis._multiplyMatrix([\n\t\t\tx/127,0,0,0,0.5*(127-x),\n\t\t\t0,x/127,0,0,0.5*(127-x),\n\t\t\t0,0,x/127,0,0.5*(127-x),\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Adjusts the color saturation of the pixel.\n\t * Positive values will increase saturation, negative values will decrease saturation (trend towards greyscale).\n\t * @method adjustSaturation\n\t * @param {Number} value A value between -100 & 100.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustSaturation = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,100);\n\t\tvar x = 1+((value > 0) ? 3*value/100 : value/100);\n\t\tvar lumR = 0.3086;\n\t\tvar lumG = 0.6094;\n\t\tvar lumB = 0.0820;\n\t\tthis._multiplyMatrix([\n\t\t\tlumR*(1-x)+x,lumG*(1-x),lumB*(1-x),0,0,\n\t\t\tlumR*(1-x),lumG*(1-x)+x,lumB*(1-x),0,0,\n\t\t\tlumR*(1-x),lumG*(1-x),lumB*(1-x)+x,0,0,\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\n\t/**\n\t * Adjusts the hue of the pixel color.\n\t * @method adjustHue\n\t * @param {Number} value A value between -180 & 180.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustHue = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,180)/180*Math.PI;\n\t\tvar cosVal = Math.cos(value);\n\t\tvar sinVal = Math.sin(value);\n\t\tvar lumR = 0.213;\n\t\tvar lumG = 0.715;\n\t\tvar lumB = 0.072;\n\t\tthis._multiplyMatrix([\n\t\t\tlumR+cosVal*(1-lumR)+sinVal*(-lumR),lumG+cosVal*(-lumG)+sinVal*(-lumG),lumB+cosVal*(-lumB)+sinVal*(1-lumB),0,0,\n\t\t\tlumR+cosVal*(-lumR)+sinVal*(0.143),lumG+cosVal*(1-lumG)+sinVal*(0.140),lumB+cosVal*(-lumB)+sinVal*(-0.283),0,0,\n\t\t\tlumR+cosVal*(-lumR)+sinVal*(-(1-lumR)),lumG+cosVal*(-lumG)+sinVal*(lumG),lumB+cosVal*(1-lumB)+sinVal*(lumB),0,0,\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Concatenates (multiplies) the specified matrix with this one.\n\t * @method concat\n\t * @param {Array} matrix An array or ColorMatrix instance.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.concat = function(matrix) {\n\t\tmatrix = this._fixMatrix(matrix);\n\t\tif (matrix.length != ColorMatrix.LENGTH) { return this; }\n\t\tthis._multiplyMatrix(matrix);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns a clone of this ColorMatrix.\n\t * @method clone\n\t * @return {ColorMatrix} A clone of this ColorMatrix.\n\t **/\n\tp.clone = function() {\n\t\treturn (new ColorMatrix()).copy(this);\n\t};\n\n\t/**\n\t * Return a length 25 (5x5) array instance containing this matrix's values.\n\t * @method toArray\n\t * @return {Array} An array holding this matrix's values.\n\t **/\n\tp.toArray = function() {\n\t\tvar arr = [];\n\t\tfor (var i= 0, l=ColorMatrix.LENGTH; i<l; i++) {\n\t\t\tarr[i] = this[i];\n\t\t}\n\t\treturn arr;\n\t};\n\n\t/**\n\t * Copy the specified matrix's values to this matrix.\n\t * @method copy\n\t * @param {Array} matrix An array or ColorMatrix instance.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.copy = function(matrix) {\n\t\tvar l = ColorMatrix.LENGTH;\n\t\tfor (var i=0;i<l;i++) {\n\t\t\tthis[i] = matrix[i];\n\t\t}\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[ColorMatrix]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _multiplyMatrix\n\t * @param {Array} matrix\n\t * @protected\n\t **/\n\tp._multiplyMatrix = function(matrix) {\n\t\tvar i, j, k, col = [];\n\n\t\tfor (i=0;i<5;i++) {\n\t\t\tfor (j=0;j<5;j++) {\n\t\t\t\tcol[j] = this[j+i*5];\n\t\t\t}\n\t\t\tfor (j=0;j<5;j++) {\n\t\t\t\tvar val=0;\n\t\t\t\tfor (k=0;k<5;k++) {\n\t\t\t\t\tval += matrix[j+k*5]*col[k];\n\t\t\t\t}\n\t\t\t\tthis[j+i*5] = val;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Make sure values are within the specified range, hue has a limit of 180, brightness is 255, others are 100.\n\t * @method _cleanValue\n\t * @param {Number} value The raw number\n\t * @param {Number} limit The maximum that the number can be. The minimum is the limit * -1.\n\t * @protected\n\t **/\n\tp._cleanValue = function(value, limit) {\n\t\treturn Math.min(limit,Math.max(-limit,value));\n\t};\n\n\t/**\n\t * Makes sure matrixes are 5x5 (25 long).\n\t * @method _fixMatrix\n\t * @param {Array} matrix\n\t * @protected\n\t **/\n\tp._fixMatrix = function(matrix) {\n\t\tif (matrix instanceof ColorMatrix) { matrix = matrix.toArray(); }\n\t\tif (matrix.length < ColorMatrix.LENGTH) {\n\t\t\tmatrix = matrix.slice(0,matrix.length).concat(ColorMatrix.IDENTITY_MATRIX.slice(matrix.length,ColorMatrix.LENGTH));\n\t\t} else if (matrix.length > ColorMatrix.LENGTH) {\n\t\t\tmatrix = matrix.slice(0,ColorMatrix.LENGTH);\n\t\t}\n\t\treturn matrix;\n\t};\n\n\n\tcreatejs.ColorMatrix = ColorMatrix;\n}());\n\n//##############################################################################\n// ColorMatrixFilter.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Allows you to carry out complex color operations such as modifying saturation, brightness, or inverting. See the\n\t * {{#crossLink \"ColorMatrix\"}}{{/crossLink}} for more information on changing colors. For an easier color transform,\n\t * consider the {{#crossLink \"ColorFilter\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t * This example creates a red circle, inverts its hue, and then saturates it to brighten it up.\n\t *\n\t *      var shape = new createjs.Shape().set({x:100,y:100});\n\t *      shape.graphics.beginFill(\"#ff0000\").drawCircle(0,0,50);\n\t *\n\t *      var matrix = new createjs.ColorMatrix().adjustHue(180).adjustSaturation(100);\n\t *      shape.filters = [\n\t *          new createjs.ColorMatrixFilter(matrix)\n\t *      ];\n\t *\n\t *      shape.cache(-50, -50, 100, 100);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for an more information on applying filters.\n\t * @class ColorMatrixFilter\n\t * @constructor\n\t * @extends Filter\n\t * @param {Array | ColorMatrix} matrix A 4x5 matrix describing the color operation to perform. See also the {{#crossLink \"ColorMatrix\"}}{{/crossLink}}\n\t * class.\n\t **/\n\tfunction ColorMatrixFilter(matrix) {\n\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * A 4x5 matrix describing the color operation to perform. See also the {{#crossLink \"ColorMatrix\"}}{{/crossLink}}\n\t\t * @property matrix\n\t\t * @type Array | ColorMatrix\n\t\t **/\n\t\tthis.matrix = matrix;\n\t}\n\tvar p = createjs.extend(ColorMatrixFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\n// public methods:\n\t/** docced in super class **/\n\tp.toString = function() {\n\t\treturn \"[ColorMatrixFilter]\";\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function() {\n\t\treturn new ColorMatrixFilter(this.matrix);\n\t};\n\n// private methods:\n\t/** docced in super class **/\n\tp._applyFilter = function(imageData) { \n\t\tvar data = imageData.data;\n\t\tvar l = data.length;\n\t\tvar r,g,b,a;\n\t\tvar mtx = this.matrix;\n\t\tvar m0 =  mtx[0],  m1 =  mtx[1],  m2 =  mtx[2],  m3 =  mtx[3],  m4 =  mtx[4];\n\t\tvar m5 =  mtx[5],  m6 =  mtx[6],  m7 =  mtx[7],  m8 =  mtx[8],  m9 =  mtx[9];\n\t\tvar m10 = mtx[10], m11 = mtx[11], m12 = mtx[12], m13 = mtx[13], m14 = mtx[14];\n\t\tvar m15 = mtx[15], m16 = mtx[16], m17 = mtx[17], m18 = mtx[18], m19 = mtx[19];\n\n\t\tfor (var i=0; i<l; i+=4) {\n\t\t\tr = data[i];\n\t\t\tg = data[i+1];\n\t\t\tb = data[i+2];\n\t\t\ta = data[i+3];\n\t\t\tdata[i] = r*m0+g*m1+b*m2+a*m3+m4; // red\n\t\t\tdata[i+1] = r*m5+g*m6+b*m7+a*m8+m9; // green\n\t\t\tdata[i+2] = r*m10+g*m11+b*m12+a*m13+m14; // blue\n\t\t\tdata[i+3] = r*m15+g*m16+b*m17+a*m18+m19; // alpha\n\t\t}\n\t\treturn true;\n\t};\n\n\n\tcreatejs.ColorMatrixFilter = createjs.promote(ColorMatrixFilter, \"Filter\");\n}());\n\n//##############################################################################\n// Touch.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n * Global utility for working with multi-touch enabled devices in EaselJS. Currently supports W3C Touch API (iOS and\n * modern Android browser) and the Pointer API (IE), including ms-prefixed events in IE10, and unprefixed in IE11.\n *\n * Ensure that you {{#crossLink \"Touch/disable\"}}{{/crossLink}} touch when cleaning up your application. You do not have\n * to check if touch is supported to enable it, as it will fail gracefully if it is not supported.\n *\n * <h4>Example</h4>\n *\n *      var stage = new createjs.Stage(\"canvasId\");\n *      createjs.Touch.enable(stage);\n *\n * <strong>Note:</strong> It is important to disable Touch on a stage that you are no longer using:\n *\n *      createjs.Touch.disable(stage);\n *\n * @class Touch\n * @static\n **/\n\tfunction Touch() {\n\t\tthrow \"Touch cannot be instantiated\";\n\t}\n\n\n// public static methods:\n\t/**\n\t * Returns `true` if touch is supported in the current browser.\n\t * @method isSupported\n\t * @return {Boolean} Indicates whether touch is supported in the current browser.\n\t * @static\n\t **/\n\tTouch.isSupported = function() {\n\t\treturn\t!!(('ontouchstart' in window) // iOS & Android\n\t\t\t|| (window.navigator['msPointerEnabled'] && window.navigator['msMaxTouchPoints'] > 0) // IE10\n\t\t\t|| (window.navigator['pointerEnabled'] && window.navigator['maxTouchPoints'] > 0)); // IE11+\n\t};\n\n\t/**\n\t * Enables touch interaction for the specified EaselJS {{#crossLink \"Stage\"}}{{/crossLink}}. Currently supports iOS\n\t * (and compatible browsers, such as modern Android browsers), and IE10/11. Supports both single touch and\n\t * multi-touch modes. Extends the EaselJS {{#crossLink \"MouseEvent\"}}{{/crossLink}} model, but without support for\n\t * double click or over/out events. See the MouseEvent {{#crossLink \"MouseEvent/pointerId:property\"}}{{/crossLink}}\n\t * for more information.\n\t * @method enable\n\t * @param {Stage} stage The {{#crossLink \"Stage\"}}{{/crossLink}} to enable touch on.\n\t * @param {Boolean} [singleTouch=false] If `true`, only a single touch will be active at a time.\n\t * @param {Boolean} [allowDefault=false] If `true`, then default gesture actions (ex. scrolling, zooming) will be\n\t * allowed when the user is interacting with the target canvas.\n\t * @return {Boolean} Returns `true` if touch was successfully enabled on the target stage.\n\t * @static\n\t **/\n\tTouch.enable = function(stage, singleTouch, allowDefault) {\n\t\tif (!stage || !stage.canvas || !Touch.isSupported()) { return false; }\n\t\tif (stage.__touch) { return true; }\n\n\t\t// inject required properties on stage:\n\t\tstage.__touch = {pointers:{}, multitouch:!singleTouch, preventDefault:!allowDefault, count:0};\n\n\t\t// note that in the future we may need to disable the standard mouse event model before adding\n\t\t// these to prevent duplicate calls. It doesn't seem to be an issue with iOS devices though.\n\t\tif ('ontouchstart' in window) { Touch._IOS_enable(stage); }\n\t\telse if (window.navigator['msPointerEnabled'] || window.navigator[\"pointerEnabled\"]) { Touch._IE_enable(stage); }\n\t\treturn true;\n\t};\n\n\t/**\n\t * Removes all listeners that were set up when calling `Touch.enable()` on a stage.\n\t * @method disable\n\t * @param {Stage} stage The {{#crossLink \"Stage\"}}{{/crossLink}} to disable touch on.\n\t * @static\n\t **/\n\tTouch.disable = function(stage) {\n\t\tif (!stage) { return; }\n\t\tif ('ontouchstart' in window) { Touch._IOS_disable(stage); }\n\t\telse if (window.navigator['msPointerEnabled'] || window.navigator[\"pointerEnabled\"]) { Touch._IE_disable(stage); }\n\t\t\n\t\tdelete stage.__touch;\n\t};\n\n\n// Private static methods:\n\t/**\n\t * @method _IOS_enable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IOS_enable = function(stage) {\n\t\tvar canvas = stage.canvas;\n\t\tvar f = stage.__touch.f = function(e) { Touch._IOS_handleEvent(stage,e); };\n\t\tcanvas.addEventListener(\"touchstart\", f, false);\n\t\tcanvas.addEventListener(\"touchmove\", f, false);\n\t\tcanvas.addEventListener(\"touchend\", f, false);\n\t\tcanvas.addEventListener(\"touchcancel\", f, false);\n\t};\n\n\t/**\n\t * @method _IOS_disable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IOS_disable = function(stage) {\n\t\tvar canvas = stage.canvas;\n\t\tif (!canvas) { return; }\n\t\tvar f = stage.__touch.f;\n\t\tcanvas.removeEventListener(\"touchstart\", f, false);\n\t\tcanvas.removeEventListener(\"touchmove\", f, false);\n\t\tcanvas.removeEventListener(\"touchend\", f, false);\n\t\tcanvas.removeEventListener(\"touchcancel\", f, false);\n\t};\n\n\t/**\n\t * @method _IOS_handleEvent\n\t * @param {Stage} stage\n\t * @param {Object} e The event to handle\n\t * @protected\n\t * @static\n\t **/\n\tTouch._IOS_handleEvent = function(stage, e) {\n\t\tif (!stage) { return; }\n\t\tif (stage.__touch.preventDefault) { e.preventDefault&&e.preventDefault(); }\n\t\tvar touches = e.changedTouches;\n\t\tvar type = e.type;\n\t\tfor (var i= 0,l=touches.length; i<l; i++) {\n\t\t\tvar touch = touches[i];\n\t\t\tvar id = touch.identifier;\n\t\t\tif (touch.target != stage.canvas) { continue; }\n\n\t\t\tif (type == \"touchstart\") {\n\t\t\t\tthis._handleStart(stage, id, e, touch.pageX, touch.pageY);\n\t\t\t} else if (type == \"touchmove\") {\n\t\t\t\tthis._handleMove(stage, id, e, touch.pageX, touch.pageY);\n\t\t\t} else if (type == \"touchend\" || type == \"touchcancel\") {\n\t\t\t\tthis._handleEnd(stage, id, e);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _IE_enable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IE_enable = function(stage) {\n\t\tvar canvas = stage.canvas;\n\t\tvar f = stage.__touch.f = function(e) { Touch._IE_handleEvent(stage,e); };\n\n\t\tif (window.navigator[\"pointerEnabled\"] === undefined) {\n\t\t\tcanvas.addEventListener(\"MSPointerDown\", f, false);\n\t\t\twindow.addEventListener(\"MSPointerMove\", f, false);\n\t\t\twindow.addEventListener(\"MSPointerUp\", f, false);\n\t\t\twindow.addEventListener(\"MSPointerCancel\", f, false);\n\t\t\tif (stage.__touch.preventDefault) { canvas.style.msTouchAction = \"none\"; }\n\t\t} else {\n\t\t\tcanvas.addEventListener(\"pointerdown\", f, false);\n\t\t\twindow.addEventListener(\"pointermove\", f, false);\n\t\t\twindow.addEventListener(\"pointerup\", f, false);\n\t\t\twindow.addEventListener(\"pointercancel\", f, false);\n\t\t\tif (stage.__touch.preventDefault) { canvas.style.touchAction = \"none\"; }\n\n\t\t}\n\t\tstage.__touch.activeIDs = {};\n\t};\n\n\t/**\n\t * @method _IE_disable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IE_disable = function(stage) {\n\t\tvar f = stage.__touch.f;\n\n\t\tif (window.navigator[\"pointerEnabled\"] === undefined) {\n\t\t\twindow.removeEventListener(\"MSPointerMove\", f, false);\n\t\t\twindow.removeEventListener(\"MSPointerUp\", f, false);\n\t\t\twindow.removeEventListener(\"MSPointerCancel\", f, false);\n\t\t\tif (stage.canvas) {\n\t\t\t\tstage.canvas.removeEventListener(\"MSPointerDown\", f, false);\n\t\t\t}\n\t\t} else {\n\t\t\twindow.removeEventListener(\"pointermove\", f, false);\n\t\t\twindow.removeEventListener(\"pointerup\", f, false);\n\t\t\twindow.removeEventListener(\"pointercancel\", f, false);\n\t\t\tif (stage.canvas) {\n\t\t\t\tstage.canvas.removeEventListener(\"pointerdown\", f, false);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _IE_handleEvent\n\t * @param {Stage} stage\n\t * @param {Object} e The event to handle.\n\t * @protected\n\t * @static\n\t **/\n\tTouch._IE_handleEvent = function(stage, e) {\n\t\tif (!stage) { return; }\n\t\tif (stage.__touch.preventDefault) { e.preventDefault && e.preventDefault(); }\n\t\tvar type = e.type;\n\t\tvar id = e.pointerId;\n\t\tvar ids = stage.__touch.activeIDs;\n\n\t\tif (type == \"MSPointerDown\" || type == \"pointerdown\") {\n\t\t\tif (e.srcElement != stage.canvas) { return; }\n\t\t\tids[id] = true;\n\t\t\tthis._handleStart(stage, id, e, e.pageX, e.pageY);\n\t\t} else if (ids[id]) { // it's an id we're watching\n\t\t\tif (type == \"MSPointerMove\" || type == \"pointermove\") {\n\t\t\t\tthis._handleMove(stage, id, e, e.pageX, e.pageY);\n\t\t\t} else if (type == \"MSPointerUp\" || type == \"MSPointerCancel\"\n\t\t\t\t\t|| type == \"pointerup\" || type == \"pointercancel\") {\n\t\t\t\tdelete(ids[id]);\n\t\t\t\tthis._handleEnd(stage, id, e);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleStart\n\t * @param {Stage} stage\n\t * @param {String|Number} id\n\t * @param {Object} e\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @protected\n\t **/\n\tTouch._handleStart = function(stage, id, e, x, y) {\n\t\tvar props = stage.__touch;\n\t\tif (!props.multitouch && props.count) { return; }\n\t\tvar ids = props.pointers;\n\t\tif (ids[id]) { return; }\n\t\tids[id] = true;\n\t\tprops.count++;\n\t\tstage._handlePointerDown(id, e, x, y);\n\t};\n\n\t/**\n\t * @method _handleMove\n\t * @param {Stage} stage\n\t * @param {String|Number} id\n\t * @param {Object} e\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @protected\n\t **/\n\tTouch._handleMove = function(stage, id, e, x, y) {\n\t\tif (!stage.__touch.pointers[id]) { return; }\n\t\tstage._handlePointerMove(id, e, x, y);\n\t};\n\n\t/**\n\t * @method _handleEnd\n\t * @param {Stage} stage\n\t * @param {String|Number} id\n\t * @param {Object} e\n\t * @protected\n\t **/\n\tTouch._handleEnd = function(stage, id, e) {\n\t\t// TODO: cancel should be handled differently for proper UI (ex. an up would trigger a click, a cancel would more closely resemble an out).\n\t\tvar props = stage.__touch;\n\t\tvar ids = props.pointers;\n\t\tif (!ids[id]) { return; }\n\t\tprops.count--;\n\t\tstage._handlePointerUp(id, e, true);\n\t\tdelete(ids[id]);\n\t};\n\n\n\tcreatejs.Touch = Touch;\n}());\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of\n\t * the library.\n\t * @class EaselJS\n\t **/\n\tvar s = createjs.EaselJS = createjs.EaselJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type String\n\t * @static\n\t **/\n\ts.version = /*=version*/\"0.8.2\"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type String\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/\"Thu, 26 Nov 2015 20:44:34 GMT\"; // injected by build process\n\n})();\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of the library.\n\t * @class PreloadJS\n\t **/\n\tvar s = createjs.PreloadJS = createjs.PreloadJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type {String}\n\t * @static\n\t **/\n\ts.version = /*=version*/\"0.6.2\"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type {String}\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/\"Thu, 26 Nov 2015 20:44:31 GMT\"; // injected by build process\n\n})();\n\n//##############################################################################\n// proxy.js\n//##############################################################################\n\n/**\n * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the\n * createjs namespace directly.\n *\n * <h4>Example</h4>\n *\n *      myObject.addEventListener(\"change\", createjs.proxy(myMethod, scope));\n *\n * @class Utility Methods\n * @main Utility Methods\n */\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a\n\t * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the\n\t * method gets called in the correct scope.\n\t *\n\t * Additional arguments can be passed that will be applied to the function when it is called.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myObject.addEventListener(\"event\", createjs.proxy(myHandler, this, arg1, arg2));\n\t *\n\t *      function myHandler(arg1, arg2) {\n\t *           // This gets called when myObject.myCallback is executed.\n\t *      }\n\t *\n\t * @method proxy\n\t * @param {Function} method The function to call\n\t * @param {Object} scope The scope to call the method name on\n\t * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.\n\t * @public\n\t * @static\n\t */\n\tcreatejs.proxy = function (method, scope) {\n\t\tvar aArgs = Array.prototype.slice.call(arguments, 2);\n\t\treturn function () {\n\t\t\treturn method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));\n\t\t};\n\t}\n\n}());\n\n//##############################################################################\n// ErrorEvent.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * A general error {{#crossLink \"Event\"}}{{/crossLink}}, that describes an error that occurred, as well as any details.\n\t * @class ErrorEvent\n\t * @param {String} [title] The error title\n\t * @param {String} [message] The error description\n\t * @param {Object} [data] Additional error data\n\t * @constructor\n\t */\n\tfunction ErrorEvent(title, message, data) {\n\t\tthis.Event_constructor(\"error\");\n\n\t\t/**\n\t\t * The short error title, which indicates the type of error that occurred.\n\t\t * @property title\n\t\t * @type String\n\t\t */\n\t\tthis.title = title;\n\n\t\t/**\n\t\t * The verbose error message, containing details about the error.\n\t\t * @property message\n\t\t * @type String\n\t\t */\n\t\tthis.message = message;\n\n\t\t/**\n\t\t * Additional data attached to an error.\n\t\t * @property data\n\t\t * @type {Object}\n\t\t */\n\t\tthis.data = data;\n\t}\n\n\tvar p = createjs.extend(ErrorEvent, createjs.Event);\n\n\tp.clone = function() {\n\t\treturn new createjs.ErrorEvent(this.title, this.message, this.data);\n\t};\n\n\tcreatejs.ErrorEvent = createjs.promote(ErrorEvent, \"Event\");\n\n}());\n\n//##############################################################################\n// ProgressEvent.js\n//##############################################################################\n\n(function (scope) {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A CreateJS {{#crossLink \"Event\"}}{{/crossLink}} that is dispatched when progress changes.\n\t * @class ProgressEvent\n\t * @param {Number} loaded The amount that has been loaded. This can be any number relative to the total.\n\t * @param {Number} [total=1] The total amount that will load. This will default to 1, so if the `loaded` value is\n\t * a percentage (between 0 and 1), it can be omitted.\n\t * @todo Consider having this event be a \"fileprogress\" event as well\n\t * @constructor\n\t */\n\tfunction ProgressEvent(loaded, total) {\n\t\tthis.Event_constructor(\"progress\");\n\n\t\t/**\n\t\t * The amount that has been loaded (out of a total amount)\n\t\t * @property loaded\n\t\t * @type {Number}\n\t\t */\n\t\tthis.loaded = loaded;\n\n\t\t/**\n\t\t * The total \"size\" of the load.\n\t\t * @property total\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.total = (total == null) ? 1 : total;\n\n\t\t/**\n\t\t * The percentage (out of 1) that the load has been completed. This is calculated using `loaded/total`.\n\t\t * @property progress\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.progress = (total == 0) ? 0 : this.loaded / this.total;\n\t};\n\n\tvar p = createjs.extend(ProgressEvent, createjs.Event);\n\n\t/**\n\t * Returns a clone of the ProgressEvent instance.\n\t * @method clone\n\t * @return {ProgressEvent} a clone of the Event instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new createjs.ProgressEvent(this.loaded, this.total);\n\t};\n\n\tcreatejs.ProgressEvent = createjs.promote(ProgressEvent, \"Event\");\n\n}(window));\n\n//##############################################################################\n// json3.js\n//##############################################################################\n\n/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\n;(function () {\n  // Detect the `define` function exposed by asynchronous module loaders. The\n  // strict `define` check is necessary for compatibility with `r.js`.\n  var isLoader = \"function\" === \"function\" && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\");\n\n  // A set of types used to distinguish objects from primitives.\n  var objectTypes = {\n    \"function\": true,\n    \"object\": true\n  };\n\n  // Detect the `exports` object exposed by CommonJS implementations.\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  // Use the `global` object exposed by Node (including Browserify via\n  // `insert-module-globals`), Narwhal, and Ringo as the default context,\n  // and the `window` object in browsers. Rhino exports a `global` function\n  // instead.\n  var root = objectTypes[typeof window] && window || this,\n      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \"object\" && global;\n\n  if (freeGlobal && (freeGlobal[\"global\"] === freeGlobal || freeGlobal[\"window\"] === freeGlobal || freeGlobal[\"self\"] === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Public: Initializes JSON 3 using the given `context` object, attaching the\n  // `stringify` and `parse` functions to the specified `exports` object.\n  function runInContext(context, exports) {\n    context || (context = root[\"Object\"]());\n    exports || (exports = root[\"Object\"]());\n\n    // Native constructor aliases.\n    var Number = context[\"Number\"] || root[\"Number\"],\n        String = context[\"String\"] || root[\"String\"],\n        Object = context[\"Object\"] || root[\"Object\"],\n        Date = context[\"Date\"] || root[\"Date\"],\n        SyntaxError = context[\"SyntaxError\"] || root[\"SyntaxError\"],\n        TypeError = context[\"TypeError\"] || root[\"TypeError\"],\n        Math = context[\"Math\"] || root[\"Math\"],\n        nativeJSON = context[\"JSON\"] || root[\"JSON\"];\n\n    // Delegate to the native `stringify` and `parse` implementations.\n    if (typeof nativeJSON == \"object\" && nativeJSON) {\n      exports.stringify = nativeJSON.stringify;\n      exports.parse = nativeJSON.parse;\n    }\n\n    // Convenience aliases.\n    var objectProto = Object.prototype,\n        getClass = objectProto.toString,\n        isProperty, forEach, undef;\n\n    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n    var isExtended = new Date(-3509827334573292);\n    try {\n      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n      // results for certain dates in Opera >= 10.53.\n      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n        // Safari < 2.0.2 stores the internal millisecond time value correctly,\n        // but clips the values returned by the date methods to the range of\n        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n    } catch (exception) {}\n\n    // Internal: Determines whether the native `JSON.stringify` and `parse`\n    // implementations are spec-compliant. Based on work by Ken Snyder.\n    function has(name) {\n      if (has[name] !== undef) {\n        // Return cached feature test result.\n        return has[name];\n      }\n      var isSupported;\n      if (name == \"bug-string-char-index\") {\n        // IE <= 7 doesn't support accessing string characters using square\n        // bracket notation. IE 8 only supports this for primitives.\n        isSupported = \"a\"[0] != \"a\";\n      } else if (name == \"json\") {\n        // Indicates whether both `JSON.stringify` and `JSON.parse` are\n        // supported.\n        isSupported = has(\"json-stringify\") && has(\"json-parse\");\n      } else {\n        var value, serialized = '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}';\n        // Test `JSON.stringify`.\n        if (name == \"json-stringify\") {\n          var stringify = exports.stringify, stringifySupported = typeof stringify == \"function\" && isExtended;\n          if (stringifySupported) {\n            // A test function object with a custom `toJSON` method.\n            (value = function () {\n              return 1;\n            }).toJSON = value;\n            try {\n              stringifySupported =\n                // Firefox 3.1b1 and b2 serialize string, number, and boolean\n                // primitives as object literals.\n                stringify(0) === \"0\" &&\n                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n                // literals.\n                stringify(new Number()) === \"0\" &&\n                stringify(new String()) == '\"\"' &&\n                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n                // does not define a canonical JSON representation (this applies to\n                // objects with `toJSON` properties as well, *unless* they are nested\n                // within an object or array).\n                stringify(getClass) === undef &&\n                // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n                // FF 3.1b3 pass this test.\n                stringify(undef) === undef &&\n                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n                // respectively, if the value is omitted entirely.\n                stringify() === undef &&\n                // FF 3.1b1, 2 throw an error if the given value is not a number,\n                // string, array, object, Boolean, or `null` literal. This applies to\n                // objects with custom `toJSON` methods as well, unless they are nested\n                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n                // methods entirely.\n                stringify(value) === \"1\" &&\n                stringify([value]) == \"[1]\" &&\n                // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n                // `\"[null]\"`.\n                stringify([undef]) == \"[null]\" &&\n                // YUI 3.0.0b1 fails to serialize `null` literals.\n                stringify(null) == \"null\" &&\n                // FF 3.1b1, 2 halts serialization if an array contains a function:\n                // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n                // elides non-JSON values from objects and arrays, unless they\n                // define custom `toJSON` methods.\n                stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n                // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n                stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n                stringify(null, value) === \"1\" &&\n                stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n                // serialize extended years.\n                stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n                // The milliseconds are optional in ES 5, but required in 5.1.\n                stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n                // four-digit years instead of six-digit years. Credits: @Yaffle.\n                stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n                // values less than 1000. Credits: @Yaffle.\n                stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n            } catch (exception) {\n              stringifySupported = false;\n            }\n          }\n          isSupported = stringifySupported;\n        }\n        // Test `JSON.parse`.\n        if (name == \"json-parse\") {\n          var parse = exports.parse;\n          if (typeof parse == \"function\") {\n            try {\n              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n              // Conforming implementations should also coerce the initial argument to\n              // a string prior to parsing.\n              if (parse(\"0\") === 0 && !parse(false)) {\n                // Simple parsing test.\n                value = parse(serialized);\n                var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n                if (parseSupported) {\n                  try {\n                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                    parseSupported = !parse('\"\\t\"');\n                  } catch (exception) {}\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n                      // certain octal literals.\n                      parseSupported = parse(\"01\") !== 1;\n                    } catch (exception) {}\n                  }\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n                      // points. These environments, along with FF 3.1b1 and 2,\n                      // also allow trailing commas in JSON objects and arrays.\n                      parseSupported = parse(\"1.\") !== 1;\n                    } catch (exception) {}\n                  }\n                }\n              }\n            } catch (exception) {\n              parseSupported = false;\n            }\n          }\n          isSupported = parseSupported;\n        }\n      }\n      return has[name] = !!isSupported;\n    }\n\n    if (!has(\"json\")) {\n      // Common `[[Class]]` name aliases.\n      var functionClass = \"[object Function]\",\n          dateClass = \"[object Date]\",\n          numberClass = \"[object Number]\",\n          stringClass = \"[object String]\",\n          arrayClass = \"[object Array]\",\n          booleanClass = \"[object Boolean]\";\n\n      // Detect incomplete support for accessing string characters by index.\n      var charIndexBuggy = has(\"bug-string-char-index\");\n\n      // Define additional utility methods if the `Date` methods are buggy.\n      if (!isExtended) {\n        var floor = Math.floor;\n        // A mapping between the months of the year and the number of days between\n        // January 1st and the first of the respective month.\n        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n        // Internal: Calculates the number of days between the Unix epoch and the\n        // first day of the given month.\n        var getDay = function (year, month) {\n          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n        };\n      }\n\n      // Internal: Determines if a property is a direct property of the given\n      // object. Delegates to the native `Object#hasOwnProperty` method.\n      if (!(isProperty = objectProto.hasOwnProperty)) {\n        isProperty = function (property) {\n          var members = {}, constructor;\n          if ((members.__proto__ = null, members.__proto__ = {\n            // The *proto* property cannot be set multiple times in recent\n            // versions of Firefox and SeaMonkey.\n            \"toString\": 1\n          }, members).toString != getClass) {\n            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n            // supports the mutable *proto* property.\n            isProperty = function (property) {\n              // Capture and break the object's prototype chain (see section 8.6.2\n              // of the ES 5.1 spec). The parenthesized expression prevents an\n              // unsafe transformation by the Closure Compiler.\n              var original = this.__proto__, result = property in (this.__proto__ = null, this);\n              // Restore the original prototype chain.\n              this.__proto__ = original;\n              return result;\n            };\n          } else {\n            // Capture a reference to the top-level `Object` constructor.\n            constructor = members.constructor;\n            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n            // other environments.\n            isProperty = function (property) {\n              var parent = (this.constructor || constructor).prototype;\n              return property in this && !(property in parent && this[property] === parent[property]);\n            };\n          }\n          members = null;\n          return isProperty.call(this, property);\n        };\n      }\n\n      // Internal: Normalizes the `for...in` iteration algorithm across\n      // environments. Each enumerated key is yielded to a `callback` function.\n      forEach = function (object, callback) {\n        var size = 0, Properties, members, property;\n\n        // Tests for bugs in the current environment's `for...in` algorithm. The\n        // `valueOf` property inherits the non-enumerable flag from\n        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n        (Properties = function () {\n          this.valueOf = 0;\n        }).prototype.valueOf = 0;\n\n        // Iterate over a new instance of the `Properties` class.\n        members = new Properties();\n        for (property in members) {\n          // Ignore all properties inherited from `Object.prototype`.\n          if (isProperty.call(members, property)) {\n            size++;\n          }\n        }\n        Properties = members = null;\n\n        // Normalize the iteration algorithm.\n        if (!size) {\n          // A list of non-enumerable properties inherited from `Object.prototype`.\n          members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n          // properties.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, length;\n            var hasProperty = !isFunction && typeof object.constructor != \"function\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\n            for (property in object) {\n              // Gecko <= 1.0 enumerates the `prototype` property of functions under\n              // certain conditions; IE does not.\n              if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for each non-enumerable property.\n            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n          };\n        } else if (size == 2) {\n          // Safari <= 2.0.4 enumerates shadowed properties twice.\n          forEach = function (object, callback) {\n            // Create a set of iterated properties.\n            var members = {}, isFunction = getClass.call(object) == functionClass, property;\n            for (property in object) {\n              // Store each property name to prevent double enumeration. The\n              // `prototype` property of functions is not enumerated due to cross-\n              // environment inconsistencies.\n              if (!(isFunction && property == \"prototype\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n          };\n        } else {\n          // No bugs detected; use the standard `for...in` algorithm.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n            for (property in object) {\n              if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for the `constructor` property due to\n            // cross-environment inconsistencies.\n            if (isConstructor || isProperty.call(object, (property = \"constructor\"))) {\n              callback(property);\n            }\n          };\n        }\n        return forEach(object, callback);\n      };\n\n      // Public: Serializes a JavaScript `value` as a JSON string. The optional\n      // `filter` argument may specify either a function that alters how object and\n      // array members are serialized, or an array of strings and numbers that\n      // indicates which properties should be serialized. The optional `width`\n      // argument may be either a string or number that specifies the indentation\n      // level of the output.\n      if (!has(\"json-stringify\")) {\n        // Internal: A map of control characters and their escaped equivalents.\n        var Escapes = {\n          92: \"\\\\\\\\\",\n          34: '\\\\\"',\n          8: \"\\\\b\",\n          12: \"\\\\f\",\n          10: \"\\\\n\",\n          13: \"\\\\r\",\n          9: \"\\\\t\"\n        };\n\n        // Internal: Converts `value` into a zero-padded string such that its\n        // length is at least equal to `width`. The `width` must be <= 6.\n        var leadingZeroes = \"000000\";\n        var toPaddedString = function (width, value) {\n          // The `|| 0` expression is necessary to work around a bug in\n          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n          return (leadingZeroes + (value || 0)).slice(-width);\n        };\n\n        // Internal: Double-quotes a string `value`, replacing all ASCII control\n        // characters (characters with code unit values between 0 and 31) with\n        // their escaped equivalents. This is an implementation of the\n        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n        var unicodePrefix = \"\\\\u00\";\n        var quote = function (value) {\n          var result = '\"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\n          var symbols = useCharIndex && (charIndexBuggy ? value.split(\"\") : value);\n          for (; index < length; index++) {\n            var charCode = value.charCodeAt(index);\n            // If the character is a control character, append its Unicode or\n            // shorthand escape sequence; otherwise, append the character as-is.\n            switch (charCode) {\n              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n                result += Escapes[charCode];\n                break;\n              default:\n                if (charCode < 32) {\n                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                  break;\n                }\n                result += useCharIndex ? symbols[index] : value.charAt(index);\n            }\n          }\n          return result + '\"';\n        };\n\n        // Internal: Recursively serializes an object. Implements the\n        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n          try {\n            // Necessary for host object support.\n            value = object[property];\n          } catch (exception) {}\n          if (typeof value == \"object\" && value) {\n            className = getClass.call(value);\n            if (className == dateClass && !isProperty.call(value, \"toJSON\")) {\n              if (value > -1 / 0 && value < 1 / 0) {\n                // Dates are serialized according to the `Date#toJSON` method\n                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n                // for the ISO 8601 date time string format.\n                if (getDay) {\n                  // Manually compute the year, month, date, hours, minutes,\n                  // seconds, and milliseconds if the `getUTC*` methods are\n                  // buggy. Adapted from @Yaffle's `date-shim` project.\n                  date = floor(value / 864e5);\n                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n                  date = 1 + date - getDay(year, month);\n                  // The `time` value specifies the time within the day (see ES\n                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                  // to compute `A modulo B`, as the `%` operator does not\n                  // correspond to the `modulo` operation for negative numbers.\n                  time = (value % 864e5 + 864e5) % 864e5;\n                  // The hours, minutes, seconds, and milliseconds are obtained by\n                  // decomposing the time within the day. See section 15.9.1.10.\n                  hours = floor(time / 36e5) % 24;\n                  minutes = floor(time / 6e4) % 60;\n                  seconds = floor(time / 1e3) % 60;\n                  milliseconds = time % 1e3;\n                } else {\n                  year = value.getUTCFullYear();\n                  month = value.getUTCMonth();\n                  date = value.getUTCDate();\n                  hours = value.getUTCHours();\n                  minutes = value.getUTCMinutes();\n                  seconds = value.getUTCSeconds();\n                  milliseconds = value.getUTCMilliseconds();\n                }\n                // Serialize extended years correctly.\n                value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n                  \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n                  // Months, dates, hours, minutes, and seconds should have two\n                  // digits; milliseconds should have three.\n                  \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n                  // Milliseconds are optional in ES 5.0, but required in 5.1.\n                  \".\" + toPaddedString(3, milliseconds) + \"Z\";\n              } else {\n                value = null;\n              }\n            } else if (typeof value.toJSON == \"function\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \"toJSON\"))) {\n              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n              // ignores all `toJSON` methods on these objects unless they are\n              // defined directly on an instance.\n              value = value.toJSON(property);\n            }\n          }\n          if (callback) {\n            // If a replacement function was provided, call it to obtain the value\n            // for serialization.\n            value = callback.call(object, property, value);\n          }\n          if (value === null) {\n            return \"null\";\n          }\n          className = getClass.call(value);\n          if (className == booleanClass) {\n            // Booleans are represented literally.\n            return \"\" + value;\n          } else if (className == numberClass) {\n            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n            // `\"null\"`.\n            return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n          } else if (className == stringClass) {\n            // Strings are double-quoted and escaped.\n            return quote(\"\" + value);\n          }\n          // Recursively serialize objects and arrays.\n          if (typeof value == \"object\") {\n            // Check for cyclic structures. This is a linear search; performance\n            // is inversely proportional to the number of unique nested objects.\n            for (length = stack.length; length--;) {\n              if (stack[length] === value) {\n                // Cyclic structures cannot be serialized by `JSON.stringify`.\n                throw TypeError();\n              }\n            }\n            // Add the object to the stack of traversed objects.\n            stack.push(value);\n            results = [];\n            // Save the current indentation level and indent one additional level.\n            prefix = indentation;\n            indentation += whitespace;\n            if (className == arrayClass) {\n              // Recursively serialize array elements.\n              for (index = 0, length = value.length; index < length; index++) {\n                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n                results.push(element === undef ? \"null\" : element);\n              }\n              result = results.length ? (whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : (\"[\" + results.join(\",\") + \"]\")) : \"[]\";\n            } else {\n              // Recursively serialize object members. Members are selected from\n              // either a user-specified list of property names, or the object\n              // itself.\n              forEach(properties || value, function (property) {\n                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n                if (element !== undef) {\n                  // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n                  // is not the empty string, let `member` {quote(property) + \":\"}\n                  // be the concatenation of `member` and the `space` character.\"\n                  // The \"`space` character\" refers to the literal space\n                  // character, not the `space` {width} argument provided to\n                  // `JSON.stringify`.\n                  results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n                }\n              });\n              result = results.length ? (whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : (\"{\" + results.join(\",\") + \"}\")) : \"{}\";\n            }\n            // Remove the object from the traversed object stack.\n            stack.pop();\n            return result;\n          }\n        };\n\n        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n        exports.stringify = function (source, filter, width) {\n          var whitespace, callback, properties, className;\n          if (objectTypes[typeof filter] && filter) {\n            if ((className = getClass.call(filter)) == functionClass) {\n              callback = filter;\n            } else if (className == arrayClass) {\n              // Convert the property names array into a makeshift set.\n              properties = {};\n              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n            }\n          }\n          if (width) {\n            if ((className = getClass.call(width)) == numberClass) {\n              // Convert the `width` to an integer and create a string containing\n              // `width` number of space characters.\n              if ((width -= width % 1) > 0) {\n                for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \");\n              }\n            } else if (className == stringClass) {\n              whitespace = width.length <= 10 ? width : width.slice(0, 10);\n            }\n          }\n          // Opera <= 7.54u2 discards the values associated with empty string keys\n          // (`\"\"`) only if they are used directly within an object member list\n          // (e.g., `!(\"\" in { \"\": 1})`).\n          return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n        };\n      }\n\n      // Public: Parses a JSON source string.\n      if (!has(\"json-parse\")) {\n        var fromCharCode = String.fromCharCode;\n\n        // Internal: A map of escaped control characters and their unescaped\n        // equivalents.\n        var Unescapes = {\n          92: \"\\\\\",\n          34: '\"',\n          47: \"/\",\n          98: \"\\b\",\n          116: \"\\t\",\n          110: \"\\n\",\n          102: \"\\f\",\n          114: \"\\r\"\n        };\n\n        // Internal: Stores the parser state.\n        var Index, Source;\n\n        // Internal: Resets the parser state and throws a `SyntaxError`.\n        var abort = function () {\n          Index = Source = null;\n          throw SyntaxError();\n        };\n\n        // Internal: Returns the next token, or `\"$\"` if the parser has reached\n        // the end of the source string. A token may be a string, number, `null`\n        // literal, or Boolean literal.\n        var lex = function () {\n          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n          while (Index < length) {\n            charCode = source.charCodeAt(Index);\n            switch (charCode) {\n              case 9: case 10: case 13: case 32:\n                // Skip whitespace tokens, including tabs, carriage returns, line\n                // feeds, and space characters.\n                Index++;\n                break;\n              case 123: case 125: case 91: case 93: case 58: case 44:\n                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n                // the current position.\n                value = charIndexBuggy ? source.charAt(Index) : source[Index];\n                Index++;\n                return value;\n              case 34:\n                // `\"` delimits a JSON string; advance to the next character and\n                // begin parsing the string. String tokens are prefixed with the\n                // sentinel `@` character to distinguish them from punctuators and\n                // end-of-string tokens.\n                for (value = \"@\", Index++; Index < length;) {\n                  charCode = source.charCodeAt(Index);\n                  if (charCode < 32) {\n                    // Unescaped ASCII control characters (those with a code unit\n                    // less than the space character) are not permitted.\n                    abort();\n                  } else if (charCode == 92) {\n                    // A reverse solidus (`\\`) marks the beginning of an escaped\n                    // control character (including `\"`, `\\`, and `/`) or Unicode\n                    // escape sequence.\n                    charCode = source.charCodeAt(++Index);\n                    switch (charCode) {\n                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n                        // Revive escaped control characters.\n                        value += Unescapes[charCode];\n                        Index++;\n                        break;\n                      case 117:\n                        // `\\u` marks the beginning of a Unicode escape sequence.\n                        // Advance to the first character and validate the\n                        // four-digit code point.\n                        begin = ++Index;\n                        for (position = Index + 4; Index < position; Index++) {\n                          charCode = source.charCodeAt(Index);\n                          // A valid sequence comprises four hexdigits (case-\n                          // insensitive) that form a single hexadecimal value.\n                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                            // Invalid Unicode escape sequence.\n                            abort();\n                          }\n                        }\n                        // Revive the escaped character.\n                        value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                        break;\n                      default:\n                        // Invalid escape sequence.\n                        abort();\n                    }\n                  } else {\n                    if (charCode == 34) {\n                      // An unescaped double-quote character marks the end of the\n                      // string.\n                      break;\n                    }\n                    charCode = source.charCodeAt(Index);\n                    begin = Index;\n                    // Optimize for the common case where a string is valid.\n                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                      charCode = source.charCodeAt(++Index);\n                    }\n                    // Append the string as-is.\n                    value += source.slice(begin, Index);\n                  }\n                }\n                if (source.charCodeAt(Index) == 34) {\n                  // Advance to the next character and return the revived string.\n                  Index++;\n                  return value;\n                }\n                // Unterminated string.\n                abort();\n              default:\n                // Parse numbers and literals.\n                begin = Index;\n                // Advance past the negative sign, if one is specified.\n                if (charCode == 45) {\n                  isSigned = true;\n                  charCode = source.charCodeAt(++Index);\n                }\n                // Parse an integer or floating-point value.\n                if (charCode >= 48 && charCode <= 57) {\n                  // Leading zeroes are interpreted as octal literals.\n                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n                    // Illegal octal literal.\n                    abort();\n                  }\n                  isSigned = false;\n                  // Parse the integer component.\n                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n                  // Floats cannot contain a leading decimal point; however, this\n                  // case is already accounted for by the parser.\n                  if (source.charCodeAt(Index) == 46) {\n                    position = ++Index;\n                    // Parse the decimal component.\n                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal trailing decimal.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Parse exponents. The `e` denoting the exponent is\n                  // case-insensitive.\n                  charCode = source.charCodeAt(Index);\n                  if (charCode == 101 || charCode == 69) {\n                    charCode = source.charCodeAt(++Index);\n                    // Skip past the sign following the exponent, if one is\n                    // specified.\n                    if (charCode == 43 || charCode == 45) {\n                      Index++;\n                    }\n                    // Parse the exponential component.\n                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal empty exponent.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Coerce the parsed value to a JavaScript number.\n                  return +source.slice(begin, Index);\n                }\n                // A negative sign may only precede numbers.\n                if (isSigned) {\n                  abort();\n                }\n                // `true`, `false`, and `null` literals.\n                if (source.slice(Index, Index + 4) == \"true\") {\n                  Index += 4;\n                  return true;\n                } else if (source.slice(Index, Index + 5) == \"false\") {\n                  Index += 5;\n                  return false;\n                } else if (source.slice(Index, Index + 4) == \"null\") {\n                  Index += 4;\n                  return null;\n                }\n                // Unrecognized token.\n                abort();\n            }\n          }\n          // Return the sentinel `$` character if the parser has reached the end\n          // of the source string.\n          return \"$\";\n        };\n\n        // Internal: Parses a JSON `value` token.\n        var get = function (value) {\n          var results, hasMembers;\n          if (value == \"$\") {\n            // Unexpected end of input.\n            abort();\n          }\n          if (typeof value == \"string\") {\n            if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n              // Remove the sentinel `@` character.\n              return value.slice(1);\n            }\n            // Parse object and array literals.\n            if (value == \"[\") {\n              // Parses a JSON array, returning a new JavaScript array.\n              results = [];\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing square bracket marks the end of the array literal.\n                if (value == \"]\") {\n                  break;\n                }\n                // If the array literal contains elements, the current token\n                // should be a comma separating the previous element from the\n                // next.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"]\") {\n                      // Unexpected trailing `,` in array literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each array element.\n                    abort();\n                  }\n                }\n                // Elisions and leading commas are not permitted.\n                if (value == \",\") {\n                  abort();\n                }\n                results.push(get(value));\n              }\n              return results;\n            } else if (value == \"{\") {\n              // Parses a JSON object, returning a new JavaScript object.\n              results = {};\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing curly brace marks the end of the object literal.\n                if (value == \"}\") {\n                  break;\n                }\n                // If the object literal contains members, the current token\n                // should be a comma separator.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"}\") {\n                      // Unexpected trailing `,` in object literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each object member.\n                    abort();\n                  }\n                }\n                // Leading commas are not permitted, object property names must be\n                // double-quoted strings, and a `:` must separate each property\n                // name and value.\n                if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n                  abort();\n                }\n                results[value.slice(1)] = get(lex());\n              }\n              return results;\n            }\n            // Unexpected token encountered.\n            abort();\n          }\n          return value;\n        };\n\n        // Internal: Updates a traversed object member.\n        var update = function (source, property, callback) {\n          var element = walk(source, property, callback);\n          if (element === undef) {\n            delete source[property];\n          } else {\n            source[property] = element;\n          }\n        };\n\n        // Internal: Recursively traverses a parsed JSON object, invoking the\n        // `callback` function for each value. This is an implementation of the\n        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n        var walk = function (source, property, callback) {\n          var value = source[property], length;\n          if (typeof value == \"object\" && value) {\n            // `forEach` can't be used to traverse an array in Opera <= 8.54\n            // because its `Object#hasOwnProperty` implementation returns `false`\n            // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n            if (getClass.call(value) == arrayClass) {\n              for (length = value.length; length--;) {\n                update(value, length, callback);\n              }\n            } else {\n              forEach(value, function (property) {\n                update(value, property, callback);\n              });\n            }\n          }\n          return callback.call(source, property, value);\n        };\n\n        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n        exports.parse = function (source, callback) {\n          var result, value;\n          Index = 0;\n          Source = \"\" + source;\n          result = get(lex());\n          // If a JSON string contains multiple tokens, it is invalid.\n          if (lex() != \"$\") {\n            abort();\n          }\n          // Reset the parser state.\n          Index = Source = null;\n          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n        };\n      }\n    }\n\n    exports[\"runInContext\"] = runInContext;\n    return exports;\n  }\n\n  if (freeExports && !isLoader) {\n    // Export for CommonJS environments.\n    runInContext(root, freeExports);\n  } else {\n    // Export for web browsers and JavaScript engines.\n    var nativeJSON = root.JSON,\n        previousJSON = root[\"JSON3\"],\n        isRestored = false;\n\n    var JSON3 = runInContext(root, (root[\"JSON3\"] = {\n      // Public: Restores the original value of the global `JSON` object and\n      // returns a reference to the `JSON3` object.\n      \"noConflict\": function () {\n        if (!isRestored) {\n          isRestored = true;\n          root.JSON = nativeJSON;\n          root[\"JSON3\"] = previousJSON;\n          nativeJSON = previousJSON = null;\n        }\n        return JSON3;\n      }\n    }));\n\n    root.JSON = {\n      \"parse\": JSON3.parse,\n      \"stringify\": JSON3.stringify\n    };\n  }\n\n  // Export for asynchronous module loaders.\n  if (isLoader) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return JSON3;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}).call(this);\n\n//##############################################################################\n// DomUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * A few utilities for interacting with the dom.\n\t * @class DomUtils\n\t */\n\tvar s = {};\n\n\ts.appendToHead = function (el) {\n\t\ts.getHead().appendChild(el)\n\t}\n\n\ts.getHead = function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}\n\n\ts.getBody = function () {\n\t\treturn document.body || document.getElementsByTagName(\"body\")[0];\n\t}\n\n\tcreatejs.DomUtils = s;\n\n}());\n\n//##############################################################################\n// DataUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * A few data utilities for formatting different data types.\n\t * @class DataUtils\n\t */\n\tvar s = {};\n\n\t// static methods\n\t/**\n\t * Parse XML using the DOM. This is required when preloading XML or SVG.\n\t * @method parseXML\n\t * @param {String} text The raw text or XML that is loaded by XHR.\n\t * @param {String} type The mime type of the XML. Use \"text/xml\" for XML, and  \"image/svg+xml\" for SVG parsing.\n\t * @return {XML} An XML document\n\t * @static\n\t */\n\ts.parseXML = function (text, type) {\n\t\tvar xml = null;\n\t\t// CocoonJS does not support XML parsing with either method.\n\n\t\t// Most browsers will use DOMParser\n\t\t// IE fails on certain SVG files, so we have a fallback below.\n\t\ttry {\n\t\t\tif (window.DOMParser) {\n\t\t\t\tvar parser = new DOMParser();\n\t\t\t\txml = parser.parseFromString(text, type);\n\t\t\t}\n\t\t} catch (e) {\n\t\t}\n\n\t\t// Fallback for IE support.\n\t\tif (!xml) {\n\t\t\ttry {\n\t\t\t\txml = new ActiveXObject(\"Microsoft.XMLDOM\");\n\t\t\t\txml.async = false;\n\t\t\t\txml.loadXML(text);\n\t\t\t} catch (e) {\n\t\t\t\txml = null;\n\t\t\t}\n\t\t}\n\n\t\treturn xml;\n\t};\n\n\t/**\n\t * Parse a string into an Object.\n\t * @method parseJSON\n\t * @param {String} value The loaded JSON string\n\t * @returns {Object} A JavaScript object.\n\t */\n\ts.parseJSON = function (value) {\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\treturn JSON.parse(value);\n\t\t} catch (e) {\n\t\t\t// TODO; Handle this with a custom error?\n\t\t\tthrow e;\n\t\t}\n\t};\n\n\tcreatejs.DataUtils = s;\n\n}());\n\n//##############################################################################\n// LoadItem.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * All loaders accept an item containing the properties defined in this class. If a raw object is passed instead,\n\t * it will not be affected, but it must contain at least a {{#crossLink \"src:property\"}}{{/crossLink}} property. A\n\t * string path or HTML tag is also acceptable, but it will be automatically converted to a LoadItem using the\n\t * {{#crossLink \"create\"}}{{/crossLink}} method by {{#crossLink \"AbstractLoader\"}}{{/crossLink}}\n\t * @class LoadItem\n\t * @constructor\n\t * @since 0.6.0\n\t */\n\tfunction LoadItem() {\n\t\t/**\n\t\t * The source of the file that is being loaded. This property is <b>required</b>. The source can either be a\n\t\t * string (recommended), or an HTML tag.\n\t\t * This can also be an object, but in that case it has to include a type and be handled by a plugin.\n\t\t * @property src\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.src = null;\n\n\t\t/**\n\t\t * The type file that is being loaded. The type of the file is usually inferred by the extension, but can also\n\t\t * be set manually. This is helpful in cases where a file does not have an extension.\n\t\t * @property type\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.type = null;\n\n\t\t/**\n\t\t * A string identifier which can be used to reference the loaded object. If none is provided, this will be\n\t\t * automatically set to the {{#crossLink \"src:property\"}}{{/crossLink}}.\n\t\t * @property id\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.id = null;\n\n\t\t/**\n\t\t * Determines if a manifest will maintain the order of this item, in relation to other items in the manifest\n\t\t * that have also set the `maintainOrder` property to `true`. This only applies when the max connections has\n\t\t * been set above 1 (using {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}}). Everything with this\n\t\t * property set to `false` will finish as it is loaded. Ordered items are combined with script tags loading in\n\t\t * order when {{#crossLink \"LoadQueue/maintainScriptOrder:property\"}}{{/crossLink}} is set to `true`.\n\t\t * @property maintainOrder\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.maintainOrder = false;\n\n\t\t/**\n\t\t * A callback used by JSONP requests that defines what global method to call when the JSONP content is loaded.\n\t\t * @property callback\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.callback = null;\n\n\t\t/**\n\t\t * An arbitrary data object, which is included with the loaded object.\n\t\t * @property data\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.data = null;\n\n\t\t/**\n\t\t * The request method used for HTTP calls. Both {{#crossLink \"AbstractLoader/GET:property\"}}{{/crossLink}} or\n\t\t * {{#crossLink \"AbstractLoader/POST:property\"}}{{/crossLink}} request types are supported, and are defined as\n\t\t * constants on {{#crossLink \"AbstractLoader\"}}{{/crossLink}}.\n\t\t * @property method\n\t\t * @type {String}\n\t\t * @default get\n\t\t */\n\t\tthis.method = createjs.LoadItem.GET;\n\n\t\t/**\n\t\t * An object hash of name/value pairs to send to the server.\n\t\t * @property values\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.values = null;\n\n\t\t/**\n\t\t * An object hash of headers to attach to an XHR request. PreloadJS will automatically attach some default\n\t\t * headers when required, including \"Origin\", \"Content-Type\", and \"X-Requested-With\". You may override the\n\t\t * default headers by including them in your headers object.\n\t\t * @property headers\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.headers = null;\n\n\t\t/**\n\t\t * Enable credentials for XHR requests.\n\t\t * @property withCredentials\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.withCredentials = false;\n\n\t\t/**\n\t\t * Set the mime type of XHR-based requests. This is automatically set to \"text/plain; charset=utf-8\" for text\n\t\t * based files (json, xml, text, css, js).\n\t\t * @property mimeType\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.mimeType = null;\n\n\t\t/**\n\t\t * Sets the crossOrigin attribute for CORS-enabled images loading cross-domain.\n\t\t * @property crossOrigin\n\t\t * @type {boolean}\n\t\t * @default Anonymous\n\t\t */\n\t\tthis.crossOrigin = null;\n\n\t\t/**\n\t\t * The duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR\n\t\t * (level one) loading, as XHR (level 2) provides its own timeout event.\n\t\t * @property loadTimeout\n\t\t * @type {Number}\n\t\t * @default 8000 (8 seconds)\n\t\t */\n\t\tthis.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;\n\t};\n\n\tvar p = LoadItem.prototype = {};\n\tvar s = LoadItem;\n\n\t/**\n\t * Default duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR\n\t * (level one) loading, as XHR (level 2) provides its own timeout event.\n\t * @property LOAD_TIMEOUT_DEFAULT\n\t * @type {number}\n\t * @static\n\t */\n\ts.LOAD_TIMEOUT_DEFAULT = 8000;\n\n\t/**\n\t * Create a LoadItem.\n\t * <ul>\n\t *     <li>String-based items are converted to a LoadItem with a populated {{#crossLink \"src:property\"}}{{/crossLink}}.</li>\n\t *     <li>LoadItem instances are returned as-is</li>\n\t *     <li>Objects are returned with any needed properties added</li>\n\t * </ul>\n\t * @method create\n\t * @param {LoadItem|String|Object} value The load item value\n\t * @returns {LoadItem|Object}\n\t * @static\n\t */\n\ts.create = function (value) {\n\t\tif (typeof value == \"string\") {\n\t\t\tvar item = new LoadItem();\n\t\t\titem.src = value;\n\t\t\treturn item;\n\t\t} else if (value instanceof s) {\n\t\t\treturn value;\n\t\t} else if (value instanceof Object && value.src) {\n\t\t\tif (value.loadTimeout == null) {\n\t\t\t\tvalue.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;\n\t\t\t}\n\t\t\treturn value;\n\t\t} else {\n\t\t\tthrow new Error(\"Type not recognized.\");\n\t\t}\n\t};\n\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var loadItem = new createjs.LoadItem().set({src:\"image.png\", maintainOrder:true});\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the LoadItem instance.\n\t * @return {LoadItem} Returns the instance the method is called on (useful for chaining calls.)\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\n\tcreatejs.LoadItem = s;\n\n}());\n\n//##############################################################################\n// RequestUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * Utilities that assist with parsing load items, and determining file types, etc.\n\t * @class RequestUtils\n\t */\n\tvar s = {};\n\n\t/**\n\t * The Regular Expression used to test file URLS for an absolute path.\n\t * @property ABSOLUTE_PATH\n\t * @type {RegExp}\n\t * @static\n\t */\n\ts.ABSOLUTE_PATT = /^(?:\\w+:)?\\/{2}/i;\n\n\t/**\n\t * The Regular Expression used to test file URLS for a relative path.\n\t * @property RELATIVE_PATH\n\t * @type {RegExp}\n\t * @static\n\t */\n\ts.RELATIVE_PATT = (/^[./]*?\\//i);\n\n\t/**\n\t * The Regular Expression used to test file URLS for an extension. Note that URIs must already have the query string\n\t * removed.\n\t * @property EXTENSION_PATT\n\t * @type {RegExp}\n\t * @static\n\t */\n\ts.EXTENSION_PATT = /\\/?[^/]+\\.(\\w{1,5})$/i;\n\n\t/**\n\t * Parse a file path to determine the information we need to work with it. Currently, PreloadJS needs to know:\n\t * <ul>\n\t *     <li>If the path is absolute. Absolute paths start with a protocol (such as `http://`, `file://`, or\n\t *     `//networkPath`)</li>\n\t *     <li>If the path is relative. Relative paths start with `../` or `/path` (or similar)</li>\n\t *     <li>The file extension. This is determined by the filename with an extension. Query strings are dropped, and\n\t *     the file path is expected to follow the format `name.ext`.</li>\n\t * </ul>\n\t * @method parseURI\n\t * @param {String} path\n\t * @returns {Object} An Object with an `absolute` and `relative` Boolean values, as well as an optional 'extension`\n\t * property, which is the lowercase extension.\n\t * @static\n\t */\n\ts.parseURI = function (path) {\n\t\tvar info = {absolute: false, relative: false};\n\t\tif (path == null) { return info; }\n\n\t\t// Drop the query string\n\t\tvar queryIndex = path.indexOf(\"?\");\n\t\tif (queryIndex > -1) {\n\t\t\tpath = path.substr(0, queryIndex);\n\t\t}\n\n\t\t// Absolute\n\t\tvar match;\n\t\tif (s.ABSOLUTE_PATT.test(path)) {\n\t\t\tinfo.absolute = true;\n\n\t\t\t// Relative\n\t\t} else if (s.RELATIVE_PATT.test(path)) {\n\t\t\tinfo.relative = true;\n\t\t}\n\n\t\t// Extension\n\t\tif (match = path.match(s.EXTENSION_PATT)) {\n\t\t\tinfo.extension = match[1].toLowerCase();\n\t\t}\n\t\treturn info;\n\t};\n\n\t/**\n\t * Formats an object into a query string for either a POST or GET request.\n\t * @method formatQueryString\n\t * @param {Object} data The data to convert to a query string.\n\t * @param {Array} [query] Existing name/value pairs to append on to this query.\n\t * @static\n\t */\n\ts.formatQueryString = function (data, query) {\n\t\tif (data == null) {\n\t\t\tthrow new Error('You must specify data.');\n\t\t}\n\t\tvar params = [];\n\t\tfor (var n in data) {\n\t\t\tparams.push(n + '=' + escape(data[n]));\n\t\t}\n\t\tif (query) {\n\t\t\tparams = params.concat(query);\n\t\t}\n\t\treturn params.join('&');\n\t};\n\n\t/**\n\t * A utility method that builds a file path using a source and a data object, and formats it into a new path.\n\t * @method buildPath\n\t * @param {String} src The source path to add values to.\n\t * @param {Object} [data] Object used to append values to this request as a query string. Existing parameters on the\n\t * path will be preserved.\n\t * @returns {string} A formatted string that contains the path and the supplied parameters.\n\t * @static\n\t */\n\ts.buildPath = function (src, data) {\n\t\tif (data == null) {\n\t\t\treturn src;\n\t\t}\n\n\t\tvar query = [];\n\t\tvar idx = src.indexOf('?');\n\n\t\tif (idx != -1) {\n\t\t\tvar q = src.slice(idx + 1);\n\t\t\tquery = query.concat(q.split('&'));\n\t\t}\n\n\t\tif (idx != -1) {\n\t\t\treturn src.slice(0, idx) + '?' + this.formatQueryString(data, query);\n\t\t} else {\n\t\t\treturn src + '?' + this.formatQueryString(data, query);\n\t\t}\n\t};\n\n\t/**\n\t * @method isCrossDomain\n\t * @param {LoadItem|Object} item A load item with a `src` property.\n\t * @return {Boolean} If the load item is loading from a different domain than the current location.\n\t * @static\n\t */\n\ts.isCrossDomain = function (item) {\n\t\tvar target = document.createElement(\"a\");\n\t\ttarget.href = item.src;\n\n\t\tvar host = document.createElement(\"a\");\n\t\thost.href = location.href;\n\n\t\tvar crossdomain = (target.hostname != \"\") &&\n\t\t\t\t\t\t  (target.port != host.port ||\n\t\t\t\t\t\t   target.protocol != host.protocol ||\n\t\t\t\t\t\t   target.hostname != host.hostname);\n\t\treturn crossdomain;\n\t};\n\n\t/**\n\t * @method isLocal\n\t * @param {LoadItem|Object} item A load item with a `src` property\n\t * @return {Boolean} If the load item is loading from the \"file:\" protocol. Assume that the host must be local as\n\t * well.\n\t * @static\n\t */\n\ts.isLocal = function (item) {\n\t\tvar target = document.createElement(\"a\");\n\t\ttarget.href = item.src;\n\t\treturn target.hostname == \"\" && target.protocol == \"file:\";\n\t};\n\n\t/**\n\t * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked\n\t * specifically as \"binary\" are loaded as binary. Note that audio is <b>not</b> a binary type, as we can not play\n\t * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get\n\t * a binary result to work with. Binary files are loaded using XHR2. Types are defined as static constants on\n\t * {{#crossLink \"AbstractLoader\"}}{{/crossLink}}.\n\t * @method isBinary\n\t * @param {String} type The item type.\n\t * @return {Boolean} If the specified type is binary.\n\t * @static\n\t */\n\ts.isBinary = function (type) {\n\t\tswitch (type) {\n\t\t\tcase createjs.AbstractLoader.IMAGE:\n\t\t\tcase createjs.AbstractLoader.BINARY:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Check if item is a valid HTMLImageElement\n\t * @method isImageTag\n\t * @param {Object} item\n\t * @returns {Boolean}\n\t * @static\n\t */\n\ts.isImageTag = function(item) {\n\t\treturn item instanceof HTMLImageElement;\n\t};\n\n\t/**\n\t * Check if item is a valid HTMLAudioElement\n\t * @method isAudioTag\n\t * @param {Object} item\n\t * @returns {Boolean}\n\t * @static\n\t */\n\ts.isAudioTag = function(item) {\n\t\tif (window.HTMLAudioElement) {\n\t\t\treturn item instanceof HTMLAudioElement;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Check if item is a valid HTMLVideoElement\n\t * @method isVideoTag\n\t * @param {Object} item\n\t * @returns {Boolean}\n\t * @static\n\t */\n\ts.isVideoTag = function(item) {\n\t\tif (window.HTMLVideoElement) {\n\t\t\treturn item instanceof HTMLVideoElement;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if a specific type is a text-based asset, and should be loaded as UTF-8.\n\t * @method isText\n\t * @param {String} type The item type.\n\t * @return {Boolean} If the specified type is text.\n\t * @static\n\t */\n\ts.isText = function (type) {\n\t\tswitch (type) {\n\t\t\tcase createjs.AbstractLoader.TEXT:\n\t\t\tcase createjs.AbstractLoader.JSON:\n\t\t\tcase createjs.AbstractLoader.MANIFEST:\n\t\t\tcase createjs.AbstractLoader.XML:\n\t\t\tcase createjs.AbstractLoader.CSS:\n\t\t\tcase createjs.AbstractLoader.SVG:\n\t\t\tcase createjs.AbstractLoader.JAVASCRIPT:\n\t\t\tcase createjs.AbstractLoader.SPRITESHEET:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Determine the type of the object using common extensions. Note that the type can be passed in with the load item\n\t * if it is an unusual extension.\n\t * @method getTypeByExtension\n\t * @param {String} extension The file extension to use to determine the load type.\n\t * @return {String} The determined load type (for example, <code>AbstractLoader.IMAGE</code>). Will return `null` if\n\t * the type can not be determined by the extension.\n\t * @static\n\t */\n\ts.getTypeByExtension = function (extension) {\n\t\tif (extension == null) {\n\t\t\treturn createjs.AbstractLoader.TEXT;\n\t\t}\n\n\t\tswitch (extension.toLowerCase()) {\n\t\t\tcase \"jpeg\":\n\t\t\tcase \"jpg\":\n\t\t\tcase \"gif\":\n\t\t\tcase \"png\":\n\t\t\tcase \"webp\":\n\t\t\tcase \"bmp\":\n\t\t\t\treturn createjs.AbstractLoader.IMAGE;\n\t\t\tcase \"ogg\":\n\t\t\tcase \"mp3\":\n\t\t\tcase \"webm\":\n\t\t\t\treturn createjs.AbstractLoader.SOUND;\n\t\t\tcase \"mp4\":\n\t\t\tcase \"webm\":\n\t\t\tcase \"ts\":\n\t\t\t\treturn createjs.AbstractLoader.VIDEO;\n\t\t\tcase \"json\":\n\t\t\t\treturn createjs.AbstractLoader.JSON;\n\t\t\tcase \"xml\":\n\t\t\t\treturn createjs.AbstractLoader.XML;\n\t\t\tcase \"css\":\n\t\t\t\treturn createjs.AbstractLoader.CSS;\n\t\t\tcase \"js\":\n\t\t\t\treturn createjs.AbstractLoader.JAVASCRIPT;\n\t\t\tcase 'svg':\n\t\t\t\treturn createjs.AbstractLoader.SVG;\n\t\t\tdefault:\n\t\t\t\treturn createjs.AbstractLoader.TEXT;\n\t\t}\n\t};\n\n\tcreatejs.RequestUtils = s;\n\n}());\n\n//##############################################################################\n// AbstractLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n// constructor\n\t/**\n\t * The base loader, which defines all the generic methods, properties, and events. All loaders extend this class,\n\t * including the {{#crossLink \"LoadQueue\"}}{{/crossLink}}.\n\t * @class AbstractLoader\n\t * @param {LoadItem|object|string} loadItem The item to be loaded.\n\t * @param {Boolean} [preferXHR] Determines if the LoadItem should <em>try</em> and load using XHR, or take a\n\t * tag-based approach, which can be better in cross-domain situations. Not all loaders can load using one or the\n\t * other, so this is a suggested directive.\n\t * @param {String} [type] The type of loader. Loader types are defined as constants on the AbstractLoader class,\n\t * such as {{#crossLink \"IMAGE:property\"}}{{/crossLink}}, {{#crossLink \"CSS:property\"}}{{/crossLink}}, etc.\n\t * @extends EventDispatcher\n\t */\n\tfunction AbstractLoader(loadItem, preferXHR, type) {\n\t\tthis.EventDispatcher_constructor();\n\n\t\t// public properties\n\t\t/**\n\t\t * If the loader has completed loading. This provides a quick check, but also ensures that the different approaches\n\t\t * used for loading do not pile up resulting in more than one `complete` {{#crossLink \"Event\"}}{{/crossLink}}.\n\t\t * @property loaded\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.loaded = false;\n\n\t\t/**\n\t\t * Determine if the loader was canceled. Canceled loads will not fire complete events. Note that this property\n\t\t * is readonly, so {{#crossLink \"LoadQueue\"}}{{/crossLink}} queues should be closed using {{#crossLink \"LoadQueue/close\"}}{{/crossLink}}\n\t\t * instead.\n\t\t * @property canceled\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t */\n\t\tthis.canceled = false;\n\n\t\t/**\n\t\t * The current load progress (percentage) for this item. This will be a number between 0 and 1.\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *     var queue = new createjs.LoadQueue();\n\t\t *     queue.loadFile(\"largeImage.png\");\n\t\t *     queue.on(\"progress\", function() {\n\t\t *         console.log(\"Progress:\", queue.progress, event.progress);\n\t\t *     });\n\t\t *\n\t\t * @property progress\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.progress = 0;\n\n\t\t/**\n\t\t * The type of item this loader will load. See {{#crossLink \"AbstractLoader\"}}{{/crossLink}} for a full list of\n\t\t * supported types.\n\t\t * @property type\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * A formatter function that converts the loaded raw result into the final result. For example, the JSONLoader\n\t\t * converts a string of text into a JavaScript object. Not all loaders have a resultFormatter, and this property\n\t\t * can be overridden to provide custom formatting.\n\t\t *\n\t\t * Optionally, a resultFormatter can return a callback function in cases where the formatting needs to be\n\t\t * asynchronous, such as creating a new image. The callback function is passed 2 parameters, which are callbacks\n\t\t * to handle success and error conditions in the resultFormatter. Note that the resultFormatter method is\n\t\t * called in the current scope, as well as the success and error callbacks.\n\t\t *\n\t\t * <h4>Example asynchronous resultFormatter</h4>\n\t\t *\n\t\t * \tfunction _formatResult(loader) {\n\t\t * \t\treturn function(success, error) {\n\t\t * \t\t\tif (errorCondition) { error(errorDetailEvent); }\n\t\t * \t\t\tsuccess(result);\n\t\t * \t\t}\n\t\t * \t}\n\t\t * @property resultFormatter\n\t\t * @type {Function}\n\t\t * @default null\n\t\t */\n\t\tthis.resultFormatter = null;\n\n\t\t// protected properties\n\t\t/**\n\t\t * The {{#crossLink \"LoadItem\"}}{{/crossLink}} this loader represents. Note that this is null in a {{#crossLink \"LoadQueue\"}}{{/crossLink}},\n\t\t * but will be available on loaders such as {{#crossLink \"XMLLoader\"}}{{/crossLink}} and {{#crossLink \"ImageLoader\"}}{{/crossLink}}.\n\t\t * @property _item\n\t\t * @type {LoadItem|Object}\n\t\t * @private\n\t\t */\n\t\tif (loadItem) {\n\t\t\tthis._item = createjs.LoadItem.create(loadItem);\n\t\t} else {\n\t\t\tthis._item = null;\n\t\t}\n\n\t\t/**\n\t\t * Whether the loader will try and load content using XHR (true) or HTML tags (false).\n\t\t * @property _preferXHR\n\t\t * @type {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._preferXHR = preferXHR;\n\n\t\t/**\n\t\t * The loaded result after it is formatted by an optional {{#crossLink \"resultFormatter\"}}{{/crossLink}}. For\n\t\t * items that are not formatted, this will be the same as the {{#crossLink \"_rawResult:property\"}}{{/crossLink}}.\n\t\t * The result is accessed using the {{#crossLink \"getResult\"}}{{/crossLink}} method.\n\t\t * @property _result\n\t\t * @type {Object|String}\n\t\t * @private\n\t\t */\n\t\tthis._result = null;\n\n\t\t/**\n\t\t * The loaded result before it is formatted. The rawResult is accessed using the {{#crossLink \"getResult\"}}{{/crossLink}}\n\t\t * method, and passing `true`.\n\t\t * @property _rawResult\n\t\t * @type {Object|String}\n\t\t * @private\n\t\t */\n\t\tthis._rawResult = null;\n\n\t\t/**\n\t\t * A list of items that loaders load behind the scenes. This does not include the main item the loader is\n\t\t * responsible for loading. Examples of loaders that have sub-items include the {{#crossLink \"SpriteSheetLoader\"}}{{/crossLink}} and\n\t\t * {{#crossLink \"ManifestLoader\"}}{{/crossLink}}.\n\t\t * @property _loadItems\n\t\t * @type {null}\n\t\t * @protected\n\t\t */\n\t\tthis._loadedItems = null;\n\n\t\t/**\n\t\t * The attribute the items loaded using tags use for the source.\n\t\t * @type {string}\n\t\t * @default null\n\t\t * @private\n\t\t */\n\t\tthis._tagSrcAttribute = null;\n\n\t\t/**\n\t\t * An HTML tag (or similar) that a loader may use to load HTML content, such as images, scripts, etc.\n\t\t * @property _tag\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._tag = null;\n\t};\n\n\tvar p = createjs.extend(AbstractLoader, createjs.EventDispatcher);\n\tvar s = AbstractLoader;\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n\t/**\n\t * Defines a POST request, use for a method value when loading data.\n\t * @property POST\n\t * @type {string}\n\t * @default post\n\t * @static\n\t */\n\ts.POST = \"POST\";\n\n\t/**\n\t * Defines a GET request, use for a method value when loading data.\n\t * @property GET\n\t * @type {string}\n\t * @default get\n\t * @static\n\t */\n\ts.GET = \"GET\";\n\n\t/**\n\t * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.\n\t * @property BINARY\n\t * @type {String}\n\t * @default binary\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.BINARY = \"binary\";\n\n\t/**\n\t * The preload type for css files. CSS files are loaded using a &lt;link&gt; when loaded with XHR, or a\n\t * &lt;style&gt; tag when loaded with tags.\n\t * @property CSS\n\t * @type {String}\n\t * @default css\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.CSS = \"css\";\n\n\t/**\n\t * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &lt;image&gt; tag.\n\t * @property IMAGE\n\t * @type {String}\n\t * @default image\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.IMAGE = \"image\";\n\n\t/**\n\t * The preload type for javascript files, usually with the \"js\" file extension. JavaScript files are loaded into a\n\t * &lt;script&gt; tag.\n\t *\n\t * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into\n\t * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,\n\t * only tag-loaded scripts are injected.\n\t * @property JAVASCRIPT\n\t * @type {String}\n\t * @default javascript\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.JAVASCRIPT = \"javascript\";\n\n\t/**\n\t * The preload type for json files, usually with the \"json\" file extension. JSON data is loaded and parsed into a\n\t * JavaScript object. Note that if a `callback` is present on the load item, the file will be loaded with JSONP,\n\t * no matter what the {{#crossLink \"LoadQueue/preferXHR:property\"}}{{/crossLink}} property is set to, and the JSON\n\t * must contain a matching wrapper function.\n\t * @property JSON\n\t * @type {String}\n\t * @default json\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.JSON = \"json\";\n\n\t/**\n\t * The preload type for jsonp files, usually with the \"json\" file extension. JSON data is loaded and parsed into a\n\t * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.\n\t * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink \"LoadQueue/preferXHR:property\"}}{{/crossLink}}\n\t * property is set to.\n\t * @property JSONP\n\t * @type {String}\n\t * @default jsonp\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.JSONP = \"jsonp\";\n\n\t/**\n\t * The preload type for json-based manifest files, usually with the \"json\" file extension. The JSON data is loaded\n\t * and parsed into a JavaScript object. PreloadJS will then look for a \"manifest\" property in the JSON, which is an\n\t * Array of files to load, following the same format as the {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}\n\t * method. If a \"callback\" is specified on the manifest object, then it will be loaded using JSONP instead,\n\t * regardless of what the {{#crossLink \"LoadQueue/preferXHR:property\"}}{{/crossLink}} property is set to.\n\t * @property MANIFEST\n\t * @type {String}\n\t * @default manifest\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.MANIFEST = \"manifest\";\n\n\t/**\n\t * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an\n\t * &lt;audio&gt; tag.\n\t * @property SOUND\n\t * @type {String}\n\t * @default sound\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.SOUND = \"sound\";\n\n\t/**\n\t * The preload type for video files, usually mp4, ts, or ogg. When loading via tags, video is loaded into an\n\t * &lt;video&gt; tag.\n\t * @property VIDEO\n\t * @type {String}\n\t * @default video\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.VIDEO = \"video\";\n\n\t/**\n\t * The preload type for SpriteSheet files. SpriteSheet files are JSON files that contain string image paths.\n\t * @property SPRITESHEET\n\t * @type {String}\n\t * @default spritesheet\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.SPRITESHEET = \"spritesheet\";\n\n\t/**\n\t * The preload type for SVG files.\n\t * @property SVG\n\t * @type {String}\n\t * @default svg\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.SVG = \"svg\";\n\n\t/**\n\t * The preload type for text files, which is also the default file type if the type can not be determined. Text is\n\t * loaded as raw text.\n\t * @property TEXT\n\t * @type {String}\n\t * @default text\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.TEXT = \"text\";\n\n\t/**\n\t * The preload type for xml files. XML is loaded into an XML document.\n\t * @property XML\n\t * @type {String}\n\t * @default xml\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.XML = \"xml\";\n\n// Events\n\t/**\n\t * The {{#crossLink \"ProgressEvent\"}}{{/crossLink}} that is fired when the overall progress changes. Prior to\n\t * version 0.6.0, this was just a regular {{#crossLink \"Event\"}}{{/crossLink}}.\n\t * @event progress\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when a load starts.\n\t * @event loadstart\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.3.1\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when the entire queue has been loaded.\n\t * @event complete\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"ErrorEvent\"}}{{/crossLink}} that is fired when the loader encounters an error. If the error was\n\t * encountered by a file, the event will contain the item that caused the error. Prior to version 0.6.0, this was\n\t * just a regular {{#crossLink \"Event\"}}{{/crossLink}}.\n\t * @event error\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when the loader encounters an internal file load error.\n\t * This enables loaders to maintain internal queues, and surface file load errors.\n\t * @event fileerror\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The even type (\"fileerror\")\n\t * @param {LoadItem|object} The item that encountered the error\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when a loader internally loads a file. This enables\n\t * loaders such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}} to maintain internal {{#crossLink \"LoadQueue\"}}{{/crossLink}}s\n\t * and notify when they have loaded a file. The {{#crossLink \"LoadQueue\"}}{{/crossLink}} class dispatches a\n\t * slightly different {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event.\n\t * @event fileload\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type (\"fileload\")\n\t * @param {Object} item The file item which was specified in the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}} call. If only a string path or tag was specified, the\n\t * object will contain that value as a `src` property.\n\t * @param {Object} result The HTML tag or parsed result of the loaded item.\n\t * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted\n\t * to a usable object.\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired after the internal request is created, but before a load.\n\t * This allows updates to the loader for specific loading needs, such as binary or XHR image loading.\n\t * @event initialize\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type (\"initialize\")\n\t * @param {AbstractLoader} loader The loader that has been initialized.\n\t */\n\n\n\t/**\n\t * Get a reference to the manifest item that is loaded by this loader. In some cases this will be the value that was\n\t * passed into {{#crossLink \"LoadQueue\"}}{{/crossLink}} using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} or\n\t * {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}. However if only a String path was passed in, then it will\n\t * be a {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t * @method getItem\n\t * @return {Object} The manifest item that this loader is responsible for loading.\n\t * @since 0.6.0\n\t */\n\tp.getItem = function () {\n\t\treturn this._item;\n\t};\n\n\t/**\n\t * Get a reference to the content that was loaded by the loader (only available after the {{#crossLink \"complete:event\"}}{{/crossLink}}\n\t * event is dispatched.\n\t * @method getResult\n\t * @param {Boolean} [raw=false] Determines if the returned result will be the formatted content, or the raw loaded\n\t * data (if it exists).\n\t * @return {Object}\n\t * @since 0.6.0\n\t */\n\tp.getResult = function (raw) {\n\t\treturn raw ? this._rawResult : this._result;\n\t};\n\n\t/**\n\t * Return the `tag` this object creates or uses for loading.\n\t * @method getTag\n\t * @return {Object} The tag instance\n\t * @since 0.6.0\n\t */\n\tp.getTag = function () {\n\t\treturn this._tag;\n\t};\n\n\t/**\n\t * Set the `tag` this item uses for loading.\n\t * @method setTag\n\t * @param {Object} tag The tag instance\n\t * @since 0.6.0\n\t */\n\tp.setTag = function(tag) {\n\t  this._tag = tag;\n\t};\n\n\t/**\n\t * Begin loading the item. This method is required when using a loader by itself.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var queue = new createjs.LoadQueue();\n\t *      queue.on(\"complete\", handleComplete);\n\t *      queue.loadManifest(fileArray, false); // Note the 2nd argument that tells the queue not to start loading yet\n\t *      queue.load();\n\t *\n\t * @method load\n\t */\n\tp.load = function () {\n\t\tthis._createRequest();\n\n\t\tthis._request.on(\"complete\", this, this);\n\t\tthis._request.on(\"progress\", this, this);\n\t\tthis._request.on(\"loadStart\", this, this);\n\t\tthis._request.on(\"abort\", this, this);\n\t\tthis._request.on(\"timeout\", this, this);\n\t\tthis._request.on(\"error\", this, this);\n\n\t\tvar evt = new createjs.Event(\"initialize\");\n\t\tevt.loader = this._request;\n\t\tthis.dispatchEvent(evt);\n\n\t\tthis._request.load();\n\t};\n\n\t/**\n\t * Close the the item. This will stop any open requests (although downloads using HTML tags may still continue in\n\t * the background), but events will not longer be dispatched.\n\t * @method cancel\n\t */\n\tp.cancel = function () {\n\t\tthis.canceled = true;\n\t\tthis.destroy();\n\t};\n\n\t/**\n\t * Clean up the loader.\n\t * @method destroy\n\t */\n\tp.destroy = function() {\n\t\tif (this._request) {\n\t\t\tthis._request.removeAllEventListeners();\n\t\t\tthis._request.destroy();\n\t\t}\n\n\t\tthis._request = null;\n\n\t\tthis._item = null;\n\t\tthis._rawResult = null;\n\t\tthis._result = null;\n\n\t\tthis._loadItems = null;\n\n\t\tthis.removeAllEventListeners();\n\t};\n\n\t/**\n\t * Get any items loaded internally by the loader. The enables loaders such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}}\n\t * to expose items it loads internally.\n\t * @method getLoadedItems\n\t * @return {Array} A list of the items loaded by the loader.\n\t * @since 0.6.0\n\t */\n\tp.getLoadedItems = function () {\n\t\treturn this._loadedItems;\n\t};\n\n\n\t// Private methods\n\t/**\n\t * Create an internal request used for loading. By default, an {{#crossLink \"XHRRequest\"}}{{/crossLink}} or\n\t * {{#crossLink \"TagRequest\"}}{{/crossLink}} is created, depending on the value of {{#crossLink \"preferXHR:property\"}}{{/crossLink}}.\n\t * Other loaders may override this to use different request types, such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}},\n\t * which uses {{#crossLink \"JSONLoader\"}}{{/crossLink}} or {{#crossLink \"JSONPLoader\"}}{{/crossLink}} under the hood.\n\t * @method _createRequest\n\t * @protected\n\t */\n\tp._createRequest = function() {\n\t\tif (!this._preferXHR) {\n\t\t\tthis._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);\n\t\t} else {\n\t\t\tthis._request = new createjs.XHRRequest(this._item);\n\t\t}\n\t};\n\n\t/**\n\t * Create the HTML tag used for loading. This method does nothing by default, and needs to be implemented\n\t * by loaders that require tag loading.\n\t * @method _createTag\n\t * @param {String} src The tag source\n\t * @return {HTMLElement} The tag that was created\n\t * @protected\n\t */\n\tp._createTag = function(src) { return null; };\n\n\t/**\n\t * Dispatch a loadstart {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"AbstractLoader/loadstart:event\"}}{{/crossLink}}\n\t * event for details on the event payload.\n\t * @method _sendLoadStart\n\t * @protected\n\t */\n\tp._sendLoadStart = function () {\n\t\tif (this._isCanceled()) { return; }\n\t\tthis.dispatchEvent(\"loadstart\");\n\t};\n\n\t/**\n\t * Dispatch a {{#crossLink \"ProgressEvent\"}}{{/crossLink}}.\n\t * @method _sendProgress\n\t * @param {Number | Object} value The progress of the loaded item, or an object containing <code>loaded</code>\n\t * and <code>total</code> properties.\n\t * @protected\n\t */\n\tp._sendProgress = function (value) {\n\t\tif (this._isCanceled()) { return; }\n\t\tvar event = null;\n\t\tif (typeof(value) == \"number\") {\n\t\t\tthis.progress = value;\n\t\t\tevent = new createjs.ProgressEvent(this.progress);\n\t\t} else {\n\t\t\tevent = value;\n\t\t\tthis.progress = value.loaded / value.total;\n\t\t\tevent.progress = this.progress;\n\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n\t\t}\n\t\tthis.hasEventListener(\"progress\") && this.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch a complete {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}} event\n\t * @method _sendComplete\n\t * @protected\n\t */\n\tp._sendComplete = function () {\n\t\tif (this._isCanceled()) { return; }\n\n\t\tthis.loaded = true;\n\n\t\tvar event = new createjs.Event(\"complete\");\n\t\tevent.rawResult = this._rawResult;\n\n\t\tif (this._result != null) {\n\t\t\tevent.result = this._result;\n\t\t}\n\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch an error {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"AbstractLoader/error:event\"}}{{/crossLink}}\n\t * event for details on the event payload.\n\t * @method _sendError\n\t * @param {ErrorEvent} event The event object containing specific error properties.\n\t * @protected\n\t */\n\tp._sendError = function (event) {\n\t\tif (this._isCanceled() || !this.hasEventListener(\"error\")) { return; }\n\t\tif (event == null) {\n\t\t\tevent = new createjs.ErrorEvent(\"PRELOAD_ERROR_EMPTY\"); // TODO: Populate error\n\t\t}\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Determine if the load has been canceled. This is important to ensure that method calls or asynchronous events\n\t * do not cause issues after the queue has been cleaned up.\n\t * @method _isCanceled\n\t * @return {Boolean} If the loader has been canceled.\n\t * @protected\n\t */\n\tp._isCanceled = function () {\n\t\tif (window.createjs == null || this.canceled) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * A custom result formatter function, which is called just before a request dispatches its complete event. Most\n\t * loader types already have an internal formatter, but this can be user-overridden for custom formatting. The\n\t * formatted result will be available on Loaders using {{#crossLink \"getResult\"}}{{/crossLink}}, and passing `true`.\n\t * @property resultFormatter\n\t * @type Function\n\t * @return {Object} The formatted result\n\t * @since 0.6.0\n\t */\n\tp.resultFormatter = null;\n\n\t/**\n\t * Handle events from internal requests. By default, loaders will handle, and redispatch the necessary events, but\n\t * this method can be overridden for custom behaviours.\n\t * @method handleEvent\n\t * @param {Event} event The event that the internal request dispatches.\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase \"complete\":\n\t\t\t\tthis._rawResult = event.target._response;\n\t\t\t\tvar result = this.resultFormatter && this.resultFormatter(this);\n\t\t\t\tif (result instanceof Function) {\n\t\t\t\t\tresult.call(this,\n\t\t\t\t\t\t\tcreatejs.proxy(this._resultFormatSuccess, this),\n\t\t\t\t\t\t\tcreatejs.proxy(this._resultFormatFailed, this)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthis._result =  result || this._rawResult;\n\t\t\t\t\tthis._sendComplete();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"progress\":\n\t\t\t\tthis._sendProgress(event);\n\t\t\t\tbreak;\n\t\t\tcase \"error\":\n\t\t\t\tthis._sendError(event);\n\t\t\t\tbreak;\n\t\t\tcase \"loadstart\":\n\t\t\t\tthis._sendLoadStart();\n\t\t\t\tbreak;\n\t\t\tcase \"abort\":\n\t\t\tcase \"timeout\":\n\t\t\t\tif (!this._isCanceled()) {\n\t\t\t\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"PRELOAD_\" + event.type.toUpperCase() + \"_ERROR\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t/**\n\t * The \"success\" callback passed to {{#crossLink \"AbstractLoader/resultFormatter\"}}{{/crossLink}} asynchronous\n\t * functions.\n\t * @method _resultFormatSuccess\n\t * @param {Object} result The formatted result\n\t * @private\n\t */\n\tp._resultFormatSuccess = function (result) {\n\t\tthis._result = result;\n\t\tthis._sendComplete();\n\t};\n\n\t/**\n\t * The \"error\" callback passed to {{#crossLink \"AbstractLoader/resultFormatter\"}}{{/crossLink}} asynchronous\n\t * functions.\n\t * @method _resultFormatSuccess\n\t * @param {Object} error The error event\n\t * @private\n\t */\n\tp._resultFormatFailed = function (event) {\n\t\tthis._sendError(event);\n\t};\n\n\t/**\n\t * @method buildPath\n\t * @protected\n\t * @deprecated Use the {{#crossLink \"RequestUtils\"}}{{/crossLink}} method {{#crossLink \"RequestUtils/buildPath\"}}{{/crossLink}}\n\t * instead.\n\t */\n\tp.buildPath = function (src, data) {\n\t\treturn createjs.RequestUtils.buildPath(src, data);\n\t};\n\n\t/**\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t */\n\tp.toString = function () {\n\t\treturn \"[PreloadJS AbstractLoader]\";\n\t};\n\n\tcreatejs.AbstractLoader = createjs.promote(AbstractLoader, \"EventDispatcher\");\n\n}());\n\n//##############################################################################\n// AbstractMediaLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * The AbstractMediaLoader is a base class that handles some of the shared methods and properties of loaders that\n\t * handle HTML media elements, such as Video and Audio.\n\t * @class AbstractMediaLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @param {String} type The type of media to load. Usually \"video\" or \"audio\".\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction AbstractMediaLoader(loadItem, preferXHR, type) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, type);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"src\";\n\n        this.on(\"initialize\", this._updateXHR, this);\n\t};\n\n\tvar p = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);\n\n\t// static properties\n\t// public methods\n\tp.load = function () {\n\t\t// TagRequest will handle most of this, but Sound / Video need a few custom properties, so just handle them here.\n\t\tif (!this._tag) {\n\t\t\tthis._tag = this._createTag(this._item.src);\n\t\t}\n\n\t\tthis._tag.preload = \"auto\";\n\t\tthis._tag.load();\n\n\t\tthis.AbstractLoader_load();\n\t};\n\n\t// protected methods\n\t/**\n\t * Creates a new tag for loading if it doesn't exist yet.\n\t * @method _createTag\n\t * @private\n\t */\n\tp._createTag = function () {};\n\n\n\tp._createRequest = function() {\n\t\tif (!this._preferXHR) {\n\t\t\tthis._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);\n\t\t} else {\n\t\t\tthis._request = new createjs.XHRRequest(this._item);\n\t\t}\n\t};\n\n    // protected methods\n    /**\n     * Before the item loads, set its mimeType and responseType.\n     * @property _updateXHR\n     * @param {Event} event\n     * @private\n     */\n    p._updateXHR = function (event) {\n        // Only exists for XHR\n        if (event.loader.setResponseType) {\n            event.loader.setResponseType(\"blob\");\n        }\n    };\n\n\t/**\n\t * The result formatter for media files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLVideoElement|HTMLAudioElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tthis._tag.removeEventListener && this._tag.removeEventListener(\"canplaythrough\", this._loadedHandler);\n\t\tthis._tag.onstalled = null;\n\t\tif (this._preferXHR) {\n            var URL = window.URL || window.webkitURL;\n            var result = loader.getResult(true);\n\n\t\t\tloader.getTag().src = URL.createObjectURL(result);\n\t\t}\n\t\treturn loader.getTag();\n\t};\n\n\tcreatejs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// AbstractRequest.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * A base class for actual data requests, such as {{#crossLink \"XHRRequest\"}}{{/crossLink}}, {{#crossLink \"TagRequest\"}}{{/crossLink}},\n\t * and {{#crossLink \"MediaRequest\"}}{{/crossLink}}. PreloadJS loaders will typically use a data loader under the\n\t * hood to get data.\n\t * @class AbstractRequest\n\t * @param {LoadItem} item\n\t * @constructor\n\t */\n\tvar AbstractRequest = function (item) {\n\t\tthis._item = item;\n\t};\n\n\tvar p = createjs.extend(AbstractRequest, createjs.EventDispatcher);\n\n\t// public methods\n\t/**\n\t * Begin a load.\n\t * @method load\n\t */\n\tp.load =  function() {};\n\n\t/**\n\t * Clean up a request.\n\t * @method destroy\n\t */\n\tp.destroy = function() {};\n\n\t/**\n\t * Cancel an in-progress request.\n\t * @method cancel\n\t */\n\tp.cancel = function() {};\n\n\tcreatejs.AbstractRequest = createjs.promote(AbstractRequest, \"EventDispatcher\");\n\n}());\n\n//##############################################################################\n// TagRequest.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * An {{#crossLink \"AbstractRequest\"}}{{/crossLink}} that loads HTML tags, such as images and scripts.\n\t * @class TagRequest\n\t * @param {LoadItem} loadItem\n\t * @param {HTMLElement} tag\n\t * @param {String} srcAttribute The tag attribute that specifies the source, such as \"src\", \"href\", etc.\n\t */\n\tfunction TagRequest(loadItem, tag, srcAttribute) {\n\t\tthis.AbstractRequest_constructor(loadItem);\n\n\t\t// protected properties\n\t\t/**\n\t\t * The HTML tag instance that is used to load.\n\t\t * @property _tag\n\t\t * @type {HTMLElement}\n\t\t * @protected\n\t\t */\n\t\tthis._tag = tag;\n\n\t\t/**\n\t\t * The tag attribute that specifies the source, such as \"src\", \"href\", etc.\n\t\t * @property _tagSrcAttribute\n\t\t * @type {String}\n\t\t * @protected\n\t\t */\n\t\tthis._tagSrcAttribute = srcAttribute;\n\n\t\t/**\n\t\t * A method closure used for handling the tag load event.\n\t\t * @property _loadedHandler\n\t\t * @type {Function}\n\t\t * @private\n\t\t */\n\t\tthis._loadedHandler = createjs.proxy(this._handleTagComplete, this);\n\n\t\t/**\n\t\t * Determines if the element was added to the DOM automatically by PreloadJS, so it can be cleaned up after.\n\t\t * @property _addedToDOM\n\t\t * @type {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._addedToDOM = false;\n\n\t\t/**\n\t\t * Determines what the tags initial style.visibility was, so we can set it correctly after a load.\n\t\t *\n\t\t * @type {null}\n\t\t * @private\n\t\t */\n\t\tthis._startTagVisibility = null;\n\t};\n\n\tvar p = createjs.extend(TagRequest, createjs.AbstractRequest);\n\n\t// public methods\n\tp.load = function () {\n\t\tthis._tag.onload = createjs.proxy(this._handleTagComplete, this);\n\t\tthis._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);\n\t\tthis._tag.onerror = createjs.proxy(this._handleError, this);\n\n\t\tvar evt = new createjs.Event(\"initialize\");\n\t\tevt.loader = this._tag;\n\n\t\tthis.dispatchEvent(evt);\n\n\t\tthis._hideTag();\n\n\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\n\t\tthis._tag[this._tagSrcAttribute] = this._item.src;\n\n\t\t// wdg:: Append the tag AFTER setting the src, or SVG loading on iOS will fail.\n\t\tif (this._tag.parentNode == null) {\n\t\t\twindow.document.body.appendChild(this._tag);\n\t\t\tthis._addedToDOM = true;\n\t\t}\n\t};\n\n\tp.destroy = function() {\n\t\tthis._clean();\n\t\tthis._tag = null;\n\n\t\tthis.AbstractRequest_destroy();\n\t};\n\n\t// private methods\n\t/**\n\t * Handle the readyStateChange event from a tag. We need this in place of the `onload` callback (mainly SCRIPT\n\t * and LINK tags), but other cases may exist.\n\t * @method _handleReadyStateChange\n\t * @private\n\t */\n\tp._handleReadyStateChange = function () {\n\t\tclearTimeout(this._loadTimeout);\n\t\t// This is strictly for tags in browsers that do not support onload.\n\t\tvar tag = this._tag;\n\n\t\t// Complete is for old IE support.\n\t\tif (tag.readyState == \"loaded\" || tag.readyState == \"complete\") {\n\t\t\tthis._handleTagComplete();\n\t\t}\n\t};\n\n\t/**\n\t * Handle any error events from the tag.\n\t * @method _handleError\n\t * @protected\n\t */\n\tp._handleError = function() {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(\"error\");\n\t};\n\n\t/**\n\t * Handle the tag's onload callback.\n\t * @method _handleTagComplete\n\t * @private\n\t */\n\tp._handleTagComplete = function () {\n\t\tthis._rawResult = this._tag;\n\t\tthis._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult;\n\n\t\tthis._clean();\n\t\tthis._showTag();\n\n\t\tthis.dispatchEvent(\"complete\");\n\t};\n\n\t/**\n\t * The tag request has not loaded within the time specified in loadTimeout.\n\t * @method _handleError\n\t * @param {Object} event The XHR error event.\n\t * @private\n\t */\n\tp._handleTimeout = function () {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.Event(\"timeout\"));\n\t};\n\n\t/**\n\t * Remove event listeners, but don't destroy the request object\n\t * @method _clean\n\t * @private\n\t */\n\tp._clean = function() {\n\t\tthis._tag.onload = null;\n\t\tthis._tag.onreadystatechange = null;\n\t\tthis._tag.onerror = null;\n\t\tif (this._addedToDOM && this._tag.parentNode != null) {\n\t\t\tthis._tag.parentNode.removeChild(this._tag);\n\t\t}\n\t\tclearTimeout(this._loadTimeout);\n\t};\n\n\tp._hideTag = function() {\n\t\tthis._startTagVisibility = this._tag.style.visibility;\n\t\tthis._tag.style.visibility = \"hidden\";\n\t};\n\n\tp._showTag = function() {\n\t\tthis._tag.style.visibility = this._startTagVisibility;\n\t};\n\n\t/**\n\t * Handle a stalled audio event. The main place this happens is with HTMLAudio in Chrome when playing back audio\n\t * that is already in a load, but not complete.\n\t * @method _handleStalled\n\t * @private\n\t */\n\tp._handleStalled = function () {\n\t\t//Ignore, let the timeout take care of it. Sometimes its not really stopped.\n\t};\n\n\tcreatejs.TagRequest = createjs.promote(TagRequest, \"AbstractRequest\");\n\n}());\n\n//##############################################################################\n// MediaTagRequest.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * An {{#crossLink \"TagRequest\"}}{{/crossLink}} that loads HTML tags for video and audio.\n\t * @class MediaTagRequest\n\t * @param {LoadItem} loadItem\n\t * @param {HTMLAudioElement|HTMLVideoElement} tag\n\t * @param {String} srcAttribute The tag attribute that specifies the source, such as \"src\", \"href\", etc.\n\t * @constructor\n\t */\n\tfunction MediaTagRequest(loadItem, tag, srcAttribute) {\n\t\tthis.AbstractRequest_constructor(loadItem);\n\n\t\t// protected properties\n\t\tthis._tag = tag;\n\t\tthis._tagSrcAttribute = srcAttribute;\n\t\tthis._loadedHandler = createjs.proxy(this._handleTagComplete, this);\n\t};\n\n\tvar p = createjs.extend(MediaTagRequest, createjs.TagRequest);\n\tvar s = MediaTagRequest;\n\n\t// public methods\n\tp.load = function () {\n\t\tvar sc = createjs.proxy(this._handleStalled, this);\n\t\tthis._stalledCallback = sc;\n\n\t\tvar pc = createjs.proxy(this._handleProgress, this);\n\t\tthis._handleProgress = pc;\n\n\t\tthis._tag.addEventListener(\"stalled\", sc);\n\t\tthis._tag.addEventListener(\"progress\", pc);\n\n\t\t// This will tell us when audio is buffered enough to play through, but not when its loaded.\n\t\t// The tag doesn't keep loading in Chrome once enough has buffered, and we have decided that behaviour is sufficient.\n\t\tthis._tag.addEventListener && this._tag.addEventListener(\"canplaythrough\", this._loadedHandler, false); // canplaythrough callback doesn't work in Chrome, so we use an event.\n\n\t\tthis.TagRequest_load();\n\t};\n\n\t// private methods\n\tp._handleReadyStateChange = function () {\n\t\tclearTimeout(this._loadTimeout);\n\t\t// This is strictly for tags in browsers that do not support onload.\n\t\tvar tag = this._tag;\n\n\t\t// Complete is for old IE support.\n\t\tif (tag.readyState == \"loaded\" || tag.readyState == \"complete\") {\n\t\t\tthis._handleTagComplete();\n\t\t}\n\t};\n\n\tp._handleStalled = function () {\n\t\t//Ignore, let the timeout take care of it. Sometimes its not really stopped.\n\t};\n\n\t/**\n\t * An XHR request has reported progress.\n\t * @method _handleProgress\n\t * @param {Object} event The XHR progress event.\n\t * @private\n\t */\n\tp._handleProgress = function (event) {\n\t\tif (!event || event.loaded > 0 && event.total == 0) {\n\t\t\treturn; // Sometimes we get no \"total\", so just ignore the progress event.\n\t\t}\n\n\t\tvar newEvent = new createjs.ProgressEvent(event.loaded, event.total);\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\t// protected methods\n\tp._clean = function () {\n\t\tthis._tag.removeEventListener && this._tag.removeEventListener(\"canplaythrough\", this._loadedHandler);\n\t\tthis._tag.removeEventListener(\"stalled\", this._stalledCallback);\n\t\tthis._tag.removeEventListener(\"progress\", this._progressCallback);\n\n\t\tthis.TagRequest__clean();\n\t};\n\n\tcreatejs.MediaTagRequest = createjs.promote(MediaTagRequest, \"TagRequest\");\n\n}());\n\n//##############################################################################\n// XHRRequest.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n// constructor\n\t/**\n\t * A preloader that loads items using XHR requests, usually XMLHttpRequest. However XDomainRequests will be used\n\t * for cross-domain requests if possible, and older versions of IE fall back on to ActiveX objects when necessary.\n\t * XHR requests load the content as text or binary data, provide progress and consistent completion events, and\n\t * can be canceled during load. Note that XHR is not supported in IE 6 or earlier, and is not recommended for\n\t * cross-domain loading.\n\t * @class XHRRequest\n\t * @constructor\n\t * @param {Object} item The object that defines the file to load. Please see the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * for an overview of supported file properties.\n\t * @extends AbstractLoader\n\t */\n\tfunction XHRRequest (item) {\n\t\tthis.AbstractRequest_constructor(item);\n\n\t\t// protected properties\n\t\t/**\n\t\t * A reference to the XHR request used to load the content.\n\t\t * @property _request\n\t\t * @type {XMLHttpRequest | XDomainRequest | ActiveX.XMLHTTP}\n\t\t * @private\n\t\t */\n\t\tthis._request = null;\n\n\t\t/**\n\t\t * A manual load timeout that is used for browsers that do not support the onTimeout event on XHR (XHR level 1,\n\t\t * typically IE9).\n\t\t * @property _loadTimeout\n\t\t * @type {Number}\n\t\t * @private\n\t\t */\n\t\tthis._loadTimeout = null;\n\n\t\t/**\n\t\t * The browser's XHR (XMLHTTPRequest) version. Supported versions are 1 and 2. There is no official way to detect\n\t\t * the version, so we use capabilities to make a best guess.\n\t\t * @property _xhrLevel\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t * @private\n\t\t */\n\t\tthis._xhrLevel = 1;\n\n\t\t/**\n\t\t * The response of a loaded file. This is set because it is expensive to look up constantly. This property will be\n\t\t * null until the file is loaded.\n\t\t * @property _response\n\t\t * @type {mixed}\n\t\t * @private\n\t\t */\n\t\tthis._response = null;\n\n\t\t/**\n\t\t * The response of the loaded file before it is modified. In most cases, content is converted from raw text to\n\t\t * an HTML tag or a formatted object which is set to the <code>result</code> property, but the developer may still\n\t\t * want to access the raw content as it was loaded.\n\t\t * @property _rawResponse\n\t\t * @type {String|Object}\n\t\t * @private\n\t\t */\n\t\tthis._rawResponse = null;\n\n\t\tthis._canceled = false;\n\n\t\t// Setup our event handlers now.\n\t\tthis._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this);\n\t\tthis._handleProgressProxy = createjs.proxy(this._handleProgress, this);\n\t\tthis._handleAbortProxy = createjs.proxy(this._handleAbort, this);\n\t\tthis._handleErrorProxy = createjs.proxy(this._handleError, this);\n\t\tthis._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this);\n\t\tthis._handleLoadProxy = createjs.proxy(this._handleLoad, this);\n\t\tthis._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this);\n\n\t\tif (!this._createXHR(item)) {\n\t\t\t//TODO: Throw error?\n\t\t}\n\t};\n\n\tvar p = createjs.extend(XHRRequest, createjs.AbstractRequest);\n\n// static properties\n\t/**\n\t * A list of XMLHTTP object IDs to try when building an ActiveX object for XHR requests in earlier versions of IE.\n\t * @property ACTIVEX_VERSIONS\n\t * @type {Array}\n\t * @since 0.4.2\n\t * @private\n\t */\n\tXHRRequest.ACTIVEX_VERSIONS = [\n\t\t\"Msxml2.XMLHTTP.6.0\",\n\t\t\"Msxml2.XMLHTTP.5.0\",\n\t\t\"Msxml2.XMLHTTP.4.0\",\n\t\t\"MSXML2.XMLHTTP.3.0\",\n\t\t\"MSXML2.XMLHTTP\",\n\t\t\"Microsoft.XMLHTTP\"\n\t];\n\n// Public methods\n\t/**\n\t * Look up the loaded result.\n\t * @method getResult\n\t * @param {Boolean} [raw=false] Return a raw result instead of a formatted result. This applies to content\n\t * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be\n\t * returned instead.\n\t * @return {Object} A result object containing the content that was loaded, such as:\n\t * <ul>\n\t *      <li>An image tag (&lt;image /&gt;) for images</li>\n\t *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts loaded with tags may be added to the\n\t *      HTML head.</li>\n\t *      <li>A style tag for CSS (&lt;style /&gt;)</li>\n\t *      <li>Raw text for TEXT</li>\n\t *      <li>A formatted JavaScript object defined by JSON</li>\n\t *      <li>An XML document</li>\n\t *      <li>An binary arraybuffer loaded by XHR</li>\n\t * </ul>\n\t * Note that if a raw result is requested, but not found, the result will be returned instead.\n\t */\n\tp.getResult = function (raw) {\n\t\tif (raw && this._rawResponse) {\n\t\t\treturn this._rawResponse;\n\t\t}\n\t\treturn this._response;\n\t};\n\n\t// Overrides abstract method in AbstractRequest\n\tp.cancel = function () {\n\t\tthis.canceled = true;\n\t\tthis._clean();\n\t\tthis._request.abort();\n\t};\n\n\t// Overrides abstract method in AbstractLoader\n\tp.load = function () {\n\t\tif (this._request == null) {\n\t\t\tthis._handleError();\n\t\t\treturn;\n\t\t}\n\n\t\t//Events\n\t\tif (this._request.addEventListener != null) {\n\t\t\tthis._request.addEventListener(\"loadstart\", this._handleLoadStartProxy, false);\n\t\t\tthis._request.addEventListener(\"progress\", this._handleProgressProxy, false);\n\t\t\tthis._request.addEventListener(\"abort\", this._handleAbortProxy, false);\n\t\t\tthis._request.addEventListener(\"error\", this._handleErrorProxy, false);\n\t\t\tthis._request.addEventListener(\"timeout\", this._handleTimeoutProxy, false);\n\n\t\t\t// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.\n\t\t\tthis._request.addEventListener(\"load\", this._handleLoadProxy, false);\n\t\t\tthis._request.addEventListener(\"readystatechange\", this._handleReadyStateChangeProxy, false);\n\t\t} else {\n\t\t\t// IE9 support\n\t\t\tthis._request.onloadstart = this._handleLoadStartProxy;\n\t\t\tthis._request.onprogress = this._handleProgressProxy;\n\t\t\tthis._request.onabort = this._handleAbortProxy;\n\t\t\tthis._request.onerror = this._handleErrorProxy;\n\t\t\tthis._request.ontimeout = this._handleTimeoutProxy;\n\n\t\t\t// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.\n\t\t\tthis._request.onload = this._handleLoadProxy;\n\t\t\tthis._request.onreadystatechange = this._handleReadyStateChangeProxy;\n\t\t}\n\n\t\t// Set up a timeout if we don't have XHR2\n\t\tif (this._xhrLevel == 1) {\n\t\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\t\t}\n\n\t\t// Sometimes we get back 404s immediately, particularly when there is a cross origin request.  // note this does not catch in Chrome\n\t\ttry {\n\t\t\tif (!this._item.values || this._item.method == createjs.AbstractLoader.GET) {\n\t\t\t\tthis._request.send();\n\t\t\t} else if (this._item.method == createjs.AbstractLoader.POST) {\n\t\t\t\tthis._request.send(createjs.RequestUtils.formatQueryString(this._item.values));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"XHR_SEND\", null, error));\n\t\t}\n\t};\n\n\tp.setResponseType = function (type) {\n\t\t// Some old browsers doesn't support blob, so we convert arraybuffer to blob after response is downloaded\n\t\tif (type === 'blob') {\n\t\t\ttype = window.URL ? 'blob' : 'arraybuffer';\n\t\t\tthis._responseType = type;\n\t\t}\n\t\tthis._request.responseType = type;\n\t};\n\n\t/**\n\t * Get all the response headers from the XmlHttpRequest.\n\t *\n\t * <strong>From the docs:</strong> Return all the HTTP headers, excluding headers that are a case-insensitive match\n\t * for Set-Cookie or Set-Cookie2, as a single string, with each header line separated by a U+000D CR U+000A LF pair,\n\t * excluding the status line, and with each header name and header value separated by a U+003A COLON U+0020 SPACE\n\t * pair.\n\t * @method getAllResponseHeaders\n\t * @return {String}\n\t * @since 0.4.1\n\t */\n\tp.getAllResponseHeaders = function () {\n\t\tif (this._request.getAllResponseHeaders instanceof Function) {\n\t\t\treturn this._request.getAllResponseHeaders();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n\t/**\n\t * Get a specific response header from the XmlHttpRequest.\n\t *\n\t * <strong>From the docs:</strong> Returns the header field value from the response of which the field name matches\n\t * header, unless the field name is Set-Cookie or Set-Cookie2.\n\t * @method getResponseHeader\n\t * @param {String} header The header name to retrieve.\n\t * @return {String}\n\t * @since 0.4.1\n\t */\n\tp.getResponseHeader = function (header) {\n\t\tif (this._request.getResponseHeader instanceof Function) {\n\t\t\treturn this._request.getResponseHeader(header);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n// protected methods\n\t/**\n\t * The XHR request has reported progress.\n\t * @method _handleProgress\n\t * @param {Object} event The XHR progress event.\n\t * @private\n\t */\n\tp._handleProgress = function (event) {\n\t\tif (!event || event.loaded > 0 && event.total == 0) {\n\t\t\treturn; // Sometimes we get no \"total\", so just ignore the progress event.\n\t\t}\n\n\t\tvar newEvent = new createjs.ProgressEvent(event.loaded, event.total);\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\t/**\n\t * The XHR request has reported a load start.\n\t * @method _handleLoadStart\n\t * @param {Object} event The XHR loadStart event.\n\t * @private\n\t */\n\tp._handleLoadStart = function (event) {\n\t\tclearTimeout(this._loadTimeout);\n\t\tthis.dispatchEvent(\"loadstart\");\n\t};\n\n\t/**\n\t * The XHR request has reported an abort event.\n\t * @method handleAbort\n\t * @param {Object} event The XHR abort event.\n\t * @private\n\t */\n\tp._handleAbort = function (event) {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"XHR_ABORTED\", null, event));\n\t};\n\n\t/**\n\t * The XHR request has reported an error event.\n\t * @method _handleError\n\t * @param {Object} event The XHR error event.\n\t * @private\n\t */\n\tp._handleError = function (event) {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(event.message));\n\t};\n\n\t/**\n\t * The XHR request has reported a readyState change. Note that older browsers (IE 7 & 8) do not provide an onload\n\t * event, so we must monitor the readyStateChange to determine if the file is loaded.\n\t * @method _handleReadyStateChange\n\t * @param {Object} event The XHR readyStateChange event.\n\t * @private\n\t */\n\tp._handleReadyStateChange = function (event) {\n\t\tif (this._request.readyState == 4) {\n\t\t\tthis._handleLoad();\n\t\t}\n\t};\n\n\t/**\n\t * The XHR request has completed. This is called by the XHR request directly, or by a readyStateChange that has\n\t * <code>request.readyState == 4</code>. Only the first call to this method will be processed.\n\t * @method _handleLoad\n\t * @param {Object} event The XHR load event.\n\t * @private\n\t */\n\tp._handleLoad = function (event) {\n\t\tif (this.loaded) {\n\t\t\treturn;\n\t\t}\n\t\tthis.loaded = true;\n\n\t\tvar error = this._checkError();\n\t\tif (error) {\n\t\t\tthis._handleError(error);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._response = this._getResponse();\n\t\t// Convert arraybuffer back to blob\n\t\tif (this._responseType === 'arraybuffer') {\n\t\t\ttry {\n\t\t\t\tthis._response = new Blob([this._response]);\n\t\t\t} catch (e) {\n\t\t\t\t// Fallback to use BlobBuilder if Blob constructor is not supported\n\t\t\t\t// Tested on Android 2.3 ~ 4.2 and iOS5 safari\n\t\t\t\twindow.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\t\t\t\tif (e.name === 'TypeError' && window.BlobBuilder) {\n\t\t\t\t\tvar builder = new BlobBuilder();\n\t\t\t\t\tbuilder.append(this._response);\n\t\t\t\t\tthis._response = builder.getBlob();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._clean();\n\n\t\tthis.dispatchEvent(new createjs.Event(\"complete\"));\n\t};\n\n\t/**\n\t * The XHR request has timed out. This is called by the XHR request directly, or via a <code>setTimeout</code>\n\t * callback.\n\t * @method _handleTimeout\n\t * @param {Object} [event] The XHR timeout event. This is occasionally null when called by the backup setTimeout.\n\t * @private\n\t */\n\tp._handleTimeout = function (event) {\n\t\tthis._clean();\n\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"PRELOAD_TIMEOUT\", null, event));\n\t};\n\n// Protected\n\t/**\n\t * Determine if there is an error in the current load. This checks the status of the request for problem codes. Note\n\t * that this does not check for an actual response. Currently, it only checks for 404 or 0 error code.\n\t * @method _checkError\n\t * @return {int} If the request status returns an error code.\n\t * @private\n\t */\n\tp._checkError = function () {\n\t\t//LM: Probably need additional handlers here, maybe 501\n\t\tvar status = parseInt(this._request.status);\n\n\t\tswitch (status) {\n\t\t\tcase 404:   // Not Found\n\t\t\tcase 0:     // Not Loaded\n\t\t\t\treturn new Error(status);\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Validate the response. Different browsers have different approaches, some of which throw errors when accessed\n\t * in other browsers. If there is no response, the <code>_response</code> property will remain null.\n\t * @method _getResponse\n\t * @private\n\t */\n\tp._getResponse = function () {\n\t\tif (this._response != null) {\n\t\t\treturn this._response;\n\t\t}\n\n\t\tif (this._request.response != null) {\n\t\t\treturn this._request.response;\n\t\t}\n\n\t\t// Android 2.2 uses .responseText\n\t\ttry {\n\t\t\tif (this._request.responseText != null) {\n\t\t\t\treturn this._request.responseText;\n\t\t\t}\n\t\t} catch (e) {\n\t\t}\n\n\t\t// When loading XML, IE9 does not return .response, instead it returns responseXML.xml\n\t\ttry {\n\t\t\tif (this._request.responseXML != null) {\n\t\t\t\treturn this._request.responseXML;\n\t\t\t}\n\t\t} catch (e) {\n\t\t}\n\n\t\treturn null;\n\t};\n\n\t/**\n\t * Create an XHR request. Depending on a number of factors, we get totally different results.\n\t * <ol><li>Some browsers get an <code>XDomainRequest</code> when loading cross-domain.</li>\n\t *      <li>XMLHttpRequest are created when available.</li>\n\t *      <li>ActiveX.XMLHTTP objects are used in older IE browsers.</li>\n\t *      <li>Text requests override the mime type if possible</li>\n\t *      <li>Origin headers are sent for crossdomain requests in some browsers.</li>\n\t *      <li>Binary loads set the response type to \"arraybuffer\"</li></ol>\n\t * @method _createXHR\n\t * @param {Object} item The requested item that is being loaded.\n\t * @return {Boolean} If an XHR request or equivalent was successfully created.\n\t * @private\n\t */\n\tp._createXHR = function (item) {\n\t\t// Check for cross-domain loads. We can't fully support them, but we can try.\n\t\tvar crossdomain = createjs.RequestUtils.isCrossDomain(item);\n\t\tvar headers = {};\n\n\t\t// Create the request. Fallback to whatever support we have.\n\t\tvar req = null;\n\t\tif (window.XMLHttpRequest) {\n\t\t\treq = new XMLHttpRequest();\n\t\t\t// This is 8 or 9, so use XDomainRequest instead.\n\t\t\tif (crossdomain && req.withCredentials === undefined && window.XDomainRequest) {\n\t\t\t\treq = new XDomainRequest();\n\t\t\t}\n\t\t} else { // Old IE versions use a different approach\n\t\t\tfor (var i = 0, l = s.ACTIVEX_VERSIONS.length; i < l; i++) {\n\t\t\t\tvar axVersion = s.ACTIVEX_VERSIONS[i];\n\t\t\t\ttry {\n\t\t\t\t\treq = new ActiveXObject(axVersion);\n\t\t\t\t\tbreak;\n\t\t\t\t} catch (e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (req == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Default to utf-8 for Text requests.\n\t\tif (item.mimeType == null && createjs.RequestUtils.isText(item.type)) {\n\t\t\titem.mimeType = \"text/plain; charset=utf-8\";\n\t\t}\n\n\t\t// IE9 doesn't support overrideMimeType(), so we need to check for it.\n\t\tif (item.mimeType && req.overrideMimeType) {\n\t\t\treq.overrideMimeType(item.mimeType);\n\t\t}\n\n\t\t// Determine the XHR level\n\t\tthis._xhrLevel = (typeof req.responseType === \"string\") ? 2 : 1;\n\n\t\tvar src = null;\n\t\tif (item.method == createjs.AbstractLoader.GET) {\n\t\t\tsrc = createjs.RequestUtils.buildPath(item.src, item.values);\n\t\t} else {\n\t\t\tsrc = item.src;\n\t\t}\n\n\t\t// Open the request.  Set cross-domain flags if it is supported (XHR level 1 only)\n\t\treq.open(item.method || createjs.AbstractLoader.GET, src, true);\n\n\t\tif (crossdomain && req instanceof XMLHttpRequest && this._xhrLevel == 1) {\n\t\t\theaders[\"Origin\"] = location.origin;\n\t\t}\n\n\t\t// To send data we need to set the Content-type header)\n\t\tif (item.values && item.method == createjs.AbstractLoader.POST) {\n\t\t\theaders[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n\t\t}\n\n\t\tif (!crossdomain && !headers[\"X-Requested-With\"]) {\n\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t}\n\n\t\tif (item.headers) {\n\t\t\tfor (var n in item.headers) {\n\t\t\t\theaders[n] = item.headers[n];\n\t\t\t}\n\t\t}\n\n\t\tfor (n in headers) {\n\t\t\treq.setRequestHeader(n, headers[n])\n\t\t}\n\n\t\tif (req instanceof XMLHttpRequest && item.withCredentials !== undefined) {\n\t\t\treq.withCredentials = item.withCredentials;\n\t\t}\n\n\t\tthis._request = req;\n\n\t\treturn true;\n\t};\n\n\t/**\n\t * A request has completed (or failed or canceled), and needs to be disposed.\n\t * @method _clean\n\t * @private\n\t */\n\tp._clean = function () {\n\t\tclearTimeout(this._loadTimeout);\n\n\t\tif (this._request.removeEventListener != null) {\n\t\t\tthis._request.removeEventListener(\"loadstart\", this._handleLoadStartProxy);\n\t\t\tthis._request.removeEventListener(\"progress\", this._handleProgressProxy);\n\t\t\tthis._request.removeEventListener(\"abort\", this._handleAbortProxy);\n\t\t\tthis._request.removeEventListener(\"error\", this._handleErrorProxy);\n\t\t\tthis._request.removeEventListener(\"timeout\", this._handleTimeoutProxy);\n\t\t\tthis._request.removeEventListener(\"load\", this._handleLoadProxy);\n\t\t\tthis._request.removeEventListener(\"readystatechange\", this._handleReadyStateChangeProxy);\n\t\t} else {\n\t\t\tthis._request.onloadstart = null;\n\t\t\tthis._request.onprogress = null;\n\t\t\tthis._request.onabort = null;\n\t\t\tthis._request.onerror = null;\n\t\t\tthis._request.ontimeout = null;\n\t\t\tthis._request.onload = null;\n\t\t\tthis._request.onreadystatechange = null;\n\t\t}\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[PreloadJS XHRRequest]\";\n\t};\n\n\tcreatejs.XHRRequest = createjs.promote(XHRRequest, \"AbstractRequest\");\n\n}());\n\n//##############################################################################\n// LoadQueue.js\n//##############################################################################\n\n/*\n TODO: WINDOWS ISSUES\n * No error for HTML audio in IE 678\n * SVG no failure error in IE 67 (maybe 8) TAGS AND XHR\n * No script complete handler in IE 67 TAGS (XHR is fine)\n * No XML/JSON in IE6 TAGS\n * Need to hide loading SVG in Opera TAGS\n * No CSS onload/readystatechange in Safari or Android TAGS (requires rule checking)\n * SVG no load or failure in Opera XHR\n * Reported issues with IE7/8\n */\n\n(function () {\n\t\"use strict\";\n\n// constructor\n\t/**\n\t * The LoadQueue class is the main API for preloading content. LoadQueue is a load manager, which can preload either\n\t * a single file, or queue of files.\n\t *\n\t * <b>Creating a Queue</b><br />\n\t * To use LoadQueue, create a LoadQueue instance. If you want to force tag loading where possible, set the preferXHR\n\t * argument to false.\n\t *\n\t *      var queue = new createjs.LoadQueue(true);\n\t *\n\t * <b>Listening for Events</b><br />\n\t * Add any listeners you want to the queue. Since PreloadJS 0.3.0, the {{#crossLink \"EventDispatcher\"}}{{/crossLink}}\n\t * lets you add as many listeners as you want for events. You can subscribe to the following events:<ul>\n\t *     <li>{{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}}: fired when a queue completes loading all\n\t *     files</li>\n\t *     <li>{{#crossLink \"AbstractLoader/error:event\"}}{{/crossLink}}: fired when the queue encounters an error with\n\t *     any file.</li>\n\t *     <li>{{#crossLink \"AbstractLoader/progress:event\"}}{{/crossLink}}: Progress for the entire queue has\n\t *     changed.</li>\n\t *     <li>{{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}}: A single file has completed loading.</li>\n\t *     <li>{{#crossLink \"LoadQueue/fileprogress:event\"}}{{/crossLink}}: Progress for a single file has changes. Note\n\t *     that only files loaded with XHR (or possibly by plugins) will fire progress events other than 0 or 100%.</li>\n\t * </ul>\n\t *\n\t *      queue.on(\"fileload\", handleFileLoad, this);\n\t *      queue.on(\"complete\", handleComplete, this);\n\t *\n\t * <b>Adding files and manifests</b><br />\n\t * Add files you want to load using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} or add multiple files at a\n\t * time using a list or a manifest definition using {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}. Files are\n\t * appended to the end of the active queue, so you can use these methods as many times as you like, whenever you\n\t * like.\n\t *\n\t *      queue.loadFile(\"filePath/file.jpg\");\n\t *      queue.loadFile({id:\"image\", src:\"filePath/file.jpg\"});\n\t *      queue.loadManifest([\"filePath/file.jpg\", {id:\"image\", src:\"filePath/file.jpg\"}]);\n\t *\n\t *      // Use an external manifest\n\t *      queue.loadManifest(\"path/to/manifest.json\");\n\t *      queue.loadManifest({src:\"manifest.json\", type:\"manifest\"});\n\t *\n\t * If you pass `false` as the `loadNow` parameter, the queue will not kick of the load of the files, but it will not\n\t * stop if it has already been started. Call the {{#crossLink \"AbstractLoader/load\"}}{{/crossLink}} method to begin\n\t * a paused queue. Note that a paused queue will automatically resume when new files are added to it with a\n\t * `loadNow` argument of `true`.\n\t *\n\t *      queue.load();\n\t *\n\t * <b>File Types</b><br />\n\t * The file type of a manifest item is auto-determined by the file extension. The pattern matching in PreloadJS\n\t * should handle the majority of standard file and url formats, and works with common file extensions. If you have\n\t * either a non-standard file extension, or are serving the file using a proxy script, then you can pass in a\n\t * <code>type</code> property with any manifest item.\n\t *\n\t *      queue.loadFile({src:\"path/to/myFile.mp3x\", type:createjs.AbstractLoader.SOUND});\n\t *\n\t *      // Note that PreloadJS will not read a file extension from the query string\n\t *      queue.loadFile({src:\"http://server.com/proxy?file=image.jpg\", type:createjs.AbstractLoader.IMAGE});\n\t *\n\t * Supported types are defined on the {{#crossLink \"AbstractLoader\"}}{{/crossLink}} class, and include:\n\t * <ul>\n\t *     <li>{{#crossLink \"AbstractLoader/BINARY:property\"}}{{/crossLink}}: Raw binary data via XHR</li>\n\t *     <li>{{#crossLink \"AbstractLoader/CSS:property\"}}{{/crossLink}}: CSS files</li>\n\t *     <li>{{#crossLink \"AbstractLoader/IMAGE:property\"}}{{/crossLink}}: Common image formats</li>\n\t *     <li>{{#crossLink \"AbstractLoader/JAVASCRIPT:property\"}}{{/crossLink}}: JavaScript files</li>\n\t *     <li>{{#crossLink \"AbstractLoader/JSON:property\"}}{{/crossLink}}: JSON data</li>\n\t *     <li>{{#crossLink \"AbstractLoader/JSONP:property\"}}{{/crossLink}}: JSON files cross-domain</li>\n\t *     <li>{{#crossLink \"AbstractLoader/MANIFEST:property\"}}{{/crossLink}}: A list of files to load in JSON format, see\n\t *     {{#crossLink \"AbstractLoader/loadManifest\"}}{{/crossLink}}</li>\n\t *     <li>{{#crossLink \"AbstractLoader/SOUND:property\"}}{{/crossLink}}: Audio file formats</li>\n\t *     <li>{{#crossLink \"AbstractLoader/SPRITESHEET:property\"}}{{/crossLink}}: JSON SpriteSheet definitions. This\n\t *     will also load sub-images, and provide a {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instance.</li>\n\t *     <li>{{#crossLink \"AbstractLoader/SVG:property\"}}{{/crossLink}}: SVG files</li>\n\t *     <li>{{#crossLink \"AbstractLoader/TEXT:property\"}}{{/crossLink}}: Text files - XHR only</li>\n     *     <li>{{#crossLink \"AbstractLoader/VIDEO:property\"}}{{/crossLink}}: Video objects</li>\n\t *     <li>{{#crossLink \"AbstractLoader/XML:property\"}}{{/crossLink}}: XML data</li>\n\t * </ul>\n\t *\n\t * <em>Note: Loader types used to be defined on LoadQueue, but have been moved to AbstractLoader for better\n\t * portability of loader classes, which can be used individually now. The properties on LoadQueue still exist, but\n\t * are deprecated.</em>\n\t *\n\t * <b>Handling Results</b><br />\n\t * When a file is finished downloading, a {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event is\n\t * dispatched. In an example above, there is an event listener snippet for fileload. Loaded files are usually a\n\t * formatted object that can be used immediately, including:\n\t * <ul>\n\t *     <li>Binary: The binary loaded result</li>\n\t *     <li>CSS: A &lt;link /&gt; tag</li>\n\t *     <li>Image: An &lt;img /&gt; tag</li>\n\t *     <li>JavaScript: A &lt;script /&gt; tag</li>\n\t *     <li>JSON/JSONP: A formatted JavaScript Object</li>\n\t *     <li>Manifest: A JavaScript object.\n\t *     <li>Sound: An &lt;audio /&gt; tag</a>\n\t *     <li>SpriteSheet: A {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instance, containing loaded images.\n\t *     <li>SVG: An &lt;object /&gt; tag</li>\n\t *     <li>Text: Raw text</li>\n     *     <li>Video: A Video DOM node</li>\n\t *     <li>XML: An XML DOM node</li>\n\t * </ul>\n\t *\n\t *      function handleFileLoad(event) {\n\t *          var item = event.item; // A reference to the item that was passed in to the LoadQueue\n\t *          var type = item.type;\n\t *\n\t *          // Add any images to the page body.\n\t *          if (type == createjs.LoadQueue.IMAGE) {\n\t *              document.body.appendChild(event.result);\n\t *          }\n\t *      }\n\t *\n\t * At any time after the file has been loaded (usually after the queue has completed), any result can be looked up\n\t * via its \"id\" using {{#crossLink \"LoadQueue/getResult\"}}{{/crossLink}}. If no id was provided, then the\n\t * \"src\" or file path can be used instead, including the `path` defined by a manifest, but <strong>not including</strong>\n\t * a base path defined on the LoadQueue. It is recommended to always pass an id if you want to look up content.\n\t *\n\t *      var image = queue.getResult(\"image\");\n\t *      document.body.appendChild(image);\n\t *\n\t * Raw loaded content can be accessed using the <code>rawResult</code> property of the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}}\n\t * event, or can be looked up using {{#crossLink \"LoadQueue/getResult\"}}{{/crossLink}}, passing `true` as the 2nd\n\t * argument. This is only applicable for content that has been parsed for the browser, specifically: JavaScript,\n\t * CSS, XML, SVG, and JSON objects, or anything loaded with XHR.\n\t *\n\t *      var image = queue.getResult(\"image\", true); // load the binary image data loaded with XHR.\n\t *\n\t * <b>Plugins</b><br />\n\t * LoadQueue has a simple plugin architecture to help process and preload content. For example, to preload audio,\n\t * make sure to install the <a href=\"http://soundjs.com\">SoundJS</a> Sound class, which will help load HTML audio,\n\t * Flash audio, and WebAudio files. This should be installed <strong>before</strong> loading any audio files.\n\t *\n\t *      queue.installPlugin(createjs.Sound);\n\t *\n\t * <h4>Known Browser Issues</h4>\n\t * <ul>\n\t *     <li>Browsers without audio support can not load audio files.</li>\n\t *     <li>Safari on Mac OS X can only play HTML audio if QuickTime is installed</li>\n\t *     <li>HTML Audio tags will only download until their <code>canPlayThrough</code> event is fired. Browsers other\n\t *     than Chrome will continue to download in the background.</li>\n\t *     <li>When loading scripts using tags, they are automatically added to the document.</li>\n\t *     <li>Scripts loaded via XHR may not be properly inspectable with browser tools.</li>\n\t *     <li>IE6 and IE7 (and some other browsers) may not be able to load XML, Text, or JSON, since they require\n\t *     XHR to work.</li>\n\t *     <li>Content loaded via tags will not show progress, and will continue to download in the background when\n\t *     canceled, although no events will be dispatched.</li>\n\t * </ul>\n\t *\n\t * @class LoadQueue\n\t * @param {Boolean} [preferXHR=true] Determines whether the preload instance will favor loading with XHR (XML HTTP\n\t * Requests), or HTML tags. When this is `false`, the queue will use tag loading when possible, and fall back on XHR\n\t * when necessary.\n\t * @param {String} [basePath=\"\"] A path that will be prepended on to the source parameter of all items in the queue\n\t * before they are loaded.  Sources beginning with a protocol such as `http://` or a relative path such as `../`\n\t * will not receive a base path.\n\t * @param {String|Boolean} [crossOrigin=\"\"] An optional flag to support images loaded from a CORS-enabled server. To\n\t * use it, set this value to `true`, which will default the crossOrigin property on images to \"Anonymous\". Any\n\t * string value will be passed through, but only \"\" and \"Anonymous\" are recommended. <strong>Note: The crossOrigin\n\t * parameter is deprecated. Use LoadItem.crossOrigin instead</strong>\n\t *\n\t * @constructor\n\t * @extends AbstractLoader\n\t */\n\tfunction LoadQueue (preferXHR, basePath, crossOrigin) {\n\t\tthis.AbstractLoader_constructor();\n\n\t\t/**\n\t\t * An array of the plugins registered using {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}}.\n\t\t * @property _plugins\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.1\n\t\t */\n\t\tthis._plugins = [];\n\n\t\t/**\n\t\t * An object hash of callbacks that are fired for each file type before the file is loaded, giving plugins the\n\t\t * ability to override properties of the load. Please see the {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}}\n\t\t * method for more information.\n\t\t * @property _typeCallbacks\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._typeCallbacks = {};\n\n\t\t/**\n\t\t * An object hash of callbacks that are fired for each file extension before the file is loaded, giving plugins the\n\t\t * ability to override properties of the load. Please see the {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}}\n\t\t * method for more information.\n\t\t * @property _extensionCallbacks\n\t\t * @type {null}\n\t\t * @private\n\t\t */\n\t\tthis._extensionCallbacks = {};\n\n\t\t/**\n\t\t * The next preload queue to process when this one is complete. If an error is thrown in the current queue, and\n\t\t * {{#crossLink \"LoadQueue/stopOnError:property\"}}{{/crossLink}} is `true`, the next queue will not be processed.\n\t\t * @property next\n\t\t * @type {LoadQueue}\n\t\t * @default null\n\t\t */\n\t\tthis.next = null;\n\n\t\t/**\n\t\t * Ensure loaded scripts \"complete\" in the order they are specified. Loaded scripts are added to the document head\n\t\t * once they are loaded. Scripts loaded via tags will load one-at-a-time when this property is `true`, whereas\n\t\t * scripts loaded using XHR can load in any order, but will \"finish\" and be added to the document in the order\n\t\t * specified.\n\t\t *\n\t\t * Any items can be set to load in order by setting the {{#crossLink \"maintainOrder:property\"}}{{/crossLink}}\n\t\t * property on the load item, or by ensuring that only one connection can be open at a time using\n\t\t * {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}}. Note that when the `maintainScriptOrder` property\n\t\t * is set to `true`, scripts items are automatically set to `maintainOrder=true`, and changing the\n\t\t * `maintainScriptOrder` to `false` during a load will not change items already in a queue.\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *      var queue = new createjs.LoadQueue();\n\t\t *      queue.setMaxConnections(3); // Set a higher number to load multiple items at once\n\t\t *      queue.maintainScriptOrder = true; // Ensure scripts are loaded in order\n\t\t *      queue.loadManifest([\n\t\t *          \"script1.js\",\n\t\t *          \"script2.js\",\n\t\t *          \"image.png\", // Load any time\n\t\t *          {src: \"image2.png\", maintainOrder: true} // Will wait for script2.js\n\t\t *          \"image3.png\",\n\t\t *          \"script3.js\" // Will wait for image2.png before loading (or completing when loading with XHR)\n\t\t *      ]);\n\t\t *\n\t\t * @property maintainScriptOrder\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.maintainScriptOrder = true;\n\n\t\t/**\n\t\t * Determines if the LoadQueue will stop processing the current queue when an error is encountered.\n\t\t * @property stopOnError\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stopOnError = false;\n\n\t\t/**\n\t\t * The number of maximum open connections that a loadQueue tries to maintain. Please see\n\t\t * {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}} for more information.\n\t\t * @property _maxConnections\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t * @private\n\t\t */\n\t\tthis._maxConnections = 1;\n\n\t\t/**\n\t\t * An internal list of all the default Loaders that are included with PreloadJS. Before an item is loaded, the\n\t\t * available loader list is iterated, in the order they are included, and as soon as a loader indicates it can\n\t\t * handle the content, it will be selected. The default loader, ({{#crossLink \"TextLoader\"}}{{/crossLink}} is\n\t\t * last in the list, so it will be used if no other match is found. Typically, loaders will match based on the\n\t\t * {{#crossLink \"LoadItem/type\"}}{{/crossLink}}, which is automatically determined using the file extension of\n\t\t * the {{#crossLink \"LoadItem/src:property\"}}{{/crossLink}}.\n\t\t *\n\t\t * Loaders can be removed from PreloadJS by simply not including them.\n\t\t *\n\t\t * Custom loaders installed using {{#crossLink \"registerLoader\"}}{{/crossLink}} will be prepended to this list\n\t\t * so that they are checked first.\n\t\t * @property _availableLoaders\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._availableLoaders = [\n\t\t\tcreatejs.ImageLoader,\n\t\t\tcreatejs.JavaScriptLoader,\n\t\t\tcreatejs.CSSLoader,\n\t\t\tcreatejs.JSONLoader,\n\t\t\tcreatejs.JSONPLoader,\n\t\t\tcreatejs.SoundLoader,\n\t\t\tcreatejs.ManifestLoader,\n\t\t\tcreatejs.SpriteSheetLoader,\n\t\t\tcreatejs.XMLLoader,\n\t\t\tcreatejs.SVGLoader,\n\t\t\tcreatejs.BinaryLoader,\n\t\t\tcreatejs.VideoLoader,\n\t\t\tcreatejs.TextLoader\n\t\t];\n\n\t\t/**\n\t\t * The number of built in loaders, so they can't be removed by {{#crossLink \"unregisterLoader\"}}{{/crossLink}.\n\t\t\t\t * @property _defaultLoaderLength\n\t\t * @type {Number}\n\t\t * @private\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._defaultLoaderLength = this._availableLoaders.length;\n\n\t\tthis.init(preferXHR, basePath, crossOrigin);\n\t}\n\n\tvar p = createjs.extend(LoadQueue, createjs.AbstractLoader);\n\tvar s = LoadQueue;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\t/**\n\t * An internal initialization method, which is used for initial set up, but also to reset the LoadQueue.\n\t * @method init\n\t * @param preferXHR\n\t * @param basePath\n\t * @param crossOrigin\n\t * @private\n\t */\n\tp.init = function (preferXHR, basePath, crossOrigin) {\n\n\t\t// public properties\n\t\t/**\n\t\t * @property useXHR\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t * @deprecated Use preferXHR instead.\n\t\t */\n\t\tthis.useXHR = true;\n\n\t\t/**\n\t\t * Try and use XMLHttpRequest (XHR) when possible. Note that LoadQueue will default to tag loading or XHR\n\t\t * loading depending on the requirements for a media type. For example, HTML audio can not be loaded with XHR,\n\t\t * and plain text can not be loaded with tags, so it will default the the correct type instead of using the\n\t\t * user-defined type.\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis.preferXHR = true; //TODO: Get/Set\n\t\tthis._preferXHR = true;\n\t\tthis.setPreferXHR(preferXHR);\n\n\t\t// protected properties\n\t\t/**\n\t\t * Whether the queue is currently paused or not.\n\t\t * @property _paused\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._paused = false;\n\n\t\t/**\n\t\t * A path that will be prepended on to the item's {{#crossLink \"LoadItem/src:property\"}}{{/crossLink}}. The\n\t\t * `_basePath` property will only be used if an item's source is relative, and does not include a protocol such\n\t\t * as `http://`, or a relative path such as `../`.\n\t\t * @property _basePath\n\t\t * @type {String}\n\t\t * @private\n\t\t * @since 0.3.1\n\t\t */\n\t\tthis._basePath = basePath;\n\n\t\t/**\n\t\t * An optional flag to set on images that are loaded using PreloadJS, which enables CORS support. Images loaded\n\t\t * cross-domain by servers that support CORS require the crossOrigin flag to be loaded and interacted with by\n\t\t * a canvas. When loading locally, or with a server with no CORS support, this flag can cause other security issues,\n\t\t * so it is recommended to only set it if you are sure the server supports it. Currently, supported values are \"\"\n\t\t * and \"Anonymous\".\n\t\t * @property _crossOrigin\n\t\t * @type {String}\n\t\t * @default \"\"\n\t\t * @private\n\t\t * @since 0.4.1\n\t\t */\n\t\tthis._crossOrigin = crossOrigin;\n\n\t\t/**\n\t\t * Determines if the loadStart event was dispatched already. This event is only fired one time, when the first\n\t\t * file is requested.\n\t\t * @property _loadStartWasDispatched\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @private\n\t\t */\n\t\tthis._loadStartWasDispatched = false;\n\n\t\t/**\n\t\t * Determines if there is currently a script loading. This helps ensure that only a single script loads at once when\n\t\t * using a script tag to do preloading.\n\t\t * @property _currentlyLoadingScript\n\t\t * @type {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._currentlyLoadingScript = null;\n\n\t\t/**\n\t\t * An array containing the currently downloading files.\n\t\t * @property _currentLoads\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._currentLoads = [];\n\n\t\t/**\n\t\t * An array containing the queued items that have not yet started downloading.\n\t\t * @property _loadQueue\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._loadQueue = [];\n\n\t\t/**\n\t\t * An array containing downloads that have not completed, so that the LoadQueue can be properly reset.\n\t\t * @property _loadQueueBackup\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._loadQueueBackup = [];\n\n\t\t/**\n\t\t * An object hash of items that have finished downloading, indexed by the {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t\t * id.\n\t\t * @property _loadItemsById\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadItemsById = {};\n\n\t\t/**\n\t\t * An object hash of items that have finished downloading, indexed by {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t\t * source.\n\t\t * @property _loadItemsBySrc\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadItemsBySrc = {};\n\n\t\t/**\n\t\t * An object hash of loaded items, indexed by the ID of the {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t\t * @property _loadedResults\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadedResults = {};\n\n\t\t/**\n\t\t * An object hash of un-parsed loaded items, indexed by the ID of the {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t\t * @property _loadedRawResults\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadedRawResults = {};\n\n\t\t/**\n\t\t * The number of items that have been requested. This helps manage an overall progress without knowing how large\n\t\t * the files are before they are downloaded. This does not include items inside of loaders such as the\n\t\t * {{#crossLink \"ManifestLoader\"}}{{/crossLink}}.\n\t\t * @property _numItems\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._numItems = 0;\n\n\t\t/**\n\t\t * The number of items that have completed loaded. This helps manage an overall progress without knowing how large\n\t\t * the files are before they are downloaded.\n\t\t * @property _numItemsLoaded\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._numItemsLoaded = 0;\n\n\t\t/**\n\t\t * A list of scripts in the order they were requested. This helps ensure that scripts are \"completed\" in the right\n\t\t * order.\n\t\t * @property _scriptOrder\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._scriptOrder = [];\n\n\t\t/**\n\t\t * A list of scripts that have been loaded. Items are added to this list as <code>null</code> when they are\n\t\t * requested, contain the loaded item if it has completed, but not been dispatched to the user, and <code>true</true>\n\t\t * once they are complete and have been dispatched.\n\t\t * @property _loadedScripts\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._loadedScripts = [];\n\n\t\t/**\n\t\t * The last progress amount. This is used to suppress duplicate progress events.\n\t\t * @property _lastProgress\n\t\t * @type {Number}\n\t\t * @private\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._lastProgress = NaN;\n\n\t};\n\n// static properties\n\t/**\n\t * The time in milliseconds to assume a load has failed. An {{#crossLink \"AbstractLoader/error:event\"}}{{/crossLink}}\n\t * event is dispatched if the timeout is reached before any data is received.\n\t * @property loadTimeout\n\t * @type {Number}\n\t * @default 8000\n\t * @static\n\t * @since 0.4.1\n\t * @deprecated In favour of {{#crossLink \"LoadItem/LOAD_TIMEOUT_DEFAULT:property}}{{/crossLink}} property.\n\t */\n\ts.loadTimeout = 8000;\n\n\t/**\n\t * The time in milliseconds to assume a load has failed.\n\t * @property LOAD_TIMEOUT\n\t * @type {Number}\n\t * @default 0\n\t * @deprecated in favor of the {{#crossLink \"LoadQueue/loadTimeout:property\"}}{{/crossLink}} property.\n\t */\n\ts.LOAD_TIMEOUT = 0;\n\n// Preload Types\n\t/**\n\t * @property BINARY\n\t * @type {String}\n\t * @default binary\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/BINARY:property\"}}{{/crossLink}} instead.\n\t */\n\ts.BINARY = createjs.AbstractLoader.BINARY;\n\n\t/**\n\t * @property CSS\n\t * @type {String}\n\t * @default css\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/CSS:property\"}}{{/crossLink}} instead.\n\t */\n\ts.CSS = createjs.AbstractLoader.CSS;\n\n\t/**\n\t * @property IMAGE\n\t * @type {String}\n\t * @default image\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/CSS:property\"}}{{/crossLink}} instead.\n\t */\n\ts.IMAGE = createjs.AbstractLoader.IMAGE;\n\n\t/**\n\t * @property JAVASCRIPT\n\t * @type {String}\n\t * @default javascript\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/JAVASCRIPT:property\"}}{{/crossLink}} instead.\n\t */\n\ts.JAVASCRIPT = createjs.AbstractLoader.JAVASCRIPT;\n\n\t/**\n\t * @property JSON\n\t * @type {String}\n\t * @default json\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/JSON:property\"}}{{/crossLink}} instead.\n\t */\n\ts.JSON = createjs.AbstractLoader.JSON;\n\n\t/**\n\t * @property JSONP\n\t * @type {String}\n\t * @default jsonp\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/JSONP:property\"}}{{/crossLink}} instead.\n\t */\n\ts.JSONP = createjs.AbstractLoader.JSONP;\n\n\t/**\n\t * @property MANIFEST\n\t * @type {String}\n\t * @default manifest\n\t * @static\n\t * @since 0.4.1\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/MANIFEST:property\"}}{{/crossLink}} instead.\n\t */\n\ts.MANIFEST = createjs.AbstractLoader.MANIFEST;\n\n\t/**\n\t * @property SOUND\n\t * @type {String}\n\t * @default sound\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/JAVASCRIPT:property\"}}{{/crossLink}} instead.\n\t */\n\ts.SOUND = createjs.AbstractLoader.SOUND;\n\n\t/**\n\t * @property VIDEO\n\t * @type {String}\n\t * @default video\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/JAVASCRIPT:property\"}}{{/crossLink}} instead.\n\t */\n\ts.VIDEO = createjs.AbstractLoader.VIDEO;\n\n\t/**\n\t * @property SVG\n\t * @type {String}\n\t * @default svg\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/SVG:property\"}}{{/crossLink}} instead.\n\t */\n\ts.SVG = createjs.AbstractLoader.SVG;\n\n\t/**\n\t * @property TEXT\n\t * @type {String}\n\t * @default text\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/TEXT:property\"}}{{/crossLink}} instead.\n\t */\n\ts.TEXT = createjs.AbstractLoader.TEXT;\n\n\t/**\n\t * @property XML\n\t * @type {String}\n\t * @default xml\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/XML:property\"}}{{/crossLink}} instead.\n\t */\n\ts.XML = createjs.AbstractLoader.XML;\n\n\t/**\n\t * @property POST\n\t * @type {string}\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/POST:property\"}}{{/crossLink}} instead.\n\t */\n\ts.POST = createjs.AbstractLoader.POST;\n\n\t/**\n\t * @property GET\n\t * @type {string}\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/GET:property\"}}{{/crossLink}} instead.\n\t */\n\ts.GET = createjs.AbstractLoader.GET;\n\n// events\n\t/**\n\t * This event is fired when an individual file has loaded, and been processed.\n\t * @event fileload\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Object} item The file item which was specified in the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}} call. If only a string path or tag was specified, the\n\t * object will contain that value as a `src` property.\n\t * @param {Object} result The HTML tag or parsed result of the loaded item.\n\t * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted\n\t * to a usable object.\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * This {{#crossLink \"ProgressEvent\"}}{{/crossLink}} that is fired when an an individual file's progress changes.\n\t * @event fileprogress\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * This event is fired when an individual file starts to load.\n\t * @event filestart\n\t * @param {Object} The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Object} item The file item which was specified in the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}} call. If only a string path or tag was specified, the\n\t * object will contain that value as a property.\n\t */\n\n\t/**\n\t * Although it extends {{#crossLink \"AbstractLoader\"}}{{/crossLink}}, the `initialize` event is never fired from\n\t * a LoadQueue instance.\n\t * @event initialize\n\t * @private\n\t */\n\n// public methods\n\t/**\n\t * Register a custom loaders class. New loaders are given precedence over loaders added earlier and default loaders.\n\t * It is recommended that loaders extend {{#crossLink \"AbstractLoader\"}}{{/crossLink}}. Loaders can only be added\n\t * once, and will be prepended to the list of available loaders.\n\t * @method registerLoader\n\t * @param {Function|AbstractLoader} loader The AbstractLoader class to add.\n\t * @since 0.6.0\n\t */\n\tp.registerLoader = function (loader) {\n\t\tif (!loader || !loader.canLoadItem) {\n\t\t\tthrow new Error(\"loader is of an incorrect type.\");\n\t\t} else if (this._availableLoaders.indexOf(loader) != -1) {\n\t\t\tthrow new Error(\"loader already exists.\"); //LM: Maybe just silently fail here\n\t\t}\n\n\t\tthis._availableLoaders.unshift(loader);\n\t};\n\n\t/**\n\t * Remove a custom loader added using {{#crossLink \"registerLoader\"}}{{/crossLink}}. Only custom loaders can be\n\t * unregistered, the default loaders will always be available.\n\t * @method unregisterLoader\n\t * @param {Function|AbstractLoader} loader The AbstractLoader class to remove\n\t */\n\tp.unregisterLoader = function (loader) {\n\t\tvar idx = this._availableLoaders.indexOf(loader);\n\t\tif (idx != -1 && idx < this._defaultLoaderLength - 1) {\n\t\t\tthis._availableLoaders.splice(idx, 1);\n\t\t}\n\t};\n\n\t/**\n\t * @method setUseXHR\n\t * @param {Boolean} value The new useXHR value to set.\n\t * @return {Boolean} The new useXHR value. If XHR is not supported by the browser, this will return false, even if\n\t * the provided value argument was true.\n\t * @since 0.3.0\n\t * @deprecated use the {{#crossLink \"LoadQueue/preferXHR:property\"}}{{/crossLink}} property, or the\n\t * {{#crossLink \"LoadQueue/setUseXHR\"}}{{/crossLink}} method instead.\n\t */\n\tp.setUseXHR = function (value) {\n\t\treturn this.setPreferXHR(value);\n\t};\n\n\t/**\n\t * Change the {{#crossLink \"preferXHR:property\"}}{{/crossLink}} value. Note that if this is set to `true`, it may\n\t * fail, or be ignored depending on the browser's capabilities and the load type.\n\t * @method setPreferXHR\n\t * @param {Boolean} value\n\t * @returns {Boolean} The value of {{#crossLink \"preferXHR\"}}{{/crossLink}} that was successfully set.\n\t * @since 0.6.0\n\t */\n\tp.setPreferXHR = function (value) {\n\t\t// Determine if we can use XHR. XHR defaults to TRUE, but the browser may not support it.\n\t\t//TODO: Should we be checking for the other XHR types? Might have to do a try/catch on the different types similar to createXHR.\n\t\tthis.preferXHR = (value != false && window.XMLHttpRequest != null);\n\t\treturn this.preferXHR;\n\t};\n\n\t/**\n\t * Stops all queued and loading items, and clears the queue. This also removes all internal references to loaded\n\t * content, and allows the queue to be used again.\n\t * @method removeAll\n\t * @since 0.3.0\n\t */\n\tp.removeAll = function () {\n\t\tthis.remove();\n\t};\n\n\t/**\n\t * Stops an item from being loaded, and removes it from the queue. If nothing is passed, all items are removed.\n\t * This also removes internal references to loaded item(s).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      queue.loadManifest([\n\t *          {src:\"test.png\", id:\"png\"},\n\t *          {src:\"test.jpg\", id:\"jpg\"},\n\t *          {src:\"test.mp3\", id:\"mp3\"}\n\t *      ]);\n\t *      queue.remove(\"png\"); // Single item by ID\n\t *      queue.remove(\"png\", \"test.jpg\"); // Items as arguments. Mixed id and src.\n\t *      queue.remove([\"test.png\", \"jpg\"]); // Items in an Array. Mixed id and src.\n\t *\n\t * @method remove\n\t * @param {String | Array} idsOrUrls* The id or ids to remove from this queue. You can pass an item, an array of\n\t * items, or multiple items as arguments.\n\t * @since 0.3.0\n\t */\n\tp.remove = function (idsOrUrls) {\n\t\tvar args = null;\n\n\t\tif (idsOrUrls && !Array.isArray(idsOrUrls)) {\n\t\t\targs = [idsOrUrls];\n\t\t} else if (idsOrUrls) {\n\t\t\targs = idsOrUrls;\n\t\t} else if (arguments.length > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar itemsWereRemoved = false;\n\n\t\t// Destroy everything\n\t\tif (!args) {\n\t\t\tthis.close();\n\t\t\tfor (var n in this._loadItemsById) {\n\t\t\t\tthis._disposeItem(this._loadItemsById[n]);\n\t\t\t}\n\t\t\tthis.init(this.preferXHR, this._basePath);\n\n\t\t\t// Remove specific items\n\t\t} else {\n\t\t\twhile (args.length) {\n\t\t\t\tvar item = args.pop();\n\t\t\t\tvar r = this.getResult(item);\n\n\t\t\t\t//Remove from the main load Queue\n\t\t\t\tfor (i = this._loadQueue.length - 1; i >= 0; i--) {\n\t\t\t\t\tloadItem = this._loadQueue[i].getItem();\n\t\t\t\t\tif (loadItem.id == item || loadItem.src == item) {\n\t\t\t\t\t\tthis._loadQueue.splice(i, 1)[0].cancel();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Remove from the backup queue\n\t\t\t\tfor (i = this._loadQueueBackup.length - 1; i >= 0; i--) {\n\t\t\t\t\tloadItem = this._loadQueueBackup[i].getItem();\n\t\t\t\t\tif (loadItem.id == item || loadItem.src == item) {\n\t\t\t\t\t\tthis._loadQueueBackup.splice(i, 1)[0].cancel();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (r) {\n\t\t\t\t\tthis._disposeItem(this.getItem(item));\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i = this._currentLoads.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tvar loadItem = this._currentLoads[i].getItem();\n\t\t\t\t\t\tif (loadItem.id == item || loadItem.src == item) {\n\t\t\t\t\t\t\tthis._currentLoads.splice(i, 1)[0].cancel();\n\t\t\t\t\t\t\titemsWereRemoved = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this was called during a load, try to load the next item.\n\t\t\tif (itemsWereRemoved) {\n\t\t\t\tthis._loadNext();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Stops all open loads, destroys any loaded items, and resets the queue, so all items can\n\t * be reloaded again by calling {{#crossLink \"AbstractLoader/load\"}}{{/crossLink}}. Items are not removed from the\n\t * queue. To remove items use the {{#crossLink \"LoadQueue/remove\"}}{{/crossLink}} or\n\t * {{#crossLink \"LoadQueue/removeAll\"}}{{/crossLink}} method.\n\t * @method reset\n\t * @since 0.3.0\n\t */\n\tp.reset = function () {\n\t\tthis.close();\n\t\tfor (var n in this._loadItemsById) {\n\t\t\tthis._disposeItem(this._loadItemsById[n]);\n\t\t}\n\n\t\t//Reset the queue to its start state\n\t\tvar a = [];\n\t\tfor (var i = 0, l = this._loadQueueBackup.length; i < l; i++) {\n\t\t\ta.push(this._loadQueueBackup[i].getItem());\n\t\t}\n\n\t\tthis.loadManifest(a, false);\n\t};\n\n\t/**\n\t * Register a plugin. Plugins can map to load types (sound, image, etc), or specific extensions (png, mp3, etc).\n\t * Currently, only one plugin can exist per type/extension.\n\t *\n\t * When a plugin is installed, a <code>getPreloadHandlers()</code> method will be called on it. For more information\n\t * on this method, check out the {{#crossLink \"SamplePlugin/getPreloadHandlers\"}}{{/crossLink}} method in the\n\t * {{#crossLink \"SamplePlugin\"}}{{/crossLink}} class.\n\t *\n\t * Before a file is loaded, a matching plugin has an opportunity to modify the load. If a `callback` is returned\n\t * from the {{#crossLink \"SamplePlugin/getPreloadHandlers\"}}{{/crossLink}} method, it will be invoked first, and its\n\t * result may cancel or modify the item. The callback method can also return a `completeHandler` to be fired when\n\t * the file is loaded, or a `tag` object, which will manage the actual download. For more information on these\n\t * methods, check out the {{#crossLink \"SamplePlugin/preloadHandler\"}}{{/crossLink}} and {{#crossLink \"SamplePlugin/fileLoadHandler\"}}{{/crossLink}}\n\t * methods on the {{#crossLink \"SamplePlugin\"}}{{/crossLink}}.\n\t *\n\t * @method installPlugin\n\t * @param {Function} plugin The plugin class to install.\n\t */\n\tp.installPlugin = function (plugin) {\n\t\tif (plugin == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (plugin.getPreloadHandlers != null) {\n\t\t\tthis._plugins.push(plugin);\n\t\t\tvar map = plugin.getPreloadHandlers();\n\t\t\tmap.scope = plugin;\n\n\t\t\tif (map.types != null) {\n\t\t\t\tfor (var i = 0, l = map.types.length; i < l; i++) {\n\t\t\t\t\tthis._typeCallbacks[map.types[i]] = map;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (map.extensions != null) {\n\t\t\t\tfor (i = 0, l = map.extensions.length; i < l; i++) {\n\t\t\t\t\tthis._extensionCallbacks[map.extensions[i]] = map;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Set the maximum number of concurrent connections. Note that browsers and servers may have a built-in maximum\n\t * number of open connections, so any additional connections may remain in a pending state until the browser\n\t * opens the connection. When loading scripts using tags, and when {{#crossLink \"LoadQueue/maintainScriptOrder:property\"}}{{/crossLink}}\n\t * is `true`, only one script is loaded at a time due to browser limitations.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var queue = new createjs.LoadQueue();\n\t *      queue.setMaxConnections(10); // Allow 10 concurrent loads\n\t *\n\t * @method setMaxConnections\n\t * @param {Number} value The number of concurrent loads to allow. By default, only a single connection per LoadQueue\n\t * is open at any time.\n\t */\n\tp.setMaxConnections = function (value) {\n\t\tthis._maxConnections = value;\n\t\tif (!this._paused && this._loadQueue.length > 0) {\n\t\t\tthis._loadNext();\n\t\t}\n\t};\n\n\t/**\n\t * Load a single file. To add multiple files at once, use the {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}\n\t * method.\n\t *\n\t * Files are always appended to the current queue, so this method can be used multiple times to add files.\n\t * To clear the queue first, use the {{#crossLink \"AbstractLoader/close\"}}{{/crossLink}} method.\n\t * @method loadFile\n\t * @param {LoadItem|Object|String} file The file object or path to load. A file can be either\n\t * <ul>\n\t *     <li>A {{#crossLink \"LoadItem\"}}{{/crossLink}} instance</li>\n\t *     <li>An object containing properties defined by {{#crossLink \"LoadItem\"}}{{/crossLink}}</li>\n\t *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t *     in the background.</li>\n\t * </ul>\n\t * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default\n\t * value is true. If the queue is paused using {{#crossLink \"LoadQueue/setPaused\"}}{{/crossLink}}, and the value is\n\t * `true`, the queue will resume automatically.\n\t * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the\n\t * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink \"AbstractLoader/MANIFEST:property\"}}{{/crossLink}},\n\t * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>\n\t * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue\n\t * constructor, or a `path` property in a manifest definition.\n\t */\n\tp.loadFile = function (file, loadNow, basePath) {\n\t\tif (file == null) {\n\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_NO_FILE\");\n\t\t\tthis._sendError(event);\n\t\t\treturn;\n\t\t}\n\t\tthis._addItem(file, null, basePath);\n\n\t\tif (loadNow !== false) {\n\t\t\tthis.setPaused(false);\n\t\t} else {\n\t\t\tthis.setPaused(true);\n\t\t}\n\t};\n\n\t/**\n\t * Load an array of files. To load a single file, use the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} method.\n\t * The files in the manifest are requested in the same order, but may complete in a different order if the max\n\t * connections are set above 1 using {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}}. Scripts will load\n\t * in the right order as long as {{#crossLink \"LoadQueue/maintainScriptOrder\"}}{{/crossLink}} is true (which is\n\t * default).\n\t *\n\t * Files are always appended to the current queue, so this method can be used multiple times to add files.\n\t * To clear the queue first, use the {{#crossLink \"AbstractLoader/close\"}}{{/crossLink}} method.\n\t * @method loadManifest\n\t * @param {Array|String|Object} manifest An list of files to load. The loadManifest call supports four types of\n\t * manifests:\n\t * <ol>\n\t *     <li>A string path, which points to a manifest file, which is a JSON file that contains a \"manifest\" property,\n\t *     which defines the list of files to load, and can optionally contain a \"path\" property, which will be\n\t *     prepended to each file in the list.</li>\n\t *     <li>An object which defines a \"src\", which is a JSON or JSONP file. A \"callback\" can be defined for JSONP\n\t *     file. The JSON/JSONP file should contain a \"manifest\" property, which defines the list of files to load,\n\t *     and can optionally contain a \"path\" property, which will be prepended to each file in the list.</li>\n\t *     <li>An object which contains a \"manifest\" property, which defines the list of files to load, and can\n\t *     optionally contain a \"path\" property, which will be prepended to each file in the list.</li>\n\t *     <li>An Array of files to load.</li>\n\t * </ol>\n\t *\n\t * Each \"file\" in a manifest can be either:\n\t * <ul>\n\t *     <li>A {{#crossLink \"LoadItem\"}}{{/crossLink}} instance</li>\n\t *     <li>An object containing properties defined by {{#crossLink \"LoadItem\"}}{{/crossLink}}</li>\n\t *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t *     in the background.</li>\n\t * </ul>\n\t *\n\t * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default\n\t * value is true. If the queue is paused using {{#crossLink \"LoadQueue/setPaused\"}}{{/crossLink}} and this value is\n\t * `true`, the queue will resume automatically.\n\t * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the\n\t * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink \"LoadQueue/MANIFEST:property\"}}{{/crossLink}},\n\t * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>\n\t * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue\n\t * constructor, or a `path` property in a manifest definition.\n\t */\n\tp.loadManifest = function (manifest, loadNow, basePath) {\n\t\tvar fileList = null;\n\t\tvar path = null;\n\n\t\t// Array-based list of items\n\t\tif (Array.isArray(manifest)) {\n\t\t\tif (manifest.length == 0) {\n\t\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_MANIFEST_EMPTY\");\n\t\t\t\tthis._sendError(event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfileList = manifest;\n\n\t\t\t// String-based. Only file manifests can be specified this way. Any other types will cause an error when loaded.\n\t\t} else if (typeof(manifest) === \"string\") {\n\t\t\tfileList = [\n\t\t\t\t{\n\t\t\t\t\tsrc: manifest,\n\t\t\t\t\ttype: s.MANIFEST\n\t\t\t\t}\n\t\t\t];\n\n\t\t} else if (typeof(manifest) == \"object\") {\n\n\t\t\t// An object that defines a manifest path\n\t\t\tif (manifest.src !== undefined) {\n\t\t\t\tif (manifest.type == null) {\n\t\t\t\t\tmanifest.type = s.MANIFEST;\n\t\t\t\t} else if (manifest.type != s.MANIFEST) {\n\t\t\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_MANIFEST_TYPE\");\n\t\t\t\t\tthis._sendError(event);\n\t\t\t\t}\n\t\t\t\tfileList = [manifest];\n\n\t\t\t\t// An object that defines a manifest\n\t\t\t} else if (manifest.manifest !== undefined) {\n\t\t\t\tfileList = manifest.manifest;\n\t\t\t\tpath = manifest.path;\n\t\t\t}\n\n\t\t\t// Unsupported. This will throw an error.\n\t\t} else {\n\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_MANIFEST_NULL\");\n\t\t\tthis._sendError(event);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0, l = fileList.length; i < l; i++) {\n\t\t\tthis._addItem(fileList[i], path, basePath);\n\t\t}\n\n\t\tif (loadNow !== false) {\n\t\t\tthis.setPaused(false);\n\t\t} else {\n\t\t\tthis.setPaused(true);\n\t\t}\n\n\t};\n\n\t/**\n\t * Start a LoadQueue that was created, but not automatically started.\n\t * @method load\n\t */\n\tp.load = function () {\n\t\tthis.setPaused(false);\n\t};\n\n\t/**\n\t * Look up a {{#crossLink \"LoadItem\"}}{{/crossLink}} using either the \"id\" or \"src\" that was specified when loading it. Note that if no \"id\" was\n\t * supplied with the load item, the ID will be the \"src\", including a `path` property defined by a manifest. The\n\t * `basePath` will not be part of the ID.\n\t * @method getItem\n\t * @param {String} value The <code>id</code> or <code>src</code> of the load item.\n\t * @return {Object} The load item that was initially requested using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}. This object is also returned via the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}}\n\t * event as the `item` parameter.\n\t */\n\tp.getItem = function (value) {\n\t\treturn this._loadItemsById[value] || this._loadItemsBySrc[value];\n\t};\n\n\t/**\n\t * Look up a loaded result using either the \"id\" or \"src\" that was specified when loading it. Note that if no \"id\"\n\t * was supplied with the load item, the ID will be the \"src\", including a `path` property defined by a manifest. The\n\t * `basePath` will not be part of the ID.\n\t * @method getResult\n\t * @param {String} value The <code>id</code> or <code>src</code> of the load item.\n\t * @param {Boolean} [rawResult=false] Return a raw result instead of a formatted result. This applies to content\n\t * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be\n\t * returned instead.\n\t * @return {Object} A result object containing the content that was loaded, such as:\n\t * <ul>\n\t *      <li>An image tag (&lt;image /&gt;) for images</li>\n\t *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts are automatically added to the HTML\n\t *      DOM.</li>\n\t *      <li>A style tag for CSS (&lt;style /&gt; or &lt;link &gt;)</li>\n\t *      <li>Raw text for TEXT</li>\n\t *      <li>A formatted JavaScript object defined by JSON</li>\n\t *      <li>An XML document</li>\n\t *      <li>A binary arraybuffer loaded by XHR</li>\n\t *      <li>An audio tag (&lt;audio &gt;) for HTML audio. Note that it is recommended to use SoundJS APIs to play\n\t *      loaded audio. Specifically, audio loaded by Flash and WebAudio will return a loader object using this method\n\t *      which can not be used to play audio back.</li>\n\t * </ul>\n\t * This object is also returned via the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event as the 'item`\n\t * parameter. Note that if a raw result is requested, but not found, the result will be returned instead.\n\t */\n\tp.getResult = function (value, rawResult) {\n\t\tvar item = this._loadItemsById[value] || this._loadItemsBySrc[value];\n\t\tif (item == null) {\n\t\t\treturn null;\n\t\t}\n\t\tvar id = item.id;\n\t\tif (rawResult && this._loadedRawResults[id]) {\n\t\t\treturn this._loadedRawResults[id];\n\t\t}\n\t\treturn this._loadedResults[id];\n\t};\n\n\t/**\n\t * Generate an list of items loaded by this queue.\n\t * @method getItems\n\t * @param {Boolean} loaded Determines if only items that have been loaded should be returned. If false, in-progress\n\t * and failed load items will also be included.\n\t * @returns {Array} A list of objects that have been loaded. Each item includes the {{#crossLink \"LoadItem\"}}{{/crossLink}},\n\t * result, and rawResult.\n\t * @since 0.6.0\n\t */\n\tp.getItems = function (loaded) {\n\t\tvar arr = [];\n\t\tfor (var n in this._loadItemsById) {\n\t\t\tvar item = this._loadItemsById[n];\n\t\t\tvar result = this.getResult(n);\n\t\t\tif (loaded === true && result == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tarr.push({\n\t\t\t\titem: item,\n\t\t\t\tresult: result,\n\t\t\t\trawResult: this.getResult(n, true)\n\t\t\t});\n\t\t}\n\t\treturn arr;\n\t};\n\n\t/**\n\t * Pause or resume the current load. Active loads will not be cancelled, but the next items in the queue will not\n\t * be processed when active loads complete. LoadQueues are not paused by default.\n\t *\n\t * Note that if new items are added to the queue using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} or\n\t * {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}, a paused queue will be resumed, unless the `loadNow`\n\t * argument is `false`.\n\t * @method setPaused\n\t * @param {Boolean} value Whether the queue should be paused or not.\n\t */\n\tp.setPaused = function (value) {\n\t\tthis._paused = value;\n\t\tif (!this._paused) {\n\t\t\tthis._loadNext();\n\t\t}\n\t};\n\n\t/**\n\t * Close the active queue. Closing a queue completely empties the queue, and prevents any remaining items from\n\t * starting to download. Note that currently any active loads will remain open, and events may be processed.\n\t *\n\t * To stop and restart a queue, use the {{#crossLink \"LoadQueue/setPaused\"}}{{/crossLink}} method instead.\n\t * @method close\n\t */\n\tp.close = function () {\n\t\twhile (this._currentLoads.length) {\n\t\t\tthis._currentLoads.pop().cancel();\n\t\t}\n\t\tthis._scriptOrder.length = 0;\n\t\tthis._loadedScripts.length = 0;\n\t\tthis.loadStartWasDispatched = false;\n\t\tthis._itemCount = 0;\n\t\tthis._lastProgress = NaN;\n\t};\n\n// protected methods\n\t/**\n\t * Add an item to the queue. Items are formatted into a usable object containing all the properties necessary to\n\t * load the content. The load queue is populated with the loader instance that handles preloading, and not the load\n\t * item that was passed in by the user. To look up the load item by id or src, use the {{#crossLink \"LoadQueue.getItem\"}}{{/crossLink}}\n\t * method.\n\t * @method _addItem\n\t * @param {String|Object} value The item to add to the queue.\n\t * @param {String} [path] An optional path prepended to the `src`. The path will only be prepended if the src is\n\t * relative, and does not start with a protocol such as `http://`, or a path like `../`. If the LoadQueue was\n\t * provided a {{#crossLink \"_basePath\"}}{{/crossLink}}, then it will optionally be prepended after.\n\t * @param {String} [basePath] <strong>Deprecated</strong>An optional basePath passed into a {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} call. This parameter will be removed in a future tagged\n\t * version.\n\t * @private\n\t */\n\tp._addItem = function (value, path, basePath) {\n\t\tvar item = this._createLoadItem(value, path, basePath); // basePath and manifest path are added to the src.\n\t\tif (item == null) {\n\t\t\treturn;\n\t\t} // Sometimes plugins or types should be skipped.\n\t\tvar loader = this._createLoader(item);\n\t\tif (loader != null) {\n\t\t\tif (\"plugins\" in loader) {\n\t\t\t\tloader.plugins = this._plugins;\n\t\t\t}\n\t\t\titem._loader = loader;\n\t\t\tthis._loadQueue.push(loader);\n\t\t\tthis._loadQueueBackup.push(loader);\n\n\t\t\tthis._numItems++;\n\t\t\tthis._updateProgress();\n\n\t\t\t// Only worry about script order when using XHR to load scripts. Tags are only loading one at a time.\n\t\t\tif ((this.maintainScriptOrder\n\t\t\t\t\t&& item.type == createjs.LoadQueue.JAVASCRIPT\n\t\t\t\t\t\t//&& loader instanceof createjs.XHRLoader //NOTE: Have to track all JS files this way\n\t\t\t\t\t)\n\t\t\t\t\t|| item.maintainOrder === true) {\n\t\t\t\tthis._scriptOrder.push(item);\n\t\t\t\tthis._loadedScripts.push(null);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Create a refined {{#crossLink \"LoadItem\"}}{{/crossLink}}, which contains all the required properties. The type of\n\t * item is determined by browser support, requirements based on the file type, and developer settings. For example,\n\t * XHR is only used for file types that support it in new browsers.\n\t *\n\t * Before the item is returned, any plugins registered to handle the type or extension will be fired, which may\n\t * alter the load item.\n\t * @method _createLoadItem\n\t * @param {String | Object | HTMLAudioElement | HTMLImageElement} value The item that needs to be preloaded.\n\t * @param {String} [path] A path to prepend to the item's source. Sources beginning with http:// or similar will\n\t * not receive a path. Since PreloadJS 0.4.1, the src will be modified to include the `path` and {{#crossLink \"LoadQueue/_basePath:property\"}}{{/crossLink}}\n\t * when it is added.\n\t * @param {String} [basePath] <strong>Deprectated</strong> A base path to prepend to the items source in addition to\n\t * the path argument.\n\t * @return {Object} The loader instance that will be used.\n\t * @private\n\t */\n\tp._createLoadItem = function (value, path, basePath) {\n\t\tvar item = createjs.LoadItem.create(value);\n\t\tif (item == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar bp = \"\"; // Store the generated basePath\n\t\tvar useBasePath = basePath || this._basePath;\n\n\t\tif (item.src instanceof Object) {\n\t\t\tif (!item.type) {\n\t\t\t\treturn null;\n\t\t\t} // the the src is an object, type is required to pass off to plugin\n\t\t\tif (path) {\n\t\t\t\tbp = path;\n\t\t\t\tvar pathMatch = createjs.RequestUtils.parseURI(path);\n\t\t\t\t// Also append basePath\n\t\t\t\tif (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {\n\t\t\t\t\tbp = useBasePath + bp;\n\t\t\t\t}\n\t\t\t} else if (useBasePath != null) {\n\t\t\t\tbp = useBasePath;\n\t\t\t}\n\t\t} else {\n\t\t\t// Determine Extension, etc.\n\t\t\tvar match = createjs.RequestUtils.parseURI(item.src);\n\t\t\tif (match.extension) {\n\t\t\t\titem.ext = match.extension;\n\t\t\t}\n\t\t\tif (item.type == null) {\n\t\t\t\titem.type = createjs.RequestUtils.getTypeByExtension(item.ext);\n\t\t\t}\n\n\t\t\t// Inject path & basePath\n\t\t\tvar autoId = item.src;\n\t\t\tif (!match.absolute && !match.relative) {\n\t\t\t\tif (path) {\n\t\t\t\t\tbp = path;\n\t\t\t\t\tvar pathMatch = createjs.RequestUtils.parseURI(path);\n\t\t\t\t\tautoId = path + autoId;\n\t\t\t\t\t// Also append basePath\n\t\t\t\t\tif (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {\n\t\t\t\t\t\tbp = useBasePath + bp;\n\t\t\t\t\t}\n\t\t\t\t} else if (useBasePath != null) {\n\t\t\t\t\tbp = useBasePath;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.src = bp + item.src;\n\t\t}\n\t\titem.path = bp;\n\n\t\t// If there's no id, set one now.\n\t\tif (item.id === undefined || item.id === null || item.id === \"\") {\n\t\t\titem.id = autoId;\n\t\t}\n\n\t\t// Give plugins a chance to modify the loadItem:\n\t\tvar customHandler = this._typeCallbacks[item.type] || this._extensionCallbacks[item.ext];\n\t\tif (customHandler) {\n\t\t\t// Plugins are now passed both the full source, as well as a combined path+basePath (appropriately)\n\t\t\tvar result = customHandler.callback.call(customHandler.scope, item, this);\n\n\t\t\t// The plugin will handle the load, or has canceled it. Ignore it.\n\t\t\tif (result === false) {\n\t\t\t\treturn null;\n\n\t\t\t\t// Load as normal:\n\t\t\t} else if (result === true) {\n\t\t\t\t// Do Nothing\n\n\t\t\t\t// Result is a loader class:\n\t\t\t} else if (result != null) {\n\t\t\t\titem._loader = result;\n\t\t\t}\n\n\t\t\t// Update the extension in case the type changed:\n\t\t\tmatch = createjs.RequestUtils.parseURI(item.src);\n\t\t\tif (match.extension != null) {\n\t\t\t\titem.ext = match.extension;\n\t\t\t}\n\t\t}\n\n\t\t// Store the item for lookup. This also helps clean-up later.\n\t\tthis._loadItemsById[item.id] = item;\n\t\tthis._loadItemsBySrc[item.src] = item;\n\n\t\tif (item.crossOrigin == null) {\n\t\t\titem.crossOrigin = this._crossOrigin;\n\t\t}\n\n\t\treturn item;\n\t};\n\n\t/**\n\t * Create a loader for a load item.\n\t * @method _createLoader\n\t * @param {Object} item A formatted load item that can be used to generate a loader.\n\t * @return {AbstractLoader} A loader that can be used to load content.\n\t * @private\n\t */\n\tp._createLoader = function (item) {\n\t\tif (item._loader != null) { // A plugin already specified a loader\n\t\t\treturn item._loader;\n\t\t}\n\n\t\t// Initially, try and use the provided/supported XHR mode:\n\t\tvar preferXHR = this.preferXHR;\n\n\t\tfor (var i = 0; i < this._availableLoaders.length; i++) {\n\t\t\tvar loader = this._availableLoaders[i];\n\t\t\tif (loader && loader.canLoadItem(item)) {\n\t\t\t\treturn new loader(item, preferXHR);\n\t\t\t}\n\t\t}\n\n\t\t// TODO: Log error (requires createjs.log)\n\t\treturn null;\n\t};\n\n\t/**\n\t * Load the next item in the queue. If the queue is empty (all items have been loaded), then the complete event\n\t * is processed. The queue will \"fill up\" any empty slots, up to the max connection specified using\n\t * {{#crossLink \"LoadQueue.setMaxConnections\"}}{{/crossLink}} method. The only exception is scripts that are loaded\n\t * using tags, which have to be loaded one at a time to maintain load order.\n\t * @method _loadNext\n\t * @private\n\t */\n\tp._loadNext = function () {\n\t\tif (this._paused) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Only dispatch loadstart event when the first file is loaded.\n\t\tif (!this._loadStartWasDispatched) {\n\t\t\tthis._sendLoadStart();\n\t\t\tthis._loadStartWasDispatched = true;\n\t\t}\n\n\t\t// The queue has completed.\n\t\tif (this._numItems == this._numItemsLoaded) {\n\t\t\tthis.loaded = true;\n\t\t\tthis._sendComplete();\n\n\t\t\t// Load the next queue, if it has been defined.\n\t\t\tif (this.next && this.next.load) {\n\t\t\t\tthis.next.load();\n\t\t\t}\n\t\t} else {\n\t\t\tthis.loaded = false;\n\t\t}\n\n\t\t// Must iterate forwards to load in the right order.\n\t\tfor (var i = 0; i < this._loadQueue.length; i++) {\n\t\t\tif (this._currentLoads.length >= this._maxConnections) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar loader = this._loadQueue[i];\n\n\t\t\t// Determine if we should be only loading one tag-script at a time:\n\t\t\t// Note: maintainOrder items don't do anything here because we can hold onto their loaded value\n\t\t\tif (!this._canStartLoad(loader)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._loadQueue.splice(i, 1);\n\t\t\ti--;\n\t\t\tthis._loadItem(loader);\n\t\t}\n\t};\n\n\t/**\n\t * Begin loading an item. Event listeners are not added to the loaders until the load starts.\n\t * @method _loadItem\n\t * @param {AbstractLoader} loader The loader instance to start. Currently, this will be an XHRLoader or TagLoader.\n\t * @private\n\t */\n\tp._loadItem = function (loader) {\n\t\tloader.on(\"fileload\", this._handleFileLoad, this);\n\t\tloader.on(\"progress\", this._handleProgress, this);\n\t\tloader.on(\"complete\", this._handleFileComplete, this);\n\t\tloader.on(\"error\", this._handleError, this);\n\t\tloader.on(\"fileerror\", this._handleFileError, this);\n\t\tthis._currentLoads.push(loader);\n\t\tthis._sendFileStart(loader.getItem());\n\t\tloader.load();\n\t};\n\n\t/**\n\t * The callback that is fired when a loader loads a file. This enables loaders like {{#crossLink \"ManifestLoader\"}}{{/crossLink}}\n\t * to maintain internal queues, but for this queue to dispatch the {{#crossLink \"fileload:event\"}}{{/crossLink}}\n\t * events.\n\t * @param {Event} event The {{#crossLink \"AbstractLoader/fileload:event\"}}{{/crossLink}} event from the loader.\n\t * @private\n\t * @since 0.6.0\n\t */\n\tp._handleFileLoad = function (event) {\n\t\tevent.target = null;\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * The callback that is fired when a loader encounters an error from an internal file load operation. This enables\n\t * loaders like M\n\t * @param event\n\t * @private\n\t */\n\tp._handleFileError = function (event) {\n\t\tvar newEvent = new createjs.ErrorEvent(\"FILE_LOAD_ERROR\", null, event.item);\n\t\tthis._sendError(newEvent);\n\t};\n\n\t/**\n\t * The callback that is fired when a loader encounters an error. The queue will continue loading unless {{#crossLink \"LoadQueue/stopOnError:property\"}}{{/crossLink}}\n\t * is set to `true`.\n\t * @method _handleError\n\t * @param {ErrorEvent} event The error event, containing relevant error information.\n\t * @private\n\t */\n\tp._handleError = function (event) {\n\t\tvar loader = event.target;\n\t\tthis._numItemsLoaded++;\n\n\t\tthis._finishOrderedItem(loader, true);\n\t\tthis._updateProgress();\n\n\t\tvar newEvent = new createjs.ErrorEvent(\"FILE_LOAD_ERROR\", null, loader.getItem());\n\t\t// TODO: Propagate actual error message.\n\n\t\tthis._sendError(newEvent);\n\n\t\tif (!this.stopOnError) {\n\t\t\tthis._removeLoadItem(loader);\n\t\t\tthis._cleanLoadItem(loader);\n\t\t\tthis._loadNext();\n\t\t} else {\n\t\t\tthis.setPaused(true);\n\t\t}\n\t};\n\n\t/**\n\t * An item has finished loading. We can assume that it is totally loaded, has been parsed for immediate use, and\n\t * is available as the \"result\" property on the load item. The raw text result for a parsed item (such as JSON, XML,\n\t * CSS, JavaScript, etc) is available as the \"rawResult\" property, and can also be looked up using {{#crossLink \"LoadQueue/getResult\"}}{{/crossLink}}.\n\t * @method _handleFileComplete\n\t * @param {Event} event The event object from the loader.\n\t * @private\n\t */\n\tp._handleFileComplete = function (event) {\n\t\tvar loader = event.target;\n\t\tvar item = loader.getItem();\n\n\t\tvar result = loader.getResult();\n\t\tthis._loadedResults[item.id] = result;\n\t\tvar rawResult = loader.getResult(true);\n\t\tif (rawResult != null && rawResult !== result) {\n\t\t\tthis._loadedRawResults[item.id] = rawResult;\n\t\t}\n\n\t\tthis._saveLoadedItems(loader);\n\n\t\t// Remove the load item\n\t\tthis._removeLoadItem(loader);\n\n\t\tif (!this._finishOrderedItem(loader)) {\n\t\t\t// The item was NOT managed, so process it now\n\t\t\tthis._processFinishedLoad(item, loader);\n\t\t}\n\n\t\t// Clean up the load item\n\t\tthis._cleanLoadItem(loader);\n\t};\n\n\t/**\n\t * Some loaders might load additional content, other than the item they were passed (such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}}).\n\t * Any items exposed by the loader using {{#crossLink \"AbstractLoader/getLoadItems\"}}{{/crossLink}} are added to the\n\t * LoadQueue's look-ups, including {{#crossLink \"getItem\"}}{{/crossLink}} and {{#crossLink \"getResult\"}}{{/crossLink}}\n\t * methods.\n\t * @method _saveLoadedItems\n\t * @param {AbstractLoader} loader\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._saveLoadedItems = function (loader) {\n\t\t// TODO: Not sure how to handle this. Would be nice to expose the items.\n\t\t// Loaders may load sub-items. This adds them to this queue\n\t\tvar list = loader.getLoadedItems();\n\t\tif (list === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tvar item = list[i].item;\n\n\t\t\t// Store item lookups\n\t\t\tthis._loadItemsBySrc[item.src] = item;\n\t\t\tthis._loadItemsById[item.id] = item;\n\n\t\t\t// Store loaded content\n\t\t\tthis._loadedResults[item.id] = list[i].result;\n\t\t\tthis._loadedRawResults[item.id] = list[i].rawResult;\n\t\t}\n\t};\n\n\t/**\n\t * Flag an item as finished. If the item's order is being managed, then ensure that it is allowed to finish, and if\n\t * so, trigger prior items to trigger as well.\n\t * @method _finishOrderedItem\n\t * @param {AbstractLoader} loader\n\t * @param {Boolean} loadFailed\n\t * @return {Boolean} If the item's order is being managed. This allows the caller to take an alternate\n\t * behaviour if it is.\n\t * @private\n\t */\n\tp._finishOrderedItem = function (loader, loadFailed) {\n\t\tvar item = loader.getItem();\n\n\t\tif ((this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT)\n\t\t\t\t|| item.maintainOrder) {\n\n\t\t\t//TODO: Evaluate removal of the _currentlyLoadingScript\n\t\t\tif (loader instanceof createjs.JavaScriptLoader) {\n\t\t\t\tthis._currentlyLoadingScript = false;\n\t\t\t}\n\n\t\t\tvar index = createjs.indexOf(this._scriptOrder, item);\n\t\t\tif (index == -1) {\n\t\t\t\treturn false;\n\t\t\t} // This loader no longer exists\n\t\t\tthis._loadedScripts[index] = (loadFailed === true) ? true : item;\n\n\t\t\tthis._checkScriptLoadOrder();\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\t/**\n\t * Ensure the scripts load and dispatch in the correct order. When using XHR, scripts are stored in an array in the\n\t * order they were added, but with a \"null\" value. When they are completed, the value is set to the load item,\n\t * and then when they are processed and dispatched, the value is set to `true`. This method simply\n\t * iterates the array, and ensures that any loaded items that are not preceded by a `null` value are\n\t * dispatched.\n\t * @method _checkScriptLoadOrder\n\t * @private\n\t */\n\tp._checkScriptLoadOrder = function () {\n\t\tvar l = this._loadedScripts.length;\n\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tvar item = this._loadedScripts[i];\n\t\t\tif (item === null) {\n\t\t\t\tbreak;\n\t\t\t} // This is still loading. Do not process further.\n\t\t\tif (item === true) {\n\t\t\t\tcontinue;\n\t\t\t} // This has completed, and been processed. Move on.\n\n\t\t\tvar loadItem = this._loadedResults[item.id];\n\t\t\tif (item.type == createjs.LoadQueue.JAVASCRIPT) {\n\t\t\t\t// Append script tags to the head automatically.\n\t\t\t\tcreatejs.DomUtils.appendToHead(loadItem);\n\t\t\t}\n\n\t\t\tvar loader = item._loader;\n\t\t\tthis._processFinishedLoad(item, loader);\n\t\t\tthis._loadedScripts[i] = true;\n\t\t}\n\t};\n\n\t/**\n\t * A file has completed loading, and the LoadQueue can move on. This triggers the complete event, and kick-starts\n\t * the next item.\n\t * @method _processFinishedLoad\n\t * @param {LoadItem|Object} item\n\t * @param {AbstractLoader} loader\n\t * @protected\n\t */\n\tp._processFinishedLoad = function (item, loader) {\n\t\tthis._numItemsLoaded++;\n\n\t\t// Since LoadQueue needs maintain order, we can't append scripts in the loader.\n\t\t// So we do it here instead. Or in _checkScriptLoadOrder();\n\t\tif (!this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT) {\n\t\t\tvar tag = loader.getTag();\n\t\t\tcreatejs.DomUtils.appendToHead(tag);\n\t\t}\n\n\t\tthis._updateProgress();\n\t\tthis._sendFileComplete(item, loader);\n\t\tthis._loadNext();\n\t};\n\n\t/**\n\t * Ensure items with `maintainOrder=true` that are before the specified item have loaded. This only applies to\n\t * JavaScript items that are being loaded with a TagLoader, since they have to be loaded and completed <strong>before</strong>\n\t * the script can even be started, since it exist in the DOM while loading.\n\t * @method _canStartLoad\n\t * @param {AbstractLoader} loader The loader for the item\n\t * @return {Boolean} Whether the item can start a load or not.\n\t * @private\n\t */\n\tp._canStartLoad = function (loader) {\n\t\tif (!this.maintainScriptOrder || loader.preferXHR) {\n\t\t\treturn true;\n\t\t}\n\t\tvar item = loader.getItem();\n\t\tif (item.type != createjs.LoadQueue.JAVASCRIPT) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this._currentlyLoadingScript) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar index = this._scriptOrder.indexOf(item);\n\t\tvar i = 0;\n\t\twhile (i < index) {\n\t\t\tvar checkItem = this._loadedScripts[i];\n\t\t\tif (checkItem == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tthis._currentlyLoadingScript = true;\n\t\treturn true;\n\t};\n\n\t/**\n\t * A load item is completed or was canceled, and needs to be removed from the LoadQueue.\n\t * @method _removeLoadItem\n\t * @param {AbstractLoader} loader A loader instance to remove.\n\t * @private\n\t */\n\tp._removeLoadItem = function (loader) {\n\t\tvar l = this._currentLoads.length;\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tif (this._currentLoads[i] == loader) {\n\t\t\t\tthis._currentLoads.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Remove unneeded references from a loader.\n\t *\n\t * @param loader\n\t * @private\n\t */\n\tp._cleanLoadItem = function(loader) {\n\t\tvar item = loader.getItem();\n\t\tif (item) {\n\t\t\tdelete item._loader;\n\t\t}\n\t}\n\n\t/**\n\t * An item has dispatched progress. Propagate that progress, and update the LoadQueue's overall progress.\n\t * @method _handleProgress\n\t * @param {ProgressEvent} event The progress event from the item.\n\t * @private\n\t */\n\tp._handleProgress = function (event) {\n\t\tvar loader = event.target;\n\t\tthis._sendFileProgress(loader.getItem(), loader.progress);\n\t\tthis._updateProgress();\n\t};\n\n\t/**\n\t * Overall progress has changed, so determine the new progress amount and dispatch it. This changes any time an\n\t * item dispatches progress or completes. Note that since we don't always know the actual filesize of items before\n\t * they are loaded. In this case, we define a \"slot\" for each item (1 item in 10 would get 10%), and then append\n\t * loaded progress on top of the already-loaded items.\n\t *\n\t * For example, if 5/10 items have loaded, and item 6 is 20% loaded, the total progress would be:\n\t * <ul>\n\t *      <li>5/10 of the items in the queue (50%)</li>\n\t *      <li>plus 20% of item 6's slot (2%)</li>\n\t *      <li>equals 52%</li>\n\t * </ul>\n\t * @method _updateProgress\n\t * @private\n\t */\n\tp._updateProgress = function () {\n\t\tvar loaded = this._numItemsLoaded / this._numItems; // Fully Loaded Progress\n\t\tvar remaining = this._numItems - this._numItemsLoaded;\n\t\tif (remaining > 0) {\n\t\t\tvar chunk = 0;\n\t\t\tfor (var i = 0, l = this._currentLoads.length; i < l; i++) {\n\t\t\t\tchunk += this._currentLoads[i].progress;\n\t\t\t}\n\t\t\tloaded += (chunk / remaining) * (remaining / this._numItems);\n\t\t}\n\n\t\tif (this._lastProgress != loaded) {\n\t\t\tthis._sendProgress(loaded);\n\t\t\tthis._lastProgress = loaded;\n\t\t}\n\t};\n\n\t/**\n\t * Clean out item results, to free them from memory. Mainly, the loaded item and results are cleared from internal\n\t * hashes.\n\t * @method _disposeItem\n\t * @param {LoadItem|Object} item The item that was passed in for preloading.\n\t * @private\n\t */\n\tp._disposeItem = function (item) {\n\t\tdelete this._loadedResults[item.id];\n\t\tdelete this._loadedRawResults[item.id];\n\t\tdelete this._loadItemsById[item.id];\n\t\tdelete this._loadItemsBySrc[item.src];\n\t};\n\n\t/**\n\t * Dispatch a \"fileprogress\" {{#crossLink \"Event\"}}{{/crossLink}}. Please see the LoadQueue {{#crossLink \"LoadQueue/fileprogress:event\"}}{{/crossLink}}\n\t * event for details on the event payload.\n\t * @method _sendFileProgress\n\t * @param {LoadItem|Object} item The item that is being loaded.\n\t * @param {Number} progress The amount the item has been loaded (between 0 and 1).\n\t * @protected\n\t */\n\tp._sendFileProgress = function (item, progress) {\n\t\tif (this._isCanceled() || this._paused) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this.hasEventListener(\"fileprogress\")) {\n\t\t\treturn;\n\t\t}\n\n\t\t//LM: Rework ProgressEvent to support this?\n\t\tvar event = new createjs.Event(\"fileprogress\");\n\t\tevent.progress = progress;\n\t\tevent.loaded = progress;\n\t\tevent.total = 1;\n\t\tevent.item = item;\n\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch a fileload {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event for\n\t * details on the event payload.\n\t * @method _sendFileComplete\n\t * @param {LoadItemObject} item The item that is being loaded.\n\t * @param {AbstractLoader} loader\n\t * @protected\n\t */\n\tp._sendFileComplete = function (item, loader) {\n\t\tif (this._isCanceled() || this._paused) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar event = new createjs.Event(\"fileload\");\n\t\tevent.loader = loader;\n\t\tevent.item = item;\n\t\tevent.result = this._loadedResults[item.id];\n\t\tevent.rawResult = this._loadedRawResults[item.id];\n\n\t\t// This calls a handler specified on the actual load item. Currently, the SoundJS plugin uses this.\n\t\tif (item.completeHandler) {\n\t\t\titem.completeHandler(event);\n\t\t}\n\n\t\tthis.hasEventListener(\"fileload\") && this.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch a filestart {{#crossLink \"Event\"}}{{/crossLink}} immediately before a file starts to load. Please see\n\t * the {{#crossLink \"LoadQueue/filestart:event\"}}{{/crossLink}} event for details on the event payload.\n\t * @method _sendFileStart\n\t * @param {LoadItem|Object} item The item that is being loaded.\n\t * @protected\n\t */\n\tp._sendFileStart = function (item) {\n\t\tvar event = new createjs.Event(\"filestart\");\n\t\tevent.item = item;\n\t\tthis.hasEventListener(\"filestart\") && this.dispatchEvent(event);\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[PreloadJS LoadQueue]\";\n\t};\n\n\tcreatejs.LoadQueue = createjs.promote(LoadQueue, \"AbstractLoader\");\n}());\n\n//##############################################################################\n// TextLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for Text files.\n\t * @class TextLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction TextLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.TEXT);\n\t};\n\n\tvar p = createjs.extend(TextLoader, createjs.AbstractLoader);\n\tvar s = TextLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader loads items that are of type {{#crossLink \"AbstractLoader/TEXT:property\"}}{{/crossLink}},\n\t * but is also the default loader if a file type can not be determined.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.TEXT;\n\t};\n\n\tcreatejs.TextLoader = createjs.promote(TextLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// BinaryLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for binary files. This is useful for loading web audio, or content that requires an ArrayBuffer.\n\t * @class BinaryLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction BinaryLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.BINARY);\n\t\tthis.on(\"initialize\", this._updateXHR, this);\n\t};\n\n\tvar p = createjs.extend(BinaryLoader, createjs.AbstractLoader);\n\tvar s = BinaryLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/BINARY:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.BINARY;\n\t};\n\n\t// private methods\n\t/**\n\t * Before the item loads, set the response type to \"arraybuffer\"\n\t * @property _updateXHR\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._updateXHR = function (event) {\n\t\tevent.loader.setResponseType(\"arraybuffer\");\n\t};\n\n\tcreatejs.BinaryLoader = createjs.promote(BinaryLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// CSSLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for CSS files.\n\t * @class CSSLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction CSSLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.CSS);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"href\";\n\n\t\tif (preferXHR) {\n\t\t\tthis._tag = document.createElement(\"style\");\n\t\t} else {\n\t\t\tthis._tag = document.createElement(\"link\");\n\t\t}\n\n\t\tthis._tag.rel = \"stylesheet\";\n\t\tthis._tag.type = \"text/css\";\n\t};\n\n\tvar p = createjs.extend(CSSLoader, createjs.AbstractLoader);\n\tvar s = CSSLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/CSS:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.CSS;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for CSS files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLLinkElement|HTMLStyleElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tif (this._preferXHR) {\n\t\t\tvar tag = loader.getTag();\n\n\t\t\tif (tag.styleSheet) { // IE\n\t\t\t\ttag.styleSheet.cssText = loader.getResult(true);\n\t\t\t} else {\n\t\t\t\tvar textNode = document.createTextNode(loader.getResult(true));\n\t\t\t\ttag.appendChild(textNode);\n\t\t\t}\n\t\t} else {\n\t\t\ttag = this._tag;\n\t\t}\n\n\t\tcreatejs.DomUtils.appendToHead(tag);\n\n\t\treturn tag;\n\t};\n\n\tcreatejs.CSSLoader = createjs.promote(CSSLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// ImageLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for image files.\n\t * @class ImageLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction ImageLoader (loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.IMAGE);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"src\";\n\n\t\t// Check if the preload item is already a tag.\n\t\tif (createjs.RequestUtils.isImageTag(loadItem)) {\n\t\t\tthis._tag = loadItem;\n\t\t} else if (createjs.RequestUtils.isImageTag(loadItem.src)) {\n\t\t\tthis._tag = loadItem.src;\n\t\t} else if (createjs.RequestUtils.isImageTag(loadItem.tag)) {\n\t\t\tthis._tag = loadItem.tag;\n\t\t}\n\n\t\tif (this._tag != null) {\n\t\t\tthis._preferXHR = false;\n\t\t} else {\n\t\t\tthis._tag = document.createElement(\"img\");\n\t\t}\n\n\t\tthis.on(\"initialize\", this._updateXHR, this);\n\t};\n\n\tvar p = createjs.extend(ImageLoader, createjs.AbstractLoader);\n\tvar s = ImageLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/IMAGE:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.IMAGE;\n\t};\n\n\t// public methods\n\tp.load = function () {\n\t\tif (this._tag.src != \"\" && this._tag.complete) {\n\t\t\tthis._sendComplete();\n\t\t\treturn;\n\t\t}\n\n\t\tvar crossOrigin = this._item.crossOrigin;\n\t\tif (crossOrigin == true) { crossOrigin = \"Anonymous\"; }\n\t\tif (crossOrigin != null && !createjs.RequestUtils.isLocal(this._item.src)) {\n\t\t\tthis._tag.crossOrigin = crossOrigin;\n\t\t}\n\n\t\tthis.AbstractLoader_load();\n\t};\n\n\t// protected methods\n\t/**\n\t * Before the item loads, set its mimeType and responseType.\n\t * @property _updateXHR\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._updateXHR = function (event) {\n\t\tevent.loader.mimeType = 'text/plain; charset=x-user-defined-binary';\n\n\t\t// Only exists for XHR\n\t\tif (event.loader.setResponseType) {\n\t\t\tevent.loader.setResponseType(\"blob\");\n\t\t}\n\t};\n\n\t/**\n\t * The result formatter for Image files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLImageElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\treturn this._formatImage;\n\t};\n\n\t/**\n\t * The asynchronous image formatter function. This is required because images have\n\t * a short delay before they are ready.\n\t * @method _formatImage\n\t * @param {Function} successCallback The method to call when the result has finished formatting\n\t * @param {Function} errorCallback The method to call if an error occurs during formatting\n\t * @private\n\t */\n\tp._formatImage = function (successCallback, errorCallback) {\n\t\tvar tag = this._tag;\n\t\tvar URL = window.URL || window.webkitURL;\n\n\t\tif (!this._preferXHR) {\n\t\t\t//document.body.removeChild(tag);\n\t\t} else if (URL) {\n\t\t\tvar objURL = URL.createObjectURL(this.getResult(true));\n\t\t\ttag.src = objURL;\n\n\t\t\ttag.addEventListener(\"load\", this._cleanUpURL, false);\n\t\t\ttag.addEventListener(\"error\", this._cleanUpURL, false);\n\t\t} else {\n\t\t\ttag.src = this._item.src;\n\t\t}\n\n\t\tif (tag.complete) {\n\t\t\tsuccessCallback(tag);\n\t\t} else {\n            tag.onload = createjs.proxy(function() {\n                successCallback(this._tag);\n            }, this);\n\n            tag.onerror = createjs.proxy(function() {\n                errorCallback(_this._tag);\n            }, this);\n\t\t}\n\t};\n\n\t/**\n\t * Clean up the ObjectURL, the tag is done with it. Note that this function is run\n\t * as an event listener without a proxy/closure, as it doesn't require it - so do not\n\t * include any functionality that requires scope without changing it.\n\t * @method _cleanUpURL\n\t * @param event\n\t * @private\n\t */\n\tp._cleanUpURL = function (event) {\n\t\tvar URL = window.URL || window.webkitURL;\n\t\tURL.revokeObjectURL(event.target.src);\n\t};\n\n\tcreatejs.ImageLoader = createjs.promote(ImageLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// JavaScriptLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JavaScript files.\n\t * @class JavaScriptLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction JavaScriptLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.JAVASCRIPT);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"src\";\n\t\tthis.setTag(document.createElement(\"script\"));\n\t};\n\n\tvar p = createjs.extend(JavaScriptLoader, createjs.AbstractLoader);\n\tvar s = JavaScriptLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/JAVASCRIPT:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.JAVASCRIPT;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for JavaScript files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLLinkElement|HTMLStyleElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tvar tag = loader.getTag();\n\t\tif (this._preferXHR) {\n\t\t\ttag.text = loader.getResult(true);\n\t\t}\n\t\treturn tag;\n\t};\n\n\tcreatejs.JavaScriptLoader = createjs.promote(JavaScriptLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// JSONLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JSON files. To load JSON cross-domain, use JSONP and the {{#crossLink \"JSONPLoader\"}}{{/crossLink}}\n\t * instead. To load JSON-formatted manifests, use {{#crossLink \"ManifestLoader\"}}{{/crossLink}}, and to\n\t * load EaselJS SpriteSheets, use {{#crossLink \"SpriteSheetLoader\"}}{{/crossLink}}.\n\t * @class JSONLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction JSONLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.JSON);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\t};\n\n\tvar p = createjs.extend(JSONLoader, createjs.AbstractLoader);\n\tvar s = JSONLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/JSON:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.JSON;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for JSON files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLLinkElement|HTMLStyleElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tvar json = null;\n\t\ttry {\n\t\t\tjson = createjs.DataUtils.parseJSON(loader.getResult(true));\n\t\t} catch (e) {\n\t\t\tvar event = new createjs.ErrorEvent(\"JSON_FORMAT\", null, e);\n\t\t\tthis._sendError(event);\n\t\t\treturn e;\n\t\t}\n\n\t\treturn json;\n\t};\n\n\tcreatejs.JSONLoader = createjs.promote(JSONLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// JSONPLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JSONP files, which are JSON-formatted text files, wrapped in a callback. To load regular JSON\n\t * without a callback use the {{#crossLink \"JSONLoader\"}}{{/crossLink}} instead. To load JSON-formatted manifests,\n\t * use {{#crossLink \"ManifestLoader\"}}{{/crossLink}}, and to load EaselJS SpriteSheets, use\n\t * {{#crossLink \"SpriteSheetLoader\"}}{{/crossLink}}.\n\t *\n\t * JSONP is a format that provides a solution for loading JSON files cross-domain <em>without</em> requiring CORS.\n\t * JSONP files are loaded as JavaScript, and the \"callback\" is executed once they are loaded. The callback in the\n\t * JSONP must match the callback passed to the loadItem.\n\t *\n\t * <h4>Example JSONP</h4>\n\t *\n\t * \t\tcallbackName({\n\t * \t\t\t\"name\": \"value\",\n\t *\t \t\t\"num\": 3,\n\t *\t\t\t\"obj\": { \"bool\":true }\n\t * \t\t});\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tvar loadItem = {id:\"json\", type:\"jsonp\", src:\"http://server.com/text.json\", callback:\"callbackName\"}\n\t * \t\tvar queue = new createjs.LoadQueue();\n\t * \t\tqueue.on(\"complete\", handleComplete);\n\t * \t\tqueue.loadItem(loadItem);\n\t *\n\t * \t\tfunction handleComplete(event) }\n\t * \t\t\tvar json = queue.getResult(\"json\");\n\t * \t\t\tconsole.log(json.obj.bool); // true\n\t * \t\t}\n\t *\n\t * Note that JSONP files loaded concurrently require a <em>unique</em> callback. To ensure JSONP files are loaded\n\t * in order, either use the {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}} method (set to 1),\n\t * or set {{#crossLink \"LoadItem/maintainOrder:property\"}}{{/crossLink}} on items with the same callback.\n\t *\n\t * @class JSONPLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction JSONPLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, false, createjs.AbstractLoader.JSONP);\n\t\tthis.setTag(document.createElement(\"script\"));\n\t\tthis.getTag().type = \"text/javascript\";\n\t};\n\n\tvar p = createjs.extend(JSONPLoader, createjs.AbstractLoader);\n\tvar s = JSONPLoader;\n\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/JSONP:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.JSONP;\n\t};\n\n\t// public methods\n\tp.cancel = function () {\n\t\tthis.AbstractLoader_cancel();\n\t\tthis._dispose();\n\t};\n\n\t/**\n\t * Loads the JSONp file.  Because of the unique loading needs of JSONp\n\t * we don't use the AbstractLoader.load() method.\n\t *\n\t * @method load\n\t *\n\t */\n\tp.load = function () {\n\t\tif (this._item.callback == null) {\n\t\t\tthrow new Error('callback is required for loading JSONP requests.');\n\t\t}\n\n\t\t// TODO: Look into creating our own iFrame to handle the load\n\t\t// In the first attempt, FF did not get the result\n\t\t//   result instanceof Object did not work either\n\t\t//   so we would need to clone the result.\n\t\tif (window[this._item.callback] != null) {\n\t\t\tthrow new Error(\n\t\t\t\t\"JSONP callback '\" +\n\t\t\t\tthis._item.callback +\n\t\t\t\t\"' already exists on window. You need to specify a different callback or re-name the current one.\");\n\t\t}\n\n\t\twindow[this._item.callback] = createjs.proxy(this._handleLoad, this);\n\t\twindow.document.body.appendChild(this._tag);\n\n\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\n\t\t// Load the tag\n\t\tthis._tag.src = this._item.src;\n\t};\n\n\t// private methods\n\t/**\n\t * Handle the JSONP callback, which is a public method defined on `window`.\n\t * @method _handleLoad\n\t * @param {Object} data The formatted JSON data.\n\t * @private\n\t */\n\tp._handleLoad = function (data) {\n\t\tthis._result = this._rawResult = data;\n\t\tthis._sendComplete();\n\n\t\tthis._dispose();\n\t};\n\n\t/**\n\t * The tag request has not loaded within the time specfied in loadTimeout.\n\t * @method _handleError\n\t * @param {Object} event The XHR error event.\n\t * @private\n\t */\n\tp._handleTimeout = function () {\n\t\tthis._dispose();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"timeout\"));\n\t};\n\n\t/**\n\t * Clean up the JSONP load. This clears out the callback and script tag that this loader creates.\n\t * @method _dispose\n\t * @private\n\t */\n\tp._dispose = function () {\n\t\twindow.document.body.removeChild(this._tag);\n\t\tdelete window[this._item.callback];\n\n\t\tclearTimeout(this._loadTimeout);\n\t};\n\n\tcreatejs.JSONPLoader = createjs.promote(JSONPLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// ManifestLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JSON manifests. Items inside the manifest are loaded before the loader completes. To load manifests\n\t * using JSONP, specify a {{#crossLink \"LoadItem/callback:property\"}}{{/crossLink}} as part of the\n\t * {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t *\n\t * The list of files in the manifest must be defined on the top-level JSON object in a `manifest` property. This\n\t * example shows a sample manifest definition, as well as how to to include a sub-manifest.\n\t *\n\t * \t\t{\n\t * \t\t\t\"path\": \"assets/\",\n\t *\t \t    \"manifest\": [\n\t *\t\t\t\t\"image.png\",\n\t *\t\t\t\t{\"src\": \"image2.png\", \"id\":\"image2\"},\n\t *\t\t\t\t{\"src\": \"sub-manifest.json\", \"type\":\"manifest\", \"callback\":\"jsonCallback\"}\n\t *\t \t    ]\n\t *\t \t}\n\t *\n\t * When a ManifestLoader has completed loading, the parent loader (usually a {{#crossLink \"LoadQueue\"}}{{/crossLink}},\n\t * but could also be another ManifestLoader) will inherit all the loaded items, so you can access them directly.\n\t *\n\t * Note that the {{#crossLink \"JSONLoader\"}}{{/crossLink}} and {{#crossLink \"JSONPLoader\"}}{{/crossLink}} are\n\t * higher priority loaders, so manifests <strong>must</strong> set the {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t * {{#crossLink \"LoadItem/type:property\"}}{{/crossLink}} property to {{#crossLink \"AbstractLoader/MANIFEST:property\"}}{{/crossLink}}.\n\t * @class ManifestLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction ManifestLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, null, createjs.AbstractLoader.MANIFEST);\n\n\t// Public Properties\n\t\t/**\n\t\t * An array of the plugins registered using {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}},\n\t\t * used to pass plugins to new LoadQueues that may be created.\n\t\t * @property _plugins\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.1\n\t\t */\n\t\tthis.plugins = null;\n\n\n\t// Protected Properties\n\t\t/**\n\t\t * An internal {{#crossLink \"LoadQueue\"}}{{/crossLink}} that loads the contents of the manifest.\n\t\t * @property _manifestQueue\n\t\t * @type {LoadQueue}\n\t\t * @private\n\t\t */\n\t\tthis._manifestQueue = null;\n\t};\n\n\tvar p = createjs.extend(ManifestLoader, createjs.AbstractLoader);\n\tvar s = ManifestLoader;\n\n\t// static properties\n\t/**\n\t * The amount of progress that the manifest itself takes up.\n\t * @property MANIFEST_PROGRESS\n\t * @type {number}\n\t * @default 0.25 (25%)\n\t * @private\n\t * @static\n\t */\n\ts.MANIFEST_PROGRESS = 0.25;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/MANIFEST:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.MANIFEST;\n\t};\n\n\t// public methods\n\tp.load = function () {\n\t\tthis.AbstractLoader_load();\n\t};\n\n\t// protected methods\n\tp._createRequest = function() {\n\t\tvar callback = this._item.callback;\n\t\tif (callback != null) {\n\t\t\tthis._request = new createjs.JSONPLoader(this._item);\n\t\t} else {\n\t\t\tthis._request = new createjs.JSONLoader(this._item);\n\t\t}\n\t};\n\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase \"complete\":\n\t\t\t\tthis._rawResult = event.target.getResult(true);\n\t\t\t\tthis._result = event.target.getResult();\n\t\t\t\tthis._sendProgress(s.MANIFEST_PROGRESS);\n\t\t\t\tthis._loadManifest(this._result);\n\t\t\t\treturn;\n\t\t\tcase \"progress\":\n\t\t\t\tevent.loaded *= s.MANIFEST_PROGRESS;\n\t\t\t\tthis.progress = event.loaded / event.total;\n\t\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n\t\t\t\tthis._sendProgress(event);\n\t\t\t\treturn;\n\t\t}\n\t\tthis.AbstractLoader_handleEvent(event);\n\t};\n\n\tp.destroy = function() {\n\t\tthis.AbstractLoader_destroy();\n\t\tthis._manifestQueue.close();\n\t};\n\n\t/**\n\t * Create and load the manifest items once the actual manifest has been loaded.\n\t * @method _loadManifest\n\t * @param {Object} json\n\t * @private\n\t */\n\tp._loadManifest = function (json) {\n\t\tif (json && json.manifest) {\n\t\t\tvar queue = this._manifestQueue = new createjs.LoadQueue();\n\t\t\tqueue.on(\"fileload\", this._handleManifestFileLoad, this);\n\t\t\tqueue.on(\"progress\", this._handleManifestProgress, this);\n\t\t\tqueue.on(\"complete\", this._handleManifestComplete, this, true);\n\t\t\tqueue.on(\"error\", this._handleManifestError, this, true);\n\t\t\tfor(var i = 0, l = this.plugins.length; i < l; i++) {\t// conserve order of plugins\n\t\t\t\tqueue.installPlugin(this.plugins[i]);\n\t\t\t}\n\t\t\tqueue.loadManifest(json);\n\t\t} else {\n\t\t\tthis._sendComplete();\n\t\t}\n\t};\n\n\t/**\n\t * An item from the {{#crossLink \"_manifestQueue:property\"}}{{/crossLink}} has completed.\n\t * @method _handleManifestFileLoad\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestFileLoad = function (event) {\n\t\tevent.target = null;\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * The manifest has completed loading. This triggers the {{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}}\n\t * {{#crossLink \"Event\"}}{{/crossLink}} from the ManifestLoader.\n\t * @method _handleManifestComplete\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestComplete = function (event) {\n\t\tthis._loadedItems = this._manifestQueue.getItems(true);\n\t\tthis._sendComplete();\n\t};\n\n\t/**\n\t * The manifest has reported progress.\n\t * @method _handleManifestProgress\n\t * @param {ProgressEvent} event\n\t * @private\n\t */\n\tp._handleManifestProgress = function (event) {\n\t\tthis.progress = event.progress * (1 - s.MANIFEST_PROGRESS) + s.MANIFEST_PROGRESS;\n\t\tthis._sendProgress(this.progress);\n\t};\n\n\t/**\n\t * The manifest has reported an error with one of the files.\n\t * @method _handleManifestError\n\t * @param {ErrorEvent} event\n\t * @private\n\t */\n\tp._handleManifestError = function (event) {\n\t\tvar newEvent = new createjs.Event(\"fileerror\");\n\t\tnewEvent.item = event.data;\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\tcreatejs.ManifestLoader = createjs.promote(ManifestLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// SoundLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for HTML audio files. PreloadJS can not load WebAudio files, as a WebAudio context is required, which\n\t * should be created by either a library playing the sound (such as <a href=\"http://soundjs.com\">SoundJS</a>, or an\n\t * external framework that handles audio playback. To load content that can be played by WebAudio, use the\n\t * {{#crossLink \"BinaryLoader\"}}{{/crossLink}}, and handle the audio context decoding manually.\n\t * @class SoundLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractMediaLoader\n\t * @constructor\n\t */\n\tfunction SoundLoader(loadItem, preferXHR) {\n\t\tthis.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SOUND);\n\n\t\t// protected properties\n\t\tif (createjs.RequestUtils.isAudioTag(loadItem)) {\n\t\t\tthis._tag = loadItem;\n\t\t} else if (createjs.RequestUtils.isAudioTag(loadItem.src)) {\n\t\t\tthis._tag = loadItem;\n\t\t} else if (createjs.RequestUtils.isAudioTag(loadItem.tag)) {\n\t\t\tthis._tag = createjs.RequestUtils.isAudioTag(loadItem) ? loadItem : loadItem.src;\n\t\t}\n\n\t\tif (this._tag != null) {\n\t\t\tthis._preferXHR = false;\n\t\t}\n\t};\n\n\tvar p = createjs.extend(SoundLoader, createjs.AbstractMediaLoader);\n\tvar s = SoundLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/SOUND:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.SOUND;\n\t};\n\n\t// protected methods\n\tp._createTag = function (src) {\n\t\tvar tag = document.createElement(\"audio\");\n\t\ttag.autoplay = false;\n\t\ttag.preload = \"none\";\n\n\t\t//LM: Firefox fails when this the preload=\"none\" for other tags, but it needs to be \"none\" to ensure PreloadJS works.\n\t\ttag.src = src;\n\t\treturn tag;\n\t};\n\n\tcreatejs.SoundLoader = createjs.promote(SoundLoader, \"AbstractMediaLoader\");\n\n}());\n\n//##############################################################################\n// VideoLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for video files.\n\t * @class VideoLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractMediaLoader\n\t * @constructor\n\t */\n\tfunction VideoLoader(loadItem, preferXHR) {\n\t\tthis.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.VIDEO);\n\n\t\tif (createjs.RequestUtils.isVideoTag(loadItem) || createjs.RequestUtils.isVideoTag(loadItem.src)) {\n\t\t\tthis.setTag(createjs.RequestUtils.isVideoTag(loadItem)?loadItem:loadItem.src);\n\n\t\t\t// We can't use XHR for a tag that's passed in.\n\t\t\tthis._preferXHR = false;\n\t\t} else {\n\t\t\tthis.setTag(this._createTag());\n\t\t}\n\t};\n\n\tvar p = createjs.extend(VideoLoader, createjs.AbstractMediaLoader);\n\tvar s = VideoLoader;\n\n\t/**\n\t * Create a new video tag\n\t *\n\t * @returns {HTMLElement}\n\t * @private\n\t */\n\tp._createTag = function () {\n\t\treturn document.createElement(\"video\");\n\t};\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/VIDEO:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.VIDEO;\n\t};\n\n\tcreatejs.VideoLoader = createjs.promote(VideoLoader, \"AbstractMediaLoader\");\n\n}());\n\n//##############################################################################\n// SpriteSheetLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for EaselJS SpriteSheets. Images inside the spritesheet definition are loaded before the loader\n\t * completes. To load SpriteSheets using JSONP, specify a {{#crossLink \"LoadItem/callback:property\"}}{{/crossLink}}\n\t * as part of the {{#crossLink \"LoadItem\"}}{{/crossLink}}. Note that the {{#crossLink \"JSONLoader\"}}{{/crossLink}}\n\t * and {{#crossLink \"JSONPLoader\"}}{{/crossLink}} are higher priority loaders, so SpriteSheets <strong>must</strong>\n\t * set the {{#crossLink \"LoadItem\"}}{{/crossLink}} {{#crossLink \"LoadItem/type:property\"}}{{/crossLink}} property\n\t * to {{#crossLink \"AbstractLoader/SPRITESHEET:property\"}}{{/crossLink}}.\n\t *\n\t * The {{#crossLink \"LoadItem\"}}{{/crossLink}} {{#crossLink \"LoadItem/crossOrigin:property\"}}{{/crossLink}} as well\n\t * as the {{#crossLink \"LoadQueue's\"}}{{/crossLink}} `basePath` argument and {{#crossLink \"LoadQueue/_preferXHR\"}}{{/crossLink}}\n\t * property supplied to the {{#crossLink \"LoadQueue\"}}{{/crossLink}} are passed on to the sub-manifest that loads\n\t * the SpriteSheet images.\n\t *\n\t * Note that the SpriteSheet JSON does not respect the {{#crossLink \"LoadQueue/_preferXHR:property\"}}{{/crossLink}}\n\t * property, which should instead be determined by the presence of a {{#crossLink \"LoadItem/callback:property\"}}{{/crossLink}}\n\t * property on the SpriteSheet load item. This is because the JSON loaded will have a different format depending on\n\t * if it is loaded as JSON, so just changing `preferXHR` is not enough to change how it is loaded.\n\t * @class SpriteSheetLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction SpriteSheetLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SPRITESHEET);\n\n\t\t// protected properties\n\t\t/**\n\t\t * An internal queue which loads the SpriteSheet's images.\n\t\t * @method _manifestQueue\n\t\t * @type {LoadQueue}\n\t\t * @private\n\t\t */\n\t\tthis._manifestQueue = null;\n\t}\n\n\tvar p = createjs.extend(SpriteSheetLoader, createjs.AbstractLoader);\n\tvar s = SpriteSheetLoader;\n\n\t// static properties\n\t/**\n\t * The amount of progress that the manifest itself takes up.\n\t * @property SPRITESHEET_PROGRESS\n\t * @type {number}\n\t * @default 0.25 (25%)\n\t * @private\n\t * @static\n\t */\n\ts.SPRITESHEET_PROGRESS = 0.25;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/SPRITESHEET:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.SPRITESHEET;\n\t};\n\n\t// public methods\n\tp.destroy = function() {\n\t\tthis.AbstractLoader_destroy;\n\t\tthis._manifestQueue.close();\n\t};\n\n\t// protected methods\n\tp._createRequest = function() {\n\t\tvar callback = this._item.callback;\n\t\tif (callback != null) {\n\t\t\tthis._request = new createjs.JSONPLoader(this._item);\n\t\t} else {\n\t\t\tthis._request = new createjs.JSONLoader(this._item);\n\t\t}\n\t};\n\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase \"complete\":\n\t\t\t\tthis._rawResult = event.target.getResult(true);\n\t\t\t\tthis._result = event.target.getResult();\n\t\t\t\tthis._sendProgress(s.SPRITESHEET_PROGRESS);\n\t\t\t\tthis._loadManifest(this._result);\n\t\t\t\treturn;\n\t\t\tcase \"progress\":\n\t\t\t\tevent.loaded *= s.SPRITESHEET_PROGRESS;\n\t\t\t\tthis.progress = event.loaded / event.total;\n\t\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n\t\t\t\tthis._sendProgress(event);\n\t\t\t\treturn;\n\t\t}\n\t\tthis.AbstractLoader_handleEvent(event);\n\t};\n\n\t/**\n\t * Create and load the images once the SpriteSheet JSON has been loaded.\n\t * @method _loadManifest\n\t * @param {Object} json\n\t * @private\n\t */\n\tp._loadManifest = function (json) {\n\t\tif (json && json.images) {\n\t\t\tvar queue = this._manifestQueue = new createjs.LoadQueue(this._preferXHR, this._item.path, this._item.crossOrigin);\n\t\t\tqueue.on(\"complete\", this._handleManifestComplete, this, true);\n\t\t\tqueue.on(\"fileload\", this._handleManifestFileLoad, this);\n\t\t\tqueue.on(\"progress\", this._handleManifestProgress, this);\n\t\t\tqueue.on(\"error\", this._handleManifestError, this, true);\n\t\t\tqueue.loadManifest(json.images);\n\t\t}\n\t};\n\n\t/**\n\t * An item from the {{#crossLink \"_manifestQueue:property\"}}{{/crossLink}} has completed.\n\t * @method _handleManifestFileLoad\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestFileLoad = function (event) {\n\t\tvar image = event.result;\n\t\tif (image != null) {\n\t\t\tvar images = this.getResult().images;\n\t\t\tvar pos = images.indexOf(event.item.src);\n\t\t\timages[pos] = image;\n\t\t}\n\t};\n\n\t/**\n\t * The images have completed loading. This triggers the {{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}}\n\t * {{#crossLink \"Event\"}}{{/crossLink}} from the SpriteSheetLoader.\n\t * @method _handleManifestComplete\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestComplete = function (event) {\n\t\tthis._result = new createjs.SpriteSheet(this._result);\n\t\tthis._loadedItems = this._manifestQueue.getItems(true);\n\t\tthis._sendComplete();\n\t};\n\n\t/**\n\t * The images {{#crossLink \"LoadQueue\"}}{{/crossLink}} has reported progress.\n\t * @method _handleManifestProgress\n\t * @param {ProgressEvent} event\n\t * @private\n\t */\n\tp._handleManifestProgress = function (event) {\n\t\tthis.progress = event.progress * (1 - s.SPRITESHEET_PROGRESS) + s.SPRITESHEET_PROGRESS;\n\t\tthis._sendProgress(this.progress);\n\t};\n\n\t/**\n\t * An image has reported an error.\n\t * @method _handleManifestError\n\t * @param {ErrorEvent} event\n\t * @private\n\t */\n\tp._handleManifestError = function (event) {\n\t\tvar newEvent = new createjs.Event(\"fileerror\");\n\t\tnewEvent.item = event.data;\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\tcreatejs.SpriteSheetLoader = createjs.promote(SpriteSheetLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// SVGLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for SVG files.\n\t * @class SVGLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction SVGLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SVG);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"data\";\n\n\t\tif (preferXHR) {\n\t\t\tthis.setTag(document.createElement(\"svg\"));\n\t\t} else {\n\t\t\tthis.setTag(document.createElement(\"object\"));\n\t\t\tthis.getTag().type = \"image/svg+xml\";\n\t\t}\n\t};\n\n\tvar p = createjs.extend(SVGLoader, createjs.AbstractLoader);\n\tvar s = SVGLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/SVG:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.SVG;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for SVG files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {Object}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\t// mime should be image/svg+xml, but Opera requires text/xml\n\t\tvar xml = createjs.DataUtils.parseXML(loader.getResult(true), \"text/xml\");\n\t\tvar tag = loader.getTag();\n\n\t\tif (!this._preferXHR && document.body.contains(tag)) {\n\t\t\tdocument.body.removeChild(tag);\n\t\t}\n\n\t\tif (xml.documentElement != null) {\n\t\t\ttag.appendChild(xml.documentElement);\n\t\t\ttag.style.visibility = \"visible\";\n\t\t\treturn tag;\n\t\t} else { // For browsers that don't support SVG, just give them the XML. (IE 9-8)\n\t\t\treturn xml;\n\t\t}\n\t};\n\n\tcreatejs.SVGLoader = createjs.promote(SVGLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// XMLLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for CSS files.\n\t * @class XMLLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction XMLLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.XML);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\t};\n\n\tvar p = createjs.extend(XMLLoader, createjs.AbstractLoader);\n\tvar s = XMLLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/XML:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.XML;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for XML files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {XMLDocument}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\treturn createjs.DataUtils.parseXML(loader.getResult(true), \"text/xml\");\n\t};\n\n\tcreatejs.XMLLoader = createjs.promote(XMLLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of the library.\n\t * The SoundJS class has been renamed {{#crossLink \"Sound\"}}{{/crossLink}}.  Please see {{#crossLink \"Sound\"}}{{/crossLink}}\n\t * for information on using sound.\n\t * @class SoundJS\n\t **/\n\tvar s = createjs.SoundJS = createjs.SoundJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type String\n\t * @static\n\t **/\n\ts.version = /*=version*/\"0.6.2\"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type String\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/\"Thu, 26 Nov 2015 20:44:31 GMT\"; // injected by build process\n\n})();\n\n//##############################################################################\n// IndexOf.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of\n * that value.  Returns -1 if value is not found.\n *\n *      var i = createjs.indexOf(myArray, myElementToFind);\n *\n * @method indexOf\n * @param {Array} array Array to search for searchElement\n * @param searchElement Element to find in array.\n * @return {Number} The first index of searchElement in array.\n */\ncreatejs.indexOf = function (array, searchElement){\n\t\"use strict\";\n\n\tfor (var i = 0,l=array.length; i < l; i++) {\n\t\tif (searchElement === array[i]) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n//##############################################################################\n// Proxy.js\n//##############################################################################\n\n/**\n * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the\n * createjs namespace directly.\n *\n * <h4>Example</h4>\n *\n *      myObject.addEventListener(\"change\", createjs.proxy(myMethod, scope));\n *\n * @class Utility Methods\n * @main Utility Methods\n */\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a\n\t * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the\n\t * method gets called in the correct scope.\n\t *\n\t * Additional arguments can be passed that will be applied to the function when it is called.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myObject.addEventListener(\"event\", createjs.proxy(myHandler, this, arg1, arg2));\n\t *\n\t *      function myHandler(arg1, arg2) {\n\t *           // This gets called when myObject.myCallback is executed.\n\t *      }\n\t *\n\t * @method proxy\n\t * @param {Function} method The function to call\n\t * @param {Object} scope The scope to call the method name on\n\t * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.\n\t * @public\n\t * @static\n\t */\n\tcreatejs.proxy = function (method, scope) {\n\t\tvar aArgs = Array.prototype.slice.call(arguments, 2);\n\t\treturn function () {\n\t\t\treturn method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));\n\t\t};\n\t}\n\n}());\n\n//##############################################################################\n// BrowserDetect.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * An object that determines the current browser, version, operating system, and other environment\n\t * variables via user agent string.\n\t *\n\t * Used for audio because feature detection is unable to detect the many limitations of mobile devices.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      if (createjs.BrowserDetect.isIOS) { // do stuff }\n\t *\n\t * @property BrowserDetect\n\t * @type {Object}\n\t * @param {Boolean} isFirefox True if our browser is Firefox.\n\t * @param {Boolean} isOpera True if our browser is opera.\n\t * @param {Boolean} isChrome True if our browser is Chrome.  Note that Chrome for Android returns true, but is a\n\t * completely different browser with different abilities.\n\t * @param {Boolean} isIOS True if our browser is safari for iOS devices (iPad, iPhone, and iPod).\n\t * @param {Boolean} isAndroid True if our browser is Android.\n\t * @param {Boolean} isBlackberry True if our browser is Blackberry.\n\t * @constructor\n\t * @static\n\t */\n\tfunction BrowserDetect() {\n\t\tthrow \"BrowserDetect cannot be instantiated\";\n\t};\n\n\tvar agent = BrowserDetect.agent = window.navigator.userAgent;\n\tBrowserDetect.isWindowPhone = (agent.indexOf(\"IEMobile\") > -1) || (agent.indexOf(\"Windows Phone\") > -1);\n\tBrowserDetect.isFirefox = (agent.indexOf(\"Firefox\") > -1);\n\tBrowserDetect.isOpera = (window.opera != null);\n\tBrowserDetect.isChrome = (agent.indexOf(\"Chrome\") > -1);  // NOTE that Chrome on Android returns true but is a completely different browser with different abilities\n\tBrowserDetect.isIOS = (agent.indexOf(\"iPod\") > -1 || agent.indexOf(\"iPhone\") > -1 || agent.indexOf(\"iPad\") > -1) && !BrowserDetect.isWindowPhone;\n\tBrowserDetect.isAndroid = (agent.indexOf(\"Android\") > -1) && !BrowserDetect.isWindowPhone;\n\tBrowserDetect.isBlackberry = (agent.indexOf(\"Blackberry\") > -1);\n\n\tcreatejs.BrowserDetect = BrowserDetect;\n\n}());\n\n//##############################################################################\n// AudioSprite.js\n//##############################################################################\n\n//  NOTE this is \"Class\" is purely to document audioSprite Setup and usage.\n\n\n/**\n * <strong>Note: AudioSprite is not a class, but its usage is easily lost in the documentation, so it has been called\n * out here for quick reference.</strong>\n *\n * Audio sprites are much like CSS sprites or image sprite sheets: multiple audio assets grouped into a single file.\n * Audio sprites work around limitations in certain browsers, where only a single sound can be loaded and played at a\n * time. We recommend at least 300ms of silence between audio clips to deal with HTML audio tag inaccuracy, and to prevent\n * accidentally playing bits of the neighbouring clips.\n *\n * <strong>Benefits of Audio Sprites:</strong>\n * <ul>\n *     <li>More robust support for older browsers and devices that only allow a single audio instance, such as iOS 5.</li>\n *     <li>They provide a work around for the Internet Explorer 9 audio tag limit, which restricts how many different\n *     sounds that could be loaded at once.</li>\n *     <li>Faster loading by only requiring a single network request for several sounds, especially on mobile devices\n * where the network round trip for each file can add significant latency.</li>\n * </ul>\n *\n * <strong>Drawbacks of Audio Sprites</strong>\n * <ul>\n *     <li>No guarantee of smooth looping when using HTML or Flash audio. If you have a track that needs to loop\n * \t\tsmoothly and you are supporting non-web audio browsers, do not use audio sprites for that sound if you can avoid\n * \t\tit.</li>\n *     <li>No guarantee that HTML audio will play back immediately, especially the first time. In some browsers\n *     (Chrome!), HTML audio will only load enough to play through at the current download speed â€“ so we rely on the\n *     `canplaythrough` event to determine if the audio is loaded. Since audio sprites must jump ahead to play specific\n *     sounds, the audio may not yet have downloaded fully.</li>\n *     <li>Audio sprites share the same core source, so if you have a sprite with 5 sounds and are limited to 2\n * \t\tconcurrently playing instances, you can only play 2 of the sounds at the same time.</li>\n * </ul>\n *\n * <h4>Example</h4>\n *\n *\t\tcreatejs.Sound.initializeDefaultPlugins();\n *\t\tvar assetsPath = \"./assets/\";\n *\t\tvar sounds = [{\n *\t\t\tsrc:\"MyAudioSprite.ogg\", data: {\n *\t\t\t\taudioSprite: [\n *\t\t\t\t\t{id:\"sound1\", startTime:0, duration:500},\n *\t\t\t\t\t{id:\"sound2\", startTime:1000, duration:400},\n *\t\t\t\t\t{id:\"sound3\", startTime:1700, duration: 1000}\n *\t\t\t\t]}\n *\t\t\t}\n *\t\t];\n *\t\tcreatejs.Sound.alternateExtensions = [\"mp3\"];\n *\t\tcreatejs.Sound.on(\"fileload\", loadSound);\n *\t\tcreatejs.Sound.registerSounds(sounds, assetsPath);\n *\t\t// after load is complete\n *\t\tcreatejs.Sound.play(\"sound2\");\n *\n * You can also create audio sprites on the fly by setting the startTime and duration when creating an new AbstractSoundInstance.\n *\n * \t\tcreatejs.Sound.play(\"MyAudioSprite\", {startTime: 1000, duration: 400});\n *\n * The excellent CreateJS community has created a tool to create audio sprites, available at\n * <a href=\"https://github.com/tonistiigi/audiosprite\" target=\"_blank\">https://github.com/tonistiigi/audiosprite</a>,\n * as well as a <a href=\"http://jsfiddle.net/bharat_battu/g8fFP/12/\" target=\"_blank\">jsfiddle</a> to convert the output\n * to SoundJS format.\n *\n * @class AudioSprite\n * @since 0.6.0\n */\n\n//##############################################################################\n// PlayPropsConfig.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\t/**\n\t * A class to store the optional play properties passed in {{#crossLink \"Sound/play\"}}{{/crossLink}} and\n\t * {{#crossLink \"AbstractSoundInstance/play\"}}{{/crossLink}} calls.\n\t *\n\t * Optional Play Properties Include:\n\t * <ul>\n\t * <li>interrupt - How to interrupt any currently playing instances of audio with the same source,\n\t * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\n\t * constants on the Sound class, with the default defined by {{#crossLink \"Sound/defaultInterruptBehavior:property\"}}{{/crossLink}}.</li>\n\t * <li>delay - The amount of time to delay the start of audio playback, in milliseconds.</li>\n\t * <li>offset - The offset from the start of the audio to begin playback, in milliseconds.</li>\n\t * <li>loop - How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t * loops), and -1 can be used for infinite playback.</li>\n\t * <li>volume - The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t * against the individual volume.</li>\n\t * <li>pan - The left-right pan of the sound (if supported), between -1 (left) and 1 (right).</li>\n\t * <li>startTime - To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.</li>\n\t * <li>duration - To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.</li>\n\t * </ul>\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \tvar ppc = new createjs.PlayPropsConfig().set({interrupt: createjs.Sound.INTERRUPT_ANY, loop: -1, volume: 0.5})\n\t * \tcreatejs.Sound.play(\"mySound\", ppc);\n\t * \tmySoundInstance.play(ppc);\n\t *\n\t * @class PlayPropsConfig\n\t * @constructor\n\t * @since 0.6.1\n\t */\n\t// TODO think of a better name for this class\n\tvar PlayPropsConfig = function () {\n// Public Properties\n\t\t/**\n\t\t * How to interrupt any currently playing instances of audio with the same source,\n\t\t * if the maximum number of instances of the sound are already playing. Values are defined as\n\t\t * <code>INTERRUPT_TYPE</code> constants on the Sound class, with the default defined by\n\t\t * {{#crossLink \"Sound/defaultInterruptBehavior:property\"}}{{/crossLink}}.\n\t\t * @property interrupt\n\t\t * @type {string}\n\t\t * @default null\n\t\t */\n\t\tthis.interrupt = null;\n\n\t\t/**\n\t\t * The amount of time to delay the start of audio playback, in milliseconds.\n\t\t * @property delay\n\t\t * @type {Number}\n\t\t * @default null\n\t\t */\n\t\tthis.delay = null;\n\n\t\t/**\n\t\t * The offset from the start of the audio to begin playback, in milliseconds.\n\t\t * @property offset\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.offset = null;\n\n\t\t/**\n\t\t * How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t\t * loops), and -1 can be used for infinite playback.\n\t\t * @property loop\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.loop = null;\n\n\t\t/**\n\t\t * The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t\t * against the individual volume.\n\t\t * @property volume\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.volume = null;\n\n\t\t/**\n\t\t * The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\n\t\t * @property pan\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.pan = null;\n\n\t\t/**\n\t\t * Used to create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\n\t\t * @property startTime\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.startTime = null;\n\n\t\t/**\n\t\t * Used to create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\n\t\t * @property duration\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.duration = null;\n\t};\n\tvar p = PlayPropsConfig.prototype = {};\n\tvar s = PlayPropsConfig;\n\n\n// Static Methods\n\t/**\n\t * Creates a PlayPropsConfig from another PlayPropsConfig or an Object.\n\t *\n\t * @method create\n\t * @param {PlayPropsConfig|Object} value The play properties\n\t * @returns {PlayPropsConfig}\n\t * @static\n\t */\n\ts.create = function (value) {\n\t\tif (value instanceof s || value instanceof Object) {\n\t\t\tvar ppc = new createjs.PlayPropsConfig();\n\t\t\tppc.set(value);\n\t\t\treturn ppc;\n\t\t} else {\n\t\t\tthrow new Error(\"Type not recognized.\");\n\t\t}\n\t};\n\n// Public Methods\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var PlayPropsConfig = new createjs.PlayPropsConfig().set({loop:-1, volume:0.7});\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the PlayPropsConfig instance.\n\t * @return {PlayPropsConfig} Returns the instance the method is called on (useful for chaining calls.)\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\n\tp.toString = function() {\n\t\treturn \"[PlayPropsConfig]\";\n\t};\n\n\tcreatejs.PlayPropsConfig = s;\n\n}());\n\n//##############################################################################\n// Sound.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * The Sound class is the public API for creating sounds, controlling the overall sound levels, and managing plugins.\n\t * All Sound APIs on this class are static.\n\t *\n\t * <b>Registering and Preloading</b><br />\n\t * Before you can play a sound, it <b>must</b> be registered. You can do this with {{#crossLink \"Sound/registerSound\"}}{{/crossLink}},\n\t * or register multiple sounds using {{#crossLink \"Sound/registerSounds\"}}{{/crossLink}}. If you don't register a\n\t * sound prior to attempting to play it using {{#crossLink \"Sound/play\"}}{{/crossLink}} or create it using {{#crossLink \"Sound/createInstance\"}}{{/crossLink}},\n\t * the sound source will be automatically registered but playback will fail as the source will not be ready. If you use\n\t * <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>, registration is handled for you when the sound is\n\t * preloaded. It is recommended to preload sounds either internally using the register functions or externally using\n\t * PreloadJS so they are ready when you want to use them.\n\t *\n\t * <b>Playback</b><br />\n\t * To play a sound once it's been registered and preloaded, use the {{#crossLink \"Sound/play\"}}{{/crossLink}} method.\n\t * This method returns a {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} which can be paused, resumed, muted, etc.\n\t * Please see the {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} documentation for more on the instance control APIs.\n\t *\n\t * <b>Plugins</b><br />\n\t * By default, the {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}} or the {{#crossLink \"HTMLAudioPlugin\"}}{{/crossLink}}\n\t * are used (when available), although developers can change plugin priority or add new plugins (such as the\n\t * provided {{#crossLink \"FlashAudioPlugin\"}}{{/crossLink}}). Please see the {{#crossLink \"Sound\"}}{{/crossLink}} API\n\t * methods for more on the playback and plugin APIs. To install plugins, or specify a different plugin order, see\n\t * {{#crossLink \"Sound/installPlugins\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.FlashAudioPlugin.swfPath = \"../src/soundjs/flashaudio\";\n\t *      createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.FlashAudioPlugin]);\n\t *      createjs.Sound.alternateExtensions = [\"mp3\"];\n\t *      createjs.Sound.on(\"fileload\", this.loadHandler, this);\n\t *      createjs.Sound.registerSound(\"path/to/mySound.ogg\", \"sound\");\n\t *      function loadHandler(event) {\n     *          // This is fired for each sound that is registered.\n     *          var instance = createjs.Sound.play(\"sound\");  // play using id.  Could also use full source path or event.src.\n     *          instance.on(\"complete\", this.handleComplete, this);\n     *          instance.volume = 0.5;\n\t *      }\n\t *\n\t * The maximum number of concurrently playing instances of the same sound can be specified in the \"data\" argument\n\t * of {{#crossLink \"Sound/registerSound\"}}{{/crossLink}}.  Note that if not specified, the active plugin will apply\n\t * a default limit.  Currently HTMLAudioPlugin sets a default limit of 2, while WebAudioPlugin and FlashAudioPlugin set a\n\t * default limit of 100.\n\t *\n\t *      createjs.Sound.registerSound(\"sound.mp3\", \"soundId\", 4);\n\t *\n\t * Sound can be used as a plugin with PreloadJS to help preload audio properly. Audio preloaded with PreloadJS is\n\t * automatically registered with the Sound class. When audio is not preloaded, Sound will do an automatic internal\n\t * load. As a result, it may fail to play the first time play is called if the audio is not finished loading. Use\n\t * the {{#crossLink \"Sound/fileload:event\"}}{{/crossLink}} event to determine when a sound has finished internally\n\t * preloading. It is recommended that all audio is preloaded before it is played.\n\t *\n\t *      var queue = new createjs.LoadQueue();\n\t *\t\tqueue.installPlugin(createjs.Sound);\n\t *\n\t * <b>Audio Sprites</b><br />\n\t * SoundJS has added support for {{#crossLink \"AudioSprite\"}}{{/crossLink}}, available as of version 0.6.0.\n\t * For those unfamiliar with audio sprites, they are much like CSS sprites or sprite sheets: multiple audio assets\n\t * grouped into a single file.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *\t\tvar assetsPath = \"./assets/\";\n\t *\t\tvar sounds = [{\n\t *\t\t\tsrc:\"MyAudioSprite.ogg\", data: {\n\t *\t\t\t\taudioSprite: [\n\t *\t\t\t\t\t{id:\"sound1\", startTime:0, duration:500},\n\t *\t\t\t\t\t{id:\"sound2\", startTime:1000, duration:400},\n\t *\t\t\t\t\t{id:\"sound3\", startTime:1700, duration: 1000}\n\t *\t\t\t\t]}\n \t *\t\t\t}\n\t *\t\t];\n\t *\t\tcreatejs.Sound.alternateExtensions = [\"mp3\"];\n\t *\t\tcreatejs.Sound.on(\"fileload\", loadSound);\n\t *\t\tcreatejs.Sound.registerSounds(sounds, assetsPath);\n\t *\t\t// after load is complete\n\t *\t\tcreatejs.Sound.play(\"sound2\");\n\t *\n\t * <b>Mobile Playback</b><br />\n\t * Devices running iOS require the WebAudio context to be \"unlocked\" by playing at least one sound inside of a user-\n\t * initiated event (such as touch/click). Earlier versions of SoundJS included a \"MobileSafe\" sample, but this is no\n\t * longer necessary as of SoundJS 0.6.2.\n\t * <ul>\n\t *     <li>\n\t *         In SoundJS 0.4.1 and above, you can either initialize plugins or use the {{#crossLink \"WebAudioPlugin/playEmptySound\"}}{{/crossLink}}\n\t *         method in the call stack of a user input event to manually unlock the audio context.\n\t *     </li>\n\t *     <li>\n\t *         In SoundJS 0.6.2 and above, SoundJS will automatically listen for the first document-level \"mousedown\"\n\t *         and \"touchend\" event, and unlock WebAudio. This will continue to check these events until the WebAudio\n\t *         context becomes \"unlocked\" (changes from \"suspended\" to \"running\")\n\t *     </li>\n\t *     <li>\n\t *         Both the \"mousedown\" and \"touchend\" events can be used to unlock audio in iOS9+, the \"touchstart\" event\n\t *         will work in iOS8 and below. The \"touchend\" event will only work in iOS9 when the gesture is interpreted\n\t *         as a \"click\", so if the user long-presses the button, it will no longer work.\n\t *     </li>\n\t *     <li>\n\t *         When using the <a href=\"http://www.createjs.com/docs/easeljs/classes/Touch.html\">EaselJS Touch class</a>,\n\t *         the \"mousedown\" event will not fire when a canvas is clicked, since MouseEvents are prevented, to ensure\n\t *         only touch events fire. To get around this, you can either rely on \"touchend\", or:\n\t *         <ol>\n\t *             <li>Set the `allowDefault` property on the Touch class constructor to `true` (defaults to `false`).</li>\n\t *             <li>Set the `preventSelection` property on the EaselJS `Stage` to `false`.</li>\n\t *         </ol>\n\t *         These settings may change how your application behaves, and are not recommended.\n\t *     </li>\n\t * </ul>\n\t *\n\t * <b>Loading Alternate Paths and Extension-less Files</b><br />\n\t * SoundJS supports loading alternate paths and extension-less files by passing an object instead of a string for\n\t * the `src` property, which is a hash using the format `{extension:\"path\", extension2:\"path2\"}`. These labels are\n\t * how SoundJS determines if the browser will support the sound. This also enables multiple formats to live in\n\t * different folders, or on CDNs, which often has completely different filenames for each file.\n\t *\n\t * Priority is determined by the property order (first property is tried first).  This is supported by both internal loading\n\t * and loading with PreloadJS.\n\t *\n\t * <em>Note: an id is required for playback.</em>\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *\t\tvar sounds = {path:\"./audioPath/\",\n\t * \t\t\t\tmanifest: [\n\t *\t\t\t\t{id: \"cool\", src: {mp3:\"mp3/awesome.mp3\", ogg:\"noExtensionOggFile\"}}\n\t *\t\t]};\n\t *\n\t *\t\tcreatejs.Sound.alternateExtensions = [\"mp3\"];\n\t *\t\tcreatejs.Sound.addEventListener(\"fileload\", handleLoad);\n\t *\t\tcreatejs.Sound.registerSounds(sounds);\n\t *\n\t * <h3>Known Browser and OS issues</h3>\n\t * <b>IE 9 HTML Audio limitations</b><br />\n\t * <ul><li>There is a delay in applying volume changes to tags that occurs once playback is started. So if you have\n\t * muted all sounds, they will all play during this delay until the mute applies internally. This happens regardless of\n\t * when or how you apply the volume change, as the tag seems to need to play to apply it.</li>\n     * <li>MP3 encoding will not always work for audio tags, particularly in Internet Explorer. We've found default\n\t * encoding with 64kbps works.</li>\n\t * <li>Occasionally very short samples will get cut off.</li>\n\t * <li>There is a limit to how many audio tags you can load and play at once, which appears to be determined by\n\t * hardware and browser settings.  See {{#crossLink \"HTMLAudioPlugin.MAX_INSTANCES\"}}{{/crossLink}} for a safe\n\t * estimate.</li></ul>\n\t *\n\t * <b>Firefox 25 Web Audio limitations</b>\n\t * <ul><li>mp3 audio files do not load properly on all windows machines, reported\n\t * <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=929969\" target=\"_blank\">here</a>. </br>\n\t * For this reason it is recommended to pass another FF supported type (ie ogg) first until this bug is resolved, if\n\t * possible.</li></ul>\n\n\t * <b>Safari limitations</b><br />\n\t * <ul><li>Safari requires Quicktime to be installed for audio playback.</li></ul>\n\t *\n\t * <b>iOS 6 Web Audio limitations</b><br />\n\t * <ul><li>Sound is initially locked, and must be unlocked via a user-initiated event. Please see the section on\n\t * Mobile Playback above.</li>\n\t * <li>A bug exists that will distort un-cached web audio when a video element is present in the DOM that has audio\n\t * at a different sampleRate.</li>\n\t * </ul>\n\t *\n\t * <b>Android HTML Audio limitations</b><br />\n\t * <ul><li>We have no control over audio volume. Only the user can set volume on their device.</li>\n\t * <li>We can only play audio inside a user event (touch/click).  This currently means you cannot loop sound or use\n\t * a delay.</li></ul>\n\t *\n\t * <b>Web Audio and PreloadJS</b><br />\n\t * <ul><li>Web Audio must be loaded through XHR, therefore when used with PreloadJS, tag loading is not possible.\n\t * This means that tag loading can not be used to avoid cross domain issues.</li><ul>\n\t *\n\t * @class Sound\n\t * @static\n\t * @uses EventDispatcher\n\t */\n\tfunction Sound() {\n\t\tthrow \"Sound cannot be instantiated\";\n\t}\n\n\tvar s = Sound;\n\n\n// Static Properties\n\t/**\n\t * The interrupt value to interrupt any currently playing instance with the same source, if the maximum number of\n\t * instances of the sound are already playing.\n\t * @property INTERRUPT_ANY\n\t * @type {String}\n\t * @default any\n\t * @static\n\t */\n\ts.INTERRUPT_ANY = \"any\";\n\n\t/**\n\t * The interrupt value to interrupt the earliest currently playing instance with the same source that progressed the\n\t * least distance in the audio track, if the maximum number of instances of the sound are already playing.\n\t * @property INTERRUPT_EARLY\n\t * @type {String}\n\t * @default early\n\t * @static\n\t */\n\ts.INTERRUPT_EARLY = \"early\";\n\n\t/**\n\t * The interrupt value to interrupt the currently playing instance with the same source that progressed the most\n\t * distance in the audio track, if the maximum number of instances of the sound are already playing.\n\t * @property INTERRUPT_LATE\n\t * @type {String}\n\t * @default late\n\t * @static\n\t */\n\ts.INTERRUPT_LATE = \"late\";\n\n\t/**\n\t * The interrupt value to not interrupt any currently playing instances with the same source, if the maximum number of\n\t * instances of the sound are already playing.\n\t * @property INTERRUPT_NONE\n\t * @type {String}\n\t * @default none\n\t * @static\n\t */\n\ts.INTERRUPT_NONE = \"none\";\n\n\t/**\n\t * Defines the playState of an instance that is still initializing.\n\t * @property PLAY_INITED\n\t * @type {String}\n\t * @default playInited\n\t * @static\n\t */\n\ts.PLAY_INITED = \"playInited\";\n\n\t/**\n\t * Defines the playState of an instance that is currently playing or paused.\n\t * @property PLAY_SUCCEEDED\n\t * @type {String}\n\t * @default playSucceeded\n\t * @static\n\t */\n\ts.PLAY_SUCCEEDED = \"playSucceeded\";\n\n\t/**\n\t * Defines the playState of an instance that was interrupted by another instance.\n\t * @property PLAY_INTERRUPTED\n\t * @type {String}\n\t * @default playInterrupted\n\t * @static\n\t */\n\ts.PLAY_INTERRUPTED = \"playInterrupted\";\n\n\t/**\n\t * Defines the playState of an instance that completed playback.\n\t * @property PLAY_FINISHED\n\t * @type {String}\n\t * @default playFinished\n\t * @static\n\t */\n\ts.PLAY_FINISHED = \"playFinished\";\n\n\t/**\n\t * Defines the playState of an instance that failed to play. This is usually caused by a lack of available channels\n\t * when the interrupt mode was \"INTERRUPT_NONE\", the playback stalled, or the sound could not be found.\n\t * @property PLAY_FAILED\n\t * @type {String}\n\t * @default playFailed\n\t * @static\n\t */\n\ts.PLAY_FAILED = \"playFailed\";\n\n\t/**\n\t * A list of the default supported extensions that Sound will <i>try</i> to play. Plugins will check if the browser\n\t * can play these types, so modifying this list before a plugin is initialized will allow the plugins to try to\n\t * support additional media types.\n\t *\n\t * NOTE this does not currently work for {{#crossLink \"FlashAudioPlugin\"}}{{/crossLink}}.\n\t *\n\t * More details on file formats can be found at <a href=\"http://en.wikipedia.org/wiki/Audio_file_format\" target=\"_blank\">http://en.wikipedia.org/wiki/Audio_file_format</a>.<br />\n\t * A very detailed list of file formats can be found at <a href=\"http://www.fileinfo.com/filetypes/audio\" target=\"_blank\">http://www.fileinfo.com/filetypes/audio</a>.\n\t * @property SUPPORTED_EXTENSIONS\n\t * @type {Array[String]}\n\t * @default [\"mp3\", \"ogg\", \"opus\", \"mpeg\", \"wav\", \"m4a\", \"mp4\", \"aiff\", \"wma\", \"mid\"]\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.SUPPORTED_EXTENSIONS = [\"mp3\", \"ogg\", \"opus\", \"mpeg\", \"wav\", \"m4a\", \"mp4\", \"aiff\", \"wma\", \"mid\"];\n\n\t/**\n\t * Some extensions use another type of extension support to play (one of them is a codex).  This allows you to map\n\t * that support so plugins can accurately determine if an extension is supported.  Adding to this list can help\n\t * plugins determine more accurately if an extension is supported.\n\t *\n \t * A useful list of extensions for each format can be found at <a href=\"http://html5doctor.com/html5-audio-the-state-of-play/\" target=\"_blank\">http://html5doctor.com/html5-audio-the-state-of-play/</a>.\n\t * @property EXTENSION_MAP\n\t * @type {Object}\n\t * @since 0.4.0\n\t * @default {m4a:\"mp4\"}\n\t * @static\n\t */\n\ts.EXTENSION_MAP = {\n\t\tm4a:\"mp4\"\n\t};\n\n\t/**\n\t * The RegExp pattern used to parse file URIs. This supports simple file names, as well as full domain URIs with\n\t * query strings. The resulting match is: protocol:$1 domain:$2 path:$3 file:$4 extension:$5 query:$6.\n\t * @property FILE_PATTERN\n\t * @type {RegExp}\n\t * @static\n\t * @protected\n\t */\n\ts.FILE_PATTERN = /^(?:(\\w+:)\\/{2}(\\w+(?:\\.\\w+)*\\/?))?([/.]*?(?:[^?]+)?\\/)?((?:[^/?]+)\\.(\\w+))(?:\\?(\\S+)?)?$/;\n\n\n// Class Public properties\n\t/**\n\t * Determines the default behavior for interrupting other currently playing instances with the same source, if the\n\t * maximum number of instances of the sound are already playing.  Currently the default is {{#crossLink \"Sound/INTERRUPT_NONE:property\"}}{{/crossLink}}\n\t * but this can be set and will change playback behavior accordingly.  This is only used when {{#crossLink \"Sound/play\"}}{{/crossLink}}\n\t * is called without passing a value for interrupt.\n\t * @property defaultInterruptBehavior\n\t * @type {String}\n\t * @default Sound.INTERRUPT_NONE, or \"none\"\n\t * @static\n\t * @since 0.4.0\n\t */\n\ts.defaultInterruptBehavior = s.INTERRUPT_NONE;  // OJR does s.INTERRUPT_ANY make more sense as default?  Needs game dev testing to see which case makes more sense.\n\n\t/**\n\t * An array of extensions to attempt to use when loading sound, if the default is unsupported by the active plugin.\n\t * These are applied in order, so if you try to Load Thunder.ogg in a browser that does not support ogg, and your\n\t * extensions array is [\"mp3\", \"m4a\", \"wav\"] it will check mp3 support, then m4a, then wav. The audio files need\n\t * to exist in the same location, as only the extension is altered.\n\t *\n\t * Note that regardless of which file is loaded, you can call {{#crossLink \"Sound/createInstance\"}}{{/crossLink}}\n\t * and {{#crossLink \"Sound/play\"}}{{/crossLink}} using the same id or full source path passed for loading.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *\tvar sounds = [\n\t *\t\t{src:\"myPath/mySound.ogg\", id:\"example\"},\n\t *\t];\n\t *\tcreatejs.Sound.alternateExtensions = [\"mp3\"]; // now if ogg is not supported, SoundJS will try asset0.mp3\n\t *\tcreatejs.Sound.on(\"fileload\", handleLoad); // call handleLoad when each sound loads\n\t *\tcreatejs.Sound.registerSounds(sounds, assetPath);\n\t *\t// ...\n\t *\tcreatejs.Sound.play(\"myPath/mySound.ogg\"); // works regardless of what extension is supported.  Note calling with ID is a better approach\n\t *\n\t * @property alternateExtensions\n\t * @type {Array}\n\t * @since 0.5.2\n\t * @static\n\t */\n\ts.alternateExtensions = [];\n\n\t/**\n\t * The currently active plugin. If this is null, then no plugin could be initialized. If no plugin was specified,\n\t * Sound attempts to apply the default plugins: {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}, followed by\n\t * {{#crossLink \"HTMLAudioPlugin\"}}{{/crossLink}}.\n\t * @property activePlugin\n\t * @type {Object}\n\t * @static\n\t */\n    s.activePlugin = null;\n\n\n// class getter / setter properties\n\t/**\n\t * Set the master volume of Sound. The master volume is multiplied against each sound's individual volume.  For\n\t * example, if master volume is 0.5 and a sound's volume is 0.5, the resulting volume is 0.25. To set individual\n\t * sound volume, use AbstractSoundInstance {{#crossLink \"AbstractSoundInstance/volume:property\"}}{{/crossLink}} instead.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.volume = 0.5;\n\t *\n\t *\n\t * @property volume\n\t * @type {Number}\n\t * @default 1\n\t * @since 0.6.1\n\t */\n\ts._masterVolume = 1;\n\tObject.defineProperty(s, \"volume\", {\n\t\tget: function () {return this._masterVolume;},\n\t\tset: function (value) {\n\t\t\t\tif (Number(value) == null) {return false;}\n\t\t\t\tvalue = Math.max(0, Math.min(1, value));\n\t\t\t\ts._masterVolume = value;\n\t\t\t\tif (!this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(value)) {\n\t\t\t\t\tvar instances = this._instances;\n\t\t\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\t\t\tinstances[i].setMasterVolume(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t});\n\n\t/**\n\t * Mute/Unmute all audio. Note that muted audio still plays at 0 volume. This global mute value is maintained\n\t * separately and when set will override, but not change the mute property of individual instances. To mute an individual\n\t * instance, use AbstractSoundInstance {{#crossLink \"AbstractSoundInstance/muted:property\"}}{{/crossLink}} instead.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.muted = true;\n\t *\n\t *\n\t * @property muted\n\t * @type {Boolean}\n\t * @default false\n\t * @since 0.6.1\n\t */\n\ts._masterMute = false;\n\t// OJR references to the methods were not working, so the code had to be duplicated here\n\tObject.defineProperty(s, \"muted\", {\n\t\tget: function () {return this._masterMute;},\n\t\tset: function (value) {\n\t\t\t\tif (value == null) {return false;}\n\n\t\t\t\tthis._masterMute = value;\n\t\t\t\tif (!this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(value)) {\n\t\t\t\t\tvar instances = this._instances;\n\t\t\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\t\t\tinstances[i].setMasterMute(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t});\n\n\t/**\n\t * Get the active plugins capabilities, which help determine if a plugin can be used in the current environment,\n\t * or if the plugin supports a specific feature. Capabilities include:\n\t * <ul>\n\t *     <li><b>panning:</b> If the plugin can pan audio from left to right</li>\n\t *     <li><b>volume;</b> If the plugin can control audio volume.</li>\n\t *     <li><b>tracks:</b> The maximum number of audio tracks that can be played back at a time. This will be -1\n\t *     if there is no known limit.</li>\n\t * <br />An entry for each file type in {{#crossLink \"Sound/SUPPORTED_EXTENSIONS:property\"}}{{/crossLink}}:\n\t *     <li><b>mp3:</b> If MP3 audio is supported.</li>\n\t *     <li><b>ogg:</b> If OGG audio is supported.</li>\n\t *     <li><b>wav:</b> If WAV audio is supported.</li>\n\t *     <li><b>mpeg:</b> If MPEG audio is supported.</li>\n\t *     <li><b>m4a:</b> If M4A audio is supported.</li>\n\t *     <li><b>mp4:</b> If MP4 audio is supported.</li>\n\t *     <li><b>aiff:</b> If aiff audio is supported.</li>\n\t *     <li><b>wma:</b> If wma audio is supported.</li>\n\t *     <li><b>mid:</b> If mid audio is supported.</li>\n\t * </ul>\n\t *\n\t * You can get a specific capability of the active plugin using standard object notation\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var mp3 = createjs.Sound.capabilities.mp3;\n\t *\n\t * Note this property is read only.\n\t *\n\t * @property capabilities\n\t * @type {Object}\n\t * @static\n\t * @readOnly\n\t * @since 0.6.1\n\t */\n\tObject.defineProperty(s, \"capabilities\", {\n\t\tget: function () {\n\t\t\t\t\tif (s.activePlugin == null) {return null;}\n\t\t\t\t\treturn s.activePlugin._capabilities;\n\t\t\t\t},\n\t\tset: function (value) { return false;}\n\t});\n\n\n// Class Private properties\n\t/**\n\t * Determines if the plugins have been registered. If false, the first call to play() will instantiate the default\n\t * plugins ({{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}, followed by {{#crossLink \"HTMLAudioPlugin\"}}{{/crossLink}}).\n\t * If plugins have been registered, but none are applicable, then sound playback will fail.\n\t * @property _pluginsRegistered\n\t * @type {Boolean}\n\t * @default false\n\t * @static\n\t * @protected\n\t */\n\ts._pluginsRegistered = false;\n\n\t/**\n\t * Used internally to assign unique IDs to each AbstractSoundInstance.\n\t * @property _lastID\n\t * @type {Number}\n\t * @static\n\t * @protected\n\t */\n\ts._lastID = 0;\n\n\t/**\n\t * An array containing all currently playing instances. This allows Sound to control the volume, mute, and playback of\n\t * all instances when using static APIs like {{#crossLink \"Sound/stop\"}}{{/crossLink}} and {{#crossLink \"Sound/setVolume\"}}{{/crossLink}}.\n\t * When an instance has finished playback, it gets removed via the {{#crossLink \"Sound/finishedPlaying\"}}{{/crossLink}}\n\t * method. If the user replays an instance, it gets added back in via the {{#crossLink \"Sound/_beginPlaying\"}}{{/crossLink}}\n\t * method.\n\t * @property _instances\n\t * @type {Array}\n\t * @protected\n\t * @static\n\t */\n\ts._instances = [];\n\n\t/**\n\t * An object hash storing objects with sound sources, startTime, and duration via there corresponding ID.\n\t * @property _idHash\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t */\n\ts._idHash = {};\n\n\t/**\n\t * An object hash that stores preloading sound sources via the parsed source that is passed to the plugin.  Contains the\n\t * source, id, and data that was passed in by the user.  Parsed sources can contain multiple instances of source, id,\n\t * and data.\n\t * @property _preloadHash\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t */\n\ts._preloadHash = {};\n\n\t/**\n\t * An object hash storing {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}} via the parsed source that is passed as defaultPlayProps in\n\t * {{#crossLink \"Sound/registerSound\"}}{{/crossLink}} and {{#crossLink \"Sound/registerSounds\"}}{{/crossLink}}.\n\t * @property _defaultPlayPropsHash\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t * @since 0.6.1\n\t */\n\ts._defaultPlayPropsHash = {};\n\n\n// EventDispatcher methods:\n\ts.addEventListener = null;\n\ts.removeEventListener = null;\n\ts.removeAllEventListeners = null;\n\ts.dispatchEvent = null;\n\ts.hasEventListener = null;\n\ts._listeners = null;\n\n\tcreatejs.EventDispatcher.initialize(s); // inject EventDispatcher methods.\n\n\n// Events\n\t/**\n\t * This event is fired when a file finishes loading internally. This event is fired for each loaded sound,\n\t * so any handler methods should look up the <code>event.src</code> to handle a particular sound.\n\t * @event fileload\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {String} src The source of the sound that was loaded.\n\t * @param {String} [id] The id passed in when the sound was registered. If one was not provided, it will be null.\n\t * @param {Number|Object} [data] Any additional data associated with the item. If not provided, it will be undefined.\n\t * @since 0.4.1\n\t */\n\n\t/**\n\t * This event is fired when a file fails loading internally. This event is fired for each loaded sound,\n\t * so any handler methods should look up the <code>event.src</code> to handle a particular sound.\n\t * @event fileerror\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {String} src The source of the sound that was loaded.\n\t * @param {String} [id] The id passed in when the sound was registered. If one was not provided, it will be null.\n\t * @param {Number|Object} [data] Any additional data associated with the item. If not provided, it will be undefined.\n\t * @since 0.6.0\n\t */\n\n\n// Class Public Methods\n\t/**\n\t * Get the preload rules to allow Sound to be used as a plugin by <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>.\n\t * Any load calls that have the matching type or extension will fire the callback method, and use the resulting\n\t * object, which is potentially modified by Sound. This helps when determining the correct path, as well as\n\t * registering the audio instance(s) with Sound. This method should not be called, except by PreloadJS.\n\t * @method getPreloadHandlers\n\t * @return {Object} An object containing:\n\t * <ul><li>callback: A preload callback that is fired when a file is added to PreloadJS, which provides\n\t *      Sound a mechanism to modify the load parameters, select the correct file format, register the sound, etc.</li>\n\t *      <li>types: A list of file types that are supported by Sound (currently supports \"sound\").</li>\n\t *      <li>extensions: A list of file extensions that are supported by Sound (see {{#crossLink \"Sound/SUPPORTED_EXTENSIONS:property\"}}{{/crossLink}}).</li></ul>\n\t * @static\n\t * @protected\n\t */\n\ts.getPreloadHandlers = function () {\n\t\treturn {\n\t\t\tcallback:createjs.proxy(s.initLoad, s),\n\t\t\ttypes:[\"sound\"],\n\t\t\textensions:s.SUPPORTED_EXTENSIONS\n\t\t};\n\t};\n\n\t/**\n\t * Used to dispatch fileload events from internal loading.\n\t * @method _handleLoadComplete\n\t * @param event A loader event.\n\t * @protected\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts._handleLoadComplete = function(event) {\n\t\tvar src = event.target.getItem().src;\n\t\tif (!s._preloadHash[src]) {return;}\n\n\t\tfor (var i = 0, l = s._preloadHash[src].length; i < l; i++) {\n\t\t\tvar item = s._preloadHash[src][i];\n\t\t\ts._preloadHash[src][i] = true;\n\n\t\t\tif (!s.hasEventListener(\"fileload\")) { continue; }\n\n\t\t\tvar event = new createjs.Event(\"fileload\");\n\t\t\tevent.src = item.src;\n\t\t\tevent.id = item.id;\n\t\t\tevent.data = item.data;\n\t\t\tevent.sprite = item.sprite;\n\n\t\t\ts.dispatchEvent(event);\n\t\t}\n\t};\n\n\t/**\n\t * Used to dispatch error events from internal preloading.\n\t * @param event\n\t * @protected\n\t * @since 0.6.0\n\t * @static\n\t */\n\ts._handleLoadError = function(event) {\n\t\tvar src = event.target.getItem().src;\n\t\tif (!s._preloadHash[src]) {return;}\n\n\t\tfor (var i = 0, l = s._preloadHash[src].length; i < l; i++) {\n\t\t\tvar item = s._preloadHash[src][i];\n\t\t\ts._preloadHash[src][i] = false;\n\n\t\t\tif (!s.hasEventListener(\"fileerror\")) { continue; }\n\n\t\t\tvar event = new createjs.Event(\"fileerror\");\n\t\t\tevent.src = item.src;\n\t\t\tevent.id = item.id;\n\t\t\tevent.data = item.data;\n\t\t\tevent.sprite = item.sprite;\n\n\t\t\ts.dispatchEvent(event);\n\t\t}\n\t};\n\n\t/**\n\t * Used by {{#crossLink \"Sound/registerPlugins\"}}{{/crossLink}} to register a Sound plugin.\n\t *\n\t * @method _registerPlugin\n\t * @param {Object} plugin The plugin class to install.\n\t * @return {Boolean} Whether the plugin was successfully initialized.\n\t * @static\n\t * @private\n\t */\n\ts._registerPlugin = function (plugin) {\n\t\t// Note: Each plugin is passed in as a class reference, but we store the activePlugin as an instance\n\t\tif (plugin.isSupported()) {\n\t\t\ts.activePlugin = new plugin();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Register a list of Sound plugins, in order of precedence. To register a single plugin, pass a single element in the array.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.FlashAudioPlugin.swfPath = \"../src/soundjs/flashaudio/\";\n\t *      createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin, createjs.FlashAudioPlugin]);\n\t *\n\t * @method registerPlugins\n\t * @param {Array} plugins An array of plugins classes to install.\n\t * @return {Boolean} Whether a plugin was successfully initialized.\n\t * @static\n\t */\n\ts.registerPlugins = function (plugins) {\n\t\ts._pluginsRegistered = true;\n\t\tfor (var i = 0, l = plugins.length; i < l; i++) {\n\t\t\tif (s._registerPlugin(plugins[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Initialize the default plugins. This method is automatically called when any audio is played or registered before\n\t * the user has manually registered plugins, and enables Sound to work without manual plugin setup. Currently, the\n\t * default plugins are {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}} followed by {{#crossLink \"HTMLAudioPlugin\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \tif (!createjs.initializeDefaultPlugins()) { return; }\n\t *\n\t * @method initializeDefaultPlugins\n\t * @returns {Boolean} True if a plugin was initialized, false otherwise.\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.initializeDefaultPlugins = function () {\n\t\tif (s.activePlugin != null) {return true;}\n\t\tif (s._pluginsRegistered) {return false;}\n\t\tif (s.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin])) {return true;}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Determines if Sound has been initialized, and a plugin has been activated.\n\t *\n\t * <h4>Example</h4>\n\t * This example sets up a Flash fallback, but only if there is no plugin specified yet.\n\t *\n\t * \tif (!createjs.Sound.isReady()) {\n\t *\t\tcreatejs.FlashAudioPlugin.swfPath = \"../src/soundjs/flashaudio/\";\n\t * \t\tcreatejs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin, createjs.FlashAudioPlugin]);\n\t *\t}\n\t *\n\t * @method isReady\n\t * @return {Boolean} If Sound has initialized a plugin.\n\t * @static\n\t */\n\ts.isReady = function () {\n\t\treturn (s.activePlugin != null);\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/capabilities:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method getCapabilities\n\t * @return {Object} An object containing the capabilities of the active plugin.\n\t * @static\n\t * @deprecated\n\t */\n\ts.getCapabilities = function () {\n\t\tif (s.activePlugin == null) {return null;}\n\t\treturn s.activePlugin._capabilities;\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/capabilities:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method getCapability\n\t * @param {String} key The capability to retrieve\n\t * @return {Number|Boolean} The value of the capability.\n\t * @static\n\t * @see getCapabilities\n\t * @deprecated\n\t */\n\ts.getCapability = function (key) {\n\t\tif (s.activePlugin == null) {return null;}\n\t\treturn s.activePlugin._capabilities[key];\n\t};\n\n\t/**\n\t * Process manifest items from <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>. This method is intended\n\t * for usage by a plugin, and not for direct interaction.\n\t * @method initLoad\n\t * @param {Object} src The object to load.\n\t * @return {Object|AbstractLoader} An instance of AbstractLoader.\n\t * @protected\n\t * @static\n\t */\n\ts.initLoad = function (loadItem) {\n\t\treturn s._registerSound(loadItem);\n\t};\n\n\t/**\n\t * Internal method for loading sounds.  This should not be called directly.\n\t *\n\t * @method _registerSound\n\t * @param {Object} src The object to load, containing src property and optionally containing id and data.\n\t * @return {Object} An object with the modified values that were passed in, which defines the sound.\n\t * Returns false if the source cannot be parsed or no plugins can be initialized.\n\t * Returns true if the source is already loaded.\n\t * @static\n\t * @private\n\t * @since 0.6.0\n\t */\n\n\ts._registerSound = function (loadItem) {\n\t\tif (!s.initializeDefaultPlugins()) {return false;}\n\n\t\tvar details;\n\t\tif (loadItem.src instanceof Object) {\n\t\t\tdetails = s._parseSrc(loadItem.src);\n\t\t\tdetails.src = loadItem.path + details.src;\n\t\t} else {\n\t\t\tdetails = s._parsePath(loadItem.src);\n\t\t}\n\t\tif (details == null) {return false;}\n\t\tloadItem.src = details.src;\n\t\tloadItem.type = \"sound\";\n\n\t\tvar data = loadItem.data;\n\t\tvar numChannels = null;\n\t\tif (data != null) {\n\t\t\tif (!isNaN(data.channels)) {\n\t\t\t\tnumChannels = parseInt(data.channels);\n\t\t\t} else if (!isNaN(data)) {\n\t\t\t\tnumChannels = parseInt(data);\n\t\t\t}\n\n\t\t\tif(data.audioSprite) {\n\t\t\t\tvar sp;\n\t\t\t\tfor(var i = data.audioSprite.length; i--; ) {\n\t\t\t\t\tsp = data.audioSprite[i];\n\t\t\t\t\ts._idHash[sp.id] = {src: loadItem.src, startTime: parseInt(sp.startTime), duration: parseInt(sp.duration)};\n\n\t\t\t\t\tif (sp.defaultPlayProps) {\n\t\t\t\t\t\ts._defaultPlayPropsHash[sp.id] = createjs.PlayPropsConfig.create(sp.defaultPlayProps);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (loadItem.id != null) {s._idHash[loadItem.id] = {src: loadItem.src}};\n\t\tvar loader = s.activePlugin.register(loadItem);\n\n\t\tSoundChannel.create(loadItem.src, numChannels);\n\n\t\t// return the number of instances to the user.  This will also be returned in the load event.\n\t\tif (data == null || !isNaN(data)) {\n\t\t\tloadItem.data = numChannels || SoundChannel.maxPerChannel();\n\t\t} else {\n\t\t\tloadItem.data.channels = numChannels || SoundChannel.maxPerChannel();\n\t\t}\n\n\t\tif (loader.type) {loadItem.type = loader.type;}\n\n\t\tif (loadItem.defaultPlayProps) {\n\t\t\ts._defaultPlayPropsHash[loadItem.src] = createjs.PlayPropsConfig.create(loadItem.defaultPlayProps);\n\t\t}\n\t\treturn loader;\n\t};\n\n\t/**\n\t * Register an audio file for loading and future playback in Sound. This is automatically called when using\n\t * <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>.  It is recommended to register all sounds that\n\t * need to be played back in order to properly prepare and preload them. Sound does internal preloading when required.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Sound.alternateExtensions = [\"mp3\"];\n\t *      createjs.Sound.on(\"fileload\", handleLoad); // add an event listener for when load is completed\n\t *      createjs.Sound.registerSound(\"myAudioPath/mySound.ogg\", \"myID\", 3);\n\t *      createjs.Sound.registerSound({ogg:\"path1/mySound.ogg\", mp3:\"path2/mySoundNoExtension\"}, \"myID\", 3);\n\t *\n\t *\n\t * @method registerSound\n\t * @param {String | Object} src The source or an Object with a \"src\" property or an Object with multiple extension labeled src properties.\n\t * @param {String} [id] An id specified by the user to play the sound later.  Note id is required for when src is multiple extension labeled src properties.\n\t * @param {Number | Object} [data] Data associated with the item. Sound uses the data parameter as the number of\n\t * channels for an audio instance, however a \"channels\" property can be appended to the data object if it is used\n\t * for other information. The audio channels will set a default based on plugin if no value is found.\n\t * Sound also uses the data property to hold an {{#crossLink \"AudioSprite\"}}{{/crossLink}} array of objects in the following format {id, startTime, duration}.<br/>\n\t *   id used to play the sound later, in the same manner as a sound src with an id.<br/>\n\t *   startTime is the initial offset to start playback and loop from, in milliseconds.<br/>\n\t *   duration is the amount of time to play the clip for, in milliseconds.<br/>\n\t * This allows Sound to support audio sprites that are played back by id.\n\t * @param {string} basePath Set a path that will be prepended to src for loading.\n\t * @param {Object | PlayPropsConfig} defaultPlayProps Optional Playback properties that will be set as the defaults on any new AbstractSoundInstance.\n\t * See {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}} for options.\n\t * @return {Object} An object with the modified values that were passed in, which defines the sound.\n\t * Returns false if the source cannot be parsed or no plugins can be initialized.\n\t * Returns true if the source is already loaded.\n\t * @static\n\t * @since 0.4.0\n\t */\n\ts.registerSound = function (src, id, data, basePath, defaultPlayProps) {\n\t\tvar loadItem = {src: src, id: id, data:data, defaultPlayProps:defaultPlayProps};\n\t\tif (src instanceof Object && src.src) {\n\t\t\tbasePath = id;\n\t\t\tloadItem = src;\n\t\t}\n\t\tloadItem = createjs.LoadItem.create(loadItem);\n\t\tloadItem.path = basePath;\n\n\t\tif (basePath != null && !(loadItem.src instanceof Object)) {loadItem.src = basePath + src;}\n\n\t\tvar loader = s._registerSound(loadItem);\n\t\tif(!loader) {return false;}\n\n\t\tif (!s._preloadHash[loadItem.src]) { s._preloadHash[loadItem.src] = [];}\n\t\ts._preloadHash[loadItem.src].push(loadItem);\n\t\tif (s._preloadHash[loadItem.src].length == 1) {\n\t\t\t// OJR note this will disallow reloading a sound if loading fails or the source changes\n\t\t\tloader.on(\"complete\", createjs.proxy(this._handleLoadComplete, this));\n\t\t\tloader.on(\"error\", createjs.proxy(this._handleLoadError, this));\n\t\t\ts.activePlugin.preload(loader);\n\t\t} else {\n\t\t\tif (s._preloadHash[loadItem.src][0] == true) {return true;}\n\t\t}\n\n\t\treturn loadItem;\n\t};\n\n\t/**\n\t * Register an array of audio files for loading and future playback in Sound. It is recommended to register all\n\t * sounds that need to be played back in order to properly prepare and preload them. Sound does internal preloading\n\t * when required.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tvar assetPath = \"./myAudioPath/\";\n\t *      var sounds = [\n\t *          {src:\"asset0.ogg\", id:\"example\"},\n\t *          {src:\"asset1.ogg\", id:\"1\", data:6},\n\t *          {src:\"asset2.mp3\", id:\"works\"}\n\t *          {src:{mp3:\"path1/asset3.mp3\", ogg:\"path2/asset3NoExtension}, id:\"better\"}\n\t *      ];\n\t *      createjs.Sound.alternateExtensions = [\"mp3\"];\t// if the passed extension is not supported, try this extension\n\t *      createjs.Sound.on(\"fileload\", handleLoad); // call handleLoad when each sound loads\n\t *      createjs.Sound.registerSounds(sounds, assetPath);\n\t *\n\t * @method registerSounds\n\t * @param {Array} sounds An array of objects to load. Objects are expected to be in the format needed for\n\t * {{#crossLink \"Sound/registerSound\"}}{{/crossLink}}: <code>{src:srcURI, id:ID, data:Data}</code>\n\t * with \"id\" and \"data\" being optional.\n\t * You can also pass an object with path and manifest properties, where path is a basePath and manifest is an array of objects to load.\n\t * Note id is required if src is an object with extension labeled src properties.\n\t * @param {string} basePath Set a path that will be prepended to each src when loading.  When creating, playing, or removing\n\t * audio that was loaded with a basePath by src, the basePath must be included.\n\t * @return {Object} An array of objects with the modified values that were passed in, which defines each sound.\n\t * Like registerSound, it will return false for any values when the source cannot be parsed or if no plugins can be initialized.\n\t * Also, it will return true for any values when the source is already loaded.\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.registerSounds = function (sounds, basePath) {\n\t\tvar returnValues = [];\n\t\tif (sounds.path) {\n\t\t\tif (!basePath) {\n\t\t\t\tbasePath = sounds.path;\n\t\t\t} else {\n\t\t\t\tbasePath = basePath + sounds.path;\n\t\t\t}\n\t\t\tsounds = sounds.manifest;\n\t\t\t// TODO document this feature\n\t\t}\n\t\tfor (var i = 0, l = sounds.length; i < l; i++) {\n\t\t\treturnValues[i] = createjs.Sound.registerSound(sounds[i].src, sounds[i].id, sounds[i].data, basePath, sounds[i].defaultPlayProps);\n\t\t}\n\t\treturn returnValues;\n\t};\n\n\t/**\n\t * Remove a sound that has been registered with {{#crossLink \"Sound/registerSound\"}}{{/crossLink}} or\n\t * {{#crossLink \"Sound/registerSounds\"}}{{/crossLink}}.\n\t * <br />Note this will stop playback on active instances playing this sound before deleting them.\n\t * <br />Note if you passed in a basePath, you need to pass it or prepend it to the src here.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Sound.removeSound(\"myID\");\n\t *      createjs.Sound.removeSound(\"myAudioBasePath/mySound.ogg\");\n\t *      createjs.Sound.removeSound(\"myPath/myOtherSound.mp3\", \"myBasePath/\");\n\t *      createjs.Sound.removeSound({mp3:\"musicNoExtension\", ogg:\"music.ogg\"}, \"myBasePath/\");\n\t *\n\t * @method removeSound\n\t * @param {String | Object} src The src or ID of the audio, or an Object with a \"src\" property, or an Object with multiple extension labeled src properties.\n\t * @param {string} basePath Set a path that will be prepended to each src when removing.\n\t * @return {Boolean} True if sound is successfully removed.\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.removeSound = function(src, basePath) {\n\t\tif (s.activePlugin == null) {return false;}\n\n\t\tif (src instanceof Object && src.src) {src = src.src;}\n\n\t\tvar details;\n\t\tif (src instanceof Object) {\n\t\t\tdetails = s._parseSrc(src);\n\t\t} else {\n\t\t\tsrc = s._getSrcById(src).src;\n\t\t\tdetails = s._parsePath(src);\n\t\t}\n\t\tif (details == null) {return false;}\n\t\tsrc = details.src;\n\t\tif (basePath != null) {src = basePath + src;}\n\n\t\tfor(var prop in s._idHash){\n\t\t\tif(s._idHash[prop].src == src) {\n\t\t\t\tdelete(s._idHash[prop]);\n\t\t\t}\n\t\t}\n\n\t\t// clear from SoundChannel, which also stops and deletes all instances\n\t\tSoundChannel.removeSrc(src);\n\n\t\tdelete(s._preloadHash[src]);\n\n\t\ts.activePlugin.removeSound(src);\n\n\t\treturn true;\n\t};\n\n\t/**\n\t * Remove an array of audio files that have been registered with {{#crossLink \"Sound/registerSound\"}}{{/crossLink}} or\n\t * {{#crossLink \"Sound/registerSounds\"}}{{/crossLink}}.\n\t * <br />Note this will stop playback on active instances playing this audio before deleting them.\n\t * <br />Note if you passed in a basePath, you need to pass it or prepend it to the src here.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tassetPath = \"./myPath/\";\n\t *      var sounds = [\n\t *          {src:\"asset0.ogg\", id:\"example\"},\n\t *          {src:\"asset1.ogg\", id:\"1\", data:6},\n\t *          {src:\"asset2.mp3\", id:\"works\"}\n\t *      ];\n\t *      createjs.Sound.removeSounds(sounds, assetPath);\n\t *\n\t * @method removeSounds\n\t * @param {Array} sounds An array of objects to remove. Objects are expected to be in the format needed for\n\t * {{#crossLink \"Sound/removeSound\"}}{{/crossLink}}: <code>{srcOrID:srcURIorID}</code>.\n\t * You can also pass an object with path and manifest properties, where path is a basePath and manifest is an array of objects to remove.\n\t * @param {string} basePath Set a path that will be prepended to each src when removing.\n\t * @return {Object} An array of Boolean values representing if the sounds with the same array index were\n\t * successfully removed.\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.removeSounds = function (sounds, basePath) {\n\t\tvar returnValues = [];\n\t\tif (sounds.path) {\n\t\t\tif (!basePath) {\n\t\t\t\tbasePath = sounds.path;\n\t\t\t} else {\n\t\t\t\tbasePath = basePath + sounds.path;\n\t\t\t}\n\t\t\tsounds = sounds.manifest;\n\t\t}\n\t\tfor (var i = 0, l = sounds.length; i < l; i++) {\n\t\t\treturnValues[i] = createjs.Sound.removeSound(sounds[i].src, basePath);\n\t\t}\n\t\treturn returnValues;\n\t};\n\n\t/**\n\t * Remove all sounds that have been registered with {{#crossLink \"Sound/registerSound\"}}{{/crossLink}} or\n\t * {{#crossLink \"Sound/registerSounds\"}}{{/crossLink}}.\n\t * <br />Note this will stop playback on all active sound instances before deleting them.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.removeAllSounds();\n\t *\n\t * @method removeAllSounds\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.removeAllSounds = function() {\n\t\ts._idHash = {};\n\t\ts._preloadHash = {};\n\t\tSoundChannel.removeAll();\n\t\tif (s.activePlugin) {s.activePlugin.removeAllSounds();}\n\t};\n\n\t/**\n\t * Check if a source has been loaded by internal preloaders. This is necessary to ensure that sounds that are\n\t * not completed preloading will not kick off a new internal preload if they are played.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     var mySound = \"assetPath/asset0.ogg\";\n\t *     if(createjs.Sound.loadComplete(mySound) {\n\t *         createjs.Sound.play(mySound);\n\t *     }\n\t *\n\t * @method loadComplete\n\t * @param {String} src The src or id that is being loaded.\n\t * @return {Boolean} If the src is already loaded.\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.loadComplete = function (src) {\n\t\tif (!s.isReady()) { return false; }\n\t\tvar details = s._parsePath(src);\n\t\tif (details) {\n\t\t\tsrc = s._getSrcById(details.src).src;\n\t\t} else {\n\t\t\tsrc = s._getSrcById(src).src;\n\t\t}\n\t\tif(s._preloadHash[src] == undefined) {return false;}\n\t\treturn (s._preloadHash[src][0] == true);  // src only loads once, so if it's true for the first it's true for all\n\t};\n\n\t/**\n\t * Parse the path of a sound. Alternate extensions will be attempted in order if the\n\t * current extension is not supported\n\t * @method _parsePath\n\t * @param {String} value The path to an audio source.\n\t * @return {Object} A formatted object that can be registered with the {{#crossLink \"Sound/activePlugin:property\"}}{{/crossLink}}\n\t * and returned to a preloader like <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>.\n\t * @protected\n\t * @static\n\t */\n\ts._parsePath = function (value) {\n\t\tif (typeof(value) != \"string\") {value = value.toString();}\n\n\t\tvar match = value.match(s.FILE_PATTERN);\n\t\tif (match == null) {return false;}\n\n\t\tvar name = match[4];\n\t\tvar ext = match[5];\n\t\tvar c = s.capabilities;\n\t\tvar i = 0;\n\t\twhile (!c[ext]) {\n\t\t\text = s.alternateExtensions[i++];\n\t\t\tif (i > s.alternateExtensions.length) { return null;}\t// no extensions are supported\n\t\t}\n\t\tvalue = value.replace(\".\"+match[5], \".\"+ext);\n\n\t\tvar ret = {name:name, src:value, extension:ext};\n\t\treturn ret;\n\t};\n\n\t/**\n\t * Parse the path of a sound based on properties of src matching with supported extensions.\n\t * Returns false if none of the properties are supported\n\t * @method _parseSrc\n\t * @param {Object} value The paths to an audio source, indexed by extension type.\n\t * @return {Object} A formatted object that can be registered with the {{#crossLink \"Sound/activePlugin:property\"}}{{/crossLink}}\n\t * and returned to a preloader like <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>.\n\t * @protected\n\t * @static\n\t */\n\ts._parseSrc = function (value) {\n\t\tvar ret = {name:undefined, src:undefined, extension:undefined};\n\t\tvar c = s.capabilities;\n\n\t\tfor (var prop in value) {\n\t\t  if(value.hasOwnProperty(prop) && c[prop]) {\n\t\t\t\tret.src = value[prop];\n\t\t\t\tret.extension = prop;\n\t\t\t\tbreak;\n\t\t  }\n\t\t}\n\t\tif (!ret.src) {return false;}\t// no matches\n\n\t\tvar i = ret.src.lastIndexOf(\"/\");\n\t\tif (i != -1) {\n\t\t\tret.name = ret.src.slice(i+1);\n\t\t} else {\n\t\t\tret.name = ret.src;\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\t/* ---------------\n\t Static API.\n\t --------------- */\n\t/**\n\t * Play a sound and get a {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} to control. If the sound fails to play, a\n\t * AbstractSoundInstance will still be returned, and have a playState of {{#crossLink \"Sound/PLAY_FAILED:property\"}}{{/crossLink}}.\n\t * Note that even on sounds with failed playback, you may still be able to call AbstractSoundInstance {{#crossLink \"AbstractSoundInstance/play\"}}{{/crossLink}},\n\t * since the failure could be due to lack of available channels. If the src does not have a supported extension or\n\t * if there is no available plugin, a default AbstractSoundInstance will be returned which will not play any audio, but will not generate errors.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Sound.on(\"fileload\", handleLoad);\n\t *      createjs.Sound.registerSound(\"myAudioPath/mySound.mp3\", \"myID\", 3);\n\t *      function handleLoad(event) {\n\t *      \tcreatejs.Sound.play(\"myID\");\n\t *      \t// store off AbstractSoundInstance for controlling\n\t *      \tvar myInstance = createjs.Sound.play(\"myID\", {interrupt: createjs.Sound.INTERRUPT_ANY, loop:-1});\n\t *      }\n\t *\n\t * NOTE to create an audio sprite that has not already been registered, both startTime and duration need to be set.\n\t * This is only when creating a new audio sprite, not when playing using the id of an already registered audio sprite.\n\t *\n\t * <b>Parameters Deprecated</b><br />\n\t * The parameters for this method are deprecated in favor of a single parameter that is an Object or {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}}.\n\t *\n\t * @method play\n\t * @param {String} src The src or ID of the audio.\n\t * @param {String | Object} [interrupt=\"none\"|options] <b>This parameter will be renamed playProps in the next release.</b><br />\n\t * This parameter can be an instance of {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}} or an Object that contains any or all optional properties by name,\n\t * including: interrupt, delay, offset, loop, volume, pan, startTime, and duration (see the above code sample).\n\t * <br /><strong>OR</strong><br />\n\t * <b>Deprecated</b> How to interrupt any currently playing instances of audio with the same source,\n\t * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\n\t * constants on the Sound class, with the default defined by {{#crossLink \"Sound/defaultInterruptBehavior:property\"}}{{/crossLink}}.\n\t * @param {Number} [delay=0] <b>Deprecated</b> The amount of time to delay the start of audio playback, in milliseconds.\n\t * @param {Number} [offset=0] <b>Deprecated</b> The offset from the start of the audio to begin playback, in milliseconds.\n\t * @param {Number} [loop=0] <b>Deprecated</b> How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t * loops), and -1 can be used for infinite playback.\n\t * @param {Number} [volume=1] <b>Deprecated</b> The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t * against the individual volume.\n\t * @param {Number} [pan=0] <b>Deprecated</b> The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\n\t * @param {Number} [startTime=null] <b>Deprecated</b> To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\n\t * @param {Number} [duration=null] <b>Deprecated</b> To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\n\t * @return {AbstractSoundInstance} A {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} that can be controlled after it is created.\n\t * @static\n\t */\n\ts.play = function (src, interrupt, delay, offset, loop, volume, pan, startTime, duration) {\n\t\tvar playProps;\n\t\tif (interrupt instanceof Object || interrupt instanceof createjs.PlayPropsConfig) {\n\t\t\tplayProps = createjs.PlayPropsConfig.create(interrupt);\n\t\t} else {\n\t\t\tplayProps = createjs.PlayPropsConfig.create({interrupt:interrupt, delay:delay, offset:offset, loop:loop, volume:volume, pan:pan, startTime:startTime, duration:duration});\n\t\t}\n\t\tvar instance = s.createInstance(src, playProps.startTime, playProps.duration);\n\t\tvar ok = s._playInstance(instance, playProps);\n\t\tif (!ok) {instance._playFailed();}\n\t\treturn instance;\n\t};\n\n\t/**\n\t * Creates a {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} using the passed in src. If the src does not have a\n\t * supported extension or if there is no available plugin, a default AbstractSoundInstance will be returned that can be\n\t * called safely but does nothing.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var myInstance = null;\n\t *      createjs.Sound.on(\"fileload\", handleLoad);\n\t *      createjs.Sound.registerSound(\"myAudioPath/mySound.mp3\", \"myID\", 3);\n\t *      function handleLoad(event) {\n\t *      \tmyInstance = createjs.Sound.createInstance(\"myID\");\n\t *      \t// alternately we could call the following\n\t *      \tmyInstance = createjs.Sound.createInstance(\"myAudioPath/mySound.mp3\");\n\t *      }\n\t *\n\t * NOTE to create an audio sprite that has not already been registered, both startTime and duration need to be set.\n\t * This is only when creating a new audio sprite, not when playing using the id of an already registered audio sprite.\n\t *\n\t * @method createInstance\n\t * @param {String} src The src or ID of the audio.\n\t * @param {Number} [startTime=null] To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\n\t * @param {Number} [duration=null] To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\n\t * @return {AbstractSoundInstance} A {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} that can be controlled after it is created.\n\t * Unsupported extensions will return the default AbstractSoundInstance.\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.createInstance = function (src, startTime, duration) {\n\t\tif (!s.initializeDefaultPlugins()) {return new createjs.DefaultSoundInstance(src, startTime, duration);}\n\n\t\tvar defaultPlayProps = s._defaultPlayPropsHash[src];\t// for audio sprites, which create and store defaults by id\n\t\tsrc = s._getSrcById(src);\n\n\t\tvar details = s._parsePath(src.src);\n\n\t\tvar instance = null;\n\t\tif (details != null && details.src != null) {\n\t\t\tSoundChannel.create(details.src);\n\t\t\tif (startTime == null) {startTime = src.startTime;}\n\t\t\tinstance = s.activePlugin.create(details.src, startTime, duration || src.duration);\n\n\t\t\tdefaultPlayProps = defaultPlayProps || s._defaultPlayPropsHash[details.src];\n\t\t\tif(defaultPlayProps) {\n\t\t\t\tinstance.applyPlayProps(defaultPlayProps);\n\t\t\t}\n\t\t} else {\n\t\t\tinstance = new createjs.DefaultSoundInstance(src, startTime, duration);\n\t\t}\n\n\t\tinstance.uniqueId = s._lastID++;\n\n\t\treturn instance;\n\t};\n\n\t/**\n\t * Stop all audio (global stop). Stopped audio is reset, and not paused. To play audio that has been stopped,\n\t * call AbstractSoundInstance {{#crossLink \"AbstractSoundInstance/play\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.stop();\n\t *\n\t * @method stop\n\t * @static\n\t */\n\ts.stop = function () {\n\t\tvar instances = this._instances;\n\t\tfor (var i = instances.length; i--; ) {\n\t\t\tinstances[i].stop();  // NOTE stop removes instance from this._instances\n\t\t}\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/volume:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method setVolume\n\t * @param {Number} value The master volume value. The acceptable range is 0-1.\n\t * @static\n\t * @deprecated\n\t */\n\ts.setVolume = function (value) {\n\t\tif (Number(value) == null) {return false;}\n\t\tvalue = Math.max(0, Math.min(1, value));\n\t\ts._masterVolume = value;\n\t\tif (!this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(value)) {\n\t\t\tvar instances = this._instances;\n\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\tinstances[i].setMasterVolume(value);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/volume:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method getVolume\n\t * @return {Number} The master volume, in a range of 0-1.\n\t * @static\n\t * @deprecated\n\t */\n\ts.getVolume = function () {\n\t\treturn this._masterVolume;\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/muted:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method setMute\n\t * @param {Boolean} value Whether the audio should be muted or not.\n\t * @return {Boolean} If the mute was set.\n\t * @static\n\t * @since 0.4.0\n\t * @deprecated\n\t */\n\ts.setMute = function (value) {\n\t\tif (value == null) {return false;}\n\n\t\tthis._masterMute = value;\n\t\tif (!this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(value)) {\n\t\t\tvar instances = this._instances;\n\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\tinstances[i].setMasterMute(value);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/muted:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method getMute\n\t * @return {Boolean} The mute value of Sound.\n\t * @static\n\t * @since 0.4.0\n\t * @deprecated\n\t */\n\ts.getMute = function () {\n\t\treturn this._masterMute;\n\t};\n\n\t/**\n\t * Set the default playback properties for all new SoundInstances of the passed in src or ID.\n\t * See {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}} for available properties.\n\t *\n\t * @method setDefaultPlayProps\n\t * @param {String} src The src or ID used to register the audio.\n\t * @param {Object | PlayPropsConfig} playProps The playback properties you would like to set.\n\t * @since 0.6.1\n\t */\n\ts.setDefaultPlayProps = function(src, playProps) {\n\t\tsrc = s._getSrcById(src);\n\t\ts._defaultPlayPropsHash[s._parsePath(src.src).src] = createjs.PlayPropsConfig.create(playProps);\n\t};\n\n\t/**\n\t * Get the default playback properties for the passed in src or ID.  These properties are applied to all\n\t * new SoundInstances.  Returns null if default does not exist.\n\t *\n\t * @method getDefaultPlayProps\n\t * @param {String} src The src or ID used to register the audio.\n\t * @returns {PlayPropsConfig} returns an existing PlayPropsConfig or null if one does not exist\n\t * @since 0.6.1\n\t */\n\ts.getDefaultPlayProps = function(src) {\n\t\tsrc = s._getSrcById(src);\n\t\treturn s._defaultPlayPropsHash[s._parsePath(src.src).src];\n\t};\n\n\n\t/* ---------------\n\t Internal methods\n\t --------------- */\n\t/**\n\t * Play an instance. This is called by the static API, as well as from plugins. This allows the core class to\n\t * control delays.\n\t * @method _playInstance\n\t * @param {AbstractSoundInstance} instance The {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} to start playing.\n\t * @param {PlayPropsConfig} playProps A PlayPropsConfig object.\n\t * @return {Boolean} If the sound can start playing. Sounds that fail immediately will return false. Sounds that\n\t * have a delay will return true, but may still fail to play.\n\t * @protected\n\t * @static\n\t */\n\ts._playInstance = function (instance, playProps) {\n\t\tvar defaultPlayProps = s._defaultPlayPropsHash[instance.src] || {};\n\t\tif (playProps.interrupt == null) {playProps.interrupt = defaultPlayProps.interrupt || s.defaultInterruptBehavior};\n\t\tif (playProps.delay == null) {playProps.delay = defaultPlayProps.delay || 0;}\n\t\tif (playProps.offset == null) {playProps.offset = instance.getPosition();}\n\t\tif (playProps.loop == null) {playProps.loop = instance.loop;}\n\t\tif (playProps.volume == null) {playProps.volume = instance.volume;}\n\t\tif (playProps.pan == null) {playProps.pan = instance.pan;}\n\n\t\tif (playProps.delay == 0) {\n\t\t\tvar ok = s._beginPlaying(instance, playProps);\n\t\t\tif (!ok) {return false;}\n\t\t} else {\n\t\t\t//Note that we can't pass arguments to proxy OR setTimeout (IE only), so just wrap the function call.\n\t\t\t// OJR WebAudio may want to handle this differently, so it might make sense to move this functionality into the plugins in the future\n\t\t\tvar delayTimeoutId = setTimeout(function () {\n\t\t\t\ts._beginPlaying(instance, playProps);\n\t\t\t}, playProps.delay);\n\t\t\tinstance.delayTimeoutId = delayTimeoutId;\n\t\t}\n\n\t\tthis._instances.push(instance);\n\n\t\treturn true;\n\t};\n\n\t/**\n\t * Begin playback. This is called immediately or after delay by {{#crossLink \"Sound/playInstance\"}}{{/crossLink}}.\n\t * @method _beginPlaying\n\t * @param {AbstractSoundInstance} instance A {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} to begin playback.\n\t * @param {PlayPropsConfig} playProps A PlayPropsConfig object.\n\t * @return {Boolean} If the sound can start playing. If there are no available channels, or the instance fails to\n\t * start, this will return false.\n\t * @protected\n\t * @static\n\t */\n\ts._beginPlaying = function (instance, playProps) {\n\t\tif (!SoundChannel.add(instance, playProps.interrupt)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar result = instance._beginPlaying(playProps);\n\t\tif (!result) {\n\t\t\tvar index = createjs.indexOf(this._instances, instance);\n\t\t\tif (index > -1) {this._instances.splice(index, 1);}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t * Get the source of a sound via the ID passed in with a register call. If no ID is found the value is returned\n\t * instead.\n\t * @method _getSrcById\n\t * @param {String} value The ID the sound was registered with.\n\t * @return {String} The source of the sound if it has been registered with this ID or the value that was passed in.\n\t * @protected\n\t * @static\n\t */\n\ts._getSrcById = function (value) {\n\t\treturn s._idHash[value] || {src: value};\n\t};\n\n\t/**\n\t * A sound has completed playback, been interrupted, failed, or been stopped. This method removes the instance from\n\t * Sound management. It will be added again, if the sound re-plays. Note that this method is called from the\n\t * instances themselves.\n\t * @method _playFinished\n\t * @param {AbstractSoundInstance} instance The instance that finished playback.\n\t * @protected\n\t * @static\n\t */\n\ts._playFinished = function (instance) {\n\t\tSoundChannel.remove(instance);\n\t\tvar index = createjs.indexOf(this._instances, instance);\n\t\tif (index > -1) {this._instances.splice(index, 1);}\t// OJR this will always be > -1, there is no way for an instance to exist without being added to this._instances\n\t};\n\n\tcreatejs.Sound = Sound;\n\n\t/**\n\t * An internal class that manages the number of active {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} instances for\n\t * each sound type. This method is only used internally by the {{#crossLink \"Sound\"}}{{/crossLink}} class.\n\t *\n\t * The number of sounds is artificially limited by Sound in order to prevent over-saturation of a\n\t * single sound, as well as to stay within hardware limitations, although the latter may disappear with better\n\t * browser support.\n\t *\n\t * When a sound is played, this class ensures that there is an available instance, or interrupts an appropriate\n\t * sound that is already playing.\n\t * #class SoundChannel\n\t * @param {String} src The source of the instances\n\t * @param {Number} [max=1] The number of instances allowed\n\t * @constructor\n\t * @protected\n\t */\n\tfunction SoundChannel(src, max) {\n\t\tthis.init(src, max);\n\t}\n\n\t/* ------------\n\t Static API\n\t ------------ */\n\t/**\n\t * A hash of channel instances indexed by source.\n\t * #property channels\n\t * @type {Object}\n\t * @static\n\t */\n\tSoundChannel.channels = {};\n\n\t/**\n\t * Create a sound channel. Note that if the sound channel already exists, this will fail.\n\t * #method create\n\t * @param {String} src The source for the channel\n\t * @param {Number} max The maximum amount this channel holds. The default is {{#crossLink \"SoundChannel.maxDefault\"}}{{/crossLink}}.\n\t * @return {Boolean} If the channels were created.\n\t * @static\n\t */\n\tSoundChannel.create = function (src, max) {\n\t\tvar channel = SoundChannel.get(src);\n\t\tif (channel == null) {\n\t\t\tSoundChannel.channels[src] = new SoundChannel(src, max);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\t/**\n\t * Delete a sound channel, stop and delete all related instances. Note that if the sound channel does not exist, this will fail.\n\t * #method remove\n\t * @param {String} src The source for the channel\n\t * @return {Boolean} If the channels were deleted.\n\t * @static\n\t */\n\tSoundChannel.removeSrc = function (src) {\n\t\tvar channel = SoundChannel.get(src);\n\t\tif (channel == null) {return false;}\n\t\tchannel._removeAll();\t// this stops and removes all active instances\n\t\tdelete(SoundChannel.channels[src]);\n\t\treturn true;\n\t};\n\t/**\n\t * Delete all sound channels, stop and delete all related instances.\n\t * #method removeAll\n\t * @static\n\t */\n\tSoundChannel.removeAll = function () {\n\t\tfor(var channel in SoundChannel.channels) {\n\t\t\tSoundChannel.channels[channel]._removeAll();\t// this stops and removes all active instances\n\t\t}\n\t\tSoundChannel.channels = {};\n\t};\n\t/**\n\t * Add an instance to a sound channel.\n\t * #method add\n\t * @param {AbstractSoundInstance} instance The instance to add to the channel\n\t * @param {String} interrupt The interrupt value to use. Please see the {{#crossLink \"Sound/play\"}}{{/crossLink}}\n\t * for details on interrupt modes.\n\t * @return {Boolean} The success of the method call. If the channel is full, it will return false.\n\t * @static\n\t */\n\tSoundChannel.add = function (instance, interrupt) {\n\t\tvar channel = SoundChannel.get(instance.src);\n\t\tif (channel == null) {return false;}\n\t\treturn channel._add(instance, interrupt);\n\t};\n\t/**\n\t * Remove an instance from the channel.\n\t * #method remove\n\t * @param {AbstractSoundInstance} instance The instance to remove from the channel\n\t * @return The success of the method call. If there is no channel, it will return false.\n\t * @static\n\t */\n\tSoundChannel.remove = function (instance) {\n\t\tvar channel = SoundChannel.get(instance.src);\n\t\tif (channel == null) {return false;}\n\t\tchannel._remove(instance);\n\t\treturn true;\n\t};\n\t/**\n\t * Get the maximum number of sounds you can have in a channel.\n\t * #method maxPerChannel\n\t * @return {Number} The maximum number of sounds you can have in a channel.\n\t */\n\tSoundChannel.maxPerChannel = function () {\n\t\treturn p.maxDefault;\n\t};\n\t/**\n\t * Get a channel instance by its src.\n\t * #method get\n\t * @param {String} src The src to use to look up the channel\n\t * @static\n\t */\n\tSoundChannel.get = function (src) {\n\t\treturn SoundChannel.channels[src];\n\t};\n\n\tvar p = SoundChannel.prototype;\n\tp.constructor = SoundChannel;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n\t/**\n\t * The source of the channel.\n\t * #property src\n\t * @type {String}\n\t */\n\tp.src = null;\n\n\t/**\n\t * The maximum number of instances in this channel.  -1 indicates no limit\n\t * #property max\n\t * @type {Number}\n\t */\n\tp.max = null;\n\n\t/**\n\t * The default value to set for max, if it isn't passed in.  Also used if -1 is passed.\n\t * #property maxDefault\n\t * @type {Number}\n\t * @default 100\n\t * @since 0.4.0\n\t */\n\tp.maxDefault = 100;\n\n\t/**\n\t * The current number of active instances.\n\t * #property length\n\t * @type {Number}\n\t */\n\tp.length = 0;\n\n\t/**\n\t * Initialize the channel.\n\t * #method init\n\t * @param {String} src The source of the channel\n\t * @param {Number} max The maximum number of instances in the channel\n\t * @protected\n\t */\n\tp.init = function (src, max) {\n\t\tthis.src = src;\n\t\tthis.max = max || this.maxDefault;\n\t\tif (this.max == -1) {this.max = this.maxDefault;}\n\t\tthis._instances = [];\n\t};\n\n\t/**\n\t * Get an instance by index.\n\t * #method get\n\t * @param {Number} index The index to return.\n\t * @return {AbstractSoundInstance} The AbstractSoundInstance at a specific instance.\n\t */\n\tp._get = function (index) {\n\t\treturn this._instances[index];\n\t};\n\n\t/**\n\t * Add a new instance to the channel.\n\t * #method add\n\t * @param {AbstractSoundInstance} instance The instance to add.\n\t * @return {Boolean} The success of the method call. If the channel is full, it will return false.\n\t */\n\tp._add = function (instance, interrupt) {\n\t\tif (!this._getSlot(interrupt, instance)) {return false;}\n\t\tthis._instances.push(instance);\n\t\tthis.length++;\n\t\treturn true;\n\t};\n\n\t/**\n\t * Remove an instance from the channel, either when it has finished playing, or it has been interrupted.\n\t * #method remove\n\t * @param {AbstractSoundInstance} instance The instance to remove\n\t * @return {Boolean} The success of the remove call. If the instance is not found in this channel, it will\n\t * return false.\n\t */\n\tp._remove = function (instance) {\n\t\tvar index = createjs.indexOf(this._instances, instance);\n\t\tif (index == -1) {return false;}\n\t\tthis._instances.splice(index, 1);\n\t\tthis.length--;\n\t\treturn true;\n\t};\n\n\t/**\n\t * Stop playback and remove all instances from the channel.  Usually in response to a delete call.\n\t * #method removeAll\n\t */\n\tp._removeAll = function () {\n\t\t// Note that stop() removes the item from the list\n\t\tfor (var i=this.length-1; i>=0; i--) {\n\t\t\tthis._instances[i].stop();\n\t\t}\n\t};\n\n\t/**\n\t * Get an available slot depending on interrupt value and if slots are available.\n\t * #method getSlot\n\t * @param {String} interrupt The interrupt value to use.\n\t * @param {AbstractSoundInstance} instance The sound instance that will go in the channel if successful.\n\t * @return {Boolean} Determines if there is an available slot. Depending on the interrupt mode, if there are no slots,\n\t * an existing AbstractSoundInstance may be interrupted. If there are no slots, this method returns false.\n\t */\n\tp._getSlot = function (interrupt, instance) {\n\t\tvar target, replacement;\n\n\t\tif (interrupt != Sound.INTERRUPT_NONE) {\n\t\t\t// First replacement candidate\n\t\t\treplacement = this._get(0);\n\t\t\tif (replacement == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = this.max; i < l; i++) {\n\t\t\ttarget = this._get(i);\n\n\t\t\t// Available Space\n\t\t\tif (target == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Audio is complete or not playing\n\t\t\tif (target.playState == Sound.PLAY_FINISHED ||\n\t\t\t\ttarget.playState == Sound.PLAY_INTERRUPTED ||\n\t\t\t\ttarget.playState == Sound.PLAY_FAILED) {\n\t\t\t\treplacement = target;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (interrupt == Sound.INTERRUPT_NONE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Audio is a better candidate than the current target, according to playhead\n\t\t\tif ((interrupt == Sound.INTERRUPT_EARLY && target.getPosition() < replacement.getPosition()) ||\n\t\t\t\t(interrupt == Sound.INTERRUPT_LATE && target.getPosition() > replacement.getPosition())) {\n\t\t\t\t\treplacement = target;\n\t\t\t}\n\t\t}\n\n\t\tif (replacement != null) {\n\t\t\treplacement._interrupt();\n\t\t\tthis._remove(replacement);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[Sound SoundChannel]\";\n\t};\n\t// do not add SoundChannel to namespace\n\n}());\n\n//##############################################################################\n// AbstractSoundInstance.js\n//##############################################################################\n\n/**\n * A AbstractSoundInstance is created when any calls to the Sound API method {{#crossLink \"Sound/play\"}}{{/crossLink}} or\n * {{#crossLink \"Sound/createInstance\"}}{{/crossLink}} are made. The AbstractSoundInstance is returned by the active plugin\n * for control by the user.\n *\n * <h4>Example</h4>\n *\n *      var myInstance = createjs.Sound.play(\"myAssetPath/mySrcFile.mp3\");\n *\n * A number of additional parameters provide a quick way to determine how a sound is played. Please see the Sound\n * API method {{#crossLink \"Sound/play\"}}{{/crossLink}} for a list of arguments.\n *\n * Once a AbstractSoundInstance is created, a reference can be stored that can be used to control the audio directly through\n * the AbstractSoundInstance. If the reference is not stored, the AbstractSoundInstance will play out its audio (and any loops), and\n * is then de-referenced from the {{#crossLink \"Sound\"}}{{/crossLink}} class so that it can be cleaned up. If audio\n * playback has completed, a simple call to the {{#crossLink \"AbstractSoundInstance/play\"}}{{/crossLink}} instance method\n * will rebuild the references the Sound class need to control it.\n *\n *      var myInstance = createjs.Sound.play(\"myAssetPath/mySrcFile.mp3\", {loop:2});\n *      myInstance.on(\"loop\", handleLoop);\n *      function handleLoop(event) {\n *          myInstance.volume = myInstance.volume * 0.5;\n *      }\n *\n * Events are dispatched from the instance to notify when the sound has completed, looped, or when playback fails\n *\n *      var myInstance = createjs.Sound.play(\"myAssetPath/mySrcFile.mp3\");\n *      myInstance.on(\"complete\", handleComplete);\n *      myInstance.on(\"loop\", handleLoop);\n *      myInstance.on(\"failed\", handleFailed);\n *\n *\n * @class AbstractSoundInstance\n * @param {String} src The path to and file name of the sound.\n * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\n * @extends EventDispatcher\n * @constructor\n */\n\n(function () {\n\t\"use strict\";\n\n\n// Constructor:\n\tvar AbstractSoundInstance = function (src, startTime, duration, playbackResource) {\n\t\tthis.EventDispatcher_constructor();\n\n\n\t// public properties:\n\t\t/**\n\t\t * The source of the sound.\n\t\t * @property src\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.src = src;\n\n\t\t/**\n\t\t * The unique ID of the instance. This is set by {{#crossLink \"Sound\"}}{{/crossLink}}.\n\t\t * @property uniqueId\n\t\t * @type {String} | Number\n\t\t * @default -1\n\t\t */\n\t\tthis.uniqueId = -1;\n\n\t\t/**\n\t\t * The play state of the sound. Play states are defined as constants on {{#crossLink \"Sound\"}}{{/crossLink}}.\n\t\t * @property playState\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.playState = null;\n\n\t\t/**\n\t\t * A Timeout created by {{#crossLink \"Sound\"}}{{/crossLink}} when this AbstractSoundInstance is played with a delay.\n\t\t * This allows AbstractSoundInstance to remove the delay if stop, pause, or cleanup are called before playback begins.\n\t\t * @property delayTimeoutId\n\t\t * @type {timeoutVariable}\n\t\t * @default null\n\t\t * @protected\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis.delayTimeoutId = null;\n\t\t// TODO consider moving delay into AbstractSoundInstance so it can be handled by plugins\n\n\n\t// private properties\n\t// Getter / Setter Properties\n\t\t// OJR TODO find original reason that we didn't use defined functions.  I think it was performance related\n\t\t/**\n\t\t * The volume of the sound, between 0 and 1.\n\t\t *\n\t\t * The actual output volume of a sound can be calculated using:\n\t\t * <code>myInstance.volume * createjs.Sound.getVolume();</code>\n\t\t *\n\t\t * @property volume\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._volume =  1;\n\t\tObject.defineProperty(this, \"volume\", {\n\t\t\tget: this.getVolume,\n\t\t\tset: this.setVolume\n\t\t});\n\n\t\t/**\n\t\t * The pan of the sound, between -1 (left) and 1 (right). Note that pan is not supported by HTML Audio.\n\t\t *\n\t\t * <br />Note in WebAudioPlugin this only gives us the \"x\" value of what is actually 3D audio.\n\t\t *\n\t\t * @property pan\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._pan =  0;\n\t\tObject.defineProperty(this, \"pan\", {\n\t\t\tget: this.getPan,\n\t\t\tset: this.setPan\n\t\t});\n\n\t\t/**\n\t\t * Audio sprite property used to determine the starting offset.\n\t\t * @property startTime\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @since 0.6.1\n\t\t */\n\t\tthis._startTime = Math.max(0, startTime || 0);\n\t\tObject.defineProperty(this, \"startTime\", {\n\t\t\tget: this.getStartTime,\n\t\t\tset: this.setStartTime\n\t\t});\n\n\t\t/**\n\t\t * Sets or gets the length of the audio clip, value is in milliseconds.\n\t\t *\n\t\t * @property duration\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._duration = Math.max(0, duration || 0);\n\t\tObject.defineProperty(this, \"duration\", {\n\t\t\tget: this.getDuration,\n\t\t\tset: this.setDuration\n\t\t});\n\n\t\t/**\n\t\t * Object that holds plugin specific resource need for audio playback.\n\t\t * This is set internally by the plugin.  For example, WebAudioPlugin will set an array buffer,\n\t\t * HTMLAudioPlugin will set a tag, FlashAudioPlugin will set a flash reference.\n\t\t *\n\t\t * @property playbackResource\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis._playbackResource = null;\n\t\tObject.defineProperty(this, \"playbackResource\", {\n\t\t\tget: this.getPlaybackResource,\n\t\t\tset: this.setPlaybackResource\n\t\t});\n\t\tif(playbackResource !== false && playbackResource !== true) { this.setPlaybackResource(playbackResource); }\n\n\t\t/**\n\t\t * The position of the playhead in milliseconds. This can be set while a sound is playing, paused, or stopped.\n\t\t *\n\t\t * @property position\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._position = 0;\n\t\tObject.defineProperty(this, \"position\", {\n\t\t\tget: this.getPosition,\n\t\t\tset: this.setPosition\n\t\t});\n\n\t\t/**\n\t\t * The number of play loops remaining. Negative values will loop infinitely.\n\t\t *\n\t\t * @property loop\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @public\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._loop = 0;\n\t\tObject.defineProperty(this, \"loop\", {\n\t\t\tget: this.getLoop,\n\t\t\tset: this.setLoop\n\t\t});\n\n\t\t/**\n\t\t * Mutes or unmutes the current audio instance.\n\t\t *\n\t\t * @property muted\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._muted = false;\n\t\tObject.defineProperty(this, \"muted\", {\n\t\t\tget: this.getMuted,\n\t\t\tset: this.setMuted\n\t\t});\n\n\t\t/**\n\t\t * Pauses or resumes the current audio instance.\n\t\t *\n\t\t * @property paused\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._paused = false;\n\t\tObject.defineProperty(this, \"paused\", {\n\t\t\tget: this.getPaused,\n\t\t\tset: this.setPaused\n\t\t});\n\n\n\t// Events\n\t\t/**\n\t\t * The event that is fired when playback has started successfully.\n\t\t * @event succeeded\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when playback is interrupted. This happens when another sound with the same\n\t\t * src property is played using an interrupt value that causes this instance to stop playing.\n\t\t * @event interrupted\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when playback has failed. This happens when there are too many channels with the same\n\t\t * src property already playing (and the interrupt value doesn't cause an interrupt of another instance), or\n\t\t * the sound could not be played, perhaps due to a 404 error.\n\t\t * @event failed\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when a sound has completed playing but has loops remaining.\n\t\t * @event loop\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when playback completes. This means that the sound has finished playing in its\n\t\t * entirety, including its loop iterations.\n\t\t * @event complete\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\t};\n\n\tvar p = createjs.extend(AbstractSoundInstance, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Public Methods:\n\t/**\n\t * Play an instance. This method is intended to be called on SoundInstances that already exist (created\n\t * with the Sound API {{#crossLink \"Sound/createInstance\"}}{{/crossLink}} or {{#crossLink \"Sound/play\"}}{{/crossLink}}).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var myInstance = createjs.Sound.createInstance(mySrc);\n\t *      myInstance.play({interrupt:createjs.Sound.INTERRUPT_ANY, loop:2, pan:0.5});\n\t *\n\t * Note that if this sound is already playing, this call will still set the passed in parameters.\n\n\t * <b>Parameters Deprecated</b><br />\n\t * The parameters for this method are deprecated in favor of a single parameter that is an Object or {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}}.\n\t *\n\t * @method play\n\t * @param {String | Object} [interrupt=\"none\"|options] <b>This parameter will be renamed playProps in the next release.</b><br />\n\t * This parameter can be an instance of {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}} or an Object that contains any or all optional properties by name,\n\t * including: interrupt, delay, offset, loop, volume, pan, startTime, and duration (see the above code sample).\n\t * <br /><strong>OR</strong><br />\n\t * <b>Deprecated</b> How to interrupt any currently playing instances of audio with the same source,\n\t * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\n\t * constants on the Sound class, with the default defined by {{#crossLink \"Sound/defaultInterruptBehavior:property\"}}{{/crossLink}}.\n\t * @param {Number} [delay=0] <b>Deprecated</b> The amount of time to delay the start of audio playback, in milliseconds.\n\t * @param {Number} [offset=0] <b>Deprecated</b> The offset from the start of the audio to begin playback, in milliseconds.\n\t * @param {Number} [loop=0] <b>Deprecated</b> How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t * loops), and -1 can be used for infinite playback.\n\t * @param {Number} [volume=1] <b>Deprecated</b> The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t * against the individual volume.\n\t * @param {Number} [pan=0] <b>Deprecated</b> The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\n\t * Note that pan is not supported for HTML Audio.\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.play = function (interrupt, delay, offset, loop, volume, pan) {\n\t\tvar playProps;\n\t\tif (interrupt instanceof Object || interrupt instanceof createjs.PlayPropsConfig) {\n\t\t\tplayProps = createjs.PlayPropsConfig.create(interrupt);\n\t\t} else {\n\t\t\tplayProps = createjs.PlayPropsConfig.create({interrupt:interrupt, delay:delay, offset:offset, loop:loop, volume:volume, pan:pan});\n\t\t}\n\n\t\tif (this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis.applyPlayProps(playProps);\n\t\t\tif (this._paused) {\tthis.setPaused(false); }\n\t\t\treturn;\n\t\t}\n\t\tthis._cleanUp();\n\t\tcreatejs.Sound._playInstance(this, playProps);\t// make this an event dispatch??\n\t\treturn this;\n\t};\n\n\t/**\n\t * Stop playback of the instance. Stopped sounds will reset their position to 0, and calls to {{#crossLink \"AbstractSoundInstance/resume\"}}{{/crossLink}}\n\t * will fail. To start playback again, call {{#crossLink \"AbstractSoundInstance/play\"}}{{/crossLink}}.\n     *\n     * If you don't want to lose your position use yourSoundInstance.paused = true instead. {{#crossLink \"AbstractSoundInstance/paused\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     myInstance.stop();\n\t *\n\t * @method stop\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.stop = function () {\n\t\tthis._position = 0;\n\t\tthis._paused = false;\n\t\tthis._handleStop();\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_FINISHED;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Remove all external references and resources from AbstractSoundInstance.  Note this is irreversible and AbstractSoundInstance will no longer work\n\t * @method destroy\n\t * @since 0.6.0\n\t */\n\tp.destroy = function() {\n\t\tthis._cleanUp();\n\t\tthis.src = null;\n\t\tthis.playbackResource = null;\n\n\t\tthis.removeAllEventListeners();\n\t};\n\n\t/**\n\t * Takes an PlayPropsConfig or Object with the same properties and sets them on this instance.\n\t * @method applyPlayProps\n\t * @param {PlayPropsConfig | Object} playProps A PlayPropsConfig or object containing the same properties.\n\t * @since 0.6.1\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.applyPlayProps = function(playProps) {\n\t\tif (playProps.offset != null) { this.setPosition(playProps.offset) }\n\t\tif (playProps.loop != null) { this.setLoop(playProps.loop); }\n\t\tif (playProps.volume != null) { this.setVolume(playProps.volume); }\n\t\tif (playProps.pan != null) { this.setPan(playProps.pan); }\n\t\tif (playProps.startTime != null) {\n\t\t\tthis.setStartTime(playProps.startTime);\n\t\t\tthis.setDuration(playProps.duration);\n\t\t}\n\t\treturn this;\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[AbstractSoundInstance]\";\n\t};\n\n// get/set methods that allow support for IE8\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/paused:property\"}}{{/crossLink}} directly as a property,\n\t *\n\t * @deprecated\n\t * @method getPaused\n\t * @returns {boolean} If the instance is currently paused\n\t * @since 0.6.0\n\t */\n\tp.getPaused = function() {\n\t\treturn this._paused;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/paused:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPaused\n\t * @param {boolean} value\n\t * @since 0.6.0\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.setPaused = function (value) {\n\t\tif ((value !== true && value !== false) || this._paused == value) {return;}\n\t\tif (value == true && this.playState != createjs.Sound.PLAY_SUCCEEDED) {return;}\n\t\tthis._paused = value;\n\t\tif(value) {\n\t\t\tthis._pause();\n\t\t} else {\n\t\t\tthis._resume();\n\t\t}\n\t\tclearTimeout(this.delayTimeoutId);\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/volume:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setVolume\n\t * @param {Number} value The volume to set, between 0 and 1.\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.setVolume = function (value) {\n\t\tif (value == this._volume) { return this; }\n\t\tthis._volume = Math.max(0, Math.min(1, value));\n\t\tif (!this._muted) {\n\t\t\tthis._updateVolume();\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/volume:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getVolume\n\t * @return {Number} The current volume of the sound instance.\n\t */\n\tp.getVolume = function () {\n\t\treturn this._volume;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/muted:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setMuted\n\t * @param {Boolean} value If the sound should be muted.\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t * @since 0.6.0\n\t */\n\tp.setMuted = function (value) {\n\t\tif (value !== true && value !== false) {return;}\n\t\tthis._muted = value;\n\t\tthis._updateVolume();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/muted:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getMuted\n\t * @return {Boolean} If the sound is muted.\n\t * @since 0.6.0\n\t */\n\tp.getMuted = function () {\n\t\treturn this._muted;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/pan:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPan\n\t * @param {Number} value The pan value, between -1 (left) and 1 (right).\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t */\n\tp.setPan = function (value) {\n\t\tif(value == this._pan) { return this; }\n\t\tthis._pan = Math.max(-1, Math.min(1, value));\n\t\tthis._updatePan();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/pan:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getPan\n\t * @return {Number} The value of the pan, between -1 (left) and 1 (right).\n\t */\n\tp.getPan = function () {\n\t\treturn this._pan;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/position:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getPosition\n\t * @return {Number} The position of the playhead in the sound, in milliseconds.\n\t */\n\tp.getPosition = function () {\n\t\tif (!this._paused && this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._position = this._calculateCurrentPosition();\n\t\t}\n\t\treturn this._position;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/position:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPosition\n\t * @param {Number} value The position to place the playhead, in milliseconds.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t */\n\tp.setPosition = function (value) {\n\t\tthis._position = Math.max(0, value);\n\t\tif (this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._updatePosition();\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/startTime:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getStartTime\n\t * @return {Number} The startTime of the sound instance in milliseconds.\n\t */\n\tp.getStartTime = function () {\n\t\treturn this._startTime;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/startTime:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setStartTime\n\t * @param {number} value The new startTime time in milli seconds.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t */\n\tp.setStartTime = function (value) {\n\t\tif (value == this._startTime) { return this; }\n\t\tthis._startTime = Math.max(0, value || 0);\n\t\tthis._updateStartTime();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/duration:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getDuration\n\t * @return {Number} The duration of the sound instance in milliseconds.\n\t */\n\tp.getDuration = function () {\n\t\treturn this._duration;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/duration:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setDuration\n\t * @param {number} value The new duration time in milli seconds.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t * @since 0.6.0\n\t */\n\tp.setDuration = function (value) {\n\t\tif (value == this._duration) { return this; }\n\t\tthis._duration = Math.max(0, value || 0);\n\t\tthis._updateDuration();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/playbackResource:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPlayback\n\t * @param {Object} value The new playback resource.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t * @since 0.6.0\n\t **/\n\tp.setPlaybackResource = function (value) {\n\t\tthis._playbackResource = value;\n\t\tif (this._duration == 0) { this._setDurationFromSource(); }\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/playbackResource:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPlayback\n\t * @param {Object} value The new playback resource.\n\t * @return {Object} playback resource used for playing audio\n\t * @since 0.6.0\n\t **/\n\tp.getPlaybackResource = function () {\n\t\treturn this._playbackResource;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/loop:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getLoop\n\t * @return {number}\n\t * @since 0.6.0\n\t **/\n\tp.getLoop = function () {\n\t\treturn this._loop;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/loop:property\"}}{{/crossLink}} directly as a property,\n\t *\n\t * @deprecated\n\t * @method setLoop\n\t * @param {number} value The number of times to loop after play.\n\t * @since 0.6.0\n\t */\n\tp.setLoop = function (value) {\n\t\tif(this._playbackResource != null) {\n\t\t\t// remove looping\n\t\t\tif (this._loop != 0 && value == 0) {\n\t\t\t\tthis._removeLooping(value);\n\t\t\t}\n\t\t\t// add looping\n\t\t\telse if (this._loop == 0 && value != 0) {\n\t\t\t\tthis._addLooping(value);\n\t\t\t}\n\t\t}\n\t\tthis._loop = value;\n\t};\n\n\n// Private Methods:\n\t/**\n\t * A helper method that dispatches all events for AbstractSoundInstance.\n\t * @method _sendEvent\n\t * @param {String} type The event type\n\t * @protected\n\t */\n\tp._sendEvent = function (type) {\n\t\tvar event = new createjs.Event(type);\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Clean up the instance. Remove references and clean up any additional properties such as timers.\n\t * @method _cleanUp\n\t * @protected\n\t */\n\tp._cleanUp = function () {\n\t\tclearTimeout(this.delayTimeoutId); // clear timeout that plays delayed sound\n\t\tthis._handleCleanUp();\n\t\tthis._paused = false;\n\n\t\tcreatejs.Sound._playFinished(this);\t// TODO change to an event\n\t};\n\n\t/**\n\t * The sound has been interrupted.\n\t * @method _interrupt\n\t * @protected\n\t */\n\tp._interrupt = function () {\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_INTERRUPTED;\n\t\tthis._sendEvent(\"interrupted\");\n\t};\n\n\t/**\n\t * Called by the Sound class when the audio is ready to play (delay has completed). Starts sound playing if the\n\t * src is loaded, otherwise playback will fail.\n\t * @method _beginPlaying\n\t * @param {PlayPropsConfig} playProps A PlayPropsConfig object.\n\t * @return {Boolean} If playback succeeded.\n\t * @protected\n\t */\n\t// OJR FlashAudioSoundInstance overwrites\n\tp._beginPlaying = function (playProps) {\n\t\tthis.setPosition(playProps.offset);\n\t\tthis.setLoop(playProps.loop);\n\t\tthis.setVolume(playProps.volume);\n\t\tthis.setPan(playProps.pan);\n\t\tif (playProps.startTime != null) {\n\t\t\tthis.setStartTime(playProps.startTime);\n\t\t\tthis.setDuration(playProps.duration);\n\t\t}\n\n\t\tif (this._playbackResource != null && this._position < this._duration) {\n\t\t\tthis._paused = false;\n\t\t\tthis._handleSoundReady();\n\t\t\tthis.playState = createjs.Sound.PLAY_SUCCEEDED;\n\t\t\tthis._sendEvent(\"succeeded\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis._playFailed();\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Play has failed, which can happen for a variety of reasons.\n\t * Cleans up instance and dispatches failed event\n\t * @method _playFailed\n\t * @private\n\t */\n\tp._playFailed = function () {\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_FAILED;\n\t\tthis._sendEvent(\"failed\");\n\t};\n\n\t/**\n\t * Audio has finished playing. Manually loop it if required.\n\t * @method _handleSoundComplete\n\t * @param event\n\t * @protected\n\t */\n\tp._handleSoundComplete = function (event) {\n\t\tthis._position = 0;  // have to set this as it can be set by pause during playback\n\n\t\tif (this._loop != 0) {\n\t\t\tthis._loop--;  // NOTE this introduces a theoretical limit on loops = float max size x 2 - 1\n\t\t\tthis._handleLoop();\n\t\t\tthis._sendEvent(\"loop\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_FINISHED;\n\t\tthis._sendEvent(\"complete\");\n\t};\n\n// Plugin specific code\n\t/**\n\t * Handles starting playback when the sound is ready for playing.\n\t * @method _handleSoundReady\n\t * @protected\n \t */\n\tp._handleSoundReady = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the volume based on the instance volume, master volume, instance mute value,\n\t * and master mute value.\n\t * @method _updateVolume\n\t * @protected\n\t */\n\tp._updateVolume = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the pan\n\t * @method _updatePan\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._updatePan = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the startTime of the audio.\n\t * @method _updateStartTime\n\t * @protected\n\t * @since 0.6.1\n\t */\n\tp._updateStartTime = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the duration of the audio.\n\t * @method _updateDuration\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._updateDuration = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to get the duration of the audio from the source we'll be playing.\n\t * @method _updateDuration\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._setDurationFromSource = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function that calculates the current position of the playhead and sets this._position to that value\n\t * @method _calculateCurrentPosition\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._calculateCurrentPosition = function () {\n\t\t// plugin specific code that sets this.position\n\t};\n\n\t/**\n\t * Internal function used to update the position of the playhead.\n\t * @method _updatePosition\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._updatePosition = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when looping is removed during playback.\n\t * @method _removeLooping\n\t * @param {number} value The number of times to loop after play.\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._removeLooping = function (value) {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when looping is added during playback.\n\t * @method _addLooping\n\t * @param {number} value The number of times to loop after play.\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._addLooping = function (value) {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when pausing playback\n\t * @method _pause\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._pause = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when resuming playback\n\t * @method _resume\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._resume = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when stopping playback\n\t * @method _handleStop\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._handleStop = function() {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when AbstractSoundInstance is being cleaned up\n\t * @method _handleCleanUp\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._handleCleanUp = function() {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when AbstractSoundInstance has played to end and is looping\n\t * @method _handleLoop\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._handleLoop = function () {\n\t\t// plugin specific code\n\t};\n\n\tcreatejs.AbstractSoundInstance = createjs.promote(AbstractSoundInstance, \"EventDispatcher\");\n\tcreatejs.DefaultSoundInstance = createjs.AbstractSoundInstance;\t// used when no plugin is supported\n}());\n\n//##############################################################################\n// AbstractPlugin.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\n// constructor:\n \t/**\n\t * A default plugin class used as a base for all other plugins.\n\t * @class AbstractPlugin\n\t * @constructor\n\t * @since 0.6.0\n\t */\n\n\tvar AbstractPlugin = function () {\n\t// private properties:\n\t\t/**\n\t\t * The capabilities of the plugin.\n\t\t * method and is used internally.\n\t\t * @property _capabilities\n\t\t * @type {Object}\n\t\t * @default null\n\t\t * @protected\n\t\t * @static\n\t\t */\n\t\tthis._capabilities = null;\n\n\t\t/**\n\t\t * Object hash indexed by the source URI of all created loaders, used to properly destroy them if sources are removed.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._loaders = {};\n\n\t\t/**\n\t\t * Object hash indexed by the source URI of each file to indicate if an audio source has begun loading,\n\t\t * is currently loading, or has completed loading.  Can be used to store non boolean data after loading\n\t\t * is complete (for example arrayBuffers for web audio).\n\t\t * @property _audioSources\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._audioSources = {};\n\n\t\t/**\n\t\t * Object hash indexed by the source URI of all created SoundInstances, updates the playbackResource if it loads after they are created,\n\t\t * and properly destroy them if sources are removed\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._soundInstances = {};\n\n\t\t/**\n\t\t * The internal master volume value of the plugin.\n\t\t * @property _volume\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t * @protected\n\t\t */\n\t\tthis._volume = 1;\n\n\t\t/**\n\t\t * A reference to a loader class used by a plugin that must be set.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._loaderClass;\n\n\t\t/**\n\t\t * A reference to an AbstractSoundInstance class used by a plugin that must be set.\n\t\t * @type {Object}\n\t\t * @protected;\n\t\t */\n\t\tthis._soundInstanceClass;\n\t};\n\tvar p = AbstractPlugin.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// Static Properties:\n// NOTE THESE PROPERTIES NEED TO BE ADDED TO EACH PLUGIN\n\t/**\n\t * The capabilities of the plugin. This is generated via the _generateCapabilities method and is used internally.\n\t * @property _capabilities\n\t * @type {Object}\n\t * @default null\n\t * @protected\n\t * @static\n\t */\n\tAbstractPlugin._capabilities = null;\n\n\t/**\n\t * Determine if the plugin can be used in the current browser/OS.\n\t * @method isSupported\n\t * @return {Boolean} If the plugin can be initialized.\n\t * @static\n\t */\n\tAbstractPlugin.isSupported = function () {\n\t\treturn true;\n\t};\n\n\n// public methods:\n\t/**\n\t * Pre-register a sound for preloading and setup. This is called by {{#crossLink \"Sound\"}}{{/crossLink}}.\n\t * Note all plugins provide a <code>Loader</code> instance, which <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>\n\t * can use to assist with preloading.\n\t * @method register\n\t * @param {String} loadItem An Object containing the source of the audio\n\t * Note that not every plugin will manage this value.\n\t * @return {Object} A result object, containing a \"tag\" for preloading purposes.\n\t */\n\tp.register = function (loadItem) {\n\t\tvar loader = this._loaders[loadItem.src];\n\t\tif(loader && !loader.canceled) {return this._loaders[loadItem.src];}\t// already loading/loaded this, so don't load twice\n\t\t// OJR potential issue that we won't be firing loaded event, might need to trigger if this is already loaded?\n\t\tthis._audioSources[loadItem.src] = true;\n\t\tthis._soundInstances[loadItem.src] = [];\n\t\tloader = new this._loaderClass(loadItem);\n\t\tloader.on(\"complete\", this._handlePreloadComplete, this);\n\t\tthis._loaders[loadItem.src] = loader;\n\t\treturn loader;\n\t};\n\n\t// note sound calls register before calling preload\n\t/**\n\t * Internally preload a sound.\n\t * @method preload\n\t * @param {Loader} loader The sound URI to load.\n\t */\n\tp.preload = function (loader) {\n\t\tloader.on(\"error\", this._handlePreloadError, this);\n\t\tloader.load();\n\t};\n\n\t/**\n\t * Checks if preloading has started for a specific source. If the source is found, we can assume it is loading,\n\t * or has already finished loading.\n\t * @method isPreloadStarted\n\t * @param {String} src The sound URI to check.\n\t * @return {Boolean}\n\t */\n\tp.isPreloadStarted = function (src) {\n\t\treturn (this._audioSources[src] != null);\n\t};\n\n\t/**\n\t * Checks if preloading has finished for a specific source.\n\t * @method isPreloadComplete\n\t * @param {String} src The sound URI to load.\n\t * @return {Boolean}\n\t */\n\tp.isPreloadComplete = function (src) {\n\t\treturn (!(this._audioSources[src] == null || this._audioSources[src] == true));\n\t};\n\n\t/**\n\t * Remove a sound added using {{#crossLink \"WebAudioPlugin/register\"}}{{/crossLink}}. Note this does not cancel a preload.\n\t * @method removeSound\n\t * @param {String} src The sound URI to unload.\n\t */\n\tp.removeSound = function (src) {\n\t\tif (!this._soundInstances[src]) { return; }\n\t\tfor (var i = this._soundInstances[src].length; i--; ) {\n\t\t\tvar item = this._soundInstances[src][i];\n\t\t\titem.destroy();\n\t\t}\n\t\tdelete(this._soundInstances[src]);\n\t\tdelete(this._audioSources[src]);\n\t\tif(this._loaders[src]) { this._loaders[src].destroy(); }\n\t\tdelete(this._loaders[src]);\n\t};\n\n\t/**\n\t * Remove all sounds added using {{#crossLink \"WebAudioPlugin/register\"}}{{/crossLink}}. Note this does not cancel a preload.\n\t * @method removeAllSounds\n\t * @param {String} src The sound URI to unload.\n\t */\n\tp.removeAllSounds = function () {\n\t\tfor(var key in this._audioSources) {\n\t\t\tthis.removeSound(key);\n\t\t}\n\t};\n\n\t/**\n\t * Create a sound instance. If the sound has not been preloaded, it is internally preloaded here.\n\t * @method create\n\t * @param {String} src The sound source to use.\n\t * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n\t * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n\t * @return {AbstractSoundInstance} A sound instance for playback and control.\n\t */\n\tp.create = function (src, startTime, duration) {\n\t\tif (!this.isPreloadStarted(src)) {\n\t\t\tthis.preload(this.register(src));\n\t\t}\n\t\tvar si = new this._soundInstanceClass(src, startTime, duration, this._audioSources[src]);\n\t\tthis._soundInstances[src].push(si);\n\t\treturn si;\n\t};\n\n\t// if a plugin does not support volume and mute, it should set these to null\n\t/**\n\t * Set the master volume of the plugin, which affects all SoundInstances.\n\t * @method setVolume\n\t * @param {Number} value The volume to set, between 0 and 1.\n\t * @return {Boolean} If the plugin processes the setVolume call (true). The Sound class will affect all the\n\t * instances manually otherwise.\n\t */\n\tp.setVolume = function (value) {\n\t\tthis._volume = value;\n\t\tthis._updateVolume();\n\t\treturn true;\n\t};\n\n\t/**\n\t * Get the master volume of the plugin, which affects all SoundInstances.\n\t * @method getVolume\n\t * @return {Number} The volume level, between 0 and 1.\n\t */\n\tp.getVolume = function () {\n\t\treturn this._volume;\n\t};\n\n\t/**\n\t * Mute all sounds via the plugin.\n\t * @method setMute\n\t * @param {Boolean} value If all sound should be muted or not. Note that plugin-level muting just looks up\n\t * the mute value of Sound {{#crossLink \"Sound/getMute\"}}{{/crossLink}}, so this property is not used here.\n\t * @return {Boolean} If the mute call succeeds.\n\t */\n\tp.setMute = function (value) {\n\t\tthis._updateVolume();\n\t\treturn true;\n\t};\n\n\t// plugins should overwrite this method\n\tp.toString = function () {\n\t\treturn \"[AbstractPlugin]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * Handles internal preload completion.\n\t * @method _handlePreloadComplete\n\t * @protected\n\t */\n\tp._handlePreloadComplete = function (event) {\n\t\tvar src = event.target.getItem().src;\n\t\tthis._audioSources[src] = event.result;\n\t\tfor (var i = 0, l = this._soundInstances[src].length; i < l; i++) {\n\t\t\tvar item = this._soundInstances[src][i];\n\t\t\titem.setPlaybackResource(this._audioSources[src]);\n\t\t\t// ToDo consider adding play call here if playstate == playfailed\n\t\t}\n\t};\n\n\t/**\n\t * Handles internal preload erros\n\t * @method _handlePreloadError\n\t * @param event\n\t * @protected\n\t */\n\tp._handlePreloadError = function(event) {\n\t\t//delete(this._audioSources[src]);\n\t};\n\n\t/**\n\t * Set the gain value for master audio. Should not be called externally.\n\t * @method _updateVolume\n\t * @protected\n\t */\n\tp._updateVolume = function () {\n\t\t// Plugin Specific code\n\t};\n\n\tcreatejs.AbstractPlugin = AbstractPlugin;\n}());\n\n//##############################################################################\n// WebAudioLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * Loader provides a mechanism to preload Web Audio content via PreloadJS or internally. Instances are returned to\n\t * the preloader, and the load method is called when the asset needs to be requested.\n\t *\n\t * @class WebAudioLoader\n\t * @param {String} loadItem The item to be loaded\n\t * @extends XHRRequest\n\t * @protected\n\t */\n\tfunction Loader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.SOUND);\n\n\t};\n\tvar p = createjs.extend(Loader, createjs.AbstractLoader);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n\t/**\n\t * web audio context required for decoding audio\n\t * @property context\n\t * @type {AudioContext}\n\t * @static\n\t */\n\tLoader.context = null;\n\n\n// public methods\n\tp.toString = function () {\n\t\treturn \"[WebAudioLoader]\";\n\t};\n\n\n// private methods\n\tp._createRequest = function() {\n\t\tthis._request = new createjs.XHRRequest(this._item, false);\n\t\tthis._request.setResponseType(\"arraybuffer\");\n\t};\n\n\tp._sendComplete = function (event) {\n\t\t// OJR we leave this wrapped in Loader because we need to reference src and the handler only receives a single argument, the decodedAudio\n\t\tLoader.context.decodeAudioData(this._rawResult,\n\t         createjs.proxy(this._handleAudioDecoded, this),\n\t         createjs.proxy(this._sendError, this));\n\t};\n\n\n\t/**\n\t* The audio has been decoded.\n\t* @method handleAudioDecoded\n\t* @param decoded\n\t* @protected\n\t*/\n\tp._handleAudioDecoded = function (decodedAudio) {\n\t\tthis._result = decodedAudio;\n\t\tthis.AbstractLoader__sendComplete();\n\t};\n\n\tcreatejs.WebAudioLoader = createjs.promote(Loader, \"AbstractLoader\");\n}());\n\n//##############################################################################\n// WebAudioSoundInstance.js\n//##############################################################################\n\n/**\n * WebAudioSoundInstance extends the base api of {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} and is used by\n * {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}.\n *\n * WebAudioSoundInstance exposes audioNodes for advanced users.\n *\n * @param {String} src The path to and file name of the sound.\n * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\n * @class WebAudioSoundInstance\n * @extends AbstractSoundInstance\n * @constructor\n */\n(function () {\n\t\"use strict\";\n\n\tfunction WebAudioSoundInstance(src, startTime, duration, playbackResource) {\n\t\tthis.AbstractSoundInstance_constructor(src, startTime, duration, playbackResource);\n\n\n// public properties\n\t\t/**\n\t\t * NOTE this is only intended for use by advanced users.\n\t\t * <br />GainNode for controlling <code>WebAudioSoundInstance</code> volume. Connected to the {{#crossLink \"WebAudioSoundInstance/destinationNode:property\"}}{{/crossLink}}.\n\t\t * @property gainNode\n\t\t * @type {AudioGainNode}\n\t\t * @since 0.4.0\n\t\t *\n\t\t */\n\t\tthis.gainNode = s.context.createGain();\n\n\t\t/**\n\t\t * NOTE this is only intended for use by advanced users.\n\t\t * <br />A panNode allowing left and right audio channel panning only. Connected to WebAudioSoundInstance {{#crossLink \"WebAudioSoundInstance/gainNode:property\"}}{{/crossLink}}.\n\t\t * @property panNode\n\t\t * @type {AudioPannerNode}\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis.panNode = s.context.createPanner();\n\t\tthis.panNode.panningModel = s._panningModel;\n\t\tthis.panNode.connect(this.gainNode);\n\t\tthis._updatePan();\n\n\t\t/**\n\t\t * NOTE this is only intended for use by advanced users.\n\t\t * <br />sourceNode is the audio source. Connected to WebAudioSoundInstance {{#crossLink \"WebAudioSoundInstance/panNode:property\"}}{{/crossLink}}.\n\t\t * @property sourceNode\n\t\t * @type {AudioNode}\n\t\t * @since 0.4.0\n\t\t *\n\t\t */\n\t\tthis.sourceNode = null;\n\n\n// private properties\n\t\t/**\n\t\t * Timeout that is created internally to handle sound playing to completion.\n\t\t * Stored so we can remove it when stop, pause, or cleanup are called\n\t\t * @property _soundCompleteTimeout\n\t\t * @type {timeoutVariable}\n\t\t * @default null\n\t\t * @protected\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis._soundCompleteTimeout = null;\n\n\t\t/**\n\t\t * NOTE this is only intended for use by very advanced users.\n\t\t * _sourceNodeNext is the audio source for the next loop, inserted in a look ahead approach to allow for smooth\n\t\t * looping. Connected to {{#crossLink \"WebAudioSoundInstance/gainNode:property\"}}{{/crossLink}}.\n\t\t * @property _sourceNodeNext\n\t\t * @type {AudioNode}\n\t\t * @default null\n\t\t * @protected\n\t\t * @since 0.4.1\n\t\t *\n\t\t */\n\t\tthis._sourceNodeNext = null;\n\n\t\t/**\n\t\t * Time audio started playback, in seconds. Used to handle set position, get position, and resuming from paused.\n\t\t * @property _playbackStartTime\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @protected\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis._playbackStartTime = 0;\n\n\t\t// Proxies, make removing listeners easier.\n\t\tthis._endedHandler = createjs.proxy(this._handleSoundComplete, this);\n\t};\n\tvar p = createjs.extend(WebAudioSoundInstance, createjs.AbstractSoundInstance);\n\tvar s = WebAudioSoundInstance;\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n\t/**\n\t * Note this is only intended for use by advanced users.\n\t * <br />Audio context used to create nodes.  This is and needs to be the same context used by {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}.\n  \t * @property context\n\t * @type {AudioContext}\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.context = null;\n\n\t/**\n\t * Note this is only intended for use by advanced users.\n\t * <br />The scratch buffer that will be assigned to the buffer property of a source node on close.  \n\t * This is and should be the same scratch buffer referenced by {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}.\n  \t * @property _scratchBuffer\n\t * @type {AudioBufferSourceNode}\n\t * @static\n\t */\n\ts._scratchBuffer = null;\n\n\t/**\n\t * Note this is only intended for use by advanced users.\n\t * <br /> Audio node from WebAudioPlugin that sequences to <code>context.destination</code>\n\t * @property destinationNode\n\t * @type {AudioNode}\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.destinationNode = null;\n\n\t/**\n\t * Value to set panning model to equal power for WebAudioSoundInstance.  Can be \"equalpower\" or 0 depending on browser implementation.\n\t * @property _panningModel\n\t * @type {Number / String}\n\t * @protected\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts._panningModel = \"equalpower\";\n\n\n// Public methods\n\tp.destroy = function() {\n\t\tthis.AbstractSoundInstance_destroy();\n\n\t\tthis.panNode.disconnect(0);\n\t\tthis.panNode = null;\n\t\tthis.gainNode.disconnect(0);\n\t\tthis.gainNode = null;\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[WebAudioSoundInstance]\";\n\t};\n\n\n// Private Methods\n\tp._updatePan = function() {\n\t\tthis.panNode.setPosition(this._pan, 0, -0.5);\n\t\t// z need to be -0.5 otherwise the sound only plays in left, right, or center\n\t};\n\n\tp._removeLooping = function(value) {\n\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\t};\n\n\tp._addLooping = function(value) {\n\t\tif (this.playState != createjs.Sound.PLAY_SUCCEEDED) { return; }\n\t\tthis._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\n\t};\n\n\tp._setDurationFromSource = function () {\n\t\tthis._duration = this.playbackResource.duration * 1000;\n\t};\n\n\tp._handleCleanUp = function () {\n\t\tif (this.sourceNode && this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis.sourceNode = this._cleanUpAudioNode(this.sourceNode);\n\t\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\t\t}\n\n\t\tif (this.gainNode.numberOfOutputs != 0) {this.gainNode.disconnect(0);}\n\t\t// OJR there appears to be a bug that this doesn't always work in webkit (Chrome and Safari). According to the documentation, this should work.\n\n\t\tclearTimeout(this._soundCompleteTimeout);\n\n\t\tthis._playbackStartTime = 0;\t// This is used by getPosition\n\t};\n\n\t/**\n\t * Turn off and disconnect an audioNode, then set reference to null to release it for garbage collection\n\t * @method _cleanUpAudioNode\n\t * @param audioNode\n\t * @return {audioNode}\n\t * @protected\n\t * @since 0.4.1\n\t */\n\tp._cleanUpAudioNode = function(audioNode) {\n\t\tif(audioNode) {\n\t\t\taudioNode.stop(0);\n\t\t\taudioNode.disconnect(0);\n\t\t\t// necessary to prevent leak on iOS Safari 7-9. will throw in almost all other\n\t\t\t// browser implementations.\n\t\t\ttry { audioNode.buffer = s._scratchBuffer; } catch(e) {}\n\t\t\taudioNode = null;\n\t\t}\n\t\treturn audioNode;\n\t};\n\n\tp._handleSoundReady = function (event) {\n\t\tthis.gainNode.connect(s.destinationNode);  // this line can cause a memory leak.  Nodes need to be disconnected from the audioDestination or any sequence that leads to it.\n\n\t\tvar dur = this._duration * 0.001;\n\t\tvar pos = this._position * 0.001;\n\t\tif (pos > dur) {pos = dur;}\n\t\tthis.sourceNode = this._createAndPlayAudioNode((s.context.currentTime - dur), pos);\n\t\tthis._playbackStartTime = this.sourceNode.startTime - pos;\n\n\t\tthis._soundCompleteTimeout = setTimeout(this._endedHandler, (dur - pos) * 1000);\n\n\t\tif(this._loop != 0) {\n\t\t\tthis._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\n\t\t}\n\t};\n\n\t/**\n\t * Creates an audio node using the current src and context, connects it to the gain node, and starts playback.\n\t * @method _createAndPlayAudioNode\n\t * @param {Number} startTime The time to add this to the web audio context, in seconds.\n\t * @param {Number} offset The amount of time into the src audio to start playback, in seconds.\n\t * @return {audioNode}\n\t * @protected\n\t * @since 0.4.1\n\t */\n\tp._createAndPlayAudioNode = function(startTime, offset) {\n\t\tvar audioNode = s.context.createBufferSource();\n\t\taudioNode.buffer = this.playbackResource;\n\t\taudioNode.connect(this.panNode);\n\t\tvar dur = this._duration * 0.001;\n\t\taudioNode.startTime = startTime + dur;\n\t\taudioNode.start(audioNode.startTime, offset+(this._startTime*0.001), dur - offset);\n\t\treturn audioNode;\n\t};\n\n\tp._pause = function () {\n\t\tthis._position = (s.context.currentTime - this._playbackStartTime) * 1000;  // * 1000 to give milliseconds, lets us restart at same point\n\t\tthis.sourceNode = this._cleanUpAudioNode(this.sourceNode);\n\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\n\t\tif (this.gainNode.numberOfOutputs != 0) {this.gainNode.disconnect(0);}\n\n\t\tclearTimeout(this._soundCompleteTimeout);\n\t};\n\n\tp._resume = function () {\n\t\tthis._handleSoundReady();\n\t};\n\n\t/*\n\tp._handleStop = function () {\n\t\t// web audio does not need to do anything extra\n\t};\n\t*/\n\n\tp._updateVolume = function () {\n\t\tvar newVolume = this._muted ? 0 : this._volume;\n\t  \tif (newVolume != this.gainNode.gain.value) {\n\t\t  this.gainNode.gain.value = newVolume;\n  \t\t}\n\t};\n\n\tp._calculateCurrentPosition = function () {\n\t\treturn ((s.context.currentTime - this._playbackStartTime) * 1000); // pos in seconds * 1000 to give milliseconds\n\t};\n\n\tp._updatePosition = function () {\n\t\tthis.sourceNode = this._cleanUpAudioNode(this.sourceNode);\n\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\t\tclearTimeout(this._soundCompleteTimeout);\n\n\t\tif (!this._paused) {this._handleSoundReady();}\n\t};\n\n\t// OJR we are using a look ahead approach to ensure smooth looping.\n\t// We add _sourceNodeNext to the audio context so that it starts playing even if this callback is delayed.\n\t// This technique is described here:  http://www.html5rocks.com/en/tutorials/audio/scheduling/\n\t// NOTE the cost of this is that our audio loop may not always match the loop event timing precisely.\n\tp._handleLoop = function () {\n\t\tthis._cleanUpAudioNode(this.sourceNode);\n\t\tthis.sourceNode = this._sourceNodeNext;\n\t\tthis._playbackStartTime = this.sourceNode.startTime;\n\t\tthis._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\n\t\tthis._soundCompleteTimeout = setTimeout(this._endedHandler, this._duration);\n\t};\n\n\tp._updateDuration = function () {\n\t\tif(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._pause();\n\t\t\tthis._resume();\n\t\t}\n\t};\n\n\tcreatejs.WebAudioSoundInstance = createjs.promote(WebAudioSoundInstance, \"AbstractSoundInstance\");\n}());\n\n//##############################################################################\n// WebAudioPlugin.js\n//##############################################################################\n\n(function () {\n\n\t\"use strict\";\n\n\t/**\n\t * Play sounds using Web Audio in the browser. The WebAudioPlugin is currently the default plugin, and will be used\n\t * anywhere that it is supported. To change plugin priority, check out the Sound API\n\t * {{#crossLink \"Sound/registerPlugins\"}}{{/crossLink}} method.\n\n\t * <h4>Known Browser and OS issues for Web Audio</h4>\n\t * <b>Firefox 25</b>\n\t * <li>\n\t *     mp3 audio files do not load properly on all windows machines, reported <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=929969\" target=\"_blank\">here</a>.\n\t *     <br />For this reason it is recommended to pass another FireFox-supported type (i.e. ogg) as the default\n\t *     extension, until this bug is resolved\n\t * </li>\n\t *\n\t * <b>Webkit (Chrome and Safari)</b>\n\t * <li>\n\t *     AudioNode.disconnect does not always seem to work.  This can cause the file size to grow over time if you\n\t * \t   are playing a lot of audio files.\n\t * </li>\n\t *\n\t * <b>iOS 6 limitations</b>\n\t * <ul>\n\t *     <li>\n\t *         Sound is initially muted and will only unmute through play being called inside a user initiated event\n\t *         (touch/click). Please read the mobile playback notes in the the {{#crossLink \"Sound\"}}{{/crossLink}}\n\t *         class for a full overview of the limitations, and how to get around them.\n\t *     </li>\n\t *\t   <li>\n\t *\t       A bug exists that will distort un-cached audio when a video element is present in the DOM. You can avoid\n\t *\t       this bug by ensuring the audio and video audio share the same sample rate.\n\t *\t   </li>\n\t * </ul>\n\t * @class WebAudioPlugin\n\t * @extends AbstractPlugin\n\t * @constructor\n\t * @since 0.4.0\n\t */\n\tfunction WebAudioPlugin() {\n\t\tthis.AbstractPlugin_constructor();\n\n\n// Private Properties\n\t\t/**\n\t\t * Value to set panning model to equal power for WebAudioSoundInstance.  Can be \"equalpower\" or 0 depending on browser implementation.\n\t\t * @property _panningModel\n\t\t * @type {Number / String}\n\t\t * @protected\n\t\t */\n\t\tthis._panningModel = s._panningModel;;\n\n\t\t/**\n\t\t * The web audio context, which WebAudio uses to play audio. All nodes that interact with the WebAudioPlugin\n\t\t * need to be created within this context.\n\t\t * @property context\n\t\t * @type {AudioContext}\n\t\t */\n\t\tthis.context = s.context;\n\n\t\t/**\n\t\t * A DynamicsCompressorNode, which is used to improve sound quality and prevent audio distortion.\n\t\t * It is connected to <code>context.destination</code>.\n\t\t *\n\t\t * Can be accessed by advanced users through createjs.Sound.activePlugin.dynamicsCompressorNode.\n\t\t * @property dynamicsCompressorNode\n\t\t * @type {AudioNode}\n\t\t */\n\t\tthis.dynamicsCompressorNode = this.context.createDynamicsCompressor();\n\t\tthis.dynamicsCompressorNode.connect(this.context.destination);\n\n\t\t/**\n\t\t * A GainNode for controlling master volume. It is connected to {{#crossLink \"WebAudioPlugin/dynamicsCompressorNode:property\"}}{{/crossLink}}.\n\t\t *\n\t\t * Can be accessed by advanced users through createjs.Sound.activePlugin.gainNode.\n\t\t * @property gainNode\n\t\t * @type {AudioGainNode}\n\t\t */\n\t\tthis.gainNode = this.context.createGain();\n\t\tthis.gainNode.connect(this.dynamicsCompressorNode);\n\t\tcreatejs.WebAudioSoundInstance.destinationNode = this.gainNode;\n\n\t\tthis._capabilities = s._capabilities;\n\n\t\tthis._loaderClass = createjs.WebAudioLoader;\n\t\tthis._soundInstanceClass = createjs.WebAudioSoundInstance;\n\n\t\tthis._addPropsToClasses();\n\t}\n\tvar p = createjs.extend(WebAudioPlugin, createjs.AbstractPlugin);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Static Properties\n\tvar s = WebAudioPlugin;\n\t/**\n\t * The capabilities of the plugin. This is generated via the {{#crossLink \"WebAudioPlugin/_generateCapabilities:method\"}}{{/crossLink}}\n\t * method and is used internally.\n\t * @property _capabilities\n\t * @type {Object}\n\t * @default null\n\t * @protected\n\t * @static\n\t */\n\ts._capabilities = null;\n\n\t/**\n\t * Value to set panning model to equal power for WebAudioSoundInstance.  Can be \"equalpower\" or 0 depending on browser implementation.\n\t * @property _panningModel\n\t * @type {Number / String}\n\t * @protected\n\t * @static\n\t */\n\ts._panningModel = \"equalpower\";\n\n\t/**\n\t * The web audio context, which WebAudio uses to play audio. All nodes that interact with the WebAudioPlugin\n\t * need to be created within this context.\n\t *\n\t * Advanced users can set this to an existing context, but <b>must</b> do so before they call\n\t * {{#crossLink \"Sound/registerPlugins\"}}{{/crossLink}} or {{#crossLink \"Sound/initializeDefaultPlugins\"}}{{/crossLink}}.\n\t *\n\t * @property context\n\t * @type {AudioContext}\n\t * @static\n\t */\n\ts.context = null;\n\n\t/**\n\t * The scratch buffer that will be assigned to the buffer property of a source node on close.\n\t * Works around an iOS Safari bug: https://github.com/CreateJS/SoundJS/issues/102\n\t *\n\t * Advanced users can set this to an existing source node, but <b>must</b> do so before they call\n\t * {{#crossLink \"Sound/registerPlugins\"}}{{/crossLink}} or {{#crossLink \"Sound/initializeDefaultPlugins\"}}{{/crossLink}}.\n\t *\n\t * @property _scratchBuffer\n\t * @type {AudioBuffer}\n\t * @protected\n\t * @static\n\t */\n\t s._scratchBuffer = null;\n\n\t/**\n\t * Indicated whether audio on iOS has been unlocked, which requires a touchend/mousedown event that plays an\n\t * empty sound.\n\t * @property _unlocked\n\t * @type {boolean}\n\t * @since 0.6.2\n\t * @private\n\t */\n\ts._unlocked = false;\n\n\n// Static Public Methods\n\t/**\n\t * Determine if the plugin can be used in the current browser/OS.\n\t * @method isSupported\n\t * @return {Boolean} If the plugin can be initialized.\n\t * @static\n\t */\n\ts.isSupported = function () {\n\t\t// check if this is some kind of mobile device, Web Audio works with local protocol under PhoneGap and it is unlikely someone is trying to run a local file\n\t\tvar isMobilePhoneGap = createjs.BrowserDetect.isIOS || createjs.BrowserDetect.isAndroid || createjs.BrowserDetect.isBlackberry;\n\t\t// OJR isMobile may be redundant with _isFileXHRSupported available.  Consider removing.\n\t\tif (location.protocol == \"file:\" && !isMobilePhoneGap && !this._isFileXHRSupported()) { return false; }  // Web Audio requires XHR, which is not usually available locally\n\t\ts._generateCapabilities();\n\t\tif (s.context == null) {return false;}\n\t\treturn true;\n\t};\n\n\t/**\n\t * Plays an empty sound in the web audio context.  This is used to enable web audio on iOS devices, as they\n\t * require the first sound to be played inside of a user initiated event (touch/click).  This is called when\n\t * {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}} is initialized (by Sound {{#crossLink \"Sound/initializeDefaultPlugins\"}}{{/crossLink}}\n\t * for example).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     function handleTouch(event) {\n\t *         createjs.WebAudioPlugin.playEmptySound();\n\t *     }\n\t *\n\t * @method playEmptySound\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.playEmptySound = function() {\n\t\tif (s.context == null) {return;}\n\t\tvar source = s.context.createBufferSource();\n\t\tsource.buffer = s._scratchBuffer;\n\t\tsource.connect(s.context.destination);\n\t\tsource.start(0, 0, 0);\n\t};\n\n\n// Static Private Methods\n\t/**\n\t * Determine if XHR is supported, which is necessary for web audio.\n\t * @method _isFileXHRSupported\n\t * @return {Boolean} If XHR is supported.\n\t * @since 0.4.2\n\t * @protected\n\t * @static\n\t */\n\ts._isFileXHRSupported = function() {\n\t\t// it's much easier to detect when something goes wrong, so let's start optimistically\n\t\tvar supported = true;\n\n\t\tvar xhr = new XMLHttpRequest();\n\t\ttry {\n\t\t\txhr.open(\"GET\", \"WebAudioPluginTest.fail\", false); // loading non-existant file triggers 404 only if it could load (synchronous call)\n\t\t} catch (error) {\n\t\t\t// catch errors in cases where the onerror is passed by\n\t\t\tsupported = false;\n\t\t\treturn supported;\n\t\t}\n\t\txhr.onerror = function() { supported = false; }; // cause irrelevant\n\t\t// with security turned off, we can get empty success results, which is actually a failed read (status code 0?)\n\t\txhr.onload = function() { supported = this.status == 404 || (this.status == 200 || (this.status == 0 && this.response != \"\")); };\n\t\ttry {\n\t\t\txhr.send();\n\t\t} catch (error) {\n\t\t\t// catch errors in cases where the onerror is passed by\n\t\t\tsupported = false;\n\t\t}\n\n\t\treturn supported;\n\t};\n\n\t/**\n\t * Determine the capabilities of the plugin. Used internally. Please see the Sound API {{#crossLink \"Sound/getCapabilities\"}}{{/crossLink}}\n\t * method for an overview of plugin capabilities.\n\t * @method _generateCapabilities\n\t * @static\n\t * @protected\n\t */\n\ts._generateCapabilities = function () {\n\t\tif (s._capabilities != null) {return;}\n\t\t// Web Audio can be in any formats supported by the audio element, from http://www.w3.org/TR/webaudio/#AudioContext-section\n\t\tvar t = document.createElement(\"audio\");\n\t\tif (t.canPlayType == null) {return null;}\n\n\t\tif (s.context == null) {\n\t\t\tif (window.AudioContext) {\n\t\t\t\ts.context = new AudioContext();\n\t\t\t} else if (window.webkitAudioContext) {\n\t\t\t\ts.context = new webkitAudioContext();\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif (s._scratchBuffer == null) {\n\t\t\ts._scratchBuffer = s.context.createBuffer(1, 1, 22050);\n\t\t}\n\n\t\ts._compatibilitySetUp();\n\n\t\t// Listen for document level clicks to unlock WebAudio on iOS. See the _unlock method.\n\t\tif (\"ontouchstart\" in window && s.context.state != \"running\") {\n\t\t\ts._unlock(); // When played inside of a touch event, this will enable audio on iOS immediately.\n\t\t\tdocument.addEventListener(\"mousedown\", s._unlock, true);\n\t\t\tdocument.addEventListener(\"touchend\", s._unlock, true);\n\t\t}\n\n\n\t\ts._capabilities = {\n\t\t\tpanning:true,\n\t\t\tvolume:true,\n\t\t\ttracks:-1\n\t\t};\n\n\t\t// determine which extensions our browser supports for this plugin by iterating through Sound.SUPPORTED_EXTENSIONS\n\t\tvar supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;\n\t\tvar extensionMap = createjs.Sound.EXTENSION_MAP;\n\t\tfor (var i = 0, l = supportedExtensions.length; i < l; i++) {\n\t\t\tvar ext = supportedExtensions[i];\n\t\t\tvar playType = extensionMap[ext] || ext;\n\t\t\ts._capabilities[ext] = (t.canPlayType(\"audio/\" + ext) != \"no\" && t.canPlayType(\"audio/\" + ext) != \"\") || (t.canPlayType(\"audio/\" + playType) != \"no\" && t.canPlayType(\"audio/\" + playType) != \"\");\n\t\t}  // OJR another way to do this might be canPlayType:\"m4a\", codex: mp4\n\n\t\t// 0=no output, 1=mono, 2=stereo, 4=surround, 6=5.1 surround.\n\t\t// See http://www.w3.org/TR/webaudio/#AudioChannelSplitter for more details on channels.\n\t\tif (s.context.destination.numberOfChannels < 2) {\n\t\t\ts._capabilities.panning = false;\n\t\t}\n\t};\n\n\t/**\n\t * Set up compatibility if only deprecated web audio calls are supported.\n\t * See http://www.w3.org/TR/webaudio/#DeprecationNotes\n\t * Needed so we can support new browsers that don't support deprecated calls (Firefox) as well as old browsers that\n\t * don't support new calls.\n\t *\n\t * @method _compatibilitySetUp\n\t * @static\n\t * @protected\n\t * @since 0.4.2\n\t */\n\ts._compatibilitySetUp = function() {\n\t\ts._panningModel = \"equalpower\";\n\t\t//assume that if one new call is supported, they all are\n\t\tif (s.context.createGain) { return; }\n\n\t\t// simple name change, functionality the same\n\t\ts.context.createGain = s.context.createGainNode;\n\n\t\t// source node, add to prototype\n\t\tvar audioNode = s.context.createBufferSource();\n\t\taudioNode.__proto__.start = audioNode.__proto__.noteGrainOn;\t// note that noteGrainOn requires all 3 parameters\n\t\taudioNode.__proto__.stop = audioNode.__proto__.noteOff;\n\n\t\t// panningModel\n\t\ts._panningModel = 0;\n\t};\n\n\t/**\n\t * Try to unlock audio on iOS. This is triggered from either WebAudio plugin setup (which will work if inside of\n\t * a `mousedown` or `touchend` event stack), or the first document touchend/mousedown event. If it fails (touchend\n\t * will fail if the user presses for too long, indicating a scroll event instead of a click event.\n\t *\n\t * Note that earlier versions of iOS supported `touchstart` for this, but iOS9 removed this functionality. Adding\n\t * a `touchstart` event to support older platforms may preclude a `mousedown` even from getting fired on iOS9, so we\n\t * stick with `mousedown` and `touchend`.\n\t * @method _unlock\n\t * @since 0.6.2\n\t * @private\n\t */\n\ts._unlock = function() {\n\t\tif (s._unlocked) { return; }\n\t\ts.playEmptySound();\n\t\tif (s.context.state == \"running\") {\n\t\t\tdocument.removeEventListener(\"mousedown\", s._unlock, true);\n\t\t\tdocument.removeEventListener(\"touchend\", s._unlock, true);\n\t\t\ts._unlocked = true;\n\t\t}\n\t};\n\n\n// Public Methods\n\tp.toString = function () {\n\t\treturn \"[WebAudioPlugin]\";\n\t};\n\n\n// Private Methods\n\t/**\n\t * Set up needed properties on supported classes WebAudioSoundInstance and WebAudioLoader.\n\t * @method _addPropsToClasses\n\t * @static\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._addPropsToClasses = function() {\n\t\tvar c = this._soundInstanceClass;\n\t\tc.context = this.context;\n\t\tc._scratchBuffer = s._scratchBuffer;\n\t\tc.destinationNode = this.gainNode;\n\t\tc._panningModel = this._panningModel;\n\n\t\tthis._loaderClass.context = this.context;\n\t};\n\n\n\t/**\n\t * Set the gain value for master audio. Should not be called externally.\n\t * @method _updateVolume\n\t * @protected\n\t */\n\tp._updateVolume = function () {\n\t\tvar newVolume = createjs.Sound._masterMute ? 0 : this._volume;\n\t\tif (newVolume != this.gainNode.gain.value) {\n\t\t\tthis.gainNode.gain.value = newVolume;\n\t\t}\n\t};\n\n\tcreatejs.WebAudioPlugin = createjs.promote(WebAudioPlugin, \"AbstractPlugin\");\n}());\n\n//##############################################################################\n// HTMLAudioTagPool.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * HTMLAudioTagPool is an object pool for HTMLAudio tag instances.\n\t * @class HTMLAudioTagPool\n\t * @param {String} src The source of the channel.\n\t * @protected\n\t */\n\tfunction HTMLAudioTagPool() {\n\t\t\tthrow \"HTMLAudioTagPool cannot be instantiated\";\n\t}\n\n\tvar s = HTMLAudioTagPool;\n\n// Static Properties\n\t/**\n\t * A hash lookup of each base audio tag, indexed by the audio source.\n\t * @property _tags\n\t * @type {{}}\n\t * @static\n\t * @protected\n\t */\n\ts._tags = {};\n\n\t/**\n\t * An object pool for html audio tags\n\t * @property _tagPool\n\t * @type {TagPool}\n\t * @static\n\t * @protected\n\t */\n\ts._tagPool = new TagPool();\n\n\t/**\n\t * A hash lookup of if a base audio tag is available, indexed by the audio source\n\t * @property _tagsUsed\n\t * @type {{}}\n\t * @protected\n\t * @static\n\t */\n\ts._tagUsed = {};\n\n// Static Methods\n\t/**\n\t  * Get an audio tag with the given source.\n\t  * @method get\n\t  * @param {String} src The source file used by the audio tag.\n\t  * @static\n\t  */\n\t s.get = function (src) {\n\t\tvar t = s._tags[src];\n\t\tif (t == null) {\n\t\t\t// create new base tag\n\t\t\tt = s._tags[src] = s._tagPool.get();\n\t\t\tt.src = src;\n\t\t} else {\n\t\t\t// get base or pool\n\t\t\tif (s._tagUsed[src]) {\n\t\t\t\tt = s._tagPool.get();\n\t\t\t\tt.src = src;\n\t\t\t} else {\n\t\t\t\ts._tagUsed[src] = true;\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t };\n\n\t /**\n\t  * Return an audio tag to the pool.\n\t  * @method set\n\t  * @param {String} src The source file used by the audio tag.\n\t  * @param {HTMLElement} tag Audio tag to set.\n\t  * @static\n\t  */\n\t s.set = function (src, tag) {\n\t\t // check if this is base, if yes set boolean if not return to pool\n\t\t if(tag == s._tags[src]) {\n\t\t\t s._tagUsed[src] = false;\n\t\t } else {\n\t\t\t s._tagPool.set(tag);\n\t\t }\n\t };\n\n\t/**\n\t * Delete stored tag reference and return them to pool. Note that if the tag reference does not exist, this will fail.\n\t * @method remove\n\t * @param {String} src The source for the tag\n\t * @return {Boolean} If the TagPool was deleted.\n\t * @static\n\t */\n\ts.remove = function (src) {\n\t\tvar tag = s._tags[src];\n\t\tif (tag == null) {return false;}\n\t\ts._tagPool.set(tag);\n\t\tdelete(s._tags[src]);\n\t\tdelete(s._tagUsed[src]);\n\t\treturn true;\n\t};\n\n\t/**\n\t * Gets the duration of the src audio in milliseconds\n\t * @method getDuration\n\t * @param {String} src The source file used by the audio tag.\n\t * @return {Number} Duration of src in milliseconds\n\t * @static\n\t */\n\ts.getDuration= function (src) {\n\t\tvar t = s._tags[src];\n\t\tif (t == null || !t.duration) {return 0;}\t// OJR duration is NaN if loading has not completed\n\t\treturn t.duration * 1000;\n\t};\n\n\tcreatejs.HTMLAudioTagPool = HTMLAudioTagPool;\n\n\n// ************************************************************************************************************\n\t/**\n\t * The TagPool is an object pool for HTMLAudio tag instances.\n\t * #class TagPool\n\t * @param {String} src The source of the channel.\n\t * @protected\n\t */\n\tfunction TagPool(src) {\n\n// Public Properties\n\t\t/**\n\t\t * A list of all available tags in the pool.\n\t\t * #property tags\n\t\t * @type {Array}\n\t\t * @protected\n\t\t */\n\t\tthis._tags = [];\n\t};\n\n\tvar p = TagPool.prototype;\n\tp.constructor = TagPool;\n\n\n// Public Methods\n\t/**\n\t * Get an HTMLAudioElement for immediate playback. This takes it out of the pool.\n\t * #method get\n\t * @return {HTMLAudioElement} An HTML audio tag.\n\t */\n\tp.get = function () {\n\t\tvar tag;\n\t\tif (this._tags.length == 0) {\n\t\t\ttag = this._createTag();\n\t\t} else {\n\t\t\ttag = this._tags.pop();\n\t\t}\n\t\tif (tag.parentNode == null) {document.body.appendChild(tag);}\n\t\treturn tag;\n\t};\n\n\t/**\n\t * Put an HTMLAudioElement back in the pool for use.\n\t * #method set\n\t * @param {HTMLAudioElement} tag HTML audio tag\n\t */\n\tp.set = function (tag) {\n\t\t// OJR this first step seems unnecessary\n\t\tvar index = createjs.indexOf(this._tags, tag);\n\t\tif (index == -1) {\n\t\t\tthis._tags.src = null;\n\t\t\tthis._tags.push(tag);\n\t\t}\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[TagPool]\";\n\t};\n\n\n// Private Methods\n\t/**\n\t * Create an HTML audio tag.\n\t * #method _createTag\n\t * @param {String} src The source file to set for the audio tag.\n\t * @return {HTMLElement} Returns an HTML audio tag.\n\t * @protected\n\t */\n\tp._createTag = function () {\n\t\tvar tag = document.createElement(\"audio\");\n\t\ttag.autoplay = false;\n\t\ttag.preload = \"none\";\n\t\t//LM: Firefox fails when this the preload=\"none\" for other tags, but it needs to be \"none\" to ensure PreloadJS works.\n\t\treturn tag;\n\t};\n\n}());\n\n//##############################################################################\n// HTMLAudioSoundInstance.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * HTMLAudioSoundInstance extends the base api of {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} and is used by\n\t * {{#crossLink \"HTMLAudioPlugin\"}}{{/crossLink}}.\n\t *\n\t * @param {String} src The path to and file name of the sound.\n\t * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n\t * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n\t * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\n\t * @class HTMLAudioSoundInstance\n\t * @extends AbstractSoundInstance\n\t * @constructor\n\t */\n\tfunction HTMLAudioSoundInstance(src, startTime, duration, playbackResource) {\n\t\tthis.AbstractSoundInstance_constructor(src, startTime, duration, playbackResource);\n\n\n// Private Properties\n\t\tthis._audioSpriteStopTime = null;\n\t\tthis._delayTimeoutId = null;\n\n\t\t// Proxies, make removing listeners easier.\n\t\tthis._endedHandler = createjs.proxy(this._handleSoundComplete, this);\n\t\tthis._readyHandler = createjs.proxy(this._handleTagReady, this);\n\t\tthis._stalledHandler = createjs.proxy(this._playFailed, this);\n\t\tthis._audioSpriteEndHandler = createjs.proxy(this._handleAudioSpriteLoop, this);\n\t\tthis._loopHandler = createjs.proxy(this._handleSoundComplete, this);\n\n\t\tif (duration) {\n\t\t\tthis._audioSpriteStopTime = (startTime + duration) * 0.001;\n\t\t} else {\n\t\t\tthis._duration = createjs.HTMLAudioTagPool.getDuration(this.src);\n\t\t}\n\t}\n\tvar p = createjs.extend(HTMLAudioSoundInstance, createjs.AbstractSoundInstance);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Public Methods\n\t/**\n\t * Called by {{#crossLink \"Sound\"}}{{/crossLink}} when plugin does not handle master volume.\n\t * undoc'd because it is not meant to be used outside of Sound\n\t * #method setMasterVolume\n\t * @param value\n\t */\n\tp.setMasterVolume = function (value) {\n\t\tthis._updateVolume();\n\t};\n\n\t/**\n\t * Called by {{#crossLink \"Sound\"}}{{/crossLink}} when plugin does not handle master mute.\n\t * undoc'd because it is not meant to be used outside of Sound\n\t * #method setMasterMute\n\t * @param value\n\t */\n\tp.setMasterMute = function (isMuted) {\n\t\tthis._updateVolume();\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[HTMLAudioSoundInstance]\";\n\t};\n\n//Private Methods\n\tp._removeLooping = function() {\n\t\tif(this._playbackResource == null) {return;}\n\t\tthis._playbackResource.loop = false;\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t};\n\n\tp._addLooping = function() {\n\t\tif(this._playbackResource == null  || this._audioSpriteStopTime) {return;}\n\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\tthis._playbackResource.loop = true;\n\t};\n\n\tp._handleCleanUp = function () {\n\t\tvar tag = this._playbackResource;\n\t\tif (tag != null) {\n\t\t\ttag.pause();\n\t\t\ttag.loop = false;\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\n\t\t\ttry {\n\t\t\t\ttag.currentTime = this._startTime;\n\t\t\t} catch (e) {\n\t\t\t} // Reset Position\n\t\t\tcreatejs.HTMLAudioTagPool.set(this.src, tag);\n\t\t\tthis._playbackResource = null;\n\t\t}\n\t};\n\n\tp._beginPlaying = function (playProps) {\n\t\tthis._playbackResource = createjs.HTMLAudioTagPool.get(this.src);\n\t\treturn this.AbstractSoundInstance__beginPlaying(playProps);\n\t};\n\n\tp._handleSoundReady = function (event) {\n\t\tif (this._playbackResource.readyState !== 4) {\n\t\t\tvar tag = this._playbackResource;\n\t\t\ttag.addEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\n\t\t\ttag.addEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\n\t\t\ttag.preload = \"auto\"; // This is necessary for Firefox, as it won't ever \"load\" until this is set.\n\t\t\ttag.load();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._updateVolume();\n\t\tthis._playbackResource.currentTime = (this._startTime + this._position) * 0.001;\n\t\tif (this._audioSpriteStopTime) {\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\t\t} else {\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\tif(this._loop != 0) {\n\t\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\t\t\tthis._playbackResource.loop = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._playbackResource.play();\n\t};\n\n\t/**\n\t * Used to handle when a tag is not ready for immediate playback when it is returned from the HTMLAudioTagPool.\n\t * @method _handleTagReady\n\t * @param event\n\t * @protected\n\t */\n\tp._handleTagReady = function (event) {\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\n\n\t\tthis._handleSoundReady();\n\t};\n\n\tp._pause = function () {\n\t\tthis._playbackResource.pause();\n\t};\n\n\tp._resume = function () {\n\t\tthis._playbackResource.play();\n\t};\n\n\tp._updateVolume = function () {\n\t\tif (this._playbackResource != null) {\n\t\t\tvar newVolume = (this._muted || createjs.Sound._masterMute) ? 0 : this._volume * createjs.Sound._masterVolume;\n\t\t\tif (newVolume != this._playbackResource.volume) {this._playbackResource.volume = newVolume;}\n\t\t}\n\t};\n\n\tp._calculateCurrentPosition = function() {\n\t\treturn (this._playbackResource.currentTime * 1000) - this._startTime;\n\t};\n\n\tp._updatePosition = function() {\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, false);\n\t\ttry {\n\t\t\tthis._playbackResource.currentTime = (this._position + this._startTime) * 0.001;\n\t\t} catch (error) { // Out of range\n\t\t\tthis._handleSetPositionSeek(null);\n\t\t}\n\t};\n\n\t/**\n\t * Used to enable setting position, as we need to wait for that seek to be done before we add back our loop handling seek listener\n\t * @method _handleSetPositionSeek\n\t * @param event\n\t * @protected\n\t */\n\tp._handleSetPositionSeek = function(event) {\n\t\tif (this._playbackResource == null) { return; }\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, false);\n\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t};\n\n\t/**\n\t * Timer used to loop audio sprites.\n\t * NOTE because of the inaccuracies in the timeupdate event (15 - 250ms) and in setting the tag to the desired timed\n\t * (up to 300ms), it is strongly recommended not to loop audio sprites with HTML Audio if smooth looping is desired\n\t *\n\t * @method _handleAudioSpriteLoop\n\t * @param event\n\t * @private\n\t */\n\tp._handleAudioSpriteLoop = function (event) {\n\t\tif(this._playbackResource.currentTime <= this._audioSpriteStopTime) {return;}\n\t\tthis._playbackResource.pause();\n\t\tif(this._loop == 0) {\n\t\t\tthis._handleSoundComplete(null);\n\t\t} else {\n\t\t\tthis._position = 0;\n\t\t\tthis._loop--;\n\t\t\tthis._playbackResource.currentTime = this._startTime * 0.001;\n\t\t\tif(!this._paused) {this._playbackResource.play();}\n\t\t\tthis._sendEvent(\"loop\");\n\t\t}\n\t};\n\n\t// NOTE with this approach audio will loop as reliably as the browser allows\n\t// but we could end up sending the loop event after next loop playback begins\n\tp._handleLoop = function (event) {\n\t\tif(this._loop == 0) {\n\t\t\tthis._playbackResource.loop = false;\n\t\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\t}\n\t};\n\n\tp._updateStartTime = function () {\n\t\tthis._audioSpriteStopTime = (this._startTime + this._duration) * 0.001;\n\n\t\tif(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\t\t}\n\t};\n\n\tp._updateDuration = function () {\n\t\tthis._audioSpriteStopTime = (this._startTime + this._duration) * 0.001;\n\n\t\tif(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\t\t}\n\t};\n\n\tp._setDurationFromSource = function () {\n\t\tthis._duration = createjs.HTMLAudioTagPool.getDuration(this.src);\n\t\tthis._playbackResource = null;\n\t};\n\n\tcreatejs.HTMLAudioSoundInstance = createjs.promote(HTMLAudioSoundInstance, \"AbstractSoundInstance\");\n}());\n\n//##############################################################################\n// HTMLAudioPlugin.js\n//##############################################################################\n\n(function () {\n\n\t\"use strict\";\n\n\t/**\n\t * Play sounds using HTML &lt;audio&gt; tags in the browser. This plugin is the second priority plugin installed\n\t * by default, after the {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}.  For older browsers that do not support html\n\t * audio, include and install the {{#crossLink \"FlashAudioPlugin\"}}{{/crossLink}}.\n\t *\n\t * <h4>Known Browser and OS issues for HTML Audio</h4>\n\t * <b>All browsers</b><br />\n\t * Testing has shown in all browsers there is a limit to how many audio tag instances you are allowed.  If you exceed\n\t * this limit, you can expect to see unpredictable results. Please use {{#crossLink \"Sound.MAX_INSTANCES\"}}{{/crossLink}} as\n\t * a guide to how many total audio tags you can safely use in all browsers.  This issue is primarily limited to IE9.\n\t *\n     * <b>IE html limitations</b><br />\n     * <ul><li>There is a delay in applying volume changes to tags that occurs once playback is started. So if you have\n     * muted all sounds, they will all play during this delay until the mute applies internally. This happens regardless of\n     * when or how you apply the volume change, as the tag seems to need to play to apply it.</li>\n     * <li>MP3 encoding will not always work for audio tags if it's not default.  We've found default encoding with\n     * 64kbps works.</li>\n\t * <li>Occasionally very short samples will get cut off.</li>\n\t * <li>There is a limit to how many audio tags you can load or play at once, which appears to be determined by\n\t * hardware and browser settings.  See {{#crossLink \"HTMLAudioPlugin.MAX_INSTANCES\"}}{{/crossLink}} for a safe estimate.\n\t * Note that audio sprites can be used as a solution to this issue.</li></ul>\n\t *\n\t * <b>Safari limitations</b><br />\n\t * <ul><li>Safari requires Quicktime to be installed for audio playback.</li></ul>\n\t *\n\t * <b>iOS 6 limitations</b><br />\n\t * <ul><li>can only have one &lt;audio&gt; tag</li>\n\t * \t\t<li>can not preload or autoplay the audio</li>\n\t * \t\t<li>can not cache the audio</li>\n\t * \t\t<li>can not play the audio except inside a user initiated event.</li>\n\t *\t\t<li>Note it is recommended to use {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}} for iOS (6+)</li>\n\t * \t\t<li>audio sprites can be used to mitigate some of these issues and are strongly recommended on iOS</li>\n\t * </ul>\n\t *\n\t * <b>Android Native Browser limitations</b><br />\n\t * <ul><li>We have no control over audio volume. Only the user can set volume on their device.</li>\n\t *      <li>We can only play audio inside a user event (touch/click).  This currently means you cannot loop sound or use a delay.</li></ul>\n\t * <b> Android Chrome 26.0.1410.58 specific limitations</b><br />\n\t * <ul> <li>Can only play 1 sound at a time.</li>\n\t *      <li>Sound is not cached.</li>\n\t *      <li>Sound can only be loaded in a user initiated touch/click event.</li>\n\t *      <li>There is a delay before a sound is played, presumably while the src is loaded.</li>\n\t * </ul>\n\t *\n\t * See {{#crossLink \"Sound\"}}{{/crossLink}} for general notes on known issues.\n\t *\n\t * @class HTMLAudioPlugin\n\t * @extends AbstractPlugin\n\t * @constructor\n\t */\n\tfunction HTMLAudioPlugin() {\n\t\tthis.AbstractPlugin_constructor();\n\n\n\t// Public Properties\n\t\t/**\n\t\t * This is no longer needed as we are now using object pooling for tags.\n\t\t *\n\t\t * <b>NOTE this property only exists as a limitation of HTML audio.</b>\n\t\t * @property defaultNumChannels\n\t\t * @type {Number}\n\t\t * @default 2\n\t\t * @since 0.4.0\n\t\t * @deprecated\n\t\t */\n\t\tthis.defaultNumChannels = 2;\n\n\t\tthis._capabilities = s._capabilities;\n\n\t\tthis._loaderClass = createjs.SoundLoader;\n\t\tthis._soundInstanceClass = createjs.HTMLAudioSoundInstance;\n\t}\n\n\tvar p = createjs.extend(HTMLAudioPlugin, createjs.AbstractPlugin);\n\tvar s = HTMLAudioPlugin;\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Static Properties\n\t/**\n\t * The maximum number of instances that can be loaded or played. This is a browser limitation, primarily limited to IE9.\n\t * The actual number varies from browser to browser (and is largely hardware dependant), but this is a safe estimate.\n\t * Audio sprites work around this limitation.\n\t * @property MAX_INSTANCES\n\t * @type {Number}\n\t * @default 30\n\t * @static\n\t */\n\ts.MAX_INSTANCES = 30;\n\n\t/**\n\t * Event constant for the \"canPlayThrough\" event for cleaner code.\n\t * @property _AUDIO_READY\n\t * @type {String}\n\t * @default canplaythrough\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_READY = \"canplaythrough\";\n\n\t/**\n\t * Event constant for the \"ended\" event for cleaner code.\n\t * @property _AUDIO_ENDED\n\t * @type {String}\n\t * @default ended\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_ENDED = \"ended\";\n\n\t/**\n\t * Event constant for the \"seeked\" event for cleaner code.  We utilize this event for maintaining loop events.\n\t * @property _AUDIO_SEEKED\n\t * @type {String}\n\t * @default seeked\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_SEEKED = \"seeked\";\n\n\t/**\n\t * Event constant for the \"stalled\" event for cleaner code.\n\t * @property _AUDIO_STALLED\n\t * @type {String}\n\t * @default stalled\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_STALLED = \"stalled\";\n\n\t/**\n\t * Event constant for the \"timeupdate\" event for cleaner code.  Utilized for looping audio sprites.\n\t * This event callsback ever 15 to 250ms and can be dropped by the browser for performance.\n\t * @property _TIME_UPDATE\n\t * @type {String}\n\t * @default timeupdate\n\t * @static\n\t * @protected\n\t */\n\ts._TIME_UPDATE = \"timeupdate\";\n\n\t/**\n\t * The capabilities of the plugin. This is generated via the {{#crossLink \"HTMLAudioPlugin/_generateCapabilities\"}}{{/crossLink}}\n\t * method. Please see the Sound {{#crossLink \"Sound/getCapabilities\"}}{{/crossLink}} method for an overview of all\n\t * of the available properties.\n\t * @property _capabilities\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t */\n\ts._capabilities = null;\n\n\n// Static Methods\n\t/**\n\t * Determine if the plugin can be used in the current browser/OS. Note that HTML audio is available in most modern\n\t * browsers, but is disabled in iOS because of its limitations.\n\t * @method isSupported\n\t * @return {Boolean} If the plugin can be initialized.\n\t * @static\n\t */\n\ts.isSupported = function () {\n\t\ts._generateCapabilities();\n\t\treturn (s._capabilities != null);\n\t};\n\n\t/**\n\t * Determine the capabilities of the plugin. Used internally. Please see the Sound API {{#crossLink \"Sound/getCapabilities\"}}{{/crossLink}}\n\t * method for an overview of plugin capabilities.\n\t * @method _generateCapabilities\n\t * @static\n\t * @protected\n\t */\n\ts._generateCapabilities = function () {\n\t\tif (s._capabilities != null) {return;}\n\t\tvar t = document.createElement(\"audio\");\n\t\tif (t.canPlayType == null) {return null;}\n\n\t\ts._capabilities = {\n\t\t\tpanning:false,\n\t\t\tvolume:true,\n\t\t\ttracks:-1\n\t\t};\n\n\t\t// determine which extensions our browser supports for this plugin by iterating through Sound.SUPPORTED_EXTENSIONS\n\t\tvar supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;\n\t\tvar extensionMap = createjs.Sound.EXTENSION_MAP;\n\t\tfor (var i = 0, l = supportedExtensions.length; i < l; i++) {\n\t\t\tvar ext = supportedExtensions[i];\n\t\t\tvar playType = extensionMap[ext] || ext;\n\t\t\ts._capabilities[ext] = (t.canPlayType(\"audio/\" + ext) != \"no\" && t.canPlayType(\"audio/\" + ext) != \"\") || (t.canPlayType(\"audio/\" + playType) != \"no\" && t.canPlayType(\"audio/\" + playType) != \"\");\n\t\t}  // OJR another way to do this might be canPlayType:\"m4a\", codex: mp4\n\t};\n\n\n// public methods\n\tp.register = function (loadItem) {\n\t\tvar tag = createjs.HTMLAudioTagPool.get(loadItem.src);\n\t\tvar loader = this.AbstractPlugin_register(loadItem);\n\t\tloader.setTag(tag);\n\n\t\treturn loader;\n\t};\n\n\tp.removeSound = function (src) {\n\t\tthis.AbstractPlugin_removeSound(src);\n\t\tcreatejs.HTMLAudioTagPool.remove(src);\n\t};\n\n\tp.create = function (src, startTime, duration) {\n\t\tvar si = this.AbstractPlugin_create(src, startTime, duration);\n\t\tsi.setPlaybackResource(null);\n\t\treturn si;\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[HTMLAudioPlugin]\";\n\t};\n\n\t// plugin does not support these\n\tp.setVolume = p.getVolume = p.setMute = null;\n\n\n\tcreatejs.HTMLAudioPlugin = createjs.promote(HTMLAudioPlugin, \"AbstractPlugin\");\n}());\n\n//##############################################################################\n// Tween.js\n//##############################################################################\n\n// TODO: possibly add a END actionsMode (only runs actions that == position)?\n// TODO: evaluate a way to decouple paused from tick registration.\n\n\n\n\n(function() {\n\t\"use strict\";\n\n\n// constructor\n\t/**\n\t * A Tween instance tweens properties for a single target. Instance methods can be chained for easy construction and sequencing:\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      target.alpha = 1;\n\t *\t    createjs.Tween.get(target)\n\t *\t         .wait(500)\n\t *\t         .to({alpha:0, visible:false}, 1000)\n\t *\t         .call(handleComplete);\n\t *\t    function handleComplete() {\n\t *\t    \t//Tween complete\n\t *\t    }\n\t *\n\t * Multiple tweens can point to the same instance, however if they affect the same properties there could be unexpected\n\t * behaviour. To stop all tweens on an object, use {{#crossLink \"Tween/removeTweens\"}}{{/crossLink}} or pass `override:true`\n\t * in the props argument.\n\t *\n\t *      createjs.Tween.get(target, {override:true}).to({x:100});\n\t *\n\t * Subscribe to the {{#crossLink \"Tween/change:event\"}}{{/crossLink}} event to get notified when a property of the\n\t * target is changed.\n\t *\n\t *      createjs.Tween.get(target, {override:true}).to({x:100}).addEventListener(\"change\", handleChange);\n\t *      function handleChange(event) {\n\t *          // The tween changed.\n\t *      }\n\t *\n\t * See the Tween {{#crossLink \"Tween/get\"}}{{/crossLink}} method for additional param documentation.\n\t * @class Tween\n\t * @param {Object} target The target object that will have its properties tweened.\n\t * @param {Object} [props] The configuration properties to apply to this tween instance (ex. `{loop:true, paused:true}`.\n\t * All properties default to false. Supported props are:<UL>\n\t *    <LI> loop: sets the loop property on this tween.</LI>\n\t *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>\n\t *    <LI> ignoreGlobalPause: sets the {{#crossLink \"Tween/ignoreGlobalPause:property\"}}{{/crossLink}} property on this tween.</LI>\n\t *    <LI> override: if true, `Tween.removeTweens(target)` will be called to remove any other tweens with the same target.\n\t *    <LI> paused: indicates whether to start the tween paused.</LI>\n\t *    <LI> position: indicates the initial position for this tween.</LI>\n\t *    <LI> onChange: specifies a listener for the \"change\" event.</LI>\n\t * </UL>\n\t * @param {Object} [pluginData] An object containing data for use by installed plugins. See individual\n\t * plugins' documentation for details.\n\t * @extends EventDispatcher\n\t * @constructor\n\t */\n\tfunction Tween(target, props, pluginData) {\n\n\t// public properties:\n\t\t/**\n\t\t * Causes this tween to continue playing when a global pause is active. For example, if TweenJS is using {{#crossLink \"Ticker\"}}{{/crossLink}},\n\t\t * then setting this to true (the default) will cause this tween to be paused when <code>Ticker.setPaused(true)</code>\n\t\t * is called. See the Tween {{#crossLink \"Tween/tick\"}}{{/crossLink}} method for more info. Can be set via the props\n\t\t * parameter.\n\t\t * @property ignoreGlobalPause\n\t\t * @type Boolean\n\t\t * @default false\n\t\t */\n\t\tthis.ignoreGlobalPause = false;\n\t\n\t\t/**\n\t\t * If true, the tween will loop when it reaches the end. Can be set via the props param.\n\t\t * @property loop\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.loop = false;\n\t\n\t\t/**\n\t\t * Specifies the total duration of this tween in milliseconds (or ticks if useTicks is true).\n\t\t * This value is automatically updated as you modify the tween. Changing it directly could result in unexpected\n\t\t * behaviour.\n\t\t * @property duration\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.duration = 0;\n\t\n\t\t/**\n\t\t * Allows you to specify data that will be used by installed plugins. Each plugin uses this differently, but in general\n\t\t * you specify data by setting it to a property of pluginData with the same name as the plugin class.\n\t\t * @example\n\t\t *\tmyTween.pluginData.PluginClassName = data;\n\t\t * <br/>\n\t\t * Also, most plugins support a property to enable or disable them. This is typically the plugin class name followed by \"_enabled\".<br/>\n\t\t * @example\n\t\t *\tmyTween.pluginData.PluginClassName_enabled = false;<br/>\n\t\t * <br/>\n\t\t * Some plugins also store instance data in this object, usually in a property named _PluginClassName.\n\t\t * See the documentation for individual plugins for more details.\n\t\t * @property pluginData\n\t\t * @type {Object}\n\t\t */\n\t\tthis.pluginData = pluginData || {};\n\t\n\t\t/**\n\t\t * The target of this tween. This is the object on which the tweened properties will be changed. Changing\n\t\t * this property after the tween is created will not have any effect.\n\t\t * @property target\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t */\n\t\tthis.target = target;\n\t\n\t\t/**\n\t\t * The current normalized position of the tween. This will always be a value between 0 and duration.\n\t\t * Changing this property directly will have no effect.\n\t\t * @property position\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t */\n\t\tthis.position = null;\n\t\n\t\t/**\n\t\t * Indicates the tween's current position is within a passive wait.\n\t\t * @property passive\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t **/\n\t\tthis.passive = false;\n\t\n\t// private properties:\t\n\t\t/**\n\t\t * @property _paused\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._paused = false;\n\t\n\t\t/**\n\t\t * @property _curQueueProps\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._curQueueProps = {};\n\t\n\t\t/**\n\t\t * @property _initQueueProps\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._initQueueProps = {};\n\t\n\t\t/**\n\t\t * @property _steps\n\t\t * @type {Array}\n\t\t * @protected\n\t\t */\n\t\tthis._steps = [];\n\t\n\t\t/**\n\t\t * @property _actions\n\t\t * @type {Array}\n\t\t * @protected\n\t\t */\n\t\tthis._actions = [];\n\t\n\t\t/**\n\t\t * Raw position.\n\t\t * @property _prevPosition\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @protected\n\t\t */\n\t\tthis._prevPosition = 0;\n\t\n\t\t/**\n\t\t * The position within the current step.\n\t\t * @property _stepPosition\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @protected\n\t\t */\n\t\tthis._stepPosition = 0; // this is needed by MovieClip.\n\t\n\t\t/**\n\t\t * Normalized position.\n\t\t * @property _prevPos\n\t\t * @type {Number}\n\t\t * @default -1\n\t\t * @protected\n\t\t */\n\t\tthis._prevPos = -1;\n\t\n\t\t/**\n\t\t * @property _target\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._target = target;\n\t\n\t\t/**\n\t\t * @property _useTicks\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._useTicks = false;\n\t\n\t\t/**\n\t\t * @property _inited\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._inited = false;\n\t\t\n\t\t/**\n\t\t * Indicates whether the tween is currently registered with Tween.\n\t\t * @property _registered\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._registered = false;\n\n\n\t\tif (props) {\n\t\t\tthis._useTicks = props.useTicks;\n\t\t\tthis.ignoreGlobalPause = props.ignoreGlobalPause;\n\t\t\tthis.loop = props.loop;\n\t\t\tprops.onChange && this.addEventListener(\"change\", props.onChange);\n\t\t\tif (props.override) { Tween.removeTweens(target); }\n\t\t}\n\t\tif (props&&props.paused) { this._paused=true; }\n\t\telse { createjs.Tween._register(this,true); }\n\t\tif (props&&props.position!=null) { this.setPosition(props.position, Tween.NONE); }\n\n\t};\n\n\tvar p = createjs.extend(Tween, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\n// static properties\n\t/**\n\t * Constant defining the none actionsMode for use with setPosition.\n\t * @property NONE\n\t * @type Number\n\t * @default 0\n\t * @static\n\t */\n\tTween.NONE = 0;\n\n\t/**\n\t * Constant defining the loop actionsMode for use with setPosition.\n\t * @property LOOP\n\t * @type Number\n\t * @default 1\n\t * @static\n\t */\n\tTween.LOOP = 1;\n\n\t/**\n\t * Constant defining the reverse actionsMode for use with setPosition.\n\t * @property REVERSE\n\t * @type Number\n\t * @default 2\n\t * @static\n\t */\n\tTween.REVERSE = 2;\n\n\t/**\n\t * Constant returned by plugins to tell the tween not to use default assignment.\n\t * @property IGNORE\n\t * @type Object\n\t * @static\n\t */\n\tTween.IGNORE = {};\n\n\t/**\n\t * @property _listeners\n\t * @type Array[Tween]\n\t * @static\n\t * @protected\n\t */\n\tTween._tweens = [];\n\n\t/**\n\t * @property _plugins\n\t * @type Object\n\t * @static\n\t * @protected\n\t */\n\tTween._plugins = {};\n\n\n// static methods\t\n\t/**\n\t * Returns a new tween instance. This is functionally identical to using \"new Tween(...)\", but looks cleaner\n\t * with the chained syntax of TweenJS.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tvar tween = createjs.Tween.get(target);\n\t *\n\t * @method get\n\t * @param {Object} target The target object that will have its properties tweened.\n\t * @param {Object} [props] The configuration properties to apply to this tween instance (ex. `{loop:true, paused:true}`).\n\t * All properties default to `false`. Supported props are:\n\t * <UL>\n\t *    <LI> loop: sets the loop property on this tween.</LI>\n\t *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>\n\t *    <LI> ignoreGlobalPause: sets the {{#crossLink \"Tween/ignoreGlobalPause:property\"}}{{/crossLink}} property on\n\t *    this tween.</LI>\n\t *    <LI> override: if true, `createjs.Tween.removeTweens(target)` will be called to remove any other tweens with\n\t *    the same target.\n\t *    <LI> paused: indicates whether to start the tween paused.</LI>\n\t *    <LI> position: indicates the initial position for this tween.</LI>\n\t *    <LI> onChange: specifies a listener for the {{#crossLink \"Tween/change:event\"}}{{/crossLink}} event.</LI>\n\t * </UL>\n\t * @param {Object} [pluginData] An object containing data for use by installed plugins. See individual plugins'\n\t * documentation for details.\n\t * @param {Boolean} [override=false] If true, any previous tweens on the same target will be removed. This is the\n\t * same as calling `Tween.removeTweens(target)`.\n\t * @return {Tween} A reference to the created tween. Additional chained tweens, method calls, or callbacks can be\n\t * applied to the returned tween instance.\n\t * @static\n\t */\n\tTween.get = function(target, props, pluginData, override) {\n\t\tif (override) { Tween.removeTweens(target); }\n\t\treturn new Tween(target, props, pluginData);\n\t};\n\n\t/**\n\t * Advances all tweens. This typically uses the {{#crossLink \"Ticker\"}}{{/crossLink}} class, but you can call it\n\t * manually if you prefer to use your own \"heartbeat\" implementation.\n\t * @method tick\n\t * @param {Number} delta The change in time in milliseconds since the last tick. Required unless all tweens have\n\t * `useTicks` set to true.\n\t * @param {Boolean} paused Indicates whether a global pause is in effect. Tweens with {{#crossLink \"Tween/ignoreGlobalPause:property\"}}{{/crossLink}}\n\t * will ignore this, but all others will pause if this is `true`.\n\t * @static\n\t */\n\tTween.tick = function(delta, paused) {\n\t\tvar tweens = Tween._tweens.slice(); // to avoid race conditions.\n\t\tfor (var i=tweens.length-1; i>=0; i--) {\n\t\t\tvar tween = tweens[i];\n\t\t\tif ((paused && !tween.ignoreGlobalPause) || tween._paused) { continue; }\n\t\t\ttween.tick(tween._useTicks?1:delta);\n\t\t}\n\t};\n\n\t/**\n\t * Handle events that result from Tween being used as an event handler. This is included to allow Tween to handle\n\t * {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}} events from the createjs {{#crossLink \"Ticker\"}}{{/crossLink}}.\n\t * No other events are handled in Tween.\n\t * @method handleEvent\n\t * @param {Object} event An event object passed in by the {{#crossLink \"EventDispatcher\"}}{{/crossLink}}. Will\n\t * usually be of type \"tick\".\n\t * @private\n\t * @static\n\t * @since 0.4.2\n\t */\n\tTween.handleEvent = function(event) {\n\t\tif (event.type == \"tick\") {\n\t\t\tthis.tick(event.delta, event.paused);\n\t\t}\n\t};\n\n\t/**\n\t * Removes all existing tweens for a target. This is called automatically by new tweens if the `override`\n\t * property is `true`.\n\t * @method removeTweens\n\t * @param {Object} target The target object to remove existing tweens from.\n\t * @static\n\t */\n\tTween.removeTweens = function(target) {\n\t\tif (!target.tweenjs_count) { return; }\n\t\tvar tweens = Tween._tweens;\n\t\tfor (var i=tweens.length-1; i>=0; i--) {\n\t\t\tvar tween = tweens[i];\n\t\t\tif (tween._target == target) {\n\t\t\t\ttween._paused = true;\n\t\t\t\ttweens.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\ttarget.tweenjs_count = 0;\n\t};\n\n\t/**\n\t * Stop and remove all existing tweens.\n\t * @method removeAllTweens\n\t * @static\n\t * @since 0.4.1\n\t */\n\tTween.removeAllTweens = function() {\n\t\tvar tweens = Tween._tweens;\n\t\tfor (var i= 0, l=tweens.length; i<l; i++) {\n\t\t\tvar tween = tweens[i];\n\t\t\ttween._paused = true;\n\t\t\ttween.target&&(tween.target.tweenjs_count = 0);\n\t\t}\n\t\ttweens.length = 0;\n\t};\n\n\t/**\n\t * Indicates whether there are any active tweens (and how many) on the target object (if specified) or in general.\n\t * @method hasActiveTweens\n\t * @param {Object} [target] The target to check for active tweens. If not specified, the return value will indicate\n\t * if there are any active tweens on any target.\n\t * @return {Boolean} If there are active tweens.\n\t * @static\n\t */\n\tTween.hasActiveTweens = function(target) {\n\t\tif (target) { return target.tweenjs_count != null && !!target.tweenjs_count; }\n\t\treturn Tween._tweens && !!Tween._tweens.length;\n\t};\n\n\t/**\n\t * Installs a plugin, which can modify how certain properties are handled when tweened. See the {{#crossLink \"CSSPlugin\"}}{{/crossLink}}\n\t * for an example of how to write TweenJS plugins.\n\t * @method installPlugin\n\t * @static\n\t * @param {Object} plugin The plugin class to install\n\t * @param {Array} properties An array of properties that the plugin will handle.\n\t */\n\tTween.installPlugin = function(plugin, properties) {\n\t\tvar priority = plugin.priority;\n\t\tif (priority == null) { plugin.priority = priority = 0; }\n\t\tfor (var i=0,l=properties.length,p=Tween._plugins;i<l;i++) {\n\t\t\tvar n = properties[i];\n\t\t\tif (!p[n]) { p[n] = [plugin]; }\n\t\t\telse {\n\t\t\t\tvar arr = p[n];\n\t\t\t\tfor (var j=0,jl=arr.length;j<jl;j++) {\n\t\t\t\t\tif (priority < arr[j].priority) { break; }\n\t\t\t\t}\n\t\t\t\tp[n].splice(j,0,plugin);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Registers or unregisters a tween with the ticking system.\n\t * @method _register\n\t * @param {Tween} tween The tween instance to register or unregister.\n\t * @param {Boolean} value If `true`, the tween is registered. If `false` the tween is unregistered.\n\t * @static\n\t * @protected\n\t */\n\tTween._register = function(tween, value) {\n\t\tvar target = tween._target;\n\t\tvar tweens = Tween._tweens;\n\t\tif (value && !tween._registered) {\n\t\t\t// TODO: this approach might fail if a dev is using sealed objects in ES5\n\t\t\tif (target) { target.tweenjs_count = target.tweenjs_count ? target.tweenjs_count+1 : 1; }\n\t\t\ttweens.push(tween);\n\t\t\tif (!Tween._inited && createjs.Ticker) { createjs.Ticker.addEventListener(\"tick\", Tween); Tween._inited = true; }\n\t\t} else if (!value && tween._registered) {\n\t\t\tif (target) { target.tweenjs_count--; }\n\t\t\tvar i = tweens.length;\n\t\t\twhile (i--) {\n\t\t\t\tif (tweens[i] == tween) {\n\t\t\t\t\ttweens.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttween._registered = value;\n\t};\n\n\n// events:\n\t/**\n\t * Called whenever the tween's position changes.\n\t * @event change\n\t * @since 0.4.0\n\t **/\n\t\n\n// public methods:\n\t/**\n\t * Queues a wait (essentially an empty tween).\n\t * <h4>Example</h4>\n\t *\n\t *\t\t//This tween will wait 1s before alpha is faded to 0.\n\t *\t\tcreatejs.Tween.get(target).wait(1000).to({alpha:0}, 1000);\n\t *\n\t * @method wait\n\t * @param {Number} duration The duration of the wait in milliseconds (or in ticks if `useTicks` is true).\n\t * @param {Boolean} [passive] Tween properties will not be updated during a passive wait. This\n\t * is mostly useful for use with {{#crossLink \"Timeline\"}}{{/crossLink}} instances that contain multiple tweens\n\t * affecting the same target at different times.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t **/\n\tp.wait = function(duration, passive) {\n\t\tif (duration == null || duration <= 0) { return this; }\n\t\tvar o = this._cloneProps(this._curQueueProps);\n\t\treturn this._addStep({d:duration, p0:o, e:this._linearEase, p1:o, v:passive});\n\t};\n\n\t/**\n\t * Queues a tween from the current values to the target properties. Set duration to 0 to jump to these value.\n\t * Numeric properties will be tweened from their current value in the tween to the target value. Non-numeric\n\t * properties will be set at the end of the specified duration.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tcreatejs.Tween.get(target).to({alpha:0}, 1000);\n\t *\n\t * @method to\n\t * @param {Object} props An object specifying property target values for this tween (Ex. `{x:300}` would tween the x\n\t * property of the target to 300).\n\t * @param {Number} [duration=0] The duration of the wait in milliseconds (or in ticks if `useTicks` is true).\n\t * @param {Function} [ease=\"linear\"] The easing function to use for this tween. See the {{#crossLink \"Ease\"}}{{/crossLink}}\n\t * class for a list of built-in ease functions.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.to = function(props, duration, ease) {\n\t\tif (isNaN(duration) || duration < 0) { duration = 0; }\n\t\treturn this._addStep({d:duration||0, p0:this._cloneProps(this._curQueueProps), e:ease, p1:this._cloneProps(this._appendQueueProps(props))});\n\t};\n\n\t/**\n\t * Queues an action to call the specified function.\n\t * <h4>Example</h4>\n\t *\n\t *   \t//would call myFunction() after 1 second.\n\t *   \tmyTween.wait(1000).call(myFunction);\n\t *\n\t * @method call\n\t * @param {Function} callback The function to call.\n\t * @param {Array} [params]. The parameters to call the function with. If this is omitted, then the function\n\t *      will be called with a single param pointing to this tween.\n\t * @param {Object} [scope]. The scope to call the function in. If omitted, it will be called in the target's\n\t *      scope.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.call = function(callback, params, scope) {\n\t\treturn this._addAction({f:callback, p:params ? params : [this], o:scope ? scope : this._target});\n\t};\n\n\t// TODO: add clarification between this and a 0 duration .to:\n\t/**\n\t * Queues an action to set the specified props on the specified target. If target is null, it will use this tween's\n\t * target.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tmyTween.wait(1000).set({visible:false},foo);\n\t *\n\t * @method set\n\t * @param {Object} props The properties to set (ex. `{visible:false}`).\n\t * @param {Object} [target] The target to set the properties on. If omitted, they will be set on the tween's target.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.set = function(props, target) {\n\t\treturn this._addAction({f:this._set, o:this, p:[props, target ? target : this._target]});\n\t};\n\n\t/**\n\t * Queues an action to play (unpause) the specified tween. This enables you to sequence multiple tweens.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tmyTween.to({x:100},500).play(otherTween);\n\t *\n\t * @method play\n\t * @param {Tween} tween The tween to play.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.play = function(tween) {\n\t\tif (!tween) { tween = this; }\n\t\treturn this.call(tween.setPaused, [false], tween);\n\t};\n\n\t/**\n\t * Queues an action to pause the specified tween.\n\t * @method pause\n\t * @param {Tween} tween The tween to pause. If null, it pauses this tween.\n\t * @return {Tween} This tween instance (for chaining calls)\n\t */\n\tp.pause = function(tween) {\n\t\tif (!tween) { tween = this; }\n\t\treturn this.call(tween.setPaused, [true], tween);\n\t};\n\n\t/**\n\t * Advances the tween to a specified position.\n\t * @method setPosition\n\t * @param {Number} value The position to seek to in milliseconds (or ticks if useTicks is true).\n\t * @param {Number} [actionsMode=1] Specifies how actions are handled (ie. call, set, play, pause):\n\t * <ul>\n\t *      <li>{{#crossLink \"Tween/NONE:property\"}}{{/crossLink}} (0) - run no actions.</li>\n\t *      <li>{{#crossLink \"Tween/LOOP:property\"}}{{/crossLink}} (1) - if new position is less than old, then run all\n\t *      actions between old and duration, then all actions between 0 and new.</li>\n\t *      <li>{{#crossLink \"Tween/REVERSE:property\"}}{{/crossLink}} (2) - if new position is less than old, run all\n\t *      actions between them in reverse.</li>\n\t * </ul>\n\t * @return {Boolean} Returns `true` if the tween is complete (ie. the full tween has run & {{#crossLink \"Tween/loop:property\"}}{{/crossLink}}\n\t * is `false`).\n\t */\n\tp.setPosition = function(value, actionsMode) {\n\t\tif (value < 0) { value = 0; }\n\t\tif (actionsMode == null) { actionsMode = 1; }\n\n\t\t// normalize position:\n\t\tvar t = value;\n\t\tvar end = false;\n\t\tif (t >= this.duration) {\n\t\t\tif (this.loop) { t = t%this.duration; }\n\t\t\telse {\n\t\t\t\tt = this.duration;\n\t\t\t\tend = true;\n\t\t\t}\n\t\t}\n\t\tif (t == this._prevPos) { return end; }\n\n\n\t\tvar prevPos = this._prevPos;\n\t\tthis.position = this._prevPos = t; // set this in advance in case an action modifies position.\n\t\tthis._prevPosition = value;\n\n\t\t// handle tweens:\n\t\tif (this._target) {\n\t\t\tif (end) {\n\t\t\t\t// addresses problems with an ending zero length step.\n\t\t\t\tthis._updateTargetProps(null,1);\n\t\t\t} else if (this._steps.length > 0) {\n\t\t\t\t// find our new tween index:\n\t\t\t\tfor (var i=0, l=this._steps.length; i<l; i++) {\n\t\t\t\t\tif (this._steps[i].t > t) { break; }\n\t\t\t\t}\n\t\t\t\tvar step = this._steps[i-1];\n\t\t\t\tthis._updateTargetProps(step,(this._stepPosition = t-step.t)/step.d);\n\t\t\t}\n\t\t}\n\n\t\t// run actions:\n\t\tif (actionsMode != 0 && this._actions.length > 0) {\n\t\t\tif (this._useTicks) {\n\t\t\t\t// only run the actions we landed on.\n\t\t\t\tthis._runActions(t,t);\n\t\t\t} else if (actionsMode == 1 && t<prevPos) {\n\t\t\t\tif (prevPos != this.duration) { this._runActions(prevPos, this.duration); }\n\t\t\t\tthis._runActions(0, t, true);\n\t\t\t} else {\n\t\t\t\tthis._runActions(prevPos, t);\n\t\t\t}\n\t\t}\n\n\t\tif (end) { this.setPaused(true); }\n\n        this.dispatchEvent(\"change\");\n\t\treturn end;\n\t};\n\n\t/**\n\t * Advances this tween by the specified amount of time in milliseconds (or ticks if`useTicks` is `true`).\n\t * This is normally called automatically by the Tween engine (via {{#crossLink \"Tween/tick\"}}{{/crossLink}}), but is\n\t * exposed for advanced uses.\n\t * @method tick\n\t * @param {Number} delta The time to advance in milliseconds (or ticks if `useTicks` is `true`).\n\t */\n\tp.tick = function(delta) {\n\t\tif (this._paused) { return; }\n\t\tthis.setPosition(this._prevPosition+delta);\n\t};\n\n\t/**\n\t * Pauses or plays this tween.\n\t * @method setPaused\n\t * @param {Boolean} [value=true] Indicates whether the tween should be paused (`true`) or played (`false`).\n\t * @return {Tween} This tween instance (for chaining calls)\n\t */\n\tp.setPaused = function(value) {\n\t\tif (this._paused === !!value) { return this; }\n\t\tthis._paused = !!value;\n\t\tTween._register(this, !value);\n\t\treturn this;\n\t};\n\n\t// tiny api (primarily for tool output):\n\tp.w = p.wait;\n\tp.t = p.to;\n\tp.c = p.call;\n\tp.s = p.set;\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t */\n\tp.toString = function() {\n\t\treturn \"[Tween]\";\n\t};\n\n\t/**\n\t * @method clone\n\t * @protected\n\t */\n\tp.clone = function() {\n\t\tthrow(\"Tween can not be cloned.\")\n\t};\n\n// private methods:\n\t/**\n\t * @method _updateTargetProps\n\t * @param {Object} step\n\t * @param {Number} ratio\n\t * @protected\n\t */\n\tp._updateTargetProps = function(step, ratio) {\n\t\tvar p0,p1,v,v0,v1,arr;\n\t\tif (!step && ratio == 1) {\n\t\t\t// GDS: when does this run? Just at the very end? Shouldn't.\n\t\t\tthis.passive = false;\n\t\t\tp0 = p1 = this._curQueueProps;\n\t\t} else {\n\t\t\tthis.passive = !!step.v;\n\t\t\tif (this.passive) { return; } // don't update props.\n\t\t\t// apply ease to ratio.\n\t\t\tif (step.e) { ratio = step.e(ratio,0,1,1); }\n\t\t\tp0 = step.p0;\n\t\t\tp1 = step.p1;\n\t\t}\n\n\t\tfor (var n in this._initQueueProps) {\n\t\t\tif ((v0 = p0[n]) == null) { p0[n] = v0 = this._initQueueProps[n]; }\n\t\t\tif ((v1 = p1[n]) == null) { p1[n] = v1 = v0; }\n\t\t\tif (v0 == v1 || ratio == 0 || ratio == 1 || (typeof(v0) != \"number\")) {\n\t\t\t\t// no interpolation - either at start, end, values don't change, or the value is non-numeric.\n\t\t\t\tv = ratio == 1 ? v1 : v0;\n\t\t\t} else {\n\t\t\t\tv = v0+(v1-v0)*ratio;\n\t\t\t}\n\n\t\t\tvar ignore = false;\n\t\t\tif (arr = Tween._plugins[n]) {\n\t\t\t\tfor (var i=0,l=arr.length;i<l;i++) {\n\t\t\t\t\tvar v2 = arr[i].tween(this, n, v, p0, p1, ratio, !!step&&p0==p1, !step);\n\t\t\t\t\tif (v2 == Tween.IGNORE) { ignore = true; }\n\t\t\t\t\telse { v = v2; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ignore) { this._target[n] = v; }\n\t\t}\n\n\t};\n\n\t/**\n\t * @method _runActions\n\t * @param {Number} startPos\n\t * @param {Number} endPos\n\t * @param {Boolean} includeStart\n\t * @protected\n\t */\n\tp._runActions = function(startPos, endPos, includeStart) {\n\t\tvar sPos = startPos;\n\t\tvar ePos = endPos;\n\t\tvar i = -1;\n\t\tvar j = this._actions.length;\n\t\tvar k = 1;\n\t\tif (startPos > endPos) {\n\t\t\t// running backwards, flip everything:\n\t\t\tsPos = endPos;\n\t\t\tePos = startPos;\n\t\t\ti = j;\n\t\t\tj = k = -1;\n\t\t}\n\t\twhile ((i+=k) != j) {\n\t\t\tvar action = this._actions[i];\n\t\t\tvar pos = action.t;\n\t\t\tif (pos == ePos || (pos > sPos && pos < ePos) || (includeStart && pos == startPos) ) {\n\t\t\t\taction.f.apply(action.o, action.p);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _appendQueueProps\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._appendQueueProps = function(o) {\n\t\tvar arr,oldValue,i, l, injectProps;\n\t\tfor (var n in o) {\n\t\t\tif (this._initQueueProps[n] === undefined) {\n\t\t\t\toldValue = this._target[n];\n\n\t\t\t\t// init plugins:\n\t\t\t\tif (arr = Tween._plugins[n]) {\n\t\t\t\t\tfor (i=0,l=arr.length;i<l;i++) {\n\t\t\t\t\t\toldValue = arr[i].init(this, n, oldValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._initQueueProps[n] = this._curQueueProps[n] = (oldValue===undefined) ? null : oldValue;\n\t\t\t} else {\n\t\t\t\toldValue = this._curQueueProps[n];\n\t\t\t}\n\t\t}\n\n\t\tfor (var n in o) {\n\t\t\toldValue = this._curQueueProps[n];\n\t\t\tif (arr = Tween._plugins[n]) {\n\t\t\t\tinjectProps = injectProps||{};\n\t\t\t\tfor (i=0, l=arr.length;i<l;i++) {\n\t\t\t\t\t// TODO: remove the check for .step in the next version. It's here for backwards compatibility.\n\t\t\t\t\tif (arr[i].step) { arr[i].step(this, n, oldValue, o[n], injectProps); }\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._curQueueProps[n] = o[n];\n\t\t}\n\t\tif (injectProps) { this._appendQueueProps(injectProps); }\n\t\treturn this._curQueueProps;\n\t};\n\n\t/**\n\t * @method _cloneProps\n\t * @param {Object} props\n\t * @protected\n\t */\n\tp._cloneProps = function(props) {\n\t\tvar o = {};\n\t\tfor (var n in props) {\n\t\t\to[n] = props[n];\n\t\t}\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _addStep\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._addStep = function(o) {\n\t\tif (o.d > 0) {\n\t\t\tthis._steps.push(o);\n\t\t\to.t = this.duration;\n\t\t\tthis.duration += o.d;\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method _addAction\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._addAction = function(o) {\n\t\to.t = this.duration;\n\t\tthis._actions.push(o);\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method _set\n\t * @param {Object} props\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._set = function(props, o) {\n\t\tfor (var n in props) {\n\t\t\to[n] = props[n];\n\t\t}\n\t};\n\n\tcreatejs.Tween = createjs.promote(Tween, \"EventDispatcher\");\n\n}());\n\n//##############################################################################\n// Timeline.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\t\n\n// constructor\t\n\t/**\n\t * The Timeline class synchronizes multiple tweens and allows them to be controlled as a group. Please note that if a\n\t * timeline is looping, the tweens on it may appear to loop even if the \"loop\" property of the tween is false.\n\t * @class Timeline\n\t * @param {Array} tweens An array of Tweens to add to this timeline. See {{#crossLink \"Timeline/addTween\"}}{{/crossLink}}\n\t * for more info.\n\t * @param {Object} labels An object defining labels for using {{#crossLink \"Timeline/gotoAndPlay\"}}{{/crossLink}}/{{#crossLink \"Timeline/gotoAndStop\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Timeline/setLabels\"}}{{/crossLink}}\n\t * for details.\n\t * @param {Object} props The configuration properties to apply to this tween instance (ex. `{loop:true}`). All properties\n\t * default to false. Supported props are:<UL>\n\t *    <LI> loop: sets the loop property on this tween.</LI>\n\t *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>\n\t *    <LI> ignoreGlobalPause: sets the ignoreGlobalPause property on this tween.</LI>\n\t *    <LI> paused: indicates whether to start the tween paused.</LI>\n\t *    <LI> position: indicates the initial position for this timeline.</LI>\n\t *    <LI> onChange: specifies a listener to add for the {{#crossLink \"Timeline/change:event\"}}{{/crossLink}} event.</LI>\n\t * </UL>\n\t * @extends EventDispatcher\n\t * @constructor\n\t **/\n\tfunction Timeline(tweens, labels, props) {\n\t\tthis.EventDispatcher_constructor();\n\n\t// public properties:\n\t\t/**\n\t\t * Causes this timeline to continue playing when a global pause is active.\n\t\t * @property ignoreGlobalPause\n\t\t * @type Boolean\n\t\t **/\n\t\tthis.ignoreGlobalPause = false;\n\n\t\t/**\n\t\t * The total duration of this timeline in milliseconds (or ticks if `useTicks `is `true`). This value is usually\n\t\t * automatically updated as you modify the timeline. See {{#crossLink \"Timeline/updateDuration\"}}{{/crossLink}}\n\t\t * for more information.\n\t\t * @property duration\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t **/\n\t\tthis.duration = 0;\n\n\t\t/**\n\t\t * If true, the timeline will loop when it reaches the end. Can be set via the props param.\n\t\t * @property loop\n\t\t * @type Boolean\n\t\t **/\n\t\tthis.loop = false;\n\n\t\t/**\n\t\t * The current normalized position of the timeline. This will always be a value between 0 and\n\t\t * {{#crossLink \"Timeline/duration:property\"}}{{/crossLink}}.\n\t\t * Changing this property directly will have no effect.\n\t\t * @property position\n\t\t * @type Object\n\t\t * @readonly\n\t\t **/\n\t\tthis.position = null;\n\n\t\t// private properties:\n\t\t/**\n\t\t * @property _paused\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._paused = false;\n\n\t\t/**\n\t\t * @property _tweens\n\t\t * @type Array[Tween]\n\t\t * @protected\n\t\t **/\n\t\tthis._tweens = [];\n\n\t\t/**\n\t\t * @property _labels\n\t\t * @type Object\n\t\t * @protected\n\t\t **/\n\t\tthis._labels = null;\n\n\t\t/**\n\t\t * @property _labelList\n\t\t * @type Array[Object]\n\t\t * @protected\n\t\t **/\n\t\tthis._labelList = null;\n\n\t\t/**\n\t\t * @property _prevPosition\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @protected\n\t\t **/\n\t\tthis._prevPosition = 0;\n\n\t\t/**\n\t\t * @property _prevPos\n\t\t * @type Number\n\t\t * @default -1\n\t\t * @protected\n\t\t **/\n\t\tthis._prevPos = -1;\n\n\t\t/**\n\t\t * @property _useTicks\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @protected\n\t\t **/\n\t\tthis._useTicks = false;\n\t\t\n\t\t/**\n\t\t * Indicates whether the timeline is currently registered with Tween.\n\t\t * @property _registered\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._registered = false;\n\n\n\t\tif (props) {\n\t\t\tthis._useTicks = props.useTicks;\n\t\t\tthis.loop = props.loop;\n\t\t\tthis.ignoreGlobalPause = props.ignoreGlobalPause;\n\t\t\tprops.onChange&&this.addEventListener(\"change\", props.onChange);\n\t\t}\n\t\tif (tweens) { this.addTween.apply(this, tweens); }\n\t\tthis.setLabels(labels);\n\t\tif (props&&props.paused) { this._paused=true; }\n\t\telse { createjs.Tween._register(this,true); }\n\t\tif (props&&props.position!=null) { this.setPosition(props.position, createjs.Tween.NONE); }\n\t\t\n\t};\n\t\n\tvar p = createjs.extend(Timeline, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\t\n// events:\n\t/**\n\t * Called whenever the timeline's position changes.\n\t * @event change\n\t * @since 0.5.0\n\t **/\n\n\n// public methods:\n\t/**\n\t * Adds one or more tweens (or timelines) to this timeline. The tweens will be paused (to remove them from the\n\t * normal ticking system) and managed by this timeline. Adding a tween to multiple timelines will result in\n\t * unexpected behaviour.\n\t * @method addTween\n\t * @param {Tween} ...tween The tween(s) to add. Accepts multiple arguments.\n\t * @return {Tween} The first tween that was passed in.\n\t **/\n\tp.addTween = function(tween) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tfor (var i=0; i<l; i++) { this.addTween(arguments[i]); }\n\t\t\treturn arguments[0];\n\t\t} else if (l == 0) { return null; }\n\t\tthis.removeTween(tween);\n\t\tthis._tweens.push(tween);\n\t\ttween.setPaused(true);\n\t\ttween._paused = false;\n\t\ttween._useTicks = this._useTicks;\n\t\tif (tween.duration > this.duration) { this.duration = tween.duration; }\n\t\tif (this._prevPos >= 0) { tween.setPosition(this._prevPos, createjs.Tween.NONE); }\n\t\treturn tween;\n\t};\n\n\t/**\n\t * Removes one or more tweens from this timeline.\n\t * @method removeTween\n\t * @param {Tween} ...tween The tween(s) to remove. Accepts multiple arguments.\n\t * @return Boolean Returns `true` if all of the tweens were successfully removed.\n\t **/\n\tp.removeTween = function(tween) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tvar good = true;\n\t\t\tfor (var i=0; i<l; i++) { good = good && this.removeTween(arguments[i]); }\n\t\t\treturn good;\n\t\t} else if (l == 0) { return false; }\n\n\t\tvar tweens = this._tweens;\n\t\tvar i = tweens.length;\n\t\twhile (i--) {\n\t\t\tif (tweens[i] == tween) {\n\t\t\t\ttweens.splice(i, 1);\n\t\t\t\tif (tween.duration >= this.duration) { this.updateDuration(); }\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Adds a label that can be used with {{#crossLink \"Timeline/gotoAndPlay\"}}{{/crossLink}}/{{#crossLink \"Timeline/gotoAndStop\"}}{{/crossLink}}.\n\t * @method addLabel\n\t * @param {String} label The label name.\n\t * @param {Number} position The position this label represents.\n\t **/\n\tp.addLabel = function(label, position) {\n\t\tthis._labels[label] = position;\n\t\tvar list = this._labelList;\n\t\tif (list) {\n\t\t\tfor (var i= 0,l=list.length; i<l; i++) { if (position < list[i].position) { break; } }\n\t\t\tlist.splice(i, 0, {label:label, position:position});\n\t\t}\n\t};\n\n\t/**\n\t * Defines labels for use with gotoAndPlay/Stop. Overwrites any previously set labels.\n\t * @method setLabels\n\t * @param {Object} o An object defining labels for using {{#crossLink \"Timeline/gotoAndPlay\"}}{{/crossLink}}/{{#crossLink \"Timeline/gotoAndStop\"}}{{/crossLink}}\n\t * in the form `{labelName:time}` where time is in milliseconds (or ticks if `useTicks` is `true`).\n\t **/\n\tp.setLabels = function(o) {\n\t\tthis._labels = o ?  o : {};\n\t};\n\n\t/**\n\t * Returns a sorted list of the labels defined on this timeline.\n\t * @method getLabels\n\t * @return {Array[Object]} A sorted array of objects with label and position properties.\n\t **/\n\tp.getLabels = function() {\n\t\tvar list = this._labelList;\n\t\tif (!list) {\n\t\t\tlist = this._labelList = [];\n\t\t\tvar labels = this._labels;\n\t\t\tfor (var n in labels) {\n\t\t\t\tlist.push({label:n, position:labels[n]});\n\t\t\t}\n\t\t\tlist.sort(function (a,b) { return a.position- b.position; });\n\t\t}\n\t\treturn list;\n\t};\n\n\t/**\n\t * Returns the name of the label on or immediately before the current position. For example, given a timeline with\n\t * two labels, \"first\" on frame index 4, and \"second\" on frame 8, getCurrentLabel would return:\n\t * <UL>\n\t * \t\t<LI>null if the current position is 2.</LI>\n\t * \t\t<LI>\"first\" if the current position is 4.</LI>\n\t * \t\t<LI>\"first\" if the current position is 7.</LI>\n\t * \t\t<LI>\"second\" if the current position is 15.</LI>\n\t * </UL>\n\t * @method getCurrentLabel\n\t * @return {String} The name of the current label or null if there is no label\n\t **/\n\tp.getCurrentLabel = function() {\n\t\tvar labels = this.getLabels();\n\t\tvar pos = this.position;\n\t\tvar l = labels.length;\n\t\tif (l) {\n\t\t\tfor (var i = 0; i<l; i++) { if (pos < labels[i].position) { break; } }\n\t\t\treturn (i==0) ? null : labels[i-1].label;\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Unpauses this timeline and jumps to the specified position or label.\n\t * @method gotoAndPlay\n\t * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`)\n\t * or label to jump to.\n\t **/\n\tp.gotoAndPlay = function(positionOrLabel) {\n\t\tthis.setPaused(false);\n\t\tthis._goto(positionOrLabel);\n\t};\n\n\t/**\n\t * Pauses this timeline and jumps to the specified position or label.\n\t * @method gotoAndStop\n\t * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`) or label\n\t * to jump to.\n\t **/\n\tp.gotoAndStop = function(positionOrLabel) {\n\t\tthis.setPaused(true);\n\t\tthis._goto(positionOrLabel);\n\t};\n\n\t/**\n\t * Advances the timeline to the specified position.\n\t * @method setPosition\n\t * @param {Number} value The position to seek to in milliseconds (or ticks if `useTicks` is `true`).\n\t * @param {Number} [actionsMode] parameter specifying how actions are handled. See the Tween {{#crossLink \"Tween/setPosition\"}}{{/crossLink}}\n\t * method for more details.\n\t * @return {Boolean} Returns `true` if the timeline is complete (ie. the full timeline has run & {{#crossLink \"Timeline/loop:property\"}}{{/crossLink}}\n\t * is `false`).\n\t **/\n\tp.setPosition = function(value, actionsMode) {\n\t\tvar t = this._calcPosition(value);\n\t\tvar end = !this.loop && value >= this.duration;\n\t\tif (t == this._prevPos) { return end; }\n\t\tthis._prevPosition = value;\n\t\tthis.position = this._prevPos = t; // in case an action changes the current frame.\n\t\tfor (var i=0, l=this._tweens.length; i<l; i++) {\n\t\t\tthis._tweens[i].setPosition(t, actionsMode);\n\t\t\tif (t != this._prevPos) { return false; } // an action changed this timeline's position.\n\t\t}\n\t\tif (end) { this.setPaused(true); }\n\t\tthis.dispatchEvent(\"change\");\n\t\treturn end;\n\t};\n\n\t/**\n\t * Pauses or plays this timeline.\n\t * @method setPaused\n\t * @param {Boolean} value Indicates whether the tween should be paused (`true`) or played (`false`).\n\t **/\n\tp.setPaused = function(value) {\n\t\tthis._paused = !!value; \n\t\tcreatejs.Tween._register(this, !value);\n\t};\n\n\t/**\n\t * Recalculates the duration of the timeline. The duration is automatically updated when tweens are added or removed,\n\t * but this method is useful if you modify a tween after it was added to the timeline.\n\t * @method updateDuration\n\t **/\n\tp.updateDuration = function() {\n\t\tthis.duration = 0;\n\t\tfor (var i=0,l=this._tweens.length; i<l; i++) {\n\t\t\tvar tween = this._tweens[i];\n\t\t\tif (tween.duration > this.duration) { this.duration = tween.duration; }\n\t\t}\n\t};\n\n\t/**\n\t * Advances this timeline by the specified amount of time in milliseconds (or ticks if `useTicks` is `true`).\n\t * This is normally called automatically by the Tween engine (via the {{#crossLink \"Tween/tick:event\"}}{{/crossLink}}\n\t * event), but is exposed for advanced uses.\n\t * @method tick\n\t * @param {Number} delta The time to advance in milliseconds (or ticks if useTicks is true).\n\t **/\n\tp.tick = function(delta) {\n\t\tthis.setPosition(this._prevPosition+delta);\n\t};\n\n\t/**\n\t * If a numeric position is passed, it is returned unchanged. If a string is passed, the position of the\n\t * corresponding frame label will be returned, or `null` if a matching label is not defined.\n\t * @method resolve\n\t * @param {String|Number} positionOrLabel A numeric position value or label string.\n\t **/\n\tp.resolve = function(positionOrLabel) {\n\t\tvar pos = Number(positionOrLabel);\n\t\tif (isNaN(pos)) { pos = this._labels[positionOrLabel]; }\n\t\treturn pos;\n\t};\n\n\t/**\n\t* Returns a string representation of this object.\n\t* @method toString\n\t* @return {String} a string representation of the instance.\n\t**/\n\tp.toString = function() {\n\t\treturn \"[Timeline]\";\n\t};\n\n\t/**\n\t * @method clone\n\t * @protected\n\t **/\n\tp.clone = function() {\n\t\tthrow(\"Timeline can not be cloned.\")\n\t};\n\n// private methods:\n\t/**\n\t * @method _goto\n\t * @param {String | Number} positionOrLabel\n\t * @protected\n\t **/\n\tp._goto = function(positionOrLabel) {\n\t\tvar pos = this.resolve(positionOrLabel);\n\t\tif (pos != null) { this.setPosition(pos); }\n\t};\n\t\n\t/**\n\t * @method _calcPosition\n\t * @param {Number} value\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._calcPosition = function(value) {\n\t\tif (value < 0) { return 0; }\n\t\tif (value < this.duration) { return value; }\n\t\treturn this.loop ? value%this.duration : this.duration;\n\t};\n\n\tcreatejs.Timeline = createjs.promote(Timeline, \"EventDispatcher\");\n\n}());\n\n//##############################################################################\n// Ease.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * The Ease class provides a collection of easing functions for use with TweenJS. It does not use the standard 4 param\n\t * easing signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.\n\t *\n\t * Most methods on Ease can be passed directly as easing functions:\n\t *\n\t *      Tween.get(target).to({x:100}, 500, Ease.linear);\n\t *\n\t * However, methods beginning with \"get\" will return an easing function based on parameter values:\n\t *\n\t *      Tween.get(target).to({y:200}, 500, Ease.getPowIn(2.2));\n\t *\n\t * Please see the <a href=\"http://www.createjs.com/Demos/TweenJS/Tween_SparkTable\">spark table demo</a> for an\n\t * overview of the different ease types on <a href=\"http://tweenjs.com\">TweenJS.com</a>.\n\t *\n\t * <em>Equations derived from work by Robert Penner.</em>\n\t * @class Ease\n\t * @static\n\t **/\n\tfunction Ease() {\n\t\tthrow \"Ease cannot be instantiated.\";\n\t}\n\n\n// static methods and properties\n\t/**\n\t * @method linear\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.linear = function(t) { return t; };\n\n\t/**\n\t * Identical to linear.\n\t * @method none\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.none = Ease.linear;\n\n\t/**\n\t * Mimics the simple -100 to 100 easing in Flash Pro.\n\t * @method get\n\t * @param {Number} amount A value from -1 (ease in) to 1 (ease out) indicating the strength and direction of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.get = function(amount) {\n\t\tif (amount < -1) { amount = -1; }\n\t\tif (amount > 1) { amount = 1; }\n\t\treturn function(t) {\n\t\t\tif (amount==0) { return t; }\n\t\t\tif (amount<0) { return t*(t*-amount+1+amount); }\n\t\t\treturn t*((2-t)*amount+(1-amount));\n\t\t};\n\t};\n\n\t/**\n\t * Configurable exponential ease.\n\t * @method getPowIn\n\t * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getPowIn = function(pow) {\n\t\treturn function(t) {\n\t\t\treturn Math.pow(t,pow);\n\t\t};\n\t};\n\n\t/**\n\t * Configurable exponential ease.\n\t * @method getPowOut\n\t * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getPowOut = function(pow) {\n\t\treturn function(t) {\n\t\t\treturn 1-Math.pow(1-t,pow);\n\t\t};\n\t};\n\n\t/**\n\t * Configurable exponential ease.\n\t * @method getPowInOut\n\t * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getPowInOut = function(pow) {\n\t\treturn function(t) {\n\t\t\tif ((t*=2)<1) return 0.5*Math.pow(t,pow);\n\t\t\treturn 1-0.5*Math.abs(Math.pow(2-t,pow));\n\t\t};\n\t};\n\n\t/**\n\t * @method quadIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quadIn = Ease.getPowIn(2);\n\t/**\n\t * @method quadOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quadOut = Ease.getPowOut(2);\n\t/**\n\t * @method quadInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quadInOut = Ease.getPowInOut(2);\n\n\t/**\n\t * @method cubicIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.cubicIn = Ease.getPowIn(3);\n\t/**\n\t * @method cubicOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.cubicOut = Ease.getPowOut(3);\n\t/**\n\t * @method cubicInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.cubicInOut = Ease.getPowInOut(3);\n\n\t/**\n\t * @method quartIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quartIn = Ease.getPowIn(4);\n\t/**\n\t * @method quartOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quartOut = Ease.getPowOut(4);\n\t/**\n\t * @method quartInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quartInOut = Ease.getPowInOut(4);\n\n\t/**\n\t * @method quintIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quintIn = Ease.getPowIn(5);\n\t/**\n\t * @method quintOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quintOut = Ease.getPowOut(5);\n\t/**\n\t * @method quintInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quintInOut = Ease.getPowInOut(5);\n\n\t/**\n\t * @method sineIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.sineIn = function(t) {\n\t\treturn 1-Math.cos(t*Math.PI/2);\n\t};\n\n\t/**\n\t * @method sineOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.sineOut = function(t) {\n\t\treturn Math.sin(t*Math.PI/2);\n\t};\n\n\t/**\n\t * @method sineInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.sineInOut = function(t) {\n\t\treturn -0.5*(Math.cos(Math.PI*t) - 1);\n\t};\n\n\t/**\n\t * Configurable \"back in\" ease.\n\t * @method getBackIn\n\t * @param {Number} amount The strength of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getBackIn = function(amount) {\n\t\treturn function(t) {\n\t\t\treturn t*t*((amount+1)*t-amount);\n\t\t};\n\t};\n\t/**\n\t * @method backIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.backIn = Ease.getBackIn(1.7);\n\n\t/**\n\t * Configurable \"back out\" ease.\n\t * @method getBackOut\n\t * @param {Number} amount The strength of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getBackOut = function(amount) {\n\t\treturn function(t) {\n\t\t\treturn (--t*t*((amount+1)*t + amount) + 1);\n\t\t};\n\t};\n\t/**\n\t * @method backOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.backOut = Ease.getBackOut(1.7);\n\n\t/**\n\t * Configurable \"back in out\" ease.\n\t * @method getBackInOut\n\t * @param {Number} amount The strength of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getBackInOut = function(amount) {\n\t\tamount*=1.525;\n\t\treturn function(t) {\n\t\t\tif ((t*=2)<1) return 0.5*(t*t*((amount+1)*t-amount));\n\t\t\treturn 0.5*((t-=2)*t*((amount+1)*t+amount)+2);\n\t\t};\n\t};\n\t/**\n\t * @method backInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.backInOut = Ease.getBackInOut(1.7);\n\n\t/**\n\t * @method circIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.circIn = function(t) {\n\t\treturn -(Math.sqrt(1-t*t)- 1);\n\t};\n\n\t/**\n\t * @method circOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.circOut = function(t) {\n\t\treturn Math.sqrt(1-(--t)*t);\n\t};\n\n\t/**\n\t * @method circInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.circInOut = function(t) {\n\t\tif ((t*=2) < 1) return -0.5*(Math.sqrt(1-t*t)-1);\n\t\treturn 0.5*(Math.sqrt(1-(t-=2)*t)+1);\n\t};\n\n\t/**\n\t * @method bounceIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.bounceIn = function(t) {\n\t\treturn 1-Ease.bounceOut(1-t);\n\t};\n\n\t/**\n\t * @method bounceOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.bounceOut = function(t) {\n\t\tif (t < 1/2.75) {\n\t\t\treturn (7.5625*t*t);\n\t\t} else if (t < 2/2.75) {\n\t\t\treturn (7.5625*(t-=1.5/2.75)*t+0.75);\n\t\t} else if (t < 2.5/2.75) {\n\t\t\treturn (7.5625*(t-=2.25/2.75)*t+0.9375);\n\t\t} else {\n\t\t\treturn (7.5625*(t-=2.625/2.75)*t +0.984375);\n\t\t}\n\t};\n\n\t/**\n\t * @method bounceInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.bounceInOut = function(t) {\n\t\tif (t<0.5) return Ease.bounceIn (t*2) * .5;\n\t\treturn Ease.bounceOut(t*2-1)*0.5+0.5;\n\t};\n\n\t/**\n\t * Configurable elastic ease.\n\t * @method getElasticIn\n\t * @param {Number} amplitude\n\t * @param {Number} period\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getElasticIn = function(amplitude,period) {\n\t\tvar pi2 = Math.PI*2;\n\t\treturn function(t) {\n\t\t\tif (t==0 || t==1) return t;\n\t\t\tvar s = period/pi2*Math.asin(1/amplitude);\n\t\t\treturn -(amplitude*Math.pow(2,10*(t-=1))*Math.sin((t-s)*pi2/period));\n\t\t};\n\t};\n\t/**\n\t * @method elasticIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.elasticIn = Ease.getElasticIn(1,0.3);\n\n\t/**\n\t * Configurable elastic ease.\n\t * @method getElasticOut\n\t * @param {Number} amplitude\n\t * @param {Number} period\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getElasticOut = function(amplitude,period) {\n\t\tvar pi2 = Math.PI*2;\n\t\treturn function(t) {\n\t\t\tif (t==0 || t==1) return t;\n\t\t\tvar s = period/pi2 * Math.asin(1/amplitude);\n\t\t\treturn (amplitude*Math.pow(2,-10*t)*Math.sin((t-s)*pi2/period )+1);\n\t\t};\n\t};\n\t/**\n\t * @method elasticOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.elasticOut = Ease.getElasticOut(1,0.3);\n\n\t/**\n\t * Configurable elastic ease.\n\t * @method getElasticInOut\n\t * @param {Number} amplitude\n\t * @param {Number} period\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getElasticInOut = function(amplitude,period) {\n\t\tvar pi2 = Math.PI*2;\n\t\treturn function(t) {\n\t\t\tvar s = period/pi2 * Math.asin(1/amplitude);\n\t\t\tif ((t*=2)<1) return -0.5*(amplitude*Math.pow(2,10*(t-=1))*Math.sin( (t-s)*pi2/period ));\n\t\t\treturn amplitude*Math.pow(2,-10*(t-=1))*Math.sin((t-s)*pi2/period)*0.5+1;\n\t\t};\n\t};\n\t/**\n\t * @method elasticInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.elasticInOut = Ease.getElasticInOut(1,0.3*1.5);\n\n\tcreatejs.Ease = Ease;\n\n}());\n\n//##############################################################################\n// MotionGuidePlugin.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * A TweenJS plugin for working with motion guides.\n\t *\n\t * To use, install the plugin after TweenJS has loaded. Next tween the 'guide' property with an object as detailed below.\n\t *\n\t *       createjs.MotionGuidePlugin.install();\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      // Using a Motion Guide\n\t *\t    createjs.Tween.get(target).to({guide:{ path:[0,0, 0,200,200,200, 200,0,0,0] }},7000);\n\t *\t    // Visualizing the line\n\t *\t    graphics.moveTo(0,0).curveTo(0,200,200,200).curveTo(200,0,0,0);\n\t *\n\t * Each path needs pre-computation to ensure there's fast performance. Because of the pre-computation there's no\n\t * built in support for path changes mid tween. These are the Guide Object's properties:<UL>\n\t *      <LI> path: Required, Array : The x/y points used to draw the path with a moveTo and 1 to n curveTo calls.</LI>\n\t *      <LI> start: Optional, 0-1 : Initial position, default 0 except for when continuing along the same path.</LI>\n\t *      <LI> end: Optional, 0-1 : Final position, default 1 if not specified.</LI>\n\t *      <LI> orient: Optional, string : \"fixed\"/\"auto\"/\"cw\"/\"ccw\"<UL>\n\t *\t\t\t\t<LI>\"fixed\" forces the object to face down the path all movement (relative to start rotation),</LI>\n\t *      \t\t<LI>\"auto\" rotates the object along the path relative to the line.</LI>\n\t *      \t\t<LI>\"cw\"/\"ccw\" force clockwise or counter clockwise rotations including flash like behaviour</LI>\n\t * \t\t</UL></LI>\n\t * </UL>\n\t * Guide objects should not be shared between tweens even if all properties are identical, the library stores\n\t * information on these objects in the background and sharing them can cause unexpected behaviour. Values\n\t * outside 0-1 range of tweens will be a \"best guess\" from the appropriate part of the defined curve.\n\t *\n\t * @class MotionGuidePlugin\n\t * @constructor\n\t **/\n\tfunction MotionGuidePlugin() {\n\t\tthrow(\"MotionGuidePlugin cannot be instantiated.\")\n\t};\n\n\n// static properties:\n\t/**\n\t * @property priority\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.priority = 0; // high priority, should run sooner\n\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotOffS;\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotOffE;\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotNormS;\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotNormE;\n\n\n// static methods\n\t/**\n\t * Installs this plugin for use with TweenJS. Call this once after TweenJS is loaded to enable this plugin.\n\t * @method install\n\t * @static\n\t **/\n\tMotionGuidePlugin.install = function() {\n\t\tcreatejs.Tween.installPlugin(MotionGuidePlugin, [\"guide\", \"x\", \"y\", \"rotation\"]);\n\t\treturn createjs.Tween.IGNORE;\n\t};\n\n\t/**\n\t * @method init\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.init = function(tween, prop, value) {\n\t\tvar target = tween.target;\n\t\tif(!target.hasOwnProperty(\"x\")){ target.x = 0; }\n\t\tif(!target.hasOwnProperty(\"y\")){ target.y = 0; }\n\t\tif(!target.hasOwnProperty(\"rotation\")){ target.rotation = 0; }\n\n\t\tif(prop==\"rotation\"){ tween.__needsRot = true; }\n\t\treturn prop==\"guide\"?null:value;\n\t};\n\n\t/**\n\t * @method step\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.step = function(tween, prop, startValue, endValue, injectProps) {\n\t\t// other props\n\t\tif(prop == \"rotation\"){\n\t\t\ttween.__rotGlobalS = startValue;\n\t\t\ttween.__rotGlobalE = endValue;\n\t\t\tMotionGuidePlugin.testRotData(tween, injectProps);\n\t\t}\n\t\tif(prop != \"guide\"){ return endValue; }\n\n\t\t// guide only information - Start -\n\t\tvar temp, data = endValue;\n\t\tif(!data.hasOwnProperty(\"path\")){ data.path = []; }\n\t\tvar path = data.path;\n\t\tif(!data.hasOwnProperty(\"end\")){ data.end = 1; }\n\t\tif(!data.hasOwnProperty(\"start\")){\n\t\t\tdata.start = (startValue&&startValue.hasOwnProperty(\"end\")&&startValue.path===path)?startValue.end:0;\n\t\t}\n\n\t\t// Figure out subline information\n\t\tif(data.hasOwnProperty(\"_segments\") && data._length){ return endValue; }\n\t\tvar l = path.length;\n\t\tvar accuracy = 10;\t\t// Adjust to improve line following precision but sacrifice performance (# of seg)\n\t\tif(l >= 6 && (l-2) % 4 == 0){\t// Enough points && contains correct number per entry ignoring start\n\t\t\tdata._segments = [];\n\t\t\tdata._length = 0;\n\t\t\tfor(var i=2; i<l; i+=4){\n\t\t\t\tvar sx = path[i-2], sy = path[i-1];\n\t\t\t\tvar cx = path[i+0], cy = path[i+1];\n\t\t\t\tvar ex = path[i+2], ey = path[i+3];\n\t\t\t\tvar oldX = sx, oldY = sy;\n\t\t\t\tvar tempX, tempY, total = 0;\n\t\t\t\tvar sublines = [];\n\t\t\t\tfor(var j=1; j<=accuracy; j++){\n\t\t\t\t\tvar t = j/accuracy;\n\t\t\t\t\tvar inv = 1 - t;\n\t\t\t\t\ttempX = inv*inv * sx + 2 * inv * t * cx + t*t * ex;\n\t\t\t\t\ttempY = inv*inv * sy + 2 * inv * t * cy + t*t * ey;\n\t\t\t\t\ttotal += sublines[sublines.push(Math.sqrt((temp=tempX-oldX)*temp + (temp=tempY-oldY)*temp))-1];\n\t\t\t\t\toldX = tempX;\n\t\t\t\t\toldY = tempY;\n\t\t\t\t}\n\t\t\t\tdata._segments.push(total);\n\t\t\t\tdata._segments.push(sublines);\n\t\t\t\tdata._length += total;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow(\"invalid 'path' data, please see documentation for valid paths\");\n\t\t}\n\n\t\t// Setup x/y tweens\n\t\ttemp = data.orient;\n\t\tdata.orient = true;\n\t\tvar o = {};\n\t\tMotionGuidePlugin.calc(data, data.start, o);\n\t\ttween.__rotPathS = Number(o.rotation.toFixed(5));\n\t\tMotionGuidePlugin.calc(data, data.end, o);\n\t\ttween.__rotPathE = Number(o.rotation.toFixed(5));\n\t\tdata.orient = false;\t//here and now we don't know if we need to\n\t\tMotionGuidePlugin.calc(data, data.end, injectProps);\n\t\tdata.orient = temp;\n\n\t\t// Setup rotation properties\n\t\tif(!data.orient){ return endValue; }\n\t\ttween.__guideData = data;\n\t\tMotionGuidePlugin.testRotData(tween, injectProps);\n\t\treturn endValue;\n\t};\n\n\t/**\n\t * @method testRotData\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.testRotData = function(tween, injectProps){\n\n\t\t// no rotation informat? if we need it come back, if we don't use 0 & ensure we have guide data\n\t\tif(tween.__rotGlobalS === undefined || tween.__rotGlobalE === undefined){\n\t\t\tif(tween.__needsRot){ return; }\n\t\t\tif(tween._curQueueProps.rotation !== undefined){\n\t\t\t\ttween.__rotGlobalS = tween.__rotGlobalE = tween._curQueueProps.rotation;\n\t\t\t} else {\n\t\t\t\ttween.__rotGlobalS = tween.__rotGlobalE = injectProps.rotation = tween.target.rotation || 0;\n\t\t\t}\n\t\t}\n\t\tif(tween.__guideData === undefined){ return; }\n\n\t\t// Process rotation properties\n\t\tvar data = tween.__guideData;\n\t\tvar rotGlobalD = tween.__rotGlobalE - tween.__rotGlobalS;\n\t\tvar rotPathD = tween.__rotPathE - tween.__rotPathS;\n\t\tvar rot = rotGlobalD - rotPathD;\n\n\t\tif(data.orient == \"auto\"){\n\t\t\tif(rot > 180){\t\t\trot -= 360; }\n\t\t\telse if(rot < -180){\trot += 360; }\n\n\t\t} else if(data.orient == \"cw\"){\n\t\t\twhile(rot < 0){ rot += 360; }\n\t\t\tif(rot == 0 && rotGlobalD > 0 && rotGlobalD != 180){ rot += 360; }\n\n\t\t} else if(data.orient == \"ccw\"){\n\t\t\trot = rotGlobalD - ((rotPathD > 180)?(360-rotPathD):(rotPathD));\t// sign flipping on path\n\t\t\twhile(rot > 0){ rot -= 360; }\n\t\t\tif(rot == 0 && rotGlobalD < 0 && rotGlobalD != -180){ rot -= 360; }\n\t\t}\n\n\t\tdata.rotDelta = rot;\n\t\tdata.rotOffS = tween.__rotGlobalS - tween.__rotPathS;\n\n\t\t// reset\n\t\ttween.__rotGlobalS = tween.__rotGlobalE = tween.__guideData = tween.__needsRot = undefined;\n\t};\n\n\t/**\n\t * @method tween\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.tween = function(tween, prop, value, startValues, endValues, ratio, wait, end) {\n\t\tvar data = endValues.guide;\n\t\tif(data == undefined || data === startValues.guide){ return value; }\n\t\tif(data.lastRatio != ratio){\n\t\t\t// first time through so calculate what I need to\n\t\t\tvar t = ((data.end-data.start)*(wait?data.end:ratio)+data.start);\n\t\t\tMotionGuidePlugin.calc(data, t, tween.target);\n\t\t\tswitch(data.orient){\n\t\t\t\tcase \"cw\":\t\t// mix in the original rotation\n\t\t\t\tcase \"ccw\":\n\t\t\t\tcase \"auto\": tween.target.rotation += data.rotOffS + data.rotDelta*ratio; break;\n\t\t\t\tcase \"fixed\":\t// follow fixed behaviour to solve potential issues\n\t\t\t\tdefault: tween.target.rotation += data.rotOffS; break;\n\t\t\t}\n\t\t\tdata.lastRatio = ratio;\n\t\t}\n\t\tif(prop == \"rotation\" && ((!data.orient) || data.orient == \"false\")){ return value; }\n\t\treturn tween.target[prop];\n\t};\n\n\t/**\n\t * Determine the appropriate x/y/rotation information about a path for a given ratio along the path.\n\t * Assumes a path object with all optional parameters specified.\n\t * @param data Data object you would pass to the \"guide:\" property in a Tween\n\t * @param ratio 0-1 Distance along path, values outside 0-1 are \"best guess\"\n\t * @param target Object to copy the results onto, will use a new object if not supplied.\n\t * @return {Object} The target object or a new object w/ the tweened properties\n\t * @static\n\t */\n\tMotionGuidePlugin.calc = function(data, ratio, target) {\n\t\tif(data._segments == undefined){ throw(\"Missing critical pre-calculated information, please file a bug\"); }\n\t\tif(target == undefined){ target = {x:0, y:0, rotation:0}; }\n\t\tvar seg = data._segments;\n\t\tvar path = data.path;\n\n\t\t// find segment\n\t\tvar pos = data._length * ratio;\n\t\tvar cap = seg.length - 2;\n\t\tvar n = 0;\n\t\twhile(pos > seg[n] && n < cap){\n\t\t\tpos -= seg[n];\n\t\t\tn+=2;\n\t\t}\n\n\t\t// find subline\n\t\tvar sublines = seg[n+1];\n\t\tvar i = 0;\n\t\tcap = sublines.length-1;\n\t\twhile(pos > sublines[i] && i < cap){\n\t\t\tpos -= sublines[i];\n\t\t\ti++;\n\t\t}\n\t\tvar t = (i/++cap)+(pos/(cap*sublines[i]));\n\n\t\t// find x/y\n\t\tn = (n*2)+2;\n\t\tvar inv = 1 - t;\n\t\ttarget.x = inv*inv * path[n-2] + 2 * inv * t * path[n+0] + t*t * path[n+2];\n\t\ttarget.y = inv*inv * path[n-1] + 2 * inv * t * path[n+1] + t*t * path[n+3];\n\n\t\t// orientation\n\t\tif(data.orient){\n\t\t\ttarget.rotation = 57.2957795 * Math.atan2(\n\t\t\t\t(path[n+1]-path[n-1])*inv + (path[n+3]-path[n+1])*t,\n\t\t\t\t(path[n+0]-path[n-2])*inv + (path[n+2]-path[n+0])*t);\n\t\t}\n\n\t\treturn target;\n\t};\n\n\tcreatejs.MotionGuidePlugin = MotionGuidePlugin;\n\n}());\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of\n\t * the library.\n\t * @class TweenJS\n\t **/\n\tvar s = createjs.TweenJS = createjs.TweenJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type String\n\t * @static\n\t **/\n\ts.version = /*=version*/\"0.6.2\"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type String\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/\"Thu, 26 Nov 2015 20:44:31 GMT\"; // injected by build process\n\n})();\nif(typeof module !== \"undefined\" && typeof module.exports !== \"undefined\") module.exports = this.createjs;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3JlYXRlanMtbW9kdWxlL2NyZWF0ZWpzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZWpzLW1vZHVsZS9jcmVhdGVqcy5qcz82NTY5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBjcmVhdGVqcyA9ICh0aGlzLmNyZWF0ZWpzID0gKHRoaXMuY3JlYXRlanMgfHwge30pKTtcbi8qIVxuKiBDcmVhdGVKU1xuKiBWaXNpdCBodHRwOi8vY3JlYXRlanMuY29tLyBmb3IgZG9jdW1lbnRhdGlvbiwgdXBkYXRlcyBhbmQgZXhhbXBsZXMuXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMCBnc2tpbm5lci5jb20sIGluYy5cbipcbiogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4qIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiogY29uZGl0aW9uczpcbipcbiogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4qXG4qIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4qIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4qIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBleHRlbmQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogU2V0cyB1cCB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBmb3IgYSBuZXcgY2xhc3MuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIHJpZ2h0IGFmdGVyIGNyZWF0aW5nIHRoZSBjbGFzcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBcdGZ1bmN0aW9uIE15U3ViQ2xhc3MoKSB7fVxuICogXHRjcmVhdGVqcy5leHRlbmQoTXlTdWJDbGFzcywgTXlTdXBlckNsYXNzKTtcbiAqIFx0TXlTdWJDbGFzcy5wcm90b3R5cGUuZG9Tb21ldGhpbmcgPSBmdW5jdGlvbigpIHsgfVxuICpcbiAqIFx0dmFyIGZvbyA9IG5ldyBNeVN1YkNsYXNzKCk7XG4gKiBcdGNvbnNvbGUubG9nKGZvbyBpbnN0YW5jZW9mIE15U3VwZXJDbGFzcyk7IC8vIHRydWVcbiAqIFx0Y29uc29sZS5sb2coZm9vLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9PT0gTXlTdWJDbGFzcyk7IC8vIHRydWVcbiAqXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ViY2xhc3MgVGhlIHN1YmNsYXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJjbGFzcyBUaGUgc3VwZXJjbGFzcyB0byBleHRlbmQuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgc3ViY2xhc3MncyBuZXcgcHJvdG90eXBlLlxuICovXG5jcmVhdGVqcy5leHRlbmQgPSBmdW5jdGlvbihzdWJjbGFzcywgc3VwZXJjbGFzcykge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRmdW5jdGlvbiBvKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gc3ViY2xhc3M7IH1cblx0by5wcm90b3R5cGUgPSBzdXBlcmNsYXNzLnByb3RvdHlwZTtcblx0cmV0dXJuIChzdWJjbGFzcy5wcm90b3R5cGUgPSBuZXcgbygpKTtcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBwcm9tb3RlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIFByb21vdGVzIGFueSBtZXRob2RzIG9uIHRoZSBzdXBlciBjbGFzcyB0aGF0IHdlcmUgb3ZlcnJpZGRlbiwgYnkgY3JlYXRpbmcgYW4gYWxpYXMgaW4gdGhlIGZvcm1hdCBgcHJlZml4X21ldGhvZE5hbWVgLlxuICogSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBzdXBlciBjbGFzcydzIG5hbWUgYXMgdGhlIHByZWZpeC5cbiAqIEFuIGFsaWFzIHRvIHRoZSBzdXBlciBjbGFzcydzIGNvbnN0cnVjdG9yIGlzIGFsd2F5cyBhZGRlZCBpbiB0aGUgZm9ybWF0IGBwcmVmaXhfY29uc3RydWN0b3JgLlxuICogVGhpcyBhbGxvd3MgdGhlIHN1YmNsYXNzIHRvIGNhbGwgc3VwZXIgY2xhc3MgbWV0aG9kcyB3aXRob3V0IHVzaW5nIGBmdW5jdGlvbi5jYWxsYCwgcHJvdmlkaW5nIGJldHRlciBwZXJmb3JtYW5jZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgYE15U3ViQ2xhc3NgIGV4dGVuZHMgYE15U3VwZXJDbGFzc2AsIGFuZCBib3RoIGRlZmluZSBhIGBkcmF3YCBtZXRob2QsIHRoZW4gY2FsbGluZyBgcHJvbW90ZShNeVN1YkNsYXNzLCBcIk15U3VwZXJDbGFzc1wiKWBcbiAqIHdvdWxkIGFkZCBhIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgIG1ldGhvZCB0byBNeVN1YkNsYXNzIGFuZCBwcm9tb3RlIHRoZSBgZHJhd2AgbWV0aG9kIG9uIGBNeVN1cGVyQ2xhc3NgIHRvIHRoZVxuICogcHJvdG90eXBlIG9mIGBNeVN1YkNsYXNzYCBhcyBgTXlTdXBlckNsYXNzX2RyYXdgLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGUgY2xhc3MncyBwcm90b3R5cGUgaXMgZnVsbHkgZGVmaW5lZC5cbiAqXG4gKiBcdGZ1bmN0aW9uIENsYXNzQShuYW1lKSB7XG4gKiBcdFx0dGhpcy5uYW1lID0gbmFtZTtcbiAqIFx0fVxuICogXHRDbGFzc0EucHJvdG90eXBlLmdyZWV0ID0gZnVuY3Rpb24oKSB7XG4gKiBcdFx0cmV0dXJuIFwiSGVsbG8gXCIrdGhpcy5uYW1lO1xuICogXHR9XG4gKlxuICogXHRmdW5jdGlvbiBDbGFzc0IobmFtZSwgcHVuY3R1YXRpb24pIHtcbiAqIFx0XHR0aGlzLkNsYXNzQV9jb25zdHJ1Y3RvcihuYW1lKTtcbiAqIFx0XHR0aGlzLnB1bmN0dWF0aW9uID0gcHVuY3R1YXRpb247XG4gKiBcdH1cbiAqIFx0Y3JlYXRlanMuZXh0ZW5kKENsYXNzQiwgQ2xhc3NBKTtcbiAqIFx0Q2xhc3NCLnByb3RvdHlwZS5ncmVldCA9IGZ1bmN0aW9uKCkge1xuICogXHRcdHJldHVybiB0aGlzLkNsYXNzQV9ncmVldCgpK3RoaXMucHVuY3R1YXRpb247XG4gKiBcdH1cbiAqIFx0Y3JlYXRlanMucHJvbW90ZShDbGFzc0IsIFwiQ2xhc3NBXCIpO1xuICpcbiAqIFx0dmFyIGZvbyA9IG5ldyBDbGFzc0IoXCJXb3JsZFwiLCBcIiE/IVwiKTtcbiAqIFx0Y29uc29sZS5sb2coZm9vLmdyZWV0KCkpOyAvLyBIZWxsbyBXb3JsZCE/IVxuICpcbiAqIEBtZXRob2QgcHJvbW90ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ViY2xhc3MgVGhlIGNsYXNzIHRvIHByb21vdGUgc3VwZXIgY2xhc3MgbWV0aG9kcyBvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIHByb21vdGVkIG1ldGhvZCBuYW1lcy4gVXN1YWxseSB0aGUgbmFtZSBvZiB0aGUgc3VwZXJjbGFzcy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBzdWJjbGFzcy5cbiAqL1xuY3JlYXRlanMucHJvbW90ZSA9IGZ1bmN0aW9uKHN1YmNsYXNzLCBwcmVmaXgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIHN1YlAgPSBzdWJjbGFzcy5wcm90b3R5cGUsIHN1cFAgPSAoT2JqZWN0LmdldFByb3RvdHlwZU9mJiZPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3ViUCkpfHxzdWJQLl9fcHJvdG9fXztcblx0aWYgKHN1cFApIHtcblx0XHRzdWJQWyhwcmVmaXgrPVwiX1wiKSArIFwiY29uc3RydWN0b3JcIl0gPSBzdXBQLmNvbnN0cnVjdG9yOyAvLyBjb25zdHJ1Y3RvciBpcyBub3QgYWx3YXlzIGlubnVtZXJhYmxlXG5cdFx0Zm9yICh2YXIgbiBpbiBzdXBQKSB7XG5cdFx0XHRpZiAoc3ViUC5oYXNPd25Qcm9wZXJ0eShuKSAmJiAodHlwZW9mIHN1cFBbbl0gPT0gXCJmdW5jdGlvblwiKSkgeyBzdWJQW3ByZWZpeCArIG5dID0gc3VwUFtuXTsgfVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3ViY2xhc3M7XG59O1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gaW5kZXhPZi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLyoqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIHNwZWNpZmllZCB2YWx1ZSBzZWFyY2hFbGVtZW50IGluIHRoZSBwYXNzZWQgaW4gYXJyYXksIGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZlxuICogdGhhdCB2YWx1ZS4gIFJldHVybnMgLTEgaWYgdmFsdWUgaXMgbm90IGZvdW5kLlxuICpcbiAqICAgICAgdmFyIGkgPSBjcmVhdGVqcy5pbmRleE9mKG15QXJyYXksIG15RWxlbWVudFRvRmluZCk7XG4gKlxuICogQG1ldGhvZCBpbmRleE9mXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBzZWFyY2ggZm9yIHNlYXJjaEVsZW1lbnRcbiAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gZmluZCBpbiBhcnJheS5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGZpcnN0IGluZGV4IG9mIHNlYXJjaEVsZW1lbnQgaW4gYXJyYXkuXG4gKi9cbmNyZWF0ZWpzLmluZGV4T2YgPSBmdW5jdGlvbiAoYXJyYXksIHNlYXJjaEVsZW1lbnQpe1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRmb3IgKHZhciBpID0gMCxsPWFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGlmIChzZWFyY2hFbGVtZW50ID09PSBhcnJheVtpXSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFdmVudC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBDb250YWlucyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHNoYXJlZCBieSBhbGwgZXZlbnRzIGZvciB1c2Ugd2l0aFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFxuXHQgKiBOb3RlIHRoYXQgRXZlbnQgb2JqZWN0cyBhcmUgb2Z0ZW4gcmV1c2VkLCBzbyB5b3Ugc2hvdWxkIG5ldmVyXG5cdCAqIHJlbHkgb24gYW4gZXZlbnQgb2JqZWN0J3Mgc3RhdGUgb3V0c2lkZSBvZiB0aGUgY2FsbCBzdGFjayBpdCB3YXMgcmVjZWl2ZWQgaW4uXG5cdCAqIEBjbGFzcyBFdmVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FuY2VsYWJsZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlKSB7XG5cdFx0XG5cdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgdHlwZSBvZiBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgdHlwZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgb2JqZWN0IHRoYXQgZ2VuZXJhdGVkIGFuIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSB0YXJnZXRcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnRhcmdldCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IHRhcmdldCB0aGF0IGEgYnViYmxpbmcgZXZlbnQgaXMgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tLiBGb3Igbm9uLWJ1YmJsaW5nIGV2ZW50cywgdGhpcyB3aWxsXG5cdFx0ICogYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRhcmdldC4gRm9yIGV4YW1wbGUsIGlmIGNoaWxkT2JqLnBhcmVudCA9IHBhcmVudE9iaiwgYW5kIGEgYnViYmxpbmcgZXZlbnRcblx0XHQgKiBpcyBnZW5lcmF0ZWQgZnJvbSBjaGlsZE9iaiwgdGhlbiBhIGxpc3RlbmVyIG9uIHBhcmVudE9iaiB3b3VsZCByZWNlaXZlIHRoZSBldmVudCB3aXRoXG5cdFx0ICogdGFyZ2V0PWNoaWxkT2JqICh0aGUgb3JpZ2luYWwgdGFyZ2V0KSBhbmQgY3VycmVudFRhcmdldD1wYXJlbnRPYmogKHdoZXJlIHRoZSBsaXN0ZW5lciB3YXMgYWRkZWQpLlxuXHRcdCAqIEBwcm9wZXJ0eSBjdXJyZW50VGFyZ2V0XG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogRm9yIGJ1YmJsaW5nIGV2ZW50cywgdGhpcyBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgZXZlbnQgcGhhc2U6PE9MPlxuXHRcdCAqIFx0PExJPiBjYXB0dXJlIHBoYXNlOiBzdGFydGluZyBmcm9tIHRoZSB0b3AgcGFyZW50IHRvIHRoZSB0YXJnZXQ8L0xJPlxuXHRcdCAqIFx0PExJPiBhdCB0YXJnZXQgcGhhc2U6IGN1cnJlbnRseSBiZWluZyBkaXNwYXRjaGVkIGZyb20gdGhlIHRhcmdldDwvTEk+XG5cdFx0ICogXHQ8TEk+IGJ1YmJsaW5nIHBoYXNlOiBmcm9tIHRoZSB0YXJnZXQgdG8gdGhlIHRvcCBwYXJlbnQ8L0xJPlxuXHRcdCAqIDwvT0w+XG5cdFx0ICogQHByb3BlcnR5IGV2ZW50UGhhc2Vcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmV2ZW50UGhhc2UgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2lsbCBidWJibGUgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBidWJibGVzXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmJ1YmJsZXMgPSAhIWJ1YmJsZXM7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0aGlzIGV2ZW50IGNhbiBiZSBjYW5jZWxsZWQgdmlhXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJldmVudERlZmF1bHRcIn19e3svY3Jvc3NMaW5rfX0uIFRoaXMgaXMgc2V0IHZpYSB0aGUgRXZlbnQgY29uc3RydWN0b3IuXG5cdFx0ICogQHByb3BlcnR5IGNhbmNlbGFibGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuY2FuY2VsYWJsZSA9ICEhY2FuY2VsYWJsZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGVwb2NoIHRpbWUgYXQgd2hpY2ggdGhpcyBldmVudCB3YXMgY3JlYXRlZC5cblx0XHQgKiBAcHJvcGVydHkgdGltZVN0YW1wXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy50aW1lU3RhbXAgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJldmVudERlZmF1bHRcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkXG5cdFx0ICogb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgZGVmYXVsdFByZXZlbnRlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHByb3BhZ2F0aW9uU3RvcHBlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWRcblx0XHQgKiBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBpbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWQgb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgcmVtb3ZlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5yZW1vdmVkID0gZmFsc2U7XG5cdH1cblx0dmFyIHAgPSBFdmVudC5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFNldHMge3sjY3Jvc3NMaW5rIFwiRXZlbnQvZGVmYXVsdFByZXZlbnRlZFwifX17ey9jcm9zc0xpbmt9fSB0byB0cnVlIGlmIHRoZSBldmVudCBpcyBjYW5jZWxhYmxlLlxuXHQgKiBNaXJyb3JzIHRoZSBET00gbGV2ZWwgMiBldmVudCBzdGFuZGFyZC4gSW4gZ2VuZXJhbCwgY2FuY2VsYWJsZSBldmVudHMgdGhhdCBoYXZlIGBwcmV2ZW50RGVmYXVsdCgpYCBjYWxsZWQgd2lsbFxuXHQgKiBjYW5jZWwgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG5cdCAqIEBtZXRob2QgcHJldmVudERlZmF1bHRcblx0ICoqL1xuXHRwLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kZWZhdWx0UHJldmVudGVkID0gdGhpcy5jYW5jZWxhYmxlJiZ0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHt7I2Nyb3NzTGluayBcIkV2ZW50L3Byb3BhZ2F0aW9uU3RvcHBlZFwifX17ey9jcm9zc0xpbmt9fSB0byB0cnVlLlxuXHQgKiBNaXJyb3JzIHRoZSBET00gZXZlbnQgc3RhbmRhcmQuXG5cdCAqIEBtZXRob2Qgc3RvcFByb3BhZ2F0aW9uXG5cdCAqKi9cblx0cC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IGFuZFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudC9pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gdG8gdHJ1ZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGV2ZW50IHN0YW5kYXJkLlxuXHQgKiBAbWV0aG9kIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblxuXHQgKiovXG5cdHAuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2F1c2VzIHRoZSBhY3RpdmUgbGlzdGVuZXIgdG8gYmUgcmVtb3ZlZCB2aWEgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuXHQgKiBcblx0ICogXHRcdG15QnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldnQpIHtcblx0ICogXHRcdFx0Ly8gZG8gc3R1ZmYuLi5cblx0ICogXHRcdFx0ZXZ0LnJlbW92ZSgpOyAvLyByZW1vdmVzIHRoaXMgbGlzdGVuZXIuXG5cdCAqIFx0XHR9KTtcblx0ICogXG5cdCAqIEBtZXRob2QgcmVtb3ZlXG5cdCAqKi9cblx0cC5yZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlbW92ZWQgPSB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgRXZlbnQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7RXZlbnR9IGEgY2xvbmUgb2YgdGhlIEV2ZW50IGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEV2ZW50KHRoaXMudHlwZSwgdGhpcy5idWJibGVzLCB0aGlzLmNhbmNlbGFibGUpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFByb3ZpZGVzIGEgY2hhaW5hYmxlIHNob3J0Y3V0IG1ldGhvZCBmb3Igc2V0dGluZyBhIG51bWJlciBvZiBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBzZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGNvcHkgdG8gdGhlIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtFdmVudH0gUmV0dXJucyB0aGUgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuc2V0ID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7IHRoaXNbbl0gPSBwcm9wc1tuXTsgfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbRXZlbnQgKHR5cGU9XCIrdGhpcy50eXBlK1wiKV1cIjtcblx0fTtcblxuXHRjcmVhdGVqcy5FdmVudCA9IEV2ZW50O1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEV2ZW50RGlzcGF0Y2hlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEV2ZW50RGlzcGF0Y2hlciBwcm92aWRlcyBtZXRob2RzIGZvciBtYW5hZ2luZyBxdWV1ZXMgb2YgZXZlbnQgbGlzdGVuZXJzIGFuZCBkaXNwYXRjaGluZyBldmVudHMuXG5cdCAqXG5cdCAqIFlvdSBjYW4gZWl0aGVyIGV4dGVuZCBFdmVudERpc3BhdGNoZXIgb3IgbWl4IGl0cyBtZXRob2RzIGludG8gYW4gZXhpc3RpbmcgcHJvdG90eXBlIG9yIGluc3RhbmNlIGJ5IHVzaW5nIHRoZVxuXHQgKiBFdmVudERpc3BhdGNoZXIge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL2luaXRpYWxpemVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBcblx0ICogVG9nZXRoZXIgd2l0aCB0aGUgQ3JlYXRlSlMgRXZlbnQgY2xhc3MsIEV2ZW50RGlzcGF0Y2hlciBwcm92aWRlcyBhbiBleHRlbmRlZCBldmVudCBtb2RlbCB0aGF0IGlzIGJhc2VkIG9uIHRoZVxuXHQgKiBET00gTGV2ZWwgMiBldmVudCBtb2RlbCwgaW5jbHVkaW5nIGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIsIGFuZCBkaXNwYXRjaEV2ZW50LiBJdCBzdXBwb3J0c1xuXHQgKiBidWJibGluZyAvIGNhcHR1cmUsIHByZXZlbnREZWZhdWx0LCBzdG9wUHJvcGFnYXRpb24sIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiwgYW5kIGhhbmRsZUV2ZW50LlxuXHQgKiBcblx0ICogRXZlbnREaXNwYXRjaGVyIGFsc28gZXhwb3NlcyBhIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vblwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QsIHdoaWNoIG1ha2VzIGl0IGVhc2llclxuXHQgKiB0byBjcmVhdGUgc2NvcGVkIGxpc3RlbmVycywgbGlzdGVuZXJzIHRoYXQgb25seSBydW4gb25jZSwgYW5kIGxpc3RlbmVycyB3aXRoIGFzc29jaWF0ZWQgYXJiaXRyYXJ5IGRhdGEuIFRoZSBcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29mZlwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgaXMgbWVyZWx5IGFuIGFsaWFzIHRvXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9yZW1vdmVFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBcblx0ICogQW5vdGhlciBhZGRpdGlvbiB0byB0aGUgRE9NIExldmVsIDIgbW9kZWwgaXMgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9yZW1vdmVBbGxFdmVudExpc3RlbmVyc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGxpc3RlbmVycyBmb3IgYWxsIGV2ZW50cywgb3IgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIGV2ZW50LiBUaGUgRXZlbnQgb2JqZWN0IGFsc28gXG5cdCAqIGluY2x1ZGVzIGEge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB3aGljaCByZW1vdmVzIHRoZSBhY3RpdmUgbGlzdGVuZXIuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogQWRkIEV2ZW50RGlzcGF0Y2hlciBjYXBhYmlsaXRpZXMgdG8gdGhlIFwiTXlDbGFzc1wiIGNsYXNzLlxuXHQgKlxuXHQgKiAgICAgIEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKE15Q2xhc3MucHJvdG90eXBlKTtcblx0ICpcblx0ICogQWRkIGFuIGV2ZW50IChzZWUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL2FkZEV2ZW50TGlzdGVuZXJcIn19e3svY3Jvc3NMaW5rfX0pLlxuXHQgKlxuXHQgKiAgICAgIGluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJldmVudE5hbWVcIiwgaGFuZGxlck1ldGhvZCk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlck1ldGhvZChldmVudCkge1xuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhldmVudC50YXJnZXQgKyBcIiBXYXMgQ2xpY2tlZFwiKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIDxiPk1haW50YWluaW5nIHByb3BlciBzY29wZTwvYj48YnIgLz5cblx0ICogU2NvcGUgKGllLiBcInRoaXNcIikgY2FuIGJlIGJlIGEgY2hhbGxlbmdlIHdpdGggZXZlbnRzLiBVc2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29uXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCB0byBzdWJzY3JpYmUgdG8gZXZlbnRzIHNpbXBsaWZpZXMgdGhpcy5cblx0ICpcblx0ICogICAgICBpbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcblx0ICogICAgICAgICAgY29uc29sZS5sb2coaW5zdGFuY2UgPT0gdGhpcyk7IC8vIGZhbHNlLCBzY29wZSBpcyBhbWJpZ3VvdXMuXG5cdCAqICAgICAgfSk7XG5cdCAqICAgICAgXG5cdCAqICAgICAgaW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhpbnN0YW5jZSA9PSB0aGlzKTsgLy8gdHJ1ZSwgXCJvblwiIHVzZXMgZGlzcGF0Y2hlciBzY29wZSBieSBkZWZhdWx0LlxuXHQgKiAgICAgIH0pO1xuXHQgKiBcblx0ICogSWYgeW91IHdhbnQgdG8gdXNlIGFkZEV2ZW50TGlzdGVuZXIgaW5zdGVhZCwgeW91IG1heSB3YW50IHRvIHVzZSBmdW5jdGlvbi5iaW5kKCkgb3IgYSBzaW1pbGFyIHByb3h5IHRvIG1hbmFnZVxuXHQgKiBzY29wZS5cblx0ICpcblx0ICogPGI+QnJvd3NlciBzdXBwb3J0PC9iPlxuXHQgKiBUaGUgZXZlbnQgbW9kZWwgaW4gQ3JlYXRlSlMgY2FuIGJlIHVzZWQgc2VwYXJhdGVseSBmcm9tIHRoZSBzdWl0ZSBpbiBhbnkgcHJvamVjdCwgaG93ZXZlciB0aGUgaW5oZXJpdGFuY2UgbW9kZWxcblx0ICogcmVxdWlyZXMgbW9kZXJuIGJyb3dzZXJzIChJRTkrKS5cblx0ICogICAgICBcblx0ICpcblx0ICogQGNsYXNzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBFdmVudERpc3BhdGNoZXIoKSB7XG5cdFxuXHRcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAcHJvcGVydHkgX2xpc3RlbmVyc1xuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqKi9cblx0XHR0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAcHJvcGVydHkgX2NhcHR1cmVMaXN0ZW5lcnNcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiovXG5cdFx0dGhpcy5fY2FwdHVyZUxpc3RlbmVycyA9IG51bGw7XG5cdH1cblx0dmFyIHAgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBzdGF0aWMgcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBTdGF0aWMgaW5pdGlhbGl6ZXIgdG8gbWl4IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzIGludG8gYSB0YXJnZXQgb2JqZWN0IG9yIHByb3RvdHlwZS5cblx0ICogXG5cdCAqIFx0XHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShNeUNsYXNzLnByb3RvdHlwZSk7IC8vIGFkZCB0byB0aGUgcHJvdG90eXBlIG9mIHRoZSBjbGFzc1xuXHQgKiBcdFx0RXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUobXlPYmplY3QpOyAvLyBhZGQgdG8gYSBzcGVjaWZpYyBpbnN0YW5jZVxuXHQgKiBcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0byBpbmplY3QgRXZlbnREaXNwYXRjaGVyIG1ldGhvZHMgaW50by4gVGhpcyBjYW4gYmUgYW4gaW5zdGFuY2Ugb3IgYVxuXHQgKiBwcm90b3R5cGUuXG5cdCAqKi9cblx0RXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lciA9IHAuYWRkRXZlbnRMaXN0ZW5lcjtcblx0XHR0YXJnZXQub24gPSBwLm9uO1xuXHRcdHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyID0gdGFyZ2V0Lm9mZiA9ICBwLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cdFx0dGFyZ2V0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gcC5yZW1vdmVBbGxFdmVudExpc3RlbmVycztcblx0XHR0YXJnZXQuaGFzRXZlbnRMaXN0ZW5lciA9IHAuaGFzRXZlbnRMaXN0ZW5lcjtcblx0XHR0YXJnZXQuZGlzcGF0Y2hFdmVudCA9IHAuZGlzcGF0Y2hFdmVudDtcblx0XHR0YXJnZXQuX2Rpc3BhdGNoRXZlbnQgPSBwLl9kaXNwYXRjaEV2ZW50O1xuXHRcdHRhcmdldC53aWxsVHJpZ2dlciA9IHAud2lsbFRyaWdnZXI7XG5cdH07XG5cdFxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEFkZHMgdGhlIHNwZWNpZmllZCBldmVudCBsaXN0ZW5lci4gTm90ZSB0aGF0IGFkZGluZyBtdWx0aXBsZSBsaXN0ZW5lcnMgdG8gdGhlIHNhbWUgZnVuY3Rpb24gd2lsbCByZXN1bHQgaW5cblx0ICogbXVsdGlwbGUgY2FsbGJhY2tzIGdldHRpbmcgZmlyZWQuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAvLyBDbGljayBoYXBwZW5lZC5cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZUV2ZW50IG1ldGhvZCwgb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cblx0ICogdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cblx0ICogQHJldHVybiB7RnVuY3Rpb24gfCBPYmplY3R9IFJldHVybnMgdGhlIGxpc3RlbmVyIGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKiovXG5cdHAuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG5cdFx0dmFyIGxpc3RlbmVycztcblx0XHRpZiAodXNlQ2FwdHVyZSkge1xuXHRcdFx0bGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnN8fHt9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnN8fHt9O1xuXHRcdH1cblx0XHR2YXIgYXJyID0gbGlzdGVuZXJzW3R5cGVdO1xuXHRcdGlmIChhcnIpIHsgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTsgfVxuXHRcdGFyciA9IGxpc3RlbmVyc1t0eXBlXTsgLy8gcmVtb3ZlIG1heSBoYXZlIGRlbGV0ZWQgdGhlIGFycmF5XG5cdFx0aWYgKCFhcnIpIHsgbGlzdGVuZXJzW3R5cGVdID0gW2xpc3RlbmVyXTsgIH1cblx0XHRlbHNlIHsgYXJyLnB1c2gobGlzdGVuZXIpOyB9XG5cdFx0cmV0dXJuIGxpc3RlbmVyO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEEgc2hvcnRjdXQgbWV0aG9kIGZvciB1c2luZyBhZGRFdmVudExpc3RlbmVyIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIHNwZWNpZnkgYW4gZXhlY3V0aW9uIHNjb3BlLCBoYXZlIGEgbGlzdGVuZXJcblx0ICogb25seSBydW4gb25jZSwgYXNzb2NpYXRlIGFyYml0cmFyeSBkYXRhIHdpdGggdGhlIGxpc3RlbmVyLCBhbmQgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cblx0ICogXG5cdCAqIFRoaXMgbWV0aG9kIHdvcmtzIGJ5IGNyZWF0aW5nIGFuIGFub255bW91cyB3cmFwcGVyIGZ1bmN0aW9uIGFuZCBzdWJzY3JpYmluZyBpdCB3aXRoIGFkZEV2ZW50TGlzdGVuZXIuXG5cdCAqIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIGlzIHJldHVybmVkIGZvciB1c2Ugd2l0aCBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgKG9yIGBvZmZgKS5cblx0ICogXG5cdCAqIDxiPklNUE9SVEFOVDo8L2I+IFRvIHJlbW92ZSBhIGxpc3RlbmVyIGFkZGVkIHdpdGggYG9uYCwgeW91IG11c3QgcGFzcyBpbiB0aGUgcmV0dXJuZWQgd3JhcHBlciBmdW5jdGlvbiBhcyB0aGUgbGlzdGVuZXIsIG9yIHVzZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudC9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0uIExpa2V3aXNlLCBlYWNoIHRpbWUgeW91IGNhbGwgYG9uYCBhIE5FVyB3cmFwcGVyIGZ1bmN0aW9uIGlzIHN1YnNjcmliZWQsIHNvIG11bHRpcGxlIGNhbGxzXG5cdCAqIHRvIGBvbmAgd2l0aCB0aGUgc2FtZSBwYXJhbXMgd2lsbCBjcmVhdGUgbXVsdGlwbGUgbGlzdGVuZXJzLlxuXHQgKiBcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBcblx0ICogXHRcdHZhciBsaXN0ZW5lciA9IG15QnRuLm9uKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2ssIG51bGwsIGZhbHNlLCB7Y291bnQ6M30pO1xuXHQgKiBcdFx0ZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZ0LCBkYXRhKSB7XG5cdCAqIFx0XHRcdGRhdGEuY291bnQgLT0gMTtcblx0ICogXHRcdFx0Y29uc29sZS5sb2codGhpcyA9PSBteUJ0bik7IC8vIHRydWUgLSBzY29wZSBkZWZhdWx0cyB0byB0aGUgZGlzcGF0Y2hlclxuXHQgKiBcdFx0XHRpZiAoZGF0YS5jb3VudCA9PSAwKSB7XG5cdCAqIFx0XHRcdFx0YWxlcnQoXCJjbGlja2VkIDMgdGltZXMhXCIpO1xuXHQgKiBcdFx0XHRcdG15QnRuLm9mZihcImNsaWNrXCIsIGxpc3RlbmVyKTtcblx0ICogXHRcdFx0XHQvLyBhbHRlcm5hdGVseTogZXZ0LnJlbW92ZSgpO1xuXHQgKiBcdFx0XHR9XG5cdCAqIFx0XHR9XG5cdCAqIFxuXHQgKiBAbWV0aG9kIG9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIEFuIG9iamVjdCB3aXRoIGEgaGFuZGxlRXZlbnQgbWV0aG9kLCBvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlblxuXHQgKiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gVGhlIHNjb3BlIHRvIGV4ZWN1dGUgdGhlIGxpc3RlbmVyIGluLiBEZWZhdWx0cyB0byB0aGUgZGlzcGF0Y2hlci9jdXJyZW50VGFyZ2V0IGZvciBmdW5jdGlvbiBsaXN0ZW5lcnMsIGFuZCB0byB0aGUgbGlzdGVuZXIgaXRzZWxmIGZvciBvYmplY3QgbGlzdGVuZXJzIChpZS4gdXNpbmcgaGFuZGxlRXZlbnQpLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBJZiB0cnVlLCB0aGUgbGlzdGVuZXIgd2lsbCByZW1vdmUgaXRzZWxmIGFmdGVyIHRoZSBmaXJzdCB0aW1lIGl0IGlzIHRyaWdnZXJlZC5cblx0ICogQHBhcmFtIHsqfSBbZGF0YV0gQXJiaXRyYXJ5IGRhdGEgdGhhdCB3aWxsIGJlIGluY2x1ZGVkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHdoZW4gdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZT1mYWxzZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYW5vbnltb3VzIGZ1bmN0aW9uIHRoYXQgd2FzIGNyZWF0ZWQgYW5kIGFzc2lnbmVkIGFzIHRoZSBsaXN0ZW5lci4gVGhpcyBpcyBuZWVkZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBsYXRlciB1c2luZyAucmVtb3ZlRXZlbnRMaXN0ZW5lci5cblx0ICoqL1xuXHRwLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHNjb3BlLCBvbmNlLCBkYXRhLCB1c2VDYXB0dXJlKSB7XG5cdFx0aWYgKGxpc3RlbmVyLmhhbmRsZUV2ZW50KSB7XG5cdFx0XHRzY29wZSA9IHNjb3BlfHxsaXN0ZW5lcjtcblx0XHRcdGxpc3RlbmVyID0gbGlzdGVuZXIuaGFuZGxlRXZlbnQ7XG5cdFx0fVxuXHRcdHNjb3BlID0gc2NvcGV8fHRoaXM7XG5cdFx0cmV0dXJuIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jdGlvbihldnQpIHtcblx0XHRcdFx0bGlzdGVuZXIuY2FsbChzY29wZSwgZXZ0LCBkYXRhKTtcblx0XHRcdFx0b25jZSYmZXZ0LnJlbW92ZSgpO1xuXHRcdFx0fSwgdXNlQ2FwdHVyZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBldmVudCBsaXN0ZW5lci5cblx0ICpcblx0ICogPGI+SW1wb3J0YW50IE5vdGU6PC9iPiB0aGF0IHlvdSBtdXN0IHBhc3MgdGhlIGV4YWN0IGZ1bmN0aW9uIHJlZmVyZW5jZSB1c2VkIHdoZW4gdGhlIGV2ZW50IHdhcyBhZGRlZC4gSWYgYSBwcm94eVxuXHQgKiBmdW5jdGlvbiwgb3IgZnVuY3Rpb24gY2xvc3VyZSBpcyB1c2VkIGFzIHRoZSBjYWxsYmFjaywgdGhlIHByb3h5L2Nsb3N1cmUgcmVmZXJlbmNlIG11c3QgYmUgdXNlZCAtIGEgbmV3IHByb3h5IG9yXG5cdCAqIGNsb3N1cmUgd2lsbCBub3Qgd29yay5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcblx0ICpcblx0ICogQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBvciBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cblx0ICoqL1xuXHRwLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuXHRcdHZhciBsaXN0ZW5lcnMgPSB1c2VDYXB0dXJlID8gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA6IHRoaXMuX2xpc3RlbmVycztcblx0XHRpZiAoIWxpc3RlbmVycykgeyByZXR1cm47IH1cblx0XHR2YXIgYXJyID0gbGlzdGVuZXJzW3R5cGVdO1xuXHRcdGlmICghYXJyKSB7IHJldHVybjsgfVxuXHRcdGZvciAodmFyIGk9MCxsPWFyci5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRpZiAoYXJyW2ldID09IGxpc3RlbmVyKSB7XG5cdFx0XHRcdGlmIChsPT0xKSB7IGRlbGV0ZShsaXN0ZW5lcnNbdHlwZV0pOyB9IC8vIGFsbG93cyBmb3IgZmFzdGVyIGNoZWNrcy5cblx0XHRcdFx0ZWxzZSB7IGFyci5zcGxpY2UoaSwxKTsgfVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHQvKipcblx0ICogQSBzaG9ydGN1dCB0byB0aGUgcmVtb3ZlRXZlbnRMaXN0ZW5lciBtZXRob2QsIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycyBhbmQgcmV0dXJuIHZhbHVlLiBUaGlzIGlzIGEgY29tcGFuaW9uIHRvIHRoZVxuXHQgKiAub24gbWV0aG9kLlxuXHQgKiBcblx0ICogPGI+SU1QT1JUQU5UOjwvYj4gVG8gcmVtb3ZlIGEgbGlzdGVuZXIgYWRkZWQgd2l0aCBgb25gLCB5b3UgbXVzdCBwYXNzIGluIHRoZSByZXR1cm5lZCB3cmFwcGVyIGZ1bmN0aW9uIGFzIHRoZSBsaXN0ZW5lci4gU2VlIFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb25cIn19e3svY3Jvc3NMaW5rfX0gZm9yIGFuIGV4YW1wbGUuXG5cdCAqXG5cdCAqIEBtZXRob2Qgb2ZmXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBvciBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cblx0ICoqL1xuXHRwLm9mZiA9IHAucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIHR5cGUsIG9yIGFsbCBsaXN0ZW5lcnMgb2YgYWxsIHR5cGVzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnNcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG5cdCAqXG5cdCAqICAgICAgLy8gUmVtb3ZlIGFsbCBjbGljayBsaXN0ZW5lcnNcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKFwiY2xpY2tcIik7XG5cdCAqXG5cdCAqIEBtZXRob2QgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnNcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LiBJZiBvbWl0dGVkLCBhbGwgbGlzdGVuZXJzIGZvciBhbGwgdHlwZXMgd2lsbCBiZSByZW1vdmVkLlxuXHQgKiovXG5cdHAucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG5cdFx0aWYgKCF0eXBlKSB7IHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSBudWxsOyB9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodGhpcy5fbGlzdGVuZXJzKSB7IGRlbGV0ZSh0aGlzLl9saXN0ZW5lcnNbdHlwZV0pOyB9XG5cdFx0XHRpZiAodGhpcy5fY2FwdHVyZUxpc3RlbmVycykgeyBkZWxldGUodGhpcy5fY2FwdHVyZUxpc3RlbmVyc1t0eXBlXSk7IH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZXMgdGhlIHNwZWNpZmllZCBldmVudCB0byBhbGwgbGlzdGVuZXJzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgLy8gVXNlIGEgc3RyaW5nIGV2ZW50XG5cdCAqICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIik7XG5cdCAqXG5cdCAqICAgICAgLy8gVXNlIGFuIEV2ZW50IGluc3RhbmNlXG5cdCAqICAgICAgdmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwicHJvZ3Jlc3NcIik7XG5cdCAqICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0ICpcblx0ICogQG1ldGhvZCBkaXNwYXRjaEV2ZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0IHwgU3RyaW5nIHwgRXZlbnR9IGV2ZW50T2JqIEFuIG9iamVjdCB3aXRoIGEgXCJ0eXBlXCIgcHJvcGVydHksIG9yIGEgc3RyaW5nIHR5cGUuXG5cdCAqIFdoaWxlIGEgZ2VuZXJpYyBvYmplY3Qgd2lsbCB3b3JrLCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYSBDcmVhdGVKUyBFdmVudCBpbnN0YW5jZS4gSWYgYSBzdHJpbmcgaXMgdXNlZCxcblx0ICogZGlzcGF0Y2hFdmVudCB3aWxsIGNvbnN0cnVjdCBhbiBFdmVudCBpbnN0YW5jZSBpZiBuZWNlc3Nhcnkgd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGUuIFRoaXMgbGF0dGVyIGFwcHJvYWNoIGNhblxuXHQgKiBiZSB1c2VkIHRvIGF2b2lkIGV2ZW50IG9iamVjdCBpbnN0YW50aWF0aW9uIGZvciBub24tYnViYmxpbmcgZXZlbnRzIHRoYXQgbWF5IG5vdCBoYXZlIGFueSBsaXN0ZW5lcnMuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXNdIFNwZWNpZmllcyB0aGUgYGJ1YmJsZXNgIHZhbHVlIHdoZW4gYSBzdHJpbmcgd2FzIHBhc3NlZCB0byBldmVudE9iai5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbY2FuY2VsYWJsZV0gU3BlY2lmaWVzIHRoZSBgY2FuY2VsYWJsZWAgdmFsdWUgd2hlbiBhIHN0cmluZyB3YXMgcGFzc2VkIHRvIGV2ZW50T2JqLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGZhbHNlIGlmIGBwcmV2ZW50RGVmYXVsdCgpYCB3YXMgY2FsbGVkIG9uIGEgY2FuY2VsYWJsZSBldmVudCwgdHJ1ZSBvdGhlcndpc2UuXG5cdCAqKi9cblx0cC5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRPYmosIGJ1YmJsZXMsIGNhbmNlbGFibGUpIHtcblx0XHRpZiAodHlwZW9mIGV2ZW50T2JqID09IFwic3RyaW5nXCIpIHtcblx0XHRcdC8vIHNraXAgZXZlcnl0aGluZyBpZiB0aGVyZSdzIG5vIGxpc3RlbmVycyBhbmQgaXQgZG9lc24ndCBidWJibGU6XG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdFx0aWYgKCFidWJibGVzICYmICghbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnNbZXZlbnRPYmpdKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0ZXZlbnRPYmogPSBuZXcgY3JlYXRlanMuRXZlbnQoZXZlbnRPYmosIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuXHRcdH0gZWxzZSBpZiAoZXZlbnRPYmoudGFyZ2V0ICYmIGV2ZW50T2JqLmNsb25lKSB7XG5cdFx0XHQvLyByZWRpc3BhdGNoaW5nIGFuIGFjdGl2ZSBldmVudCBvYmplY3QsIHNvIGNsb25lIGl0OlxuXHRcdFx0ZXZlbnRPYmogPSBldmVudE9iai5jbG9uZSgpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBUT0RPOiBpdCB3b3VsZCBiZSBuaWNlIHRvIGVsaW1pbmF0ZSB0aGlzLiBNYXliZSBpbiBmYXZvdXIgb2YgZXZ0T2JqIGluc3RhbmNlb2YgRXZlbnQ/IE9yICEhZXZ0T2JqLmNyZWF0ZUV2ZW50XG5cdFx0dHJ5IHsgZXZlbnRPYmoudGFyZ2V0ID0gdGhpczsgfSBjYXRjaCAoZSkge30gLy8gdHJ5L2NhdGNoIGFsbG93cyByZWRpc3BhdGNoaW5nIG9mIG5hdGl2ZSBldmVudHNcblxuXHRcdGlmICghZXZlbnRPYmouYnViYmxlcyB8fCAhdGhpcy5wYXJlbnQpIHtcblx0XHRcdHRoaXMuX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdG9wPXRoaXMsIGxpc3Q9W3RvcF07XG5cdFx0XHR3aGlsZSAodG9wLnBhcmVudCkgeyBsaXN0LnB1c2godG9wID0gdG9wLnBhcmVudCk7IH1cblx0XHRcdHZhciBpLCBsPWxpc3QubGVuZ3RoO1xuXG5cdFx0XHQvLyBjYXB0dXJlICYgYXRUYXJnZXRcblx0XHRcdGZvciAoaT1sLTE7IGk+PTAgJiYgIWV2ZW50T2JqLnByb3BhZ2F0aW9uU3RvcHBlZDsgaS0tKSB7XG5cdFx0XHRcdGxpc3RbaV0uX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDErKGk9PTApKTtcblx0XHRcdH1cblx0XHRcdC8vIGJ1YmJsaW5nXG5cdFx0XHRmb3IgKGk9MTsgaTxsICYmICFldmVudE9iai5wcm9wYWdhdGlvblN0b3BwZWQ7IGkrKykge1xuXHRcdFx0XHRsaXN0W2ldLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuICFldmVudE9iai5kZWZhdWx0UHJldmVudGVkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZS5cblx0ICogQG1ldGhvZCBoYXNFdmVudExpc3RlbmVyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG5cdCAqKi9cblx0cC5oYXNFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSkge1xuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMsIGNhcHR1cmVMaXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzO1xuXHRcdHJldHVybiAhISgobGlzdGVuZXJzICYmIGxpc3RlbmVyc1t0eXBlXSkgfHwgKGNhcHR1cmVMaXN0ZW5lcnMgJiYgY2FwdHVyZUxpc3RlbmVyc1t0eXBlXSkpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlIG9uIHRoaXMgb2JqZWN0IG9yIGFueSBvZiBpdHNcblx0ICogYW5jZXN0b3JzIChwYXJlbnQsIHBhcmVudCdzIHBhcmVudCwgZXRjKS4gQSByZXR1cm4gdmFsdWUgb2YgdHJ1ZSBpbmRpY2F0ZXMgdGhhdCBpZiBhIGJ1YmJsaW5nIGV2ZW50IG9mIHRoZVxuXHQgKiBzcGVjaWZpZWQgdHlwZSBpcyBkaXNwYXRjaGVkIGZyb20gdGhpcyBvYmplY3QsIGl0IHdpbGwgdHJpZ2dlciBhdCBsZWFzdCBvbmUgbGlzdGVuZXIuXG5cdCAqIFxuXHQgKiBUaGlzIGlzIHNpbWlsYXIgdG8ge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL2hhc0V2ZW50TGlzdGVuZXJcIn19e3svY3Jvc3NMaW5rfX0sIGJ1dCBpdCBzZWFyY2hlcyB0aGUgZW50aXJlXG5cdCAqIGV2ZW50IGZsb3cgZm9yIGEgbGlzdGVuZXIsIG5vdCBqdXN0IHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHdpbGxUcmlnZ2VyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cblx0ICoqL1xuXHRwLndpbGxUcmlnZ2VyID0gZnVuY3Rpb24odHlwZSkge1xuXHRcdHZhciBvID0gdGhpcztcblx0XHR3aGlsZSAobykge1xuXHRcdFx0aWYgKG8uaGFzRXZlbnRMaXN0ZW5lcih0eXBlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0byA9IG8ucGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltFdmVudERpc3BhdGNoZXJdXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfZGlzcGF0Y2hFdmVudFxuXHQgKiBAcGFyYW0ge09iamVjdCB8IFN0cmluZyB8IEV2ZW50fSBldmVudE9ialxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRQaGFzZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50T2JqLCBldmVudFBoYXNlKSB7XG5cdFx0dmFyIGwsIGxpc3RlbmVycyA9IChldmVudFBoYXNlPT0xKSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0aWYgKGV2ZW50T2JqICYmIGxpc3RlbmVycykge1xuXHRcdFx0dmFyIGFyciA9IGxpc3RlbmVyc1tldmVudE9iai50eXBlXTtcblx0XHRcdGlmICghYXJyfHwhKGw9YXJyLmxlbmd0aCkpIHsgcmV0dXJuOyB9XG5cdFx0XHR0cnkgeyBldmVudE9iai5jdXJyZW50VGFyZ2V0ID0gdGhpczsgfSBjYXRjaCAoZSkge31cblx0XHRcdHRyeSB7IGV2ZW50T2JqLmV2ZW50UGhhc2UgPSBldmVudFBoYXNlOyB9IGNhdGNoIChlKSB7fVxuXHRcdFx0ZXZlbnRPYmoucmVtb3ZlZCA9IGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRhcnIgPSBhcnIuc2xpY2UoKTsgLy8gdG8gYXZvaWQgaXNzdWVzIHdpdGggaXRlbXMgYmVpbmcgcmVtb3ZlZCBvciBhZGRlZCBkdXJpbmcgdGhlIGRpc3BhdGNoXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bCAmJiAhZXZlbnRPYmouaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOyBpKyspIHtcblx0XHRcdFx0dmFyIG8gPSBhcnJbaV07XG5cdFx0XHRcdGlmIChvLmhhbmRsZUV2ZW50KSB7IG8uaGFuZGxlRXZlbnQoZXZlbnRPYmopOyB9XG5cdFx0XHRcdGVsc2UgeyBvKGV2ZW50T2JqKTsgfVxuXHRcdFx0XHRpZiAoZXZlbnRPYmoucmVtb3ZlZCkge1xuXHRcdFx0XHRcdHRoaXMub2ZmKGV2ZW50T2JqLnR5cGUsIG8sIGV2ZW50UGhhc2U9PTEpO1xuXHRcdFx0XHRcdGV2ZW50T2JqLnJlbW92ZWQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXG5cdGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlciA9IEV2ZW50RGlzcGF0Y2hlcjtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUaWNrZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGUgVGlja2VyIHByb3ZpZGVzIGEgY2VudHJhbGl6ZWQgdGljayBvciBoZWFydGJlYXQgYnJvYWRjYXN0IGF0IGEgc2V0IGludGVydmFsLiBMaXN0ZW5lcnMgY2FuIHN1YnNjcmliZSB0byB0aGUgdGlja1xuXHQgKiBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIGEgc2V0IHRpbWUgaW50ZXJ2YWwgaGFzIGVsYXBzZWQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgaW50ZXJ2YWwgdGhhdCB0aGUgdGljayBldmVudCBpcyBjYWxsZWQgaXMgYSB0YXJnZXQgaW50ZXJ2YWwsIGFuZCBtYXkgYmUgYnJvYWRjYXN0IGF0IGEgc2xvd2VyIGludGVydmFsXG5cdCAqIHdoZW4gdW5kZXIgaGlnaCBDUFUgbG9hZC4gVGhlIFRpY2tlciBjbGFzcyB1c2VzIGEgc3RhdGljIGludGVyZmFjZSAoZXguIGBUaWNrZXIuZnJhbWVyYXRlID0gMzA7YCkgYW5kXG5cdCAqIGNhbiBub3QgYmUgaW5zdGFudGlhdGVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgLy8gQWN0aW9ucyBjYXJyaWVkIG91dCBlYWNoIHRpY2sgKGFrYSBmcmFtZSlcblx0ICogICAgICAgICAgaWYgKCFldmVudC5wYXVzZWQpIHtcblx0ICogICAgICAgICAgICAgIC8vIEFjdGlvbnMgY2FycmllZCBvdXQgd2hlbiB0aGUgVGlja2VyIGlzIG5vdCBwYXVzZWQuXG5cdCAqICAgICAgICAgIH1cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBjbGFzcyBUaWNrZXJcblx0ICogQHVzZXMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRmdW5jdGlvbiBUaWNrZXIoKSB7XG5cdFx0dGhyb3cgXCJUaWNrZXIgY2Fubm90IGJlIGluc3RhbnRpYXRlZC5cIjtcblx0fVxuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIEluIHRoaXMgbW9kZSwgVGlja2VyIHVzZXMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBBUEksIGJ1dCBhdHRlbXB0cyB0byBzeW5jaCB0aGUgdGlja3MgdG8gdGFyZ2V0IGZyYW1lcmF0ZS4gSXRcblx0ICogdXNlcyBhIHNpbXBsZSBoZXVyaXN0aWMgdGhhdCBjb21wYXJlcyB0aGUgdGltZSBvZiB0aGUgUkFGIHJldHVybiB0byB0aGUgdGFyZ2V0IHRpbWUgZm9yIHRoZSBjdXJyZW50IGZyYW1lIGFuZFxuXHQgKiBkaXNwYXRjaGVzIHRoZSB0aWNrIHdoZW4gdGhlIHRpbWUgaXMgd2l0aGluIGEgY2VydGFpbiB0aHJlc2hvbGQuXG5cdCAqXG5cdCAqIFRoaXMgbW9kZSBoYXMgYSBoaWdoZXIgdmFyaWFuY2UgZm9yIHRpbWUgYmV0d2VlbiBmcmFtZXMgdGhhbiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYnV0IGRvZXMgbm90IHJlcXVpcmUgdGhhdCBjb250ZW50IGJlIHRpbWUgYmFzZWQgYXMgd2l0aCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvUkFGOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHdoaWxlXG5cdCAqIGdhaW5pbmcgdGhlIGJlbmVmaXRzIG9mIHRoYXQgQVBJIChzY3JlZW4gc3luY2gsIGJhY2tncm91bmQgdGhyb3R0bGluZykuXG5cdCAqXG5cdCAqIFZhcmlhbmNlIGlzIHVzdWFsbHkgbG93ZXN0IGZvciBmcmFtZXJhdGVzIHRoYXQgYXJlIGEgZGl2aXNvciBvZiB0aGUgUkFGIGZyZXF1ZW5jeS4gVGhpcyBpcyB1c3VhbGx5IDYwLCBzb1xuXHQgKiBmcmFtZXJhdGVzIG9mIDEwLCAxMiwgMTUsIDIwLCBhbmQgMzAgd29yayB3ZWxsLlxuXHQgKlxuXHQgKiBGYWxscyBiYWNrIHRvIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlmIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJIGlzIG5vdFxuXHQgKiBzdXBwb3J0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBSQUZfU1lOQ0hFRFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFwic3luY2hlZFwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFRpY2tlci5SQUZfU1lOQ0hFRCA9IFwic3luY2hlZFwiO1xuXG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciBwYXNzZXMgdGhyb3VnaCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGhlYXJ0YmVhdCwgaWdub3JpbmcgdGhlIHRhcmdldCBmcmFtZXJhdGUgY29tcGxldGVseS5cblx0ICogQmVjYXVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnJlcXVlbmN5IGlzIG5vdCBkZXRlcm1pbmlzdGljLCBhbnkgY29udGVudCB1c2luZyB0aGlzIG1vZGUgc2hvdWxkIGJlIHRpbWUgYmFzZWQuXG5cdCAqIFlvdSBjYW4gbGV2ZXJhZ2Uge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2dldFRpbWVcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBvYmplY3QncyBcImRlbHRhXCIgcHJvcGVydGllcyB0byBtYWtlIHRoaXMgZWFzaWVyLlxuXHQgKlxuXHQgKiBGYWxscyBiYWNrIG9uIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlmIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJIGlzIG5vdFxuXHQgKiBzdXBwb3J0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBSQUZcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBcInJhZlwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFRpY2tlci5SQUYgPSBcInJhZlwiO1xuXG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciB1c2VzIHRoZSBzZXRUaW1lb3V0IEFQSS4gVGhpcyBwcm92aWRlcyBwcmVkaWN0YWJsZSwgYWRhcHRpdmUgZnJhbWUgdGltaW5nLCBidXQgZG9lcyBub3Rcblx0ICogcHJvdmlkZSB0aGUgYmVuZWZpdHMgb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChzY3JlZW4gc3luY2gsIGJhY2tncm91bmQgdGhyb3R0bGluZykuXG5cdCAqIEBwcm9wZXJ0eSBUSU1FT1VUXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgXCJ0aW1lb3V0XCJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0VGlja2VyLlRJTUVPVVQgPSBcInRpbWVvdXRcIjtcblxuXG4vLyBzdGF0aWMgZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBlYWNoIHRpY2suIFRoZSBldmVudCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gZWFjaCBsaXN0ZW5lciBldmVuIHdoZW4gdGhlIFRpY2tlciBoYXMgYmVlbiBwYXVzZWQgdXNpbmdcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3NldFBhdXNlZFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVUaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKFwiUGF1c2VkOlwiLCBldmVudC5wYXVzZWQsIGV2ZW50LmRlbHRhKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBldmVudCB0aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBwYXVzZWQgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpY2tlciBpcyBjdXJyZW50bHkgcGF1c2VkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgVGhlIHRpbWUgZWxhcHNlZCBpbiBtcyBzaW5jZSB0aGUgbGFzdCB0aWNrLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgdG90YWwgdGltZSBpbiBtcyBzaW5jZSBUaWNrZXIgd2FzIGluaXRpYWxpemVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcnVuVGltZSBUaGUgdG90YWwgdGltZSBpbiBtcyB0aGF0IFRpY2tlciB3YXMgbm90IHBhdXNlZCBzaW5jZSBpdCB3YXMgaW5pdGlhbGl6ZWQuIEZvciBleGFtcGxlLFxuXHQgKiBcdHlvdSBjb3VsZCBkZXRlcm1pbmUgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgdGhlIFRpY2tlciBoYXMgYmVlbiBwYXVzZWQgc2luY2UgaW5pdGlhbGl6YXRpb24gd2l0aCBgdGltZS1ydW5UaW1lYC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cbi8vIHB1YmxpYyBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aW1pbmdNb2RlXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIElmIHRydWUsIHRpbWluZ01vZGUgd2lsbFxuXHQgKiB1c2Uge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRl9TWU5DSEVEXCJ9fXt7L2Nyb3NzTGlua319IGJ5IGRlZmF1bHQuXG5cdCAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aW1pbmdNb2RlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcHJvcGVydHkgdXNlUkFGXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqKi9cblx0VGlja2VyLnVzZVJBRiA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgdGhlIHRpbWluZyBhcGkgKHNldFRpbWVvdXQgb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSBhbmQgbW9kZSB0byB1c2UuIFNlZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVFwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRlwifX17ey9jcm9zc0xpbmt9fSwgYW5kXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRpY2tlci9SQUZfU1lOQ0hFRFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9kZSBkZXRhaWxzLlxuXHQgKiBAcHJvcGVydHkgdGltaW5nTW9kZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFRpY2tlci5USU1FT1VUXG5cdCAqKi9cblx0VGlja2VyLnRpbWluZ01vZGUgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgYSBtYXhpbXVtIHZhbHVlIGZvciB0aGUgZGVsdGEgcHJvcGVydHkgaW4gdGhlIHRpY2sgZXZlbnQgb2JqZWN0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGJ1aWxkaW5nIHRpbWVcblx0ICogYmFzZWQgYW5pbWF0aW9ucyBhbmQgc3lzdGVtcyB0byBwcmV2ZW50IGlzc3VlcyBjYXVzZWQgYnkgbGFyZ2UgdGltZSBnYXBzIGNhdXNlZCBieSBiYWNrZ3JvdW5kIHRhYnMsIHN5c3RlbSBzbGVlcCxcblx0ICogYWxlcnQgZGlhbG9ncywgb3Igb3RoZXIgYmxvY2tpbmcgcm91dGluZXMuIERvdWJsZSB0aGUgZXhwZWN0ZWQgZnJhbWUgZHVyYXRpb24gaXMgb2Z0ZW4gYW4gZWZmZWN0aXZlIHZhbHVlXG5cdCAqIChleC4gbWF4RGVsdGE9NTAgd2hlbiBydW5uaW5nIGF0IDQwZnBzKS5cblx0ICogXG5cdCAqIFRoaXMgZG9lcyBub3QgaW1wYWN0IGFueSBvdGhlciB2YWx1ZXMgKGV4LiB0aW1lLCBydW5UaW1lLCBldGMpLCBzbyB5b3UgbWF5IGV4cGVyaWVuY2UgaXNzdWVzIGlmIHlvdSBlbmFibGUgbWF4RGVsdGFcblx0ICogd2hlbiB1c2luZyBib3RoIGRlbHRhIGFuZCBvdGhlciB2YWx1ZXMuXG5cdCAqIFxuXHQgKiBJZiAwLCB0aGVyZSBpcyBubyBtYXhpbXVtLlxuXHQgKiBAcHJvcGVydHkgbWF4RGVsdGFcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAwXG5cdCAqL1xuXHRUaWNrZXIubWF4RGVsdGEgPSAwO1xuXHRcblx0LyoqXG5cdCAqIFdoZW4gdGhlIHRpY2tlciBpcyBwYXVzZWQsIGFsbCBsaXN0ZW5lcnMgd2lsbCBzdGlsbCByZWNlaXZlIGEgdGljayBldmVudCwgYnV0IHRoZSA8Y29kZT5wYXVzZWQ8L2NvZGU+IHByb3BlcnR5XG5cdCAqIG9mIHRoZSBldmVudCB3aWxsIGJlIGB0cnVlYC4gQWxzbywgd2hpbGUgcGF1c2VkIHRoZSBgcnVuVGltZWAgd2lsbCBub3QgaW5jcmVhc2UuIFNlZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fSxcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2dldFRpbWVcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZ2V0RXZlbnRUaW1lXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlXG5cdCAqIGluZm8uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLnBhdXNlZCA9IHRydWU7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlVGljayhldmVudCkge1xuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhldmVudC5wYXVzZWQsXG5cdCAqICAgICAgICAgIFx0Y3JlYXRlanMuVGlja2VyLmdldFRpbWUoZmFsc2UpLFxuXHQgKiAgICAgICAgICBcdGNyZWF0ZWpzLlRpY2tlci5nZXRUaW1lKHRydWUpKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBwYXVzZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICoqL1xuXHRUaWNrZXIucGF1c2VkID0gZmFsc2U7XG5cblxuLy8gbWl4LWluczpcblx0Ly8gRXZlbnREaXNwYXRjaGVyIG1ldGhvZHM6XG5cdFRpY2tlci5yZW1vdmVFdmVudExpc3RlbmVyID0gbnVsbDtcblx0VGlja2VyLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gbnVsbDtcblx0VGlja2VyLmRpc3BhdGNoRXZlbnQgPSBudWxsO1xuXHRUaWNrZXIuaGFzRXZlbnRMaXN0ZW5lciA9IG51bGw7XG5cdFRpY2tlci5fbGlzdGVuZXJzID0gbnVsbDtcblx0Y3JlYXRlanMuRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoVGlja2VyKTsgLy8gaW5qZWN0IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzLlxuXHRUaWNrZXIuX2FkZEV2ZW50TGlzdGVuZXIgPSBUaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcjtcblx0VGlja2VyLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0XHQhVGlja2VyLl9pbml0ZWQmJlRpY2tlci5pbml0KCk7XG5cdFx0cmV0dXJuIFRpY2tlci5fYWRkRXZlbnRMaXN0ZW5lci5hcHBseShUaWNrZXIsIGFyZ3VtZW50cyk7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfaW5pdGVkXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2luaXRlZCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3N0YXJ0VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3N0YXJ0VGltZSA9IDA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfcGF1c2VkVGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3BhdXNlZFRpbWU9MDtcblxuXHQvKipcblx0ICogVGhlIG51bWJlciBvZiB0aWNrcyB0aGF0IGhhdmUgcGFzc2VkXG5cdCAqIEBwcm9wZXJ0eSBfdGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aWNrcyA9IDA7XG5cblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgdGlja3MgdGhhdCBoYXZlIHBhc3NlZCB3aGlsZSBUaWNrZXIgaGFzIGJlZW4gcGF1c2VkXG5cdCAqIEBwcm9wZXJ0eSBfcGF1c2VkVGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9wYXVzZWRUaWNrcyA9IDA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfaW50ZXJ2YWxcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9pbnRlcnZhbCA9IDUwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2xhc3RUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fbGFzdFRpbWUgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3RpbWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aW1lcyA9IG51bGw7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfdGlja1RpbWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aWNrVGltZXMgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBTdG9yZXMgdGhlIHRpbWVvdXQgb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGlkLlxuXHQgKiBAcHJvcGVydHkgX3RpbWVySWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XG5cdC8qKlxuXHQgKiBUcnVlIGlmIGN1cnJlbnRseSB1c2luZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGZhbHNlIGlmIHVzaW5nIHNldFRpbWVvdXQuIFRoaXMgbWF5IGJlIGRpZmZlcmVudCB0aGFuIHRpbWluZ01vZGVcblx0ICogaWYgdGhhdCBwcm9wZXJ0eSBjaGFuZ2VkIGFuZCBhIHRpY2sgaGFzbid0IGZpcmVkLlxuXHQgKiBAcHJvcGVydHkgX3JhZlxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9yYWYgPSB0cnVlO1xuXHRcblxuLy8gc3RhdGljIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9pbnRlcnZhbDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIHNldEludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLnNldEludGVydmFsID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcblx0XHRUaWNrZXIuX2ludGVydmFsID0gaW50ZXJ2YWw7XG5cdFx0aWYgKCFUaWNrZXIuX2luaXRlZCkgeyByZXR1cm47IH1cblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9pbnRlcnZhbDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdFRpY2tlci5nZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBUaWNrZXIuX2ludGVydmFsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBzZXRGUFNcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuc2V0RlBTID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRUaWNrZXIuc2V0SW50ZXJ2YWwoMTAwMC92YWx1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2ZyYW1lcmF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEZQU1xuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuZ2V0RlBTID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIDEwMDAvVGlja2VyLl9pbnRlcnZhbDtcblx0fTtcblxuXHQvKipcblx0ICogSW5kaWNhdGVzIHRoZSB0YXJnZXQgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSBiZXR3ZWVuIHRpY2tzLiBEZWZhdWx0IGlzIDUwICgyMCBGUFMpLlxuXHQgKiBOb3RlIHRoYXQgYWN0dWFsIHRpbWUgYmV0d2VlbiB0aWNrcyBtYXkgYmUgbW9yZSB0aGFuIHNwZWNpZmllZCBkZXBlbmRpbmcgb24gQ1BVIGxvYWQuXG5cdCAqIFRoaXMgcHJvcGVydHkgaXMgaWdub3JlZCBpZiB0aGUgdGlja2VyIGlzIHVzaW5nIHRoZSBgUkFGYCB0aW1pbmcgbW9kZS5cblx0ICogQHByb3BlcnR5IGludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICoqL1xuXHQgXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgdGhlIHRhcmdldCBmcmFtZSByYXRlIGluIGZyYW1lcyBwZXIgc2Vjb25kIChGUFMpLiBFZmZlY3RpdmVseSBqdXN0IGEgc2hvcnRjdXQgdG8gYGludGVydmFsYCwgd2hlcmVcblx0ICogYGZyYW1lcmF0ZSA9PSAxMDAwL2ludGVydmFsYC5cblx0ICogQHByb3BlcnR5IGZyYW1lcmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhUaWNrZXIsIHtcblx0XHRcdGludGVydmFsOiB7IGdldDogVGlja2VyLmdldEludGVydmFsLCBzZXQ6IFRpY2tlci5zZXRJbnRlcnZhbCB9LFxuXHRcdFx0ZnJhbWVyYXRlOiB7IGdldDogVGlja2VyLmdldEZQUywgc2V0OiBUaWNrZXIuc2V0RlBTIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkgeyBjb25zb2xlLmxvZyhlKTsgfVxuXG5cbi8vIHB1YmxpYyBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFN0YXJ0cyB0aGUgdGljay4gVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBmaXJzdCBsaXN0ZW5lciBpcyBhZGRlZC5cblx0ICogQG1ldGhvZCBpbml0XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUaWNrZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChUaWNrZXIuX2luaXRlZCkgeyByZXR1cm47IH1cblx0XHRUaWNrZXIuX2luaXRlZCA9IHRydWU7XG5cdFx0VGlja2VyLl90aW1lcyA9IFtdO1xuXHRcdFRpY2tlci5fdGlja1RpbWVzID0gW107XG5cdFx0VGlja2VyLl9zdGFydFRpbWUgPSBUaWNrZXIuX2dldFRpbWUoKTtcblx0XHRUaWNrZXIuX3RpbWVzLnB1c2goVGlja2VyLl9sYXN0VGltZSA9IDApO1xuXHRcdFRpY2tlci5pbnRlcnZhbCA9IFRpY2tlci5faW50ZXJ2YWw7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU3RvcHMgdGhlIFRpY2tlciBhbmQgcmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiBVc2UgaW5pdCgpIHRvIHJlc3RhcnQgdGhlIFRpY2tlci5cblx0ICogQG1ldGhvZCByZXNldFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VGlja2VyLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKFRpY2tlci5fcmFmKSB7XG5cdFx0XHR2YXIgZiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cdFx0XHRmJiZmKFRpY2tlci5fdGltZXJJZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNsZWFyVGltZW91dChUaWNrZXIuX3RpbWVySWQpO1xuXHRcdH1cblx0XHRUaWNrZXIucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoXCJ0aWNrXCIpO1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IFRpY2tlci5fdGltZXMgPSBUaWNrZXIuX3RpY2tUaW1lcyA9IG51bGw7XG5cdFx0VGlja2VyLl9zdGFydFRpbWUgPSBUaWNrZXIuX2xhc3RUaW1lID0gVGlja2VyLl90aWNrcyA9IDA7XG5cdFx0VGlja2VyLl9pbml0ZWQgPSBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYXZlcmFnZSB0aW1lIHNwZW50IHdpdGhpbiBhIHRpY2suIFRoaXMgY2FuIHZhcnkgc2lnbmlmaWNhbnRseSBmcm9tIHRoZSB2YWx1ZSBwcm92aWRlZCBieSBnZXRNZWFzdXJlZEZQU1xuXHQgKiBiZWNhdXNlIGl0IG9ubHkgbWVhc3VyZXMgdGhlIHRpbWUgc3BlbnQgd2l0aGluIHRoZSB0aWNrIGV4ZWN1dGlvbiBzdGFjay4gXG5cdCAqIFxuXHQgKiBFeGFtcGxlIDE6IFdpdGggYSB0YXJnZXQgRlBTIG9mIDIwLCBnZXRNZWFzdXJlZEZQUygpIHJldHVybnMgMjBmcHMsIHdoaWNoIGluZGljYXRlcyBhbiBhdmVyYWdlIG9mIDUwbXMgYmV0d2VlbiBcblx0ICogdGhlIGVuZCBvZiBvbmUgdGljayBhbmQgdGhlIGVuZCBvZiB0aGUgbmV4dC4gSG93ZXZlciwgZ2V0TWVhc3VyZWRUaWNrVGltZSgpIHJldHVybnMgMTVtcy4gVGhpcyBpbmRpY2F0ZXMgdGhhdCBcblx0ICogdGhlcmUgbWF5IGJlIHVwIHRvIDM1bXMgb2YgXCJpZGxlXCIgdGltZSBiZXR3ZWVuIHRoZSBlbmQgb2Ygb25lIHRpY2sgYW5kIHRoZSBzdGFydCBvZiB0aGUgbmV4dC5cblx0ICpcblx0ICogRXhhbXBsZSAyOiBXaXRoIGEgdGFyZ2V0IEZQUyBvZiAzMCwgZ2V0RlBTKCkgcmV0dXJucyAxMGZwcywgd2hpY2ggaW5kaWNhdGVzIGFuIGF2ZXJhZ2Ugb2YgMTAwbXMgYmV0d2VlbiB0aGUgZW5kIG9mXG5cdCAqIG9uZSB0aWNrIGFuZCB0aGUgZW5kIG9mIHRoZSBuZXh0LiBIb3dldmVyLCBnZXRNZWFzdXJlZFRpY2tUaW1lKCkgcmV0dXJucyAyMG1zLiBUaGlzIHdvdWxkIGluZGljYXRlIHRoYXQgc29tZXRoaW5nXG5cdCAqIG90aGVyIHRoYW4gdGhlIHRpY2sgaXMgdXNpbmcgfjgwbXMgKGFub3RoZXIgc2NyaXB0LCBET00gcmVuZGVyaW5nLCBldGMpLlxuXHQgKiBAbWV0aG9kIGdldE1lYXN1cmVkVGlja1RpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpY2tzXSBUaGUgbnVtYmVyIG9mIHByZXZpb3VzIHRpY2tzIG92ZXIgd2hpY2ggdG8gbWVhc3VyZSB0aGUgYXZlcmFnZSB0aW1lIHNwZW50IGluIGEgdGljay5cblx0ICogRGVmYXVsdHMgdG8gdGhlIG51bWJlciBvZiB0aWNrcyBwZXIgc2Vjb25kLiBUbyBnZXQgb25seSB0aGUgbGFzdCB0aWNrJ3MgdGltZSwgcGFzcyBpbiAxLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhdmVyYWdlIHRpbWUgc3BlbnQgaW4gYSB0aWNrIGluIG1pbGxpc2Vjb25kcy5cblx0ICoqL1xuXHRUaWNrZXIuZ2V0TWVhc3VyZWRUaWNrVGltZSA9IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIHR0bD0wLCB0aW1lcz1UaWNrZXIuX3RpY2tUaW1lcztcblx0XHRpZiAoIXRpbWVzIHx8IHRpbWVzLmxlbmd0aCA8IDEpIHsgcmV0dXJuIC0xOyB9XG5cblx0XHQvLyBieSBkZWZhdWx0LCBjYWxjdWxhdGUgYXZlcmFnZSBmb3IgdGhlIHBhc3QgfjEgc2Vjb25kOlxuXHRcdHRpY2tzID0gTWF0aC5taW4odGltZXMubGVuZ3RoLCB0aWNrc3x8KFRpY2tlci5nZXRGUFMoKXwwKSk7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPHRpY2tzOyBpKyspIHsgdHRsICs9IHRpbWVzW2ldOyB9XG5cdFx0cmV0dXJuIHR0bC90aWNrcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYWN0dWFsIGZyYW1lcyAvIHRpY2tzIHBlciBzZWNvbmQuXG5cdCAqIEBtZXRob2QgZ2V0TWVhc3VyZWRGUFNcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpY2tzXSBUaGUgbnVtYmVyIG9mIHByZXZpb3VzIHRpY2tzIG92ZXIgd2hpY2ggdG8gbWVhc3VyZSB0aGUgYWN0dWFsIGZyYW1lcyAvIHRpY2tzIHBlciBzZWNvbmQuXG5cdCAqIERlZmF1bHRzIHRvIHRoZSBudW1iZXIgb2YgdGlja3MgcGVyIHNlY29uZC5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgYWN0dWFsIGZyYW1lcyAvIHRpY2tzIHBlciBzZWNvbmQuIERlcGVuZGluZyBvbiBwZXJmb3JtYW5jZSwgdGhpcyBtYXkgZGlmZmVyXG5cdCAqIGZyb20gdGhlIHRhcmdldCBmcmFtZXMgcGVyIHNlY29uZC5cblx0ICoqL1xuXHRUaWNrZXIuZ2V0TWVhc3VyZWRGUFMgPSBmdW5jdGlvbih0aWNrcykge1xuXHRcdHZhciB0aW1lcyA9IFRpY2tlci5fdGltZXM7XG5cdFx0aWYgKCF0aW1lcyB8fCB0aW1lcy5sZW5ndGggPCAyKSB7IHJldHVybiAtMTsgfVxuXG5cdFx0Ly8gYnkgZGVmYXVsdCwgY2FsY3VsYXRlIGZwcyBmb3IgdGhlIHBhc3QgfjEgc2Vjb25kOlxuXHRcdHRpY2tzID0gTWF0aC5taW4odGltZXMubGVuZ3RoLTEsIHRpY2tzfHwoVGlja2VyLmdldEZQUygpfDApKTtcblx0XHRyZXR1cm4gMTAwMC8oKHRpbWVzWzBdLXRpbWVzW3RpY2tzXSkvdGlja3MpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9wYXVzZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBzZXRQYXVzZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLnNldFBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0Ly8gVE9ETzogZGVwcmVjYXRlZC5cblx0XHRUaWNrZXIucGF1c2VkID0gdmFsdWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3BhdXNlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldFBhdXNlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLmdldFBhdXNlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cdFx0cmV0dXJuIFRpY2tlci5wYXVzZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgVGlja2VyIHdhcyBpbml0aWFsaXplZCB2aWEge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2luaXRcIn19LlxuXHQgKiBSZXR1cm5zIC0xIGlmIFRpY2tlciBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuIEZvciBleGFtcGxlLCB5b3UgY291bGQgdXNlXG5cdCAqIHRoaXMgaW4gYSB0aW1lIHN5bmNocm9uaXplZCBhbmltYXRpb24gdG8gZGV0ZXJtaW5lIHRoZSBleGFjdCBhbW91bnQgb2YgdGltZSB0aGF0IGhhcyBlbGFwc2VkLlxuXHQgKiBAbWV0aG9kIGdldFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtydW5UaW1lPWZhbHNlXSBJZiB0cnVlIG9ubHkgdGltZSBlbGFwc2VkIHdoaWxlIFRpY2tlciB3YXMgbm90IHBhdXNlZCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBJZiBmYWxzZSwgdGhlIHZhbHVlIHJldHVybmVkIHdpbGwgYmUgdG90YWwgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBmaXJzdCB0aWNrIGV2ZW50IGxpc3RlbmVyIHdhcyBhZGRlZC5cblx0ICogQHJldHVybiB7TnVtYmVyfSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIFRpY2tlciB3YXMgaW5pdGlhbGl6ZWQgb3IgLTEuXG5cdCAqKi9cblx0VGlja2VyLmdldFRpbWUgPSBmdW5jdGlvbihydW5UaW1lKSB7XG5cdFx0cmV0dXJuIFRpY2tlci5fc3RhcnRUaW1lID8gVGlja2VyLl9nZXRUaW1lKCkgLSAocnVuVGltZSA/IFRpY2tlci5fcGF1c2VkVGltZSA6IDApIDogLTE7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNpbWlsYXIgdG8gdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9nZXRUaW1lXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCwgYnV0IHJldHVybnMgdGhlIHRpbWUgb24gdGhlIG1vc3QgcmVjZW50IHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IG9iamVjdC5cblx0ICogQG1ldGhvZCBnZXRFdmVudFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0gcnVuVGltZSB7Qm9vbGVhbn0gW3J1blRpbWU9ZmFsc2VdIElmIHRydWUsIHRoZSBydW5UaW1lIHByb3BlcnR5IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiB0aW1lLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdGltZSBvciBydW5UaW1lIHByb3BlcnR5IGZyb20gdGhlIG1vc3QgcmVjZW50IHRpY2sgZXZlbnQgb3IgLTEuXG5cdCAqL1xuXHRUaWNrZXIuZ2V0RXZlbnRUaW1lID0gZnVuY3Rpb24ocnVuVGltZSkge1xuXHRcdHJldHVybiBUaWNrZXIuX3N0YXJ0VGltZSA/IChUaWNrZXIuX2xhc3RUaW1lIHx8IFRpY2tlci5fc3RhcnRUaW1lKSAtIChydW5UaW1lID8gVGlja2VyLl9wYXVzZWRUaW1lIDogMCkgOiAtMTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGlja3MgdGhhdCBoYXZlIGJlZW4gYnJvYWRjYXN0IGJ5IFRpY2tlci5cblx0ICogQG1ldGhvZCBnZXRUaWNrc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGF1c2VhYmxlIEluZGljYXRlcyB3aGV0aGVyIHRvIGluY2x1ZGUgdGlja3MgdGhhdCB3b3VsZCBoYXZlIGJlZW4gYnJvYWRjYXN0XG5cdCAqIHdoaWxlIFRpY2tlciB3YXMgcGF1c2VkLiBJZiB0cnVlIG9ubHkgdGljayBldmVudHMgYnJvYWRjYXN0IHdoaWxlIFRpY2tlciBpcyBub3QgcGF1c2VkIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIElmIGZhbHNlLCB0aWNrIGV2ZW50cyB0aGF0IHdvdWxkIGhhdmUgYmVlbiBicm9hZGNhc3Qgd2hpbGUgVGlja2VyIHdhcyBwYXVzZWQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcmV0dXJuXG5cdCAqIHZhbHVlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBmYWxzZS5cblx0ICogQHJldHVybiB7TnVtYmVyfSBvZiB0aWNrcyB0aGF0IGhhdmUgYmVlbiBicm9hZGNhc3QuXG5cdCAqKi9cblx0VGlja2VyLmdldFRpY2tzID0gZnVuY3Rpb24ocGF1c2VhYmxlKSB7XG5cdFx0cmV0dXJuICBUaWNrZXIuX3RpY2tzIC0gKHBhdXNlYWJsZSA/IFRpY2tlci5fcGF1c2VkVGlja3MgOiAwKTtcblx0fTtcblxuXG4vLyBwcml2YXRlIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlU3luY2hcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9oYW5kbGVTeW5jaCA9IGZ1bmN0aW9uKCkge1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IG51bGw7XG5cdFx0VGlja2VyLl9zZXR1cFRpY2soKTtcblxuXHRcdC8vIHJ1biBpZiBlbm91Z2ggdGltZSBoYXMgZWxhcHNlZCwgd2l0aCBhIGxpdHRsZSBiaXQgb2YgZmxleGliaWxpdHkgdG8gYmUgZWFybHk6XG5cdFx0aWYgKFRpY2tlci5fZ2V0VGltZSgpIC0gVGlja2VyLl9sYXN0VGltZSA+PSAoVGlja2VyLl9pbnRlcnZhbC0xKSowLjk3KSB7XG5cdFx0XHRUaWNrZXIuX3RpY2soKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVJBRlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2hhbmRsZVJBRiA9IGZ1bmN0aW9uKCkge1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IG51bGw7XG5cdFx0VGlja2VyLl9zZXR1cFRpY2soKTtcblx0XHRUaWNrZXIuX3RpY2soKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlVGltZW91dFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2hhbmRsZVRpbWVvdXQgPSBmdW5jdGlvbigpIHtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBudWxsO1xuXHRcdFRpY2tlci5fc2V0dXBUaWNrKCk7XG5cdFx0VGlja2VyLl90aWNrKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3NldHVwVGlja1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3NldHVwVGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChUaWNrZXIuX3RpbWVySWQgIT0gbnVsbCkgeyByZXR1cm47IH0gLy8gYXZvaWQgZHVwbGljYXRlc1xuXG5cdFx0dmFyIG1vZGUgPSBUaWNrZXIudGltaW5nTW9kZXx8KFRpY2tlci51c2VSQUYmJlRpY2tlci5SQUZfU1lOQ0hFRCk7XG5cdFx0aWYgKG1vZGUgPT0gVGlja2VyLlJBRl9TWU5DSEVEIHx8IG1vZGUgPT0gVGlja2VyLlJBRikge1xuXHRcdFx0dmFyIGYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0XHRpZiAoZikge1xuXHRcdFx0XHRUaWNrZXIuX3RpbWVySWQgPSBmKG1vZGUgPT0gVGlja2VyLlJBRiA/IFRpY2tlci5faGFuZGxlUkFGIDogVGlja2VyLl9oYW5kbGVTeW5jaCk7XG5cdFx0XHRcdFRpY2tlci5fcmFmID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRUaWNrZXIuX3JhZiA9IGZhbHNlO1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IHNldFRpbWVvdXQoVGlja2VyLl9oYW5kbGVUaW1lb3V0LCBUaWNrZXIuX2ludGVydmFsKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfdGlja1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpY2sgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF1c2VkID0gVGlja2VyLnBhdXNlZDtcblx0XHR2YXIgdGltZSA9IFRpY2tlci5fZ2V0VGltZSgpO1xuXHRcdHZhciBlbGFwc2VkVGltZSA9IHRpbWUtVGlja2VyLl9sYXN0VGltZTtcblx0XHRUaWNrZXIuX2xhc3RUaW1lID0gdGltZTtcblx0XHRUaWNrZXIuX3RpY2tzKys7XG5cdFx0XG5cdFx0aWYgKHBhdXNlZCkge1xuXHRcdFx0VGlja2VyLl9wYXVzZWRUaWNrcysrO1xuXHRcdFx0VGlja2VyLl9wYXVzZWRUaW1lICs9IGVsYXBzZWRUaW1lO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoVGlja2VyLmhhc0V2ZW50TGlzdGVuZXIoXCJ0aWNrXCIpKSB7XG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJ0aWNrXCIpO1xuXHRcdFx0dmFyIG1heERlbHRhID0gVGlja2VyLm1heERlbHRhO1xuXHRcdFx0ZXZlbnQuZGVsdGEgPSAobWF4RGVsdGEgJiYgZWxhcHNlZFRpbWUgPiBtYXhEZWx0YSkgPyBtYXhEZWx0YSA6IGVsYXBzZWRUaW1lO1xuXHRcdFx0ZXZlbnQucGF1c2VkID0gcGF1c2VkO1xuXHRcdFx0ZXZlbnQudGltZSA9IHRpbWU7XG5cdFx0XHRldmVudC5ydW5UaW1lID0gdGltZS1UaWNrZXIuX3BhdXNlZFRpbWU7XG5cdFx0XHRUaWNrZXIuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0fVxuXHRcdFxuXHRcdFRpY2tlci5fdGlja1RpbWVzLnVuc2hpZnQoVGlja2VyLl9nZXRUaW1lKCktdGltZSk7XG5cdFx0d2hpbGUgKFRpY2tlci5fdGlja1RpbWVzLmxlbmd0aCA+IDEwMCkgeyBUaWNrZXIuX3RpY2tUaW1lcy5wb3AoKTsgfVxuXG5cdFx0VGlja2VyLl90aW1lcy51bnNoaWZ0KHRpbWUpO1xuXHRcdHdoaWxlIChUaWNrZXIuX3RpbWVzLmxlbmd0aCA+IDEwMCkgeyBUaWNrZXIuX3RpbWVzLnBvcCgpOyB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0dmFyIG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZSAmJiAocGVyZm9ybWFuY2Uubm93IHx8IHBlcmZvcm1hbmNlLm1vek5vdyB8fCBwZXJmb3JtYW5jZS5tc05vdyB8fCBwZXJmb3JtYW5jZS5vTm93IHx8IHBlcmZvcm1hbmNlLndlYmtpdE5vdyk7XG5cdFRpY2tlci5fZ2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAoKG5vdyYmbm93LmNhbGwocGVyZm9ybWFuY2UpKXx8KG5ldyBEYXRlKCkuZ2V0VGltZSgpKSkgLSBUaWNrZXIuX3N0YXJ0VGltZTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlRpY2tlciA9IFRpY2tlcjtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBVSUQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBHbG9iYWwgdXRpbGl0eSBmb3IgZ2VuZXJhdGluZyBzZXF1ZW50aWFsIHVuaXF1ZSBJRCBudW1iZXJzLiBUaGUgVUlEIGNsYXNzIHVzZXMgYSBzdGF0aWMgaW50ZXJmYWNlIChleC4gPGNvZGU+VUlELmdldCgpPC9jb2RlPilcblx0ICogYW5kIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkLlxuXHQgKiBAY2xhc3MgVUlEXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRmdW5jdGlvbiBVSUQoKSB7XG5cdFx0dGhyb3cgXCJVSUQgY2Fubm90IGJlIGluc3RhbnRpYXRlZFwiO1xuXHR9XG5cblxuLy8gcHJpdmF0ZSBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfbmV4dElEXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VUlELl9uZXh0SUQgPSAwO1xuXG5cbi8vIHB1YmxpYyBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG5leHQgdW5pcXVlIGlkLlxuXHQgKiBAbWV0aG9kIGdldFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBuZXh0IHVuaXF1ZSBpZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VUlELmdldCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBVSUQuX25leHRJRCsrO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuVUlEID0gVUlEO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIE1vdXNlRXZlbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBQYXNzZWQgYXMgdGhlIHBhcmFtZXRlciB0byBhbGwgbW91c2UvcG9pbnRlci90b3VjaCByZWxhdGVkIGV2ZW50cy4gRm9yIGEgbGlzdGluZyBvZiBtb3VzZSBldmVudHMgYW5kIHRoZWlyIHByb3BlcnRpZXMsXG5cdCAqIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgbGlzdGluZ3MuXG5cdCAqIEBjbGFzcyBNb3VzZUV2ZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJ1YmJsZXMgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdpbGwgYnViYmxlIHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBjYW5jZWxhYmxlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0aGlzIGV2ZW50IGNhbiBiZSBjYW5jZWxsZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFnZVggVGhlIG5vcm1hbGl6ZWQgeCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFnZVkgVGhlIG5vcm1hbGl6ZWQgeSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gbmF0aXZlRXZlbnQgVGhlIG5hdGl2ZSBET00gZXZlbnQgcmVsYXRlZCB0byB0aGlzIG1vdXNlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRlcklEIFRoZSB1bmlxdWUgaWQgZm9yIHRoZSBwb2ludGVyLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByaW1hcnkgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyB0aGUgcHJpbWFyeSBwb2ludGVyIGluIGEgbXVsdGl0b3VjaCBlbnZpcm9ubWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhd1ggVGhlIHJhdyB4IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzdGFnZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhd1kgVGhlIHJhdyB5IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzdGFnZS5cblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSByZWxhdGVkVGFyZ2V0IFRoZSBzZWNvbmRhcnkgdGFyZ2V0IGZvciB0aGUgZXZlbnQuXG5cdCAqIEBleHRlbmRzIEV2ZW50XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIE1vdXNlRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgc3RhZ2VYLCBzdGFnZVksIG5hdGl2ZUV2ZW50LCBwb2ludGVySUQsIHByaW1hcnksIHJhd1gsIHJhd1ksIHJlbGF0ZWRUYXJnZXQpIHtcblx0XHR0aGlzLkV2ZW50X2NvbnN0cnVjdG9yKHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgbm9ybWFsaXplZCB4IHBvc2l0aW9uIG9uIHRoZSBzdGFnZS4gVGhpcyB3aWxsIGFsd2F5cyBiZSB3aXRoaW4gdGhlIHJhbmdlIDAgdG8gc3RhZ2Ugd2lkdGguXG5cdFx0ICogQHByb3BlcnR5IHN0YWdlWFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCovXG5cdFx0dGhpcy5zdGFnZVggPSBzdGFnZVg7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBub3JtYWxpemVkIHkgcG9zaXRpb24gb24gdGhlIHN0YWdlLiBUaGlzIHdpbGwgYWx3YXlzIGJlIHdpdGhpbiB0aGUgcmFuZ2UgMCB0byBzdGFnZSBoZWlnaHQuXG5cdFx0ICogQHByb3BlcnR5IHN0YWdlWVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLnN0YWdlWSA9IHN0YWdlWTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHJhdyB4IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzdGFnZS4gTm9ybWFsbHkgdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBzdGFnZVggdmFsdWUsIHVubGVzc1xuXHRcdCAqIHN0YWdlLm1vdXNlTW92ZU91dHNpZGUgaXMgdHJ1ZSBhbmQgdGhlIHBvaW50ZXIgaXMgb3V0c2lkZSBvZiB0aGUgc3RhZ2UgYm91bmRzLlxuXHRcdCAqIEBwcm9wZXJ0eSByYXdYXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0Ki9cblx0XHR0aGlzLnJhd1ggPSAocmF3WD09bnVsbCk/c3RhZ2VYOnJhd1g7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSByYXcgeSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuIE5vcm1hbGx5IHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgc3RhZ2VZIHZhbHVlLCB1bmxlc3Ncblx0XHQgKiBzdGFnZS5tb3VzZU1vdmVPdXRzaWRlIGlzIHRydWUgYW5kIHRoZSBwb2ludGVyIGlzIG91dHNpZGUgb2YgdGhlIHN0YWdlIGJvdW5kcy5cblx0XHQgKiBAcHJvcGVydHkgcmF3WVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCovXG5cdFx0dGhpcy5yYXdZID0gKHJhd1k9PW51bGwpP3N0YWdlWTpyYXdZO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbmF0aXZlIE1vdXNlRXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBicm93c2VyLiBUaGUgcHJvcGVydGllcyBhbmQgQVBJIGZvciB0aGlzXG5cdFx0ICogZXZlbnQgbWF5IGRpZmZlciBiZXR3ZWVuIGJyb3dzZXJzLiBUaGlzIHByb3BlcnR5IHdpbGwgYmUgbnVsbCBpZiB0aGVcblx0XHQgKiBFYXNlbEpTIHByb3BlcnR5IHdhcyBub3QgZGlyZWN0bHkgZ2VuZXJhdGVkIGZyb20gYSBuYXRpdmUgTW91c2VFdmVudC5cblx0XHQgKiBAcHJvcGVydHkgbmF0aXZlRXZlbnRcblx0XHQgKiBAdHlwZSBIdG1sTW91c2VFdmVudFxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgdW5pcXVlIGlkIGZvciB0aGUgcG9pbnRlciAodG91Y2ggcG9pbnQgb3IgY3Vyc29yKS4gVGhpcyB3aWxsIGJlIGVpdGhlciAtMSBmb3IgdGhlIG1vdXNlLCBvciB0aGUgc3lzdGVtXG5cdFx0ICogc3VwcGxpZWQgaWQgdmFsdWUuXG5cdFx0ICogQHByb3BlcnR5IHBvaW50ZXJJRFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5wb2ludGVySUQgPSBwb2ludGVySUQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgdGhlIHByaW1hcnkgcG9pbnRlciBpbiBhIG11bHRpdG91Y2ggZW52aXJvbm1lbnQuIFRoaXMgd2lsbCBhbHdheXMgYmUgdHJ1ZSBmb3IgdGhlIG1vdXNlLlxuXHRcdCAqIEZvciB0b3VjaCBwb2ludGVycywgdGhlIGZpcnN0IHBvaW50ZXIgaW4gdGhlIGN1cnJlbnQgc3RhY2sgd2lsbCBiZSBjb25zaWRlcmVkIHRoZSBwcmltYXJ5IHBvaW50ZXIuXG5cdFx0ICogQHByb3BlcnR5IHByaW1hcnlcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLnByaW1hcnkgPSAhIXByaW1hcnk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHNlY29uZGFyeSB0YXJnZXQgZm9yIHRoZSBldmVudCwgaWYgYXBwbGljYWJsZS4gVGhpcyBpcyB1c2VkIGZvciBtb3VzZW91dC9yb2xsb3V0XG5cdFx0ICogZXZlbnRzIHRvIGluZGljYXRlIHRoZSBvYmplY3QgdGhhdCB0aGUgbW91c2UgZW50ZXJlZCBmcm9tLCBtb3VzZW92ZXIvcm9sbG92ZXIgZm9yIHRoZSBvYmplY3QgdGhlIG1vdXNlIGV4aXRlZCxcblx0XHQgKiBhbmQgc3RhZ2Vtb3VzZWRvd24vc3RhZ2Vtb3VzZXVwIGV2ZW50cyBmb3IgdGhlIG9iamVjdCB0aGF0IHdhcyB0aGUgdW5kZXIgdGhlIGN1cnNvciwgaWYgYW55LlxuXHRcdCAqIFxuXHRcdCAqIE9ubHkgdmFsaWQgaW50ZXJhY3Rpb24gdGFyZ2V0cyB3aWxsIGJlIHJldHVybmVkIChpZS4gb2JqZWN0cyB3aXRoIG1vdXNlIGxpc3RlbmVycyBvciBhIGN1cnNvciBzZXQpLlxuXHRcdCAqIEBwcm9wZXJ0eSByZWxhdGVkVGFyZ2V0XG5cdFx0ICogQHR5cGUge0Rpc3BsYXlPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gcmVsYXRlZFRhcmdldDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChNb3VzZUV2ZW50LCBjcmVhdGVqcy5FdmVudCk7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cdFxuXHRcbi8vIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBtb3VzZSBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgdGhlIGN1cnJlbnQgdGFyZ2V0IChpZS4gdGhlIGRpc3BhdGNoZXIpLlxuXHQgKiBAcHJvcGVydHkgbG9jYWxYXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEByZWFkb25seVxuXHQgKi9cblx0cC5fZ2V0X2xvY2FsWCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmN1cnJlbnRUYXJnZXQuZ2xvYmFsVG9Mb2NhbCh0aGlzLnJhd1gsIHRoaXMucmF3WSkueDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBtb3VzZSBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgdGhlIGN1cnJlbnQgdGFyZ2V0IChpZS4gdGhlIGRpc3BhdGNoZXIpLlxuXHQgKiBAcHJvcGVydHkgbG9jYWxZXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEByZWFkb25seVxuXHQgKi9cblx0cC5fZ2V0X2xvY2FsWSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmN1cnJlbnRUYXJnZXQuZ2xvYmFsVG9Mb2NhbCh0aGlzLnJhd1gsIHRoaXMucmF3WSkueTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2FzIGdlbmVyYXRlZCBieSBhIHRvdWNoIGlucHV0ICh2ZXJzdXMgYSBtb3VzZSBpbnB1dCkuXG5cdCAqIEBwcm9wZXJ0eSBpc1RvdWNoXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdHAuX2dldF9pc1RvdWNoID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucG9pbnRlcklEICE9PSAtMTtcblx0fTtcblx0XG5cdFxuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdGxvY2FsWDogeyBnZXQ6IHAuX2dldF9sb2NhbFggfSxcblx0XHRcdGxvY2FsWTogeyBnZXQ6IHAuX2dldF9sb2NhbFkgfSxcblx0XHRcdGlzVG91Y2g6IHsgZ2V0OiBwLl9nZXRfaXNUb3VjaCB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9IC8vIFRPRE86IHVzZSBMb2dcblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgTW91c2VFdmVudCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtNb3VzZUV2ZW50fSBhIGNsb25lIG9mIHRoZSBNb3VzZUV2ZW50IGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IE1vdXNlRXZlbnQodGhpcy50eXBlLCB0aGlzLmJ1YmJsZXMsIHRoaXMuY2FuY2VsYWJsZSwgdGhpcy5zdGFnZVgsIHRoaXMuc3RhZ2VZLCB0aGlzLm5hdGl2ZUV2ZW50LCB0aGlzLnBvaW50ZXJJRCwgdGhpcy5wcmltYXJ5LCB0aGlzLnJhd1gsIHRoaXMucmF3WSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltNb3VzZUV2ZW50ICh0eXBlPVwiK3RoaXMudHlwZStcIiBzdGFnZVg9XCIrdGhpcy5zdGFnZVgrXCIgc3RhZ2VZPVwiK3RoaXMuc3RhZ2VZK1wiKV1cIjtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLk1vdXNlRXZlbnQgPSBjcmVhdGVqcy5wcm9tb3RlKE1vdXNlRXZlbnQsIFwiRXZlbnRcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTWF0cml4MkQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIGFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXgsIGFuZCBwcm92aWRlcyB0b29scyBmb3IgY29uc3RydWN0aW5nIGFuZCBjb25jYXRlbmF0aW5nIG1hdHJpY2VzLlxuXHQgKlxuXHQgKiBUaGlzIG1hdHJpeCBjYW4gYmUgdmlzdWFsaXplZCBhczpcblx0ICpcblx0ICogXHRbIGEgIGMgIHR4XG5cdCAqIFx0ICBiICBkICB0eVxuXHQgKiBcdCAgMCAgMCAgMSAgXVxuXHQgKlxuXHQgKiBOb3RlIHRoZSBsb2NhdGlvbnMgb2YgYiBhbmQgYy5cblx0ICpcblx0ICogQGNsYXNzIE1hdHJpeDJEXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYT0xXSBTcGVjaWZpZXMgdGhlIGEgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2I9MF0gU3BlY2lmaWVzIHRoZSBiIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjPTBdIFNwZWNpZmllcyB0aGUgYyBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZD0xXSBTcGVjaWZpZXMgdGhlIGQgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3R4PTBdIFNwZWNpZmllcyB0aGUgdHggcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3R5PTBdIFNwZWNpZmllcyB0aGUgdHkgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBNYXRyaXgyRChhLCBiLCBjLCBkLCB0eCwgdHkpIHtcblx0XHR0aGlzLnNldFZhbHVlcyhhLGIsYyxkLHR4LHR5KTtcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0Ly8gYXNzaWduZWQgaW4gdGhlIHNldFZhbHVlcyBtZXRob2QuXG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gKDAsIDApIGluIGEgM3gzIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdFx0ICogQHByb3BlcnR5IGFcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgwLCAxKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSBiXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBQb3NpdGlvbiAoMSwgMCkgaW4gYSAzeDMgYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0XHQgKiBAcHJvcGVydHkgY1xuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gKDEsIDEpIGluIGEgM3gzIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdFx0ICogQHByb3BlcnR5IGRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgyLCAwKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSB0eFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gKDIsIDEpIGluIGEgM3gzIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdFx0ICogQHByb3BlcnR5IHR5XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHR9XG5cdHZhciBwID0gTWF0cml4MkQucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBjb25zdGFudHM6XG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVyIGZvciBjb252ZXJ0aW5nIGRlZ3JlZXMgdG8gcmFkaWFucy4gVXNlZCBpbnRlcm5hbGx5IGJ5IE1hdHJpeDJELlxuXHQgKiBAcHJvcGVydHkgREVHX1RPX1JBRFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0TWF0cml4MkQuREVHX1RPX1JBRCA9IE1hdGguUEkvMTgwO1xuXG5cbi8vIHN0YXRpYyBwdWJsaWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEFuIGlkZW50aXR5IG1hdHJpeCwgcmVwcmVzZW50aW5nIGEgbnVsbCB0cmFuc2Zvcm1hdGlvbi5cblx0ICogQHByb3BlcnR5IGlkZW50aXR5XG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUgTWF0cml4MkRcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0TWF0cml4MkQuaWRlbnRpdHkgPSBudWxsOyAvLyBzZXQgYXQgYm90dG9tIG9mIGNsYXNzIGRlZmluaXRpb24uXG5cdFxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFNldHMgdGhlIHNwZWNpZmllZCB2YWx1ZXMgb24gdGhpcyBpbnN0YW5jZS4gXG5cdCAqIEBtZXRob2Qgc2V0VmFsdWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYT0xXSBTcGVjaWZpZXMgdGhlIGEgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2I9MF0gU3BlY2lmaWVzIHRoZSBiIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjPTBdIFNwZWNpZmllcyB0aGUgYyBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZD0xXSBTcGVjaWZpZXMgdGhlIGQgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3R4PTBdIFNwZWNpZmllcyB0aGUgdHggcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3R5PTBdIFNwZWNpZmllcyB0aGUgdHkgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCovXG5cdHAuc2V0VmFsdWVzID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgdHgsIHR5KSB7XG5cdFx0Ly8gZG9uJ3QgZm9yZ2V0IHRvIHVwZGF0ZSBkb2NzIGluIHRoZSBjb25zdHJ1Y3RvciBpZiB0aGVzZSBjaGFuZ2U6XG5cdFx0dGhpcy5hID0gKGEgPT0gbnVsbCkgPyAxIDogYTtcblx0XHR0aGlzLmIgPSBiIHx8IDA7XG5cdFx0dGhpcy5jID0gYyB8fCAwO1xuXHRcdHRoaXMuZCA9IChkID09IG51bGwpID8gMSA6IGQ7XG5cdFx0dGhpcy50eCA9IHR4IHx8IDA7XG5cdFx0dGhpcy50eSA9IHR5IHx8IDA7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgdGhlIHNwZWNpZmllZCBtYXRyaXggcHJvcGVydGllcyB0byB0aGlzIG1hdHJpeC4gQWxsIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkLlxuXHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIG11bHRpcGx5aW5nIGAodGhpcyBtYXRyaXgpICogKHNwZWNpZmllZCBtYXRyaXgpYC5cblx0ICogQG1ldGhvZCBhcHBlbmRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHR4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0eVxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAuYXBwZW5kID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgdHgsIHR5KSB7XG5cdFx0dmFyIGExID0gdGhpcy5hO1xuXHRcdHZhciBiMSA9IHRoaXMuYjtcblx0XHR2YXIgYzEgPSB0aGlzLmM7XG5cdFx0dmFyIGQxID0gdGhpcy5kO1xuXHRcdGlmIChhICE9IDEgfHwgYiAhPSAwIHx8IGMgIT0gMCB8fCBkICE9IDEpIHtcblx0XHRcdHRoaXMuYSAgPSBhMSphK2MxKmI7XG5cdFx0XHR0aGlzLmIgID0gYjEqYStkMSpiO1xuXHRcdFx0dGhpcy5jICA9IGExKmMrYzEqZDtcblx0XHRcdHRoaXMuZCAgPSBiMSpjK2QxKmQ7XG5cdFx0fVxuXHRcdHRoaXMudHggPSBhMSp0eCtjMSp0eSt0aGlzLnR4O1xuXHRcdHRoaXMudHkgPSBiMSp0eCtkMSp0eSt0aGlzLnR5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcmVwZW5kcyB0aGUgc3BlY2lmaWVkIG1hdHJpeCBwcm9wZXJ0aWVzIHRvIHRoaXMgbWF0cml4LlxuXHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIG11bHRpcGx5aW5nIGAoc3BlY2lmaWVkIG1hdHJpeCkgKiAodGhpcyBtYXRyaXgpYC5cblx0ICogQWxsIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkLlxuXHQgKiBAbWV0aG9kIHByZXBlbmRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHR4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0eVxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAucHJlcGVuZCA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuXHRcdHZhciBhMSA9IHRoaXMuYTtcblx0XHR2YXIgYzEgPSB0aGlzLmM7XG5cdFx0dmFyIHR4MSA9IHRoaXMudHg7XG5cblx0XHR0aGlzLmEgID0gYSphMStjKnRoaXMuYjtcblx0XHR0aGlzLmIgID0gYiphMStkKnRoaXMuYjtcblx0XHR0aGlzLmMgID0gYSpjMStjKnRoaXMuZDtcblx0XHR0aGlzLmQgID0gYipjMStkKnRoaXMuZDtcblx0XHR0aGlzLnR4ID0gYSp0eDErYyp0aGlzLnR5K3R4O1xuXHRcdHRoaXMudHkgPSBiKnR4MStkKnRoaXMudHkrdHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgdGhlIHNwZWNpZmllZCBtYXRyaXggdG8gdGhpcyBtYXRyaXguXG5cdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgbXVsdGlwbHlpbmcgYCh0aGlzIG1hdHJpeCkgKiAoc3BlY2lmaWVkIG1hdHJpeClgLlxuXHQgKiBAbWV0aG9kIGFwcGVuZE1hdHJpeFxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXhcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLmFwcGVuZE1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChtYXRyaXguYSwgbWF0cml4LmIsIG1hdHJpeC5jLCBtYXRyaXguZCwgbWF0cml4LnR4LCBtYXRyaXgudHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcmVwZW5kcyB0aGUgc3BlY2lmaWVkIG1hdHJpeCB0byB0aGlzIG1hdHJpeC5cblx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiBtdWx0aXBseWluZyBgKHNwZWNpZmllZCBtYXRyaXgpICogKHRoaXMgbWF0cml4KWAuXG5cdCAqIEZvciBleGFtcGxlLCB5b3UgY291bGQgY2FsY3VsYXRlIHRoZSBjb21iaW5lZCB0cmFuc2Zvcm1hdGlvbiBmb3IgYSBjaGlsZCBvYmplY3QgdXNpbmc6XG5cdCAqIFxuXHQgKiBcdHZhciBvID0gbXlEaXNwbGF5T2JqZWN0O1xuXHQgKiBcdHZhciBtdHggPSBvLmdldE1hdHJpeCgpO1xuXHQgKiBcdHdoaWxlIChvID0gby5wYXJlbnQpIHtcblx0ICogXHRcdC8vIHByZXBlbmQgZWFjaCBwYXJlbnQncyB0cmFuc2Zvcm1hdGlvbiBpbiB0dXJuOlxuXHQgKiBcdFx0by5wcmVwZW5kTWF0cml4KG8uZ2V0TWF0cml4KCkpO1xuXHQgKiBcdH1cblx0ICogQG1ldGhvZCBwcmVwZW5kTWF0cml4XG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAucHJlcGVuZE1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiB0aGlzLnByZXBlbmQobWF0cml4LmEsIG1hdHJpeC5iLCBtYXRyaXguYywgbWF0cml4LmQsIG1hdHJpeC50eCwgbWF0cml4LnR5KTtcblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIG1hdHJpeCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNwZWNpZmllZCBkaXNwbGF5IG9iamVjdCB0cmFuc2Zvcm0gcHJvcGVydGllcywgYW5kIGFwcGVuZHMgdGhlbSB0byB0aGlzIG1hdHJpeC5cblx0ICogRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlIHRoaXMgdG8gZ2VuZXJhdGUgYSBtYXRyaXggcmVwcmVzZW50aW5nIHRoZSB0cmFuc2Zvcm1hdGlvbnMgb2YgYSBkaXNwbGF5IG9iamVjdDpcblx0ICogXG5cdCAqIFx0dmFyIG10eCA9IG5ldyBjcmVhdGVqcy5NYXRyaXgyRCgpO1xuXHQgKiBcdG10eC5hcHBlbmRUcmFuc2Zvcm0oby54LCBvLnksIG8uc2NhbGVYLCBvLnNjYWxlWSwgby5yb3RhdGlvbik7XG5cdCAqIEBtZXRob2QgYXBwZW5kVHJhbnNmb3JtXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcm90YXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmVnWCBPcHRpb25hbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJlZ1kgT3B0aW9uYWwuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5hcHBlbmRUcmFuc2Zvcm0gPSBmdW5jdGlvbih4LCB5LCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSwgcmVnWCwgcmVnWSkge1xuXHRcdGlmIChyb3RhdGlvbiUzNjApIHtcblx0XHRcdHZhciByID0gcm90YXRpb24qTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHZhciBjb3MgPSBNYXRoLmNvcyhyKTtcblx0XHRcdHZhciBzaW4gPSBNYXRoLnNpbihyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29zID0gMTtcblx0XHRcdHNpbiA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKHNrZXdYIHx8IHNrZXdZKSB7XG5cdFx0XHQvLyBUT0RPOiBjYW4gdGhpcyBiZSBjb21iaW5lZCBpbnRvIGEgc2luZ2xlIGFwcGVuZCBvcGVyYXRpb24/XG5cdFx0XHRza2V3WCAqPSBNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0c2tld1kgKj0gTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHRoaXMuYXBwZW5kKE1hdGguY29zKHNrZXdZKSwgTWF0aC5zaW4oc2tld1kpLCAtTWF0aC5zaW4oc2tld1gpLCBNYXRoLmNvcyhza2V3WCksIHgsIHkpO1xuXHRcdFx0dGhpcy5hcHBlbmQoY29zKnNjYWxlWCwgc2luKnNjYWxlWCwgLXNpbipzY2FsZVksIGNvcypzY2FsZVksIDAsIDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFwcGVuZChjb3Mqc2NhbGVYLCBzaW4qc2NhbGVYLCAtc2luKnNjYWxlWSwgY29zKnNjYWxlWSwgeCwgeSk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChyZWdYIHx8IHJlZ1kpIHtcblx0XHRcdC8vIGFwcGVuZCB0aGUgcmVnaXN0cmF0aW9uIG9mZnNldDpcblx0XHRcdHRoaXMudHggLT0gcmVnWCp0aGlzLmErcmVnWSp0aGlzLmM7IFxuXHRcdFx0dGhpcy50eSAtPSByZWdYKnRoaXMuYityZWdZKnRoaXMuZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBtYXRyaXggcHJvcGVydGllcyBmcm9tIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBvYmplY3QgdHJhbnNmb3JtIHByb3BlcnRpZXMsIGFuZCBwcmVwZW5kcyB0aGVtIHRvIHRoaXMgbWF0cml4LlxuXHQgKiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGNhbGN1bGF0ZSB0aGUgY29tYmluZWQgdHJhbnNmb3JtYXRpb24gZm9yIGEgY2hpbGQgb2JqZWN0IHVzaW5nOlxuXHQgKiBcblx0ICogXHR2YXIgbyA9IG15RGlzcGxheU9iamVjdDtcblx0ICogXHR2YXIgbXR4ID0gbmV3IGNyZWF0ZWpzLk1hdHJpeDJEKCk7XG5cdCAqIFx0ZG8gIHtcblx0ICogXHRcdC8vIHByZXBlbmQgZWFjaCBwYXJlbnQncyB0cmFuc2Zvcm1hdGlvbiBpbiB0dXJuOlxuXHQgKiBcdFx0bXR4LnByZXBlbmRUcmFuc2Zvcm0oby54LCBvLnksIG8uc2NhbGVYLCBvLnNjYWxlWSwgby5yb3RhdGlvbiwgby5za2V3WCwgby5za2V3WSwgby5yZWdYLCBvLnJlZ1kpO1xuXHQgKiBcdH0gd2hpbGUgKG8gPSBvLnBhcmVudCk7XG5cdCAqIFx0XG5cdCAqIFx0Tm90ZSB0aGF0IHRoZSBhYm92ZSBleGFtcGxlIHdvdWxkIG5vdCBhY2NvdW50IGZvciB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3RyYW5zZm9ybU1hdHJpeDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBcdHZhbHVlcy4gU2VlIHt7I2Nyb3NzTGluayBcIk1hdHJpeDJEL3ByZXBlbmRNYXRyaXhcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGFuIGV4YW1wbGUgdGhhdCBkb2VzLlxuXHQgKiBAbWV0aG9kIHByZXBlbmRUcmFuc2Zvcm1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByb3RhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1hcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdZXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByZWdYIE9wdGlvbmFsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmVnWSBPcHRpb25hbC5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLnByZXBlbmRUcmFuc2Zvcm0gPSBmdW5jdGlvbih4LCB5LCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSwgcmVnWCwgcmVnWSkge1xuXHRcdGlmIChyb3RhdGlvbiUzNjApIHtcblx0XHRcdHZhciByID0gcm90YXRpb24qTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHZhciBjb3MgPSBNYXRoLmNvcyhyKTtcblx0XHRcdHZhciBzaW4gPSBNYXRoLnNpbihyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29zID0gMTtcblx0XHRcdHNpbiA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKHJlZ1ggfHwgcmVnWSkge1xuXHRcdFx0Ly8gcHJlcGVuZCB0aGUgcmVnaXN0cmF0aW9uIG9mZnNldDpcblx0XHRcdHRoaXMudHggLT0gcmVnWDsgdGhpcy50eSAtPSByZWdZO1xuXHRcdH1cblx0XHRpZiAoc2tld1ggfHwgc2tld1kpIHtcblx0XHRcdC8vIFRPRE86IGNhbiB0aGlzIGJlIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgcHJlcGVuZCBvcGVyYXRpb24/XG5cdFx0XHRza2V3WCAqPSBNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0c2tld1kgKj0gTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHRoaXMucHJlcGVuZChjb3Mqc2NhbGVYLCBzaW4qc2NhbGVYLCAtc2luKnNjYWxlWSwgY29zKnNjYWxlWSwgMCwgMCk7XG5cdFx0XHR0aGlzLnByZXBlbmQoTWF0aC5jb3Moc2tld1kpLCBNYXRoLnNpbihza2V3WSksIC1NYXRoLnNpbihza2V3WCksIE1hdGguY29zKHNrZXdYKSwgeCwgeSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucHJlcGVuZChjb3Mqc2NhbGVYLCBzaW4qc2NhbGVYLCAtc2luKnNjYWxlWSwgY29zKnNjYWxlWSwgeCwgeSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgY2xvY2t3aXNlIHJvdGF0aW9uIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXG5cdCAqIEBtZXRob2Qgcm90YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBpbiBkZWdyZWVzLiBUbyB1c2UgYSB2YWx1ZSBpbiByYWRpYW5zLCBtdWx0aXBseSBpdCBieSBgMTgwL01hdGguUElgLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAucm90YXRlID0gZnVuY3Rpb24oYW5nbGUpIHtcblx0XHRhbmdsZSA9IGFuZ2xlKk1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0dmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHR2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG5cdFx0dmFyIGExID0gdGhpcy5hO1xuXHRcdHZhciBiMSA9IHRoaXMuYjtcblxuXHRcdHRoaXMuYSA9IGExKmNvcyt0aGlzLmMqc2luO1xuXHRcdHRoaXMuYiA9IGIxKmNvcyt0aGlzLmQqc2luO1xuXHRcdHRoaXMuYyA9IC1hMSpzaW4rdGhpcy5jKmNvcztcblx0XHR0aGlzLmQgPSAtYjEqc2luK3RoaXMuZCpjb3M7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBza2V3IHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXG5cdCAqIEBtZXRob2Qgc2tld1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1ggVGhlIGFtb3VudCB0byBza2V3IGhvcml6b250YWxseSBpbiBkZWdyZWVzLiBUbyB1c2UgYSB2YWx1ZSBpbiByYWRpYW5zLCBtdWx0aXBseSBpdCBieSBgMTgwL01hdGguUElgLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1kgVGhlIGFtb3VudCB0byBza2V3IHZlcnRpY2FsbHkgaW4gZGVncmVlcy5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0Ki9cblx0cC5za2V3ID0gZnVuY3Rpb24oc2tld1gsIHNrZXdZKSB7XG5cdFx0c2tld1ggPSBza2V3WCpNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdHNrZXdZID0gc2tld1kqTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHR0aGlzLmFwcGVuZChNYXRoLmNvcyhza2V3WSksIE1hdGguc2luKHNrZXdZKSwgLU1hdGguc2luKHNrZXdYKSwgTWF0aC5jb3Moc2tld1gpLCAwLCAwKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQXBwbGllcyBhIHNjYWxlIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXG5cdCAqIEBtZXRob2Qgc2NhbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGFtb3VudCB0byBzY2FsZSBob3Jpem9udGFsbHkuIEUuRy4gYSB2YWx1ZSBvZiAyIHdpbGwgZG91YmxlIHRoZSBzaXplIGluIHRoZSBYIGRpcmVjdGlvbiwgYW5kIDAuNSB3aWxsIGhhbHZlIGl0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgYW1vdW50IHRvIHNjYWxlIHZlcnRpY2FsbHkuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5zY2FsZSA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLmEgKj0geDtcblx0XHR0aGlzLmIgKj0geDtcblx0XHR0aGlzLmMgKj0geTtcblx0XHR0aGlzLmQgKj0geTtcblx0XHQvL3RoaXMudHggKj0geDtcblx0XHQvL3RoaXMudHkgKj0geTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogVHJhbnNsYXRlcyB0aGUgbWF0cml4IG9uIHRoZSB4IGFuZCB5IGF4ZXMuXG5cdCAqIEBtZXRob2QgdHJhbnNsYXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC50cmFuc2xhdGUgPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy50eCArPSB0aGlzLmEqeCArIHRoaXMuYyp5O1xuXHRcdHRoaXMudHkgKz0gdGhpcy5iKnggKyB0aGlzLmQqeTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgcHJvcGVydGllcyBvZiB0aGUgbWF0cml4IHRvIHRob3NlIG9mIGFuIGlkZW50aXR5IG1hdHJpeCAob25lIHRoYXQgYXBwbGllcyBhIG51bGwgdHJhbnNmb3JtYXRpb24pLlxuXHQgKiBAbWV0aG9kIGlkZW50aXR5XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5pZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuYSA9IHRoaXMuZCA9IDE7XG5cdFx0dGhpcy5iID0gdGhpcy5jID0gdGhpcy50eCA9IHRoaXMudHkgPSAwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnZlcnRzIHRoZSBtYXRyaXgsIGNhdXNpbmcgaXQgdG8gcGVyZm9ybSB0aGUgb3Bwb3NpdGUgdHJhbnNmb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgaW52ZXJ0XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5pbnZlcnQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgYTEgPSB0aGlzLmE7XG5cdFx0dmFyIGIxID0gdGhpcy5iO1xuXHRcdHZhciBjMSA9IHRoaXMuYztcblx0XHR2YXIgZDEgPSB0aGlzLmQ7XG5cdFx0dmFyIHR4MSA9IHRoaXMudHg7XG5cdFx0dmFyIG4gPSBhMSpkMS1iMSpjMTtcblxuXHRcdHRoaXMuYSA9IGQxL247XG5cdFx0dGhpcy5iID0gLWIxL247XG5cdFx0dGhpcy5jID0gLWMxL247XG5cdFx0dGhpcy5kID0gYTEvbjtcblx0XHR0aGlzLnR4ID0gKGMxKnRoaXMudHktZDEqdHgxKS9uO1xuXHRcdHRoaXMudHkgPSAtKGExKnRoaXMudHktYjEqdHgxKS9uO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1hdHJpeCBpcyBhbiBpZGVudGl0eSBtYXRyaXguXG5cdCAqIEBtZXRob2QgaXNJZGVudGl0eVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiovXG5cdHAuaXNJZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnR4ID09PSAwICYmIHRoaXMudHkgPT09IDAgJiYgdGhpcy5hID09PSAxICYmIHRoaXMuYiA9PT0gMCAmJiB0aGlzLmMgPT09IDAgJiYgdGhpcy5kID09PSAxO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIG1hdHJpeCBpcyBlcXVhbCB0byB0aGUgc3BlY2lmaWVkIG1hdHJpeCAoYWxsIHByb3BlcnR5IHZhbHVlcyBhcmUgZXF1YWwpLlxuXHQgKiBAbWV0aG9kIGVxdWFsc1xuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXggVGhlIG1hdHJpeCB0byBjb21wYXJlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiovXG5cdHAuZXF1YWxzID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMudHggPT09IG1hdHJpeC50eCAmJiB0aGlzLnR5ID09PSBtYXRyaXgudHkgJiYgdGhpcy5hID09PSBtYXRyaXguYSAmJiB0aGlzLmIgPT09IG1hdHJpeC5iICYmIHRoaXMuYyA9PT0gbWF0cml4LmMgJiYgdGhpcy5kID09PSBtYXRyaXguZDtcblx0fTtcblxuXHQvKipcblx0ICogVHJhbnNmb3JtcyBhIHBvaW50IGFjY29yZGluZyB0byB0aGlzIG1hdHJpeC5cblx0ICogQG1ldGhvZCB0cmFuc2Zvcm1Qb2ludFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHBvaW50IHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSBwb2ludCB0byB0cmFuc2Zvcm0uXG5cdCAqIEBwYXJhbSB7UG9pbnQgfCBPYmplY3R9IFtwdF0gQW4gb2JqZWN0IHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvLiBJZiBvbWl0dGVkIGEgZ2VuZXJpYyBvYmplY3Qgd2l0aCB4L3kgcHJvcGVydGllcyB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtQb2ludH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAudHJhbnNmb3JtUG9pbnQgPSBmdW5jdGlvbih4LCB5LCBwdCkge1xuXHRcdHB0ID0gcHR8fHt9O1xuXHRcdHB0LnggPSB4KnRoaXMuYSt5KnRoaXMuYyt0aGlzLnR4O1xuXHRcdHB0LnkgPSB4KnRoaXMuYit5KnRoaXMuZCt0aGlzLnR5O1xuXHRcdHJldHVybiBwdDtcblx0fTtcblxuXHQvKipcblx0ICogRGVjb21wb3NlcyB0aGUgbWF0cml4IGludG8gdHJhbnNmb3JtIHByb3BlcnRpZXMgKHgsIHksIHNjYWxlWCwgc2NhbGVZLCBhbmQgcm90YXRpb24pLiBOb3RlIHRoYXQgdGhlc2UgdmFsdWVzXG5cdCAqIG1heSBub3QgbWF0Y2ggdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIHlvdSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBtYXRyaXgsIHRob3VnaCB0aGV5IHdpbGwgcHJvZHVjZSB0aGUgc2FtZSB2aXN1YWxcblx0ICogcmVzdWx0cy5cblx0ICogQG1ldGhvZCBkZWNvbXBvc2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyB0by4gSWYgbnVsbCwgdGhlbiBhIG5ldyBvYmplY3Qgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgdGFyZ2V0LCBvciBhIG5ldyBnZW5lcmljIG9iamVjdCB3aXRoIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyBhcHBsaWVkLlxuXHQqL1xuXHRwLmRlY29tcG9zZSA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdC8vIFRPRE86IGl0IHdvdWxkIGJlIG5pY2UgdG8gYmUgYWJsZSB0byBzb2x2ZSBmb3Igd2hldGhlciB0aGUgbWF0cml4IGNhbiBiZSBkZWNvbXBvc2VkIGludG8gb25seSBzY2FsZS9yb3RhdGlvbiBldmVuIHdoZW4gc2NhbGUgaXMgbmVnYXRpdmVcblx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHsgdGFyZ2V0ID0ge307IH1cblx0XHR0YXJnZXQueCA9IHRoaXMudHg7XG5cdFx0dGFyZ2V0LnkgPSB0aGlzLnR5O1xuXHRcdHRhcmdldC5zY2FsZVggPSBNYXRoLnNxcnQodGhpcy5hICogdGhpcy5hICsgdGhpcy5iICogdGhpcy5iKTtcblx0XHR0YXJnZXQuc2NhbGVZID0gTWF0aC5zcXJ0KHRoaXMuYyAqIHRoaXMuYyArIHRoaXMuZCAqIHRoaXMuZCk7XG5cblx0XHR2YXIgc2tld1ggPSBNYXRoLmF0YW4yKC10aGlzLmMsIHRoaXMuZCk7XG5cdFx0dmFyIHNrZXdZID0gTWF0aC5hdGFuMih0aGlzLmIsIHRoaXMuYSk7XG5cblx0XHR2YXIgZGVsdGEgPSBNYXRoLmFicygxLXNrZXdYL3NrZXdZKTtcblx0XHRpZiAoZGVsdGEgPCAwLjAwMDAxKSB7IC8vIGVmZmVjdGl2ZWx5IGlkZW50aWNhbCwgY2FuIHVzZSByb3RhdGlvbjpcblx0XHRcdHRhcmdldC5yb3RhdGlvbiA9IHNrZXdZL01hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHRpZiAodGhpcy5hIDwgMCAmJiB0aGlzLmQgPj0gMCkge1xuXHRcdFx0XHR0YXJnZXQucm90YXRpb24gKz0gKHRhcmdldC5yb3RhdGlvbiA8PSAwKSA/IDE4MCA6IC0xODA7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQuc2tld1ggPSB0YXJnZXQuc2tld1kgPSAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuc2tld1ggPSBza2V3WC9NYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0dGFyZ2V0LnNrZXdZID0gc2tld1kvTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIG1hdHJpeCB0byB0aGlzIG1hdHJpeC5cblx0ICogQG1ldGhvZCBjb3B5XG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeCBUaGUgbWF0cml4IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQqL1xuXHRwLmNvcHkgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRWYWx1ZXMobWF0cml4LmEsIG1hdHJpeC5iLCBtYXRyaXguYywgbWF0cml4LmQsIG1hdHJpeC50eCwgbWF0cml4LnR5KTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBNYXRyaXgyRCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gYSBjbG9uZSBvZiB0aGUgTWF0cml4MkQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgTWF0cml4MkQodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGhpcy5kLCB0aGlzLnR4LCB0aGlzLnR5KTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW01hdHJpeDJEIChhPVwiK3RoaXMuYStcIiBiPVwiK3RoaXMuYitcIiBjPVwiK3RoaXMuYytcIiBkPVwiK3RoaXMuZCtcIiB0eD1cIit0aGlzLnR4K1wiIHR5PVwiK3RoaXMudHkrXCIpXVwiO1xuXHR9O1xuXG5cdC8vIHRoaXMgaGFzIHRvIGJlIHBvcHVsYXRlZCBhZnRlciB0aGUgY2xhc3MgaXMgZGVmaW5lZDpcblx0TWF0cml4MkQuaWRlbnRpdHkgPSBuZXcgTWF0cml4MkQoKTtcblxuXG5cdGNyZWF0ZWpzLk1hdHJpeDJEID0gTWF0cml4MkQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRGlzcGxheVByb3BzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBVc2VkIGZvciBjYWxjdWxhdGluZyBhbmQgZW5jYXBzdWxhdGluZyBkaXNwbGF5IHJlbGF0ZWQgcHJvcGVydGllcy5cblx0ICogQGNsYXNzIERpc3BsYXlQcm9wc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJsZSB2YWx1ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYT0xXSBBbHBoYSB2YWx1ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzaGFkb3c9bnVsbF0gQSBTaGFkb3cgaW5zdGFuY2Ugb3IgbnVsbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjb21wb3NpdGVPcGVyYXRpb249bnVsbF0gQSBjb21wb3NpdGVPcGVyYXRpb24gdmFsdWUgb3IgbnVsbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttYXRyaXhdIEEgdHJhbnNmb3JtYXRpb24gbWF0cml4LiBEZWZhdWx0cyB0byBhIG5ldyBpZGVudGl0eSBtYXRyaXguXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIERpc3BsYXlQcm9wcyh2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBjb21wb3NpdGVPcGVyYXRpb24sIG1hdHJpeCkge1xuXHRcdHRoaXMuc2V0VmFsdWVzKHZpc2libGUsIGFscGhhLCBzaGFkb3csIGNvbXBvc2l0ZU9wZXJhdGlvbiwgbWF0cml4KTtcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0Ly8gYXNzaWduZWQgaW4gdGhlIHNldFZhbHVlcyBtZXRob2QuXG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgcmVwcmVzZW50aW5nIHRoZSBhbHBoYSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhIGRpc3BsYXkgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBhbHBoYVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgcmVwcmVzZW50aW5nIHRoZSBzaGFkb3cgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgc2hhZG93XG5cdFx0ICogQHR5cGUgU2hhZG93XG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBQcm9wZXJ0eSByZXByZXNlbnRpbmcgdGhlIGNvbXBvc2l0ZU9wZXJhdGlvbiB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhIGRpc3BsYXkgb2JqZWN0LlxuXHRcdCAqIFlvdSBjYW4gZmluZCBhIGxpc3Qgb2YgdmFsaWQgY29tcG9zaXRlIG9wZXJhdGlvbnMgYXQ6XG5cdFx0ICogPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NhbnZhc190dXRvcmlhbC9Db21wb3NpdGluZ1wiPmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NhbnZhc190dXRvcmlhbC9Db21wb3NpdGluZzwvYT5cblx0XHQgKiBAcHJvcGVydHkgY29tcG9zaXRlT3BlcmF0aW9uXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICoqL1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFByb3BlcnR5IHJlcHJlc2VudGluZyB0aGUgdmFsdWUgZm9yIHZpc2libGUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgdmlzaWJsZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiovXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhIGRpc3BsYXkgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBtYXRyaXhcblx0XHQgKiBAdHlwZSBNYXRyaXgyRFxuXHRcdCAqKi9cblx0fVxuXHR2YXIgcCA9IERpc3BsYXlQcm9wcy5wcm90b3R5cGU7XG5cbi8vIGluaXRpYWxpemF0aW9uOlxuXHQvKipcblx0ICogUmVpbml0aWFsaXplcyB0aGUgaW5zdGFuY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlcy5cblx0ICogQG1ldGhvZCBzZXRWYWx1ZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt2aXNpYmxlPXRydWVdIFZpc2libGUgdmFsdWUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWxwaGE9MV0gQWxwaGEgdmFsdWUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2hhZG93PW51bGxdIEEgU2hhZG93IGluc3RhbmNlIG9yIG51bGwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9zaXRlT3BlcmF0aW9uPW51bGxdIEEgY29tcG9zaXRlT3BlcmF0aW9uIHZhbHVlIG9yIG51bGwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbWF0cml4XSBBIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gRGVmYXVsdHMgdG8gYW4gaWRlbnRpdHkgbWF0cml4LlxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5UHJvcHN9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuc2V0VmFsdWVzID0gZnVuY3Rpb24gKHZpc2libGUsIGFscGhhLCBzaGFkb3csIGNvbXBvc2l0ZU9wZXJhdGlvbiwgbWF0cml4KSB7XG5cdFx0dGhpcy52aXNpYmxlID0gdmlzaWJsZSA9PSBudWxsID8gdHJ1ZSA6ICEhdmlzaWJsZTtcblx0XHR0aGlzLmFscGhhID0gYWxwaGEgPT0gbnVsbCA/IDEgOiBhbHBoYTtcblx0XHR0aGlzLnNoYWRvdyA9IHNoYWRvdztcblx0XHR0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHR0aGlzLm1hdHJpeCA9IG1hdHJpeCB8fCAodGhpcy5tYXRyaXgmJnRoaXMubWF0cml4LmlkZW50aXR5KCkpIHx8IG5ldyBjcmVhdGVqcy5NYXRyaXgyRCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEFwcGVuZHMgdGhlIHNwZWNpZmllZCBkaXNwbGF5IHByb3BlcnRpZXMuIFRoaXMgaXMgZ2VuZXJhbGx5IHVzZWQgdG8gYXBwbHkgYSBjaGlsZCdzIHByb3BlcnRpZXMgaXRzIHBhcmVudCdzLlxuXHQgKiBAbWV0aG9kIGFwcGVuZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUgZGVzaXJlZCB2aXNpYmxlIHZhbHVlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbHBoYSBkZXNpcmVkIGFscGhhIHZhbHVlXG5cdCAqIEBwYXJhbSB7U2hhZG93fSBzaGFkb3cgZGVzaXJlZCBzaGFkb3cgdmFsdWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvc2l0ZU9wZXJhdGlvbiBkZXNpcmVkIGNvbXBvc2l0ZSBvcGVyYXRpb24gdmFsdWVcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gW21hdHJpeF0gYSBNYXRyaXgyRCBpbnN0YW5jZVxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5UHJvcHN9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuYXBwZW5kID0gZnVuY3Rpb24odmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgY29tcG9zaXRlT3BlcmF0aW9uLCBtYXRyaXgpIHtcblx0XHR0aGlzLmFscGhhICo9IGFscGhhO1xuXHRcdHRoaXMuc2hhZG93ID0gc2hhZG93IHx8IHRoaXMuc2hhZG93O1xuXHRcdHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlT3BlcmF0aW9uIHx8IHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdHRoaXMudmlzaWJsZSA9IHRoaXMudmlzaWJsZSAmJiB2aXNpYmxlO1xuXHRcdG1hdHJpeCYmdGhpcy5tYXRyaXguYXBwZW5kTWF0cml4KG1hdHJpeCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUHJlcGVuZHMgdGhlIHNwZWNpZmllZCBkaXNwbGF5IHByb3BlcnRpZXMuIFRoaXMgaXMgZ2VuZXJhbGx5IHVzZWQgdG8gYXBwbHkgYSBwYXJlbnQncyBwcm9wZXJ0aWVzIHRvIGEgY2hpbGQncy5cblx0ICogRm9yIGV4YW1wbGUsIHRvIGdldCB0aGUgY29tYmluZWQgZGlzcGxheSBwcm9wZXJ0aWVzIHRoYXQgd291bGQgYmUgYXBwbGllZCB0byBhIGNoaWxkLCB5b3UgY291bGQgdXNlOlxuXHQgKiBcblx0ICogXHR2YXIgbyA9IG15RGlzcGxheU9iamVjdDtcblx0ICogXHR2YXIgcHJvcHMgPSBuZXcgY3JlYXRlanMuRGlzcGxheVByb3BzKCk7XG5cdCAqIFx0ZG8ge1xuXHQgKiBcdFx0Ly8gcHJlcGVuZCBlYWNoIHBhcmVudCdzIHByb3BzIGluIHR1cm46XG5cdCAqIFx0XHRwcm9wcy5wcmVwZW5kKG8udmlzaWJsZSwgby5hbHBoYSwgby5zaGFkb3csIG8uY29tcG9zaXRlT3BlcmF0aW9uLCBvLmdldE1hdHJpeCgpKTtcblx0ICogXHR9IHdoaWxlIChvID0gby5wYXJlbnQpO1xuXHQgKiBcdFxuXHQgKiBAbWV0aG9kIHByZXBlbmRcblx0ICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIGRlc2lyZWQgdmlzaWJsZSB2YWx1ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYWxwaGEgZGVzaXJlZCBhbHBoYSB2YWx1ZVxuXHQgKiBAcGFyYW0ge1NoYWRvd30gc2hhZG93IGRlc2lyZWQgc2hhZG93IHZhbHVlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb3NpdGVPcGVyYXRpb24gZGVzaXJlZCBjb21wb3NpdGUgb3BlcmF0aW9uIHZhbHVlXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IFttYXRyaXhdIGEgTWF0cml4MkQgaW5zdGFuY2Vcblx0ICogQHJldHVybiB7RGlzcGxheVByb3BzfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnByZXBlbmQgPSBmdW5jdGlvbih2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBjb21wb3NpdGVPcGVyYXRpb24sIG1hdHJpeCkge1xuXHRcdHRoaXMuYWxwaGEgKj0gYWxwaGE7XG5cdFx0dGhpcy5zaGFkb3cgPSB0aGlzLnNoYWRvdyB8fCBzaGFkb3c7XG5cdFx0dGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiB8fCBjb21wb3NpdGVPcGVyYXRpb247XG5cdFx0dGhpcy52aXNpYmxlID0gdGhpcy52aXNpYmxlICYmIHZpc2libGU7XG5cdFx0bWF0cml4JiZ0aGlzLm1hdHJpeC5wcmVwZW5kTWF0cml4KG1hdHJpeCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmVzZXRzIHRoaXMgaW5zdGFuY2UgYW5kIGl0cyBtYXRyaXggdG8gZGVmYXVsdCB2YWx1ZXMuXG5cdCAqIEBtZXRob2QgaWRlbnRpdHlcblx0ICogQHJldHVybiB7RGlzcGxheVByb3BzfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLmlkZW50aXR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblx0XHR0aGlzLmFscGhhID0gMTtcblx0XHR0aGlzLnNoYWRvdyA9IHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uID0gbnVsbDtcblx0XHR0aGlzLm1hdHJpeC5pZGVudGl0eSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgRGlzcGxheVByb3BzIGluc3RhbmNlLiBDbG9uZXMgdGhlIGFzc29jaWF0ZWQgbWF0cml4LlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlQcm9wc30gYSBjbG9uZSBvZiB0aGUgRGlzcGxheVByb3BzIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IERpc3BsYXlQcm9wcyh0aGlzLmFscGhhLCB0aGlzLnNoYWRvdywgdGhpcy5jb21wb3NpdGVPcGVyYXRpb24sIHRoaXMudmlzaWJsZSwgdGhpcy5tYXRyaXguY2xvbmUoKSk7XG5cdH07XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblxuXHRjcmVhdGVqcy5EaXNwbGF5UHJvcHMgPSBEaXNwbGF5UHJvcHM7XG59KSgpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gUG9pbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIGEgcG9pbnQgb24gYSAyIGRpbWVuc2lvbmFsIHggLyB5IGNvb3JkaW5hdGUgc3lzdGVtLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFxuXHQgKiAgICAgIHZhciBwb2ludCA9IG5ldyBjcmVhdGVqcy5Qb2ludCgwLCAxMDApO1xuXHQgKiBcblx0ICogQGNsYXNzIFBvaW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBYIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gWSBwb3NpdGlvbi5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuXHQgXHR0aGlzLnNldFZhbHVlcyh4LCB5KTtcblx0IFx0XG5cdCBcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvLyBhc3NpZ25lZCBpbiB0aGUgc2V0VmFsdWVzIG1ldGhvZC5cblx0XHQvKipcblx0XHQgKiBYIHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSB4XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBZIHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSB5XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHR9XG5cdHZhciBwID0gUG9pbnQucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXHRcbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKiogXG5cdCAqIFNldHMgdGhlIHNwZWNpZmllZCB2YWx1ZXMgb24gdGhpcyBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBzZXRWYWx1ZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIFggcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSBZIHBvc2l0aW9uLlxuXHQgKiBAcmV0dXJuIHtQb2ludH0gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5zZXRWYWx1ZXMgPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy54ID0geHx8MDtcblx0XHR0aGlzLnkgPSB5fHwwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENvcGllcyBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBzcGVjaWZpZWQgcG9pbnQgdG8gdGhpcyBwb2ludC5cblx0ICogQG1ldGhvZCBjb3B5XG5cdCAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IFRoZSBwb2ludCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cblx0ICogQHJldHVybiB7UG9pbnR9IFRoaXMgcG9pbnQuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuY29weSA9IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dGhpcy54ID0gcG9pbnQueDtcblx0XHR0aGlzLnkgPSBwb2ludC55O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgUG9pbnQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7UG9pbnR9IGEgY2xvbmUgb2YgdGhlIFBvaW50IGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1BvaW50ICh4PVwiK3RoaXMueCtcIiB5PVwiK3RoaXMueStcIildXCI7XG5cdH07XG5cdFxuXHRcblx0Y3JlYXRlanMuUG9pbnQgPSBQb2ludDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBSZWN0YW5nbGUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIGEgcmVjdGFuZ2xlIGFzIGRlZmluZWQgYnkgdGhlIHBvaW50cyAoeCwgeSkgYW5kICh4K3dpZHRoLCB5K2hlaWdodCkuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgcmVjdCA9IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoMCwgMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBAY2xhc3MgUmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBYIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gWSBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD0wXSBUaGUgd2lkdGggb2YgdGhlIFJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MF0gVGhlIGhlaWdodCBvZiB0aGUgUmVjdGFuZ2xlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMuc2V0VmFsdWVzKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvLyBhc3NpZ25lZCBpbiB0aGUgc2V0VmFsdWVzIG1ldGhvZC5cblx0XHQvKipcblx0XHQgKiBYIHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSB4XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBZIHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSB5XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBXaWR0aC5cblx0XHQgKiBAcHJvcGVydHkgd2lkdGhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEhlaWdodC5cblx0XHQgKiBAcHJvcGVydHkgaGVpZ2h0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHR9XG5cdHZhciBwID0gUmVjdGFuZ2xlLnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKiBcblx0ICogU2V0cyB0aGUgc3BlY2lmaWVkIHZhbHVlcyBvbiB0aGlzIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIHNldFZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gWCBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIFkgcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9MF0gVGhlIHdpZHRoIG9mIHRoZSBSZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTBdIFRoZSBoZWlnaHQgb2YgdGhlIFJlY3RhbmdsZS5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldFZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHQvLyBkb24ndCBmb3JnZXQgdG8gdXBkYXRlIGRvY3MgaW4gdGhlIGNvbnN0cnVjdG9yIGlmIHRoZXNlIGNoYW5nZTpcblx0XHR0aGlzLnggPSB4fHwwO1xuXHRcdHRoaXMueSA9IHl8fDA7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRofHwwO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0fHwwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBFeHRlbmRzIHRoZSByZWN0YW5nbGUncyBib3VuZHMgdG8gaW5jbHVkZSB0aGUgZGVzY3JpYmVkIHBvaW50IG9yIHJlY3RhbmdsZS5cblx0ICogQG1ldGhvZCBleHRlbmRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggWCBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBZIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvciByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9MF0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTBdIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLmV4dGVuZCA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR3aWR0aCA9IHdpZHRofHwwO1xuXHRcdGhlaWdodCA9IGhlaWdodHx8MDtcblx0XHRpZiAoeCt3aWR0aCA+IHRoaXMueCt0aGlzLndpZHRoKSB7IHRoaXMud2lkdGggPSB4K3dpZHRoLXRoaXMueDsgfVxuXHRcdGlmICh5K2hlaWdodCA+IHRoaXMueSt0aGlzLmhlaWdodCkgeyB0aGlzLmhlaWdodCA9IHkraGVpZ2h0LXRoaXMueTsgfVxuXHRcdGlmICh4IDwgdGhpcy54KSB7IHRoaXMud2lkdGggKz0gdGhpcy54LXg7IHRoaXMueCA9IHg7IH1cblx0XHRpZiAoeSA8IHRoaXMueSkgeyB0aGlzLmhlaWdodCArPSB0aGlzLnkteTsgdGhpcy55ID0geTsgfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBBZGRzIHRoZSBzcGVjaWZpZWQgcGFkZGluZyB0byB0aGUgcmVjdGFuZ2xlJ3MgYm91bmRzLlxuXHQgKiBAbWV0aG9kIHBhZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdG9wXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByaWdodFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYm90dG9tXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5wYWQgPSBmdW5jdGlvbih0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQpIHtcblx0XHR0aGlzLnggLT0gbGVmdDtcblx0XHR0aGlzLnkgLT0gdG9wO1xuXHRcdHRoaXMud2lkdGggKz0gbGVmdCtyaWdodDtcblx0XHR0aGlzLmhlaWdodCArPSB0b3ArYm90dG9tO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENvcGllcyBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBzcGVjaWZpZWQgcmVjdGFuZ2xlIHRvIHRoaXMgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIGNvcHlcblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RhbmdsZSBUaGUgcmVjdGFuZ2xlIHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoaXMgcmVjdGFuZ2xlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLmNvcHkgPSBmdW5jdGlvbihyZWN0YW5nbGUpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRWYWx1ZXMocmVjdGFuZ2xlLngsIHJlY3RhbmdsZS55LCByZWN0YW5nbGUud2lkdGgsIHJlY3RhbmdsZS5oZWlnaHQpO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyByZWN0YW5nbGUgZnVsbHkgZW5jbG9zZXMgdGhlIGRlc2NyaWJlZCBwb2ludCBvciByZWN0YW5nbGUuXG5cdCAqIEBtZXRob2QgY29udGFpbnNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggWCBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBZIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvciByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9MF0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTBdIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgZGVzY3JpYmVkIHBvaW50IG9yIHJlY3RhbmdsZSBpcyBjb250YWluZWQgd2l0aGluIHRoaXMgcmVjdGFuZ2xlLlxuXHQqL1xuXHRwLmNvbnRhaW5zID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHdpZHRoID0gd2lkdGh8fDA7XG5cdFx0aGVpZ2h0ID0gaGVpZ2h0fHwwO1xuXHRcdHJldHVybiAoeCA+PSB0aGlzLnggJiYgeCt3aWR0aCA8PSB0aGlzLngrdGhpcy53aWR0aCAmJiB5ID49IHRoaXMueSAmJiB5K2hlaWdodCA8PSB0aGlzLnkrdGhpcy5oZWlnaHQpO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB3aGljaCBjb250YWlucyB0aGlzIHJlY3RhbmdsZSBhbmQgdGhlIHNwZWNpZmllZCByZWN0YW5nbGUuXG5cdCAqIEBtZXRob2QgdW5pb25cblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgVGhlIHJlY3RhbmdsZSB0byBjYWxjdWxhdGUgYSB1bmlvbiB3aXRoLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEEgbmV3IHJlY3RhbmdsZSBkZXNjcmliaW5nIHRoZSB1bmlvbi5cblx0Ki9cblx0cC51bmlvbiA9IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLmV4dGVuZChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB3aGljaCBkZXNjcmliZXMgdGhlIGludGVyc2VjdGlvbiAob3ZlcmxhcCkgb2YgdGhpcyByZWN0YW5nbGUgYW5kIHRoZSBzcGVjaWZpZWQgcmVjdGFuZ2xlLFxuXHQgKiBvciBudWxsIGlmIHRoZXkgZG8gbm90IGludGVyc2VjdC5cblx0ICogQG1ldGhvZCBpbnRlcnNlY3Rpb25cblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgVGhlIHJlY3RhbmdsZSB0byBjYWxjdWxhdGUgYW4gaW50ZXJzZWN0aW9uIHdpdGguXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQSBuZXcgcmVjdGFuZ2xlIGRlc2NyaWJpbmcgdGhlIGludGVyc2VjdGlvbiBvciBudWxsLlxuXHQqL1xuXHRwLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgeDEgPSByZWN0LngsIHkxID0gcmVjdC55LCB4MiA9IHgxK3JlY3Qud2lkdGgsIHkyID0geTErcmVjdC5oZWlnaHQ7XG5cdFx0aWYgKHRoaXMueCA+IHgxKSB7IHgxID0gdGhpcy54OyB9XG5cdFx0aWYgKHRoaXMueSA+IHkxKSB7IHkxID0gdGhpcy55OyB9XG5cdFx0aWYgKHRoaXMueCArIHRoaXMud2lkdGggPCB4MikgeyB4MiA9IHRoaXMueCArIHRoaXMud2lkdGg7IH1cblx0XHRpZiAodGhpcy55ICsgdGhpcy5oZWlnaHQgPCB5MikgeyB5MiA9IHRoaXMueSArIHRoaXMuaGVpZ2h0OyB9XG5cdFx0cmV0dXJuICh4MiA8PSB4MSB8fCB5MiA8PSB5MSkgPyBudWxsIDogbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyLXgxLCB5Mi15MSk7XG5cdH07XG5cdFxuXHQvKiogXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZSBpbnRlcnNlY3RzIChoYXMgYW55IG92ZXJsYXApIHdpdGggdGhpcyByZWN0YW5nbGUuXG5cdCAqIEBtZXRob2QgaW50ZXJzZWN0c1xuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdCBUaGUgcmVjdGFuZ2xlIHRvIGNvbXBhcmUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHJlY3RhbmdsZXMgaW50ZXJzZWN0LlxuXHQqL1xuXHRwLmludGVyc2VjdHMgPSBmdW5jdGlvbihyZWN0KSB7XG5cdFx0cmV0dXJuIChyZWN0LnggPD0gdGhpcy54K3RoaXMud2lkdGggJiYgdGhpcy54IDw9IHJlY3QueCtyZWN0LndpZHRoICYmIHJlY3QueSA8PSB0aGlzLnkrdGhpcy5oZWlnaHQgJiYgdGhpcy55IDw9IHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKiBcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSB3aWR0aCBvciBoZWlnaHQgYXJlIGVxdWFsIG9yIGxlc3MgdGhhbiAwLlxuXHQgKiBAbWV0aG9kIGlzRW1wdHlcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVtcHR5LlxuXHQqL1xuXHRwLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDA7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBSZWN0YW5nbGUgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBhIGNsb25lIG9mIHRoZSBSZWN0YW5nbGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltSZWN0YW5nbGUgKHg9XCIrdGhpcy54K1wiIHk9XCIrdGhpcy55K1wiIHdpZHRoPVwiK3RoaXMud2lkdGgrXCIgaGVpZ2h0PVwiK3RoaXMuaGVpZ2h0K1wiKV1cIjtcblx0fTtcblx0XG5cdFxuXHRjcmVhdGVqcy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQnV0dG9uSGVscGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhlIEJ1dHRvbkhlbHBlciBpcyBhIGhlbHBlciBjbGFzcyB0byBjcmVhdGUgaW50ZXJhY3RpdmUgYnV0dG9ucyBmcm9tIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcFwifX17ey9jcm9zc0xpbmt9fSBvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTcHJpdGVcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzLiBUaGlzIGNsYXNzIHdpbGwgaW50ZXJjZXB0IG1vdXNlIGV2ZW50cyBmcm9tIGFuIG9iamVjdCwgYW5kXG5cdCAqIGF1dG9tYXRpY2FsbHkgY2FsbCB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB0byB0aGUgcmVzcGVjdGl2ZSBhbmltYXRpb24gbGFiZWxzLCBhZGQgYSBwb2ludGVyIGN1cnNvciwgYW5kIGFsbG93cyB0aGUgdXNlciB0byBkZWZpbmUgYSBoaXQgc3RhdGUgZnJhbWUuXG5cdCAqXG5cdCAqIFRoZSBCdXR0b25IZWxwZXIgaW5zdGFuY2UgZG9lcyBub3QgbmVlZCB0byBiZSBhZGRlZCB0byB0aGUgc3RhZ2UsIGJ1dCBhIHJlZmVyZW5jZSBzaG91bGQgYmUgbWFpbnRhaW5lZCB0byBwcmV2ZW50XG5cdCAqIGdhcmJhZ2UgY29sbGVjdGlvbi5cblx0ICogXG5cdCAqIE5vdGUgdGhhdCBvdmVyIHN0YXRlcyB3aWxsIG5vdCB3b3JrIHVubGVzcyB5b3UgY2FsbCB7eyNjcm9zc0xpbmsgXCJTdGFnZS9lbmFibGVNb3VzZU92ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgaGVscGVyID0gbmV3IGNyZWF0ZWpzLkJ1dHRvbkhlbHBlcihteUluc3RhbmNlLCBcIm91dFwiLCBcIm92ZXJcIiwgXCJkb3duXCIsIGZhbHNlLCBteUluc3RhbmNlLCBcImhpdFwiKTtcblx0ICogICAgICBteUluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgLy8gQ2xpY2sgSGFwcGVuZWQuXG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAY2xhc3MgQnV0dG9uSGVscGVyXG5cdCAqIEBwYXJhbSB7U3ByaXRlfE1vdmllQ2xpcH0gdGFyZ2V0IFRoZSBpbnN0YW5jZSB0byBtYW5hZ2UuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbb3V0TGFiZWw9XCJvdXRcIl0gVGhlIGxhYmVsIG9yIGFuaW1hdGlvbiB0byBnbyB0byB3aGVuIHRoZSB1c2VyIHJvbGxzIG91dCBvZiB0aGUgYnV0dG9uLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW292ZXJMYWJlbD1cIm92ZXJcIl0gVGhlIGxhYmVsIG9yIGFuaW1hdGlvbiB0byBnbyB0byB3aGVuIHRoZSB1c2VyIHJvbGxzIG92ZXIgdGhlIGJ1dHRvbi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtkb3duTGFiZWw9XCJkb3duXCJdIFRoZSBsYWJlbCBvciBhbmltYXRpb24gdG8gZ28gdG8gd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZSBidXR0b24uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BsYXk9ZmFsc2VdIElmIHRoZSBoZWxwZXIgc2hvdWxkIGNhbGwgXCJnb3RvQW5kUGxheVwiIG9yIFwiZ290b0FuZFN0b3BcIiBvbiB0aGUgYnV0dG9uIHdoZW4gY2hhbmdpbmdcblx0ICogc3RhdGVzLlxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IFtoaXRBcmVhXSBBbiBvcHRpb25hbCBpdGVtIHRvIHVzZSBhcyB0aGUgaGl0IHN0YXRlIGZvciB0aGUgYnV0dG9uLiBJZiB0aGlzIGlzIG5vdCBkZWZpbmVkLFxuXHQgKiB0aGVuIHRoZSBidXR0b24ncyB2aXNpYmxlIHN0YXRlcyB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gTm90ZSB0aGF0IHRoZSBzYW1lIGluc3RhbmNlIGFzIHRoZSBcInRhcmdldFwiIGFyZ3VtZW50IGNhbiBiZVxuXHQgKiB1c2VkIGZvciB0aGUgaGl0U3RhdGUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbaGl0TGFiZWxdIFRoZSBsYWJlbCBvciBhbmltYXRpb24gb24gdGhlIGhpdEFyZWEgaW5zdGFuY2UgdGhhdCBkZWZpbmVzIHRoZSBoaXRBcmVhIGJvdW5kcy4gSWYgdGhpcyBpc1xuXHQgKiBudWxsLCB0aGVuIHRoZSBkZWZhdWx0IHN0YXRlIG9mIHRoZSBoaXRBcmVhIHdpbGwgYmUgdXNlZC4gKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEJ1dHRvbkhlbHBlcih0YXJnZXQsIG91dExhYmVsLCBvdmVyTGFiZWwsIGRvd25MYWJlbCwgcGxheSwgaGl0QXJlYSwgaGl0TGFiZWwpIHtcblx0XHRpZiAoIXRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7IHJldHVybjsgfVxuXHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0YXJnZXQgZm9yIHRoaXMgYnV0dG9uIGhlbHBlci5cblx0XHQgKiBAcHJvcGVydHkgdGFyZ2V0XG5cdFx0ICogQHR5cGUgTW92aWVDbGlwIHwgU3ByaXRlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbGFiZWwgbmFtZSBvciBmcmFtZSBudW1iZXIgdG8gZGlzcGxheSB3aGVuIHRoZSB1c2VyIG1vdXNlcyBvdXQgb2YgdGhlIHRhcmdldC4gRGVmYXVsdHMgdG8gXCJvdmVyXCIuXG5cdFx0ICogQHByb3BlcnR5IG92ZXJMYWJlbFxuXHRcdCAqIEB0eXBlIFN0cmluZyB8IE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLm92ZXJMYWJlbCA9IG92ZXJMYWJlbCA9PSBudWxsID8gXCJvdmVyXCIgOiBvdmVyTGFiZWw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYWJlbCBuYW1lIG9yIGZyYW1lIG51bWJlciB0byBkaXNwbGF5IHdoZW4gdGhlIHVzZXIgbW91c2VzIG92ZXIgdGhlIHRhcmdldC4gRGVmYXVsdHMgdG8gXCJvdXRcIi5cblx0XHQgKiBAcHJvcGVydHkgb3V0TGFiZWxcblx0XHQgKiBAdHlwZSBTdHJpbmcgfCBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5vdXRMYWJlbCA9IG91dExhYmVsID09IG51bGwgPyBcIm91dFwiIDogb3V0TGFiZWw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYWJlbCBuYW1lIG9yIGZyYW1lIG51bWJlciB0byBkaXNwbGF5IHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBvbiB0aGUgdGFyZ2V0LiBEZWZhdWx0cyB0byBcImRvd25cIi5cblx0XHQgKiBAcHJvcGVydHkgZG93bkxhYmVsXG5cdFx0ICogQHR5cGUgU3RyaW5nIHwgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuZG93bkxhYmVsID0gZG93bkxhYmVsID09IG51bGwgPyBcImRvd25cIiA6IGRvd25MYWJlbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgdGhlbiBCdXR0b25IZWxwZXIgd2lsbCBjYWxsIGdvdG9BbmRQbGF5LCBpZiBmYWxzZSwgaXQgd2lsbCB1c2UgZ290b0FuZFN0b3AuIERlZmF1bHQgaXMgZmFsc2UuXG5cdFx0ICogQHByb3BlcnR5IHBsYXlcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiovXG5cdFx0dGhpcy5wbGF5ID0gcGxheTtcblx0XHRcblx0XHRcblx0Ly8gIHByaXZhdGUgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaXNQcmVzc2VkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5faXNQcmVzc2VkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaXNPdmVyXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5faXNPdmVyID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZW5hYmxlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblx0XHRcblx0Ly8gc2V0dXA6XG5cdFx0dGFyZ2V0Lm1vdXNlQ2hpbGRyZW4gPSBmYWxzZTsgLy8gcHJldmVudHMgaXNzdWVzIHdoZW4gY2hpbGRyZW4gYXJlIHJlbW92ZWQgZnJvbSB0aGUgZGlzcGxheSBsaXN0IHdoZW4gc3RhdGUgY2hhbmdlcy5cblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuaGFuZGxlRXZlbnQoe30pO1xuXHRcdGlmIChoaXRBcmVhKSB7XG5cdFx0XHRpZiAoaGl0TGFiZWwpIHtcblx0XHRcdFx0aGl0QXJlYS5hY3Rpb25zRW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0XHRoaXRBcmVhLmdvdG9BbmRTdG9wJiZoaXRBcmVhLmdvdG9BbmRTdG9wKGhpdExhYmVsKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldC5oaXRBcmVhID0gaGl0QXJlYTtcblx0XHR9XG5cdH1cblx0dmFyIHAgPSBCdXR0b25IZWxwZXIucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXHRcbi8vIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIkJ1dHRvbkhlbHBlci9lbmFibGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2Qgc2V0RW5hYmxlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5zZXRFbmFibGVkID0gZnVuY3Rpb24odmFsdWUpIHsgLy8gVE9ETzogZGVwcmVjYXRlZC5cblx0XHRpZiAodmFsdWUgPT0gdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cblx0XHR2YXIgbyA9IHRoaXMudGFyZ2V0O1xuXHRcdHRoaXMuX2VuYWJsZWQgPSB2YWx1ZTtcblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdG8uY3Vyc29yID0gXCJwb2ludGVyXCI7XG5cdFx0XHRvLmFkZEV2ZW50TGlzdGVuZXIoXCJyb2xsb3ZlclwiLCB0aGlzKTtcblx0XHRcdG8uYWRkRXZlbnRMaXN0ZW5lcihcInJvbGxvdXRcIiwgdGhpcyk7XG5cdFx0XHRvLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcyk7XG5cdFx0XHRvLmFkZEV2ZW50TGlzdGVuZXIoXCJwcmVzc3VwXCIsIHRoaXMpO1xuXHRcdFx0aWYgKG8uX3Jlc2V0KSB7IG8uX19yZXNldCA9IG8uX3Jlc2V0OyBvLl9yZXNldCA9IHRoaXMuX3Jlc2V0O31cblx0XHR9IGVsc2Uge1xuXHRcdFx0by5jdXJzb3IgPSBudWxsO1xuXHRcdFx0by5yZW1vdmVFdmVudExpc3RlbmVyKFwicm9sbG92ZXJcIiwgdGhpcyk7XG5cdFx0XHRvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyb2xsb3V0XCIsIHRoaXMpO1xuXHRcdFx0by5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMpO1xuXHRcdFx0by5yZW1vdmVFdmVudExpc3RlbmVyKFwicHJlc3N1cFwiLCB0aGlzKTtcblx0XHRcdGlmIChvLl9fcmVzZXQpIHsgby5fcmVzZXQgPSBvLl9fcmVzZXQ7IGRlbGV0ZShvLl9fcmVzZXQpOyB9XG5cdFx0fVxuXHR9O1xuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJCdXR0b25IZWxwZXIvZW5hYmxlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEVuYWJsZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLmdldEVuYWJsZWQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZW5hYmxlZDtcblx0fTtcblxuXHQvKipcblx0ICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgYnV0dG9uIGZ1bmN0aW9uYWxpdHkgb24gdGhlIHRhcmdldC5cblx0ICogQHByb3BlcnR5IGVuYWJsZWRcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRlbmFibGVkOiB7IGdldDogcC5nZXRFbmFibGVkLCBzZXQ6IHAuc2V0RW5hYmxlZCB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9IC8vIFRPRE86IHVzZSBMb2dcblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltCdXR0b25IZWxwZXJdXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBoYW5kbGVFdmVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZ0IFRoZSBtb3VzZSBldmVudCB0byBoYW5kbGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oZXZ0KSB7XG5cdFx0dmFyIGxhYmVsLCB0ID0gdGhpcy50YXJnZXQsIHR5cGUgPSBldnQudHlwZTtcblx0XHRpZiAodHlwZSA9PSBcIm1vdXNlZG93blwiKSB7XG5cdFx0XHR0aGlzLl9pc1ByZXNzZWQgPSB0cnVlO1xuXHRcdFx0bGFiZWwgPSB0aGlzLmRvd25MYWJlbDtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gXCJwcmVzc3VwXCIpIHtcblx0XHRcdHRoaXMuX2lzUHJlc3NlZCA9IGZhbHNlO1xuXHRcdFx0bGFiZWwgPSB0aGlzLl9pc092ZXIgPyB0aGlzLm92ZXJMYWJlbCA6IHRoaXMub3V0TGFiZWw7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09IFwicm9sbG92ZXJcIikge1xuXHRcdFx0dGhpcy5faXNPdmVyID0gdHJ1ZTtcblx0XHRcdGxhYmVsID0gdGhpcy5faXNQcmVzc2VkID8gdGhpcy5kb3duTGFiZWwgOiB0aGlzLm92ZXJMYWJlbDtcblx0XHR9IGVsc2UgeyAvLyByb2xsb3V0IGFuZCBkZWZhdWx0XG5cdFx0XHR0aGlzLl9pc092ZXIgPSBmYWxzZTtcblx0XHRcdGxhYmVsID0gdGhpcy5faXNQcmVzc2VkID8gdGhpcy5vdmVyTGFiZWwgOiB0aGlzLm91dExhYmVsO1xuXHRcdH1cblx0XHRpZiAodGhpcy5wbGF5KSB7XG5cdFx0XHR0LmdvdG9BbmRQbGF5JiZ0LmdvdG9BbmRQbGF5KGxhYmVsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dC5nb3RvQW5kU3RvcCYmdC5nb3RvQW5kU3RvcChsYWJlbCk7XG5cdFx0fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEluamVjdGVkIGludG8gdGFyZ2V0LiBQcmVzZXJ2ZXMgdGhlIHBhdXNlZCBzdGF0ZSB0aHJvdWdoIGEgcmVzZXQuXG5cdCAqIEBtZXRob2QgX3Jlc2V0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRPRE86IGV4cGxvcmUgYmV0dGVyIHdheXMgdG8gaGFuZGxlIHRoaXMgaXNzdWUuIFRoaXMgaXMgaGFja3kgJiBkaXNydXB0cyBvYmplY3Qgc2lnbmF0dXJlcy5cblx0XHR2YXIgcCA9IHRoaXMucGF1c2VkO1xuXHRcdHRoaXMuX19yZXNldCgpO1xuXHRcdHRoaXMucGF1c2VkID0gcDtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLkJ1dHRvbkhlbHBlciA9IEJ1dHRvbkhlbHBlcjtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTaGFkb3cuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGlzIGNsYXNzIGVuY2Fwc3VsYXRlcyB0aGUgcHJvcGVydGllcyByZXF1aXJlZCB0byBkZWZpbmUgYSBzaGFkb3cgdG8gYXBwbHkgdG8gYSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHZpYSBpdHMgPGNvZGU+c2hhZG93PC9jb2RlPiBwcm9wZXJ0eS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIG15SW1hZ2Uuc2hhZG93ID0gbmV3IGNyZWF0ZWpzLlNoYWRvdyhcIiMwMDAwMDBcIiwgNSwgNSwgMTApO1xuXHQgKlxuXHQgKiBAY2xhc3MgU2hhZG93XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBzaGFkb3cuIFRoaXMgY2FuIGJlIGFueSB2YWxpZCBDU1MgY29sb3IgdmFsdWUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRYIFRoZSB4IG9mZnNldCBvZiB0aGUgc2hhZG93IGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFkgVGhlIHkgb2Zmc2V0IG9mIHRoZSBzaGFkb3cgaW4gcGl4ZWxzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYmx1ciBUaGUgc2l6ZSBvZiB0aGUgYmx1cnJpbmcgZWZmZWN0LlxuXHQgKiovXG5cdGZ1bmN0aW9uIFNoYWRvdyhjb2xvciwgb2Zmc2V0WCwgb2Zmc2V0WSwgYmx1cikge1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKiogXG5cdFx0ICogVGhlIGNvbG9yIG9mIHRoZSBzaGFkb3cuIFRoaXMgY2FuIGJlIGFueSB2YWxpZCBDU1MgY29sb3IgdmFsdWUuXG5cdFx0ICogQHByb3BlcnR5IGNvbG9yXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuY29sb3IgPSBjb2xvcnx8XCJibGFja1wiO1xuXHRcblx0XHQvKiogVGhlIHggb2Zmc2V0IG9mIHRoZSBzaGFkb3cuXG5cdFx0ICogQHByb3BlcnR5IG9mZnNldFhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5vZmZzZXRYID0gb2Zmc2V0WHx8MDtcblx0XG5cdFx0LyoqIFRoZSB5IG9mZnNldCBvZiB0aGUgc2hhZG93LlxuXHRcdCAqIEBwcm9wZXJ0eSBvZmZzZXRZXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMub2Zmc2V0WSA9IG9mZnNldFl8fDA7XG5cdFxuXHRcdC8qKiBUaGUgYmx1ciBvZiB0aGUgc2hhZG93LlxuXHRcdCAqIEBwcm9wZXJ0eSBibHVyXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuYmx1ciA9IGJsdXJ8fDA7XG5cdH1cblx0dmFyIHAgPSBTaGFkb3cucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBzdGF0aWMgcHVibGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBBbiBpZGVudGl0eSBzaGFkb3cgb2JqZWN0IChhbGwgcHJvcGVydGllcyBhcmUgc2V0IHRvIDApLlxuXHQgKiBAcHJvcGVydHkgaWRlbnRpdHlcblx0ICogQHR5cGUgU2hhZG93XG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFNoYWRvdy5pZGVudGl0eSA9IG5ldyBTaGFkb3coXCJ0cmFuc3BhcmVudFwiLCAwLCAwLCAwKTtcblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltTaGFkb3ddXCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIFNoYWRvdyBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtTaGFkb3d9IEEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgU2hhZG93IGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNoYWRvdyh0aGlzLmNvbG9yLCB0aGlzLm9mZnNldFgsIHRoaXMub2Zmc2V0WSwgdGhpcy5ibHVyKTtcblx0fTtcblx0XG5cblx0Y3JlYXRlanMuU2hhZG93ID0gU2hhZG93O1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNwcml0ZVNoZWV0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogRW5jYXBzdWxhdGVzIHRoZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGFzc29jaWF0ZWQgd2l0aCBhIHNwcml0ZSBzaGVldC4gQSBzcHJpdGUgc2hlZXQgaXMgYSBzZXJpZXMgb2YgaW1hZ2VzICh1c3VhbGx5XG5cdCAqIGFuaW1hdGlvbiBmcmFtZXMpIGNvbWJpbmVkIGludG8gYSBsYXJnZXIgaW1hZ2UgKG9yIGltYWdlcykuIEZvciBleGFtcGxlLCBhbiBhbmltYXRpb24gY29uc2lzdGluZyBvZiBlaWdodCAxMDB4MTAwXG5cdCAqIGltYWdlcyBjb3VsZCBiZSBjb21iaW5lZCBpbnRvIGEgc2luZ2xlIDQwMHgyMDAgc3ByaXRlIHNoZWV0ICg0IGZyYW1lcyBhY3Jvc3MgYnkgMiBoaWdoKS5cblx0ICpcblx0ICogVGhlIGRhdGEgcGFzc2VkIHRvIHRoZSBTcHJpdGVTaGVldCBjb25zdHJ1Y3RvciBkZWZpbmVzOlxuXHQgKiA8b2w+XG5cdCAqIFx0PGxpPiBUaGUgc291cmNlIGltYWdlIG9yIGltYWdlcyB0byB1c2UuPC9saT5cblx0ICogXHQ8bGk+IFRoZSBwb3NpdGlvbnMgb2YgaW5kaXZpZHVhbCBpbWFnZSBmcmFtZXMuPC9saT5cblx0ICogXHQ8bGk+IFNlcXVlbmNlcyBvZiBmcmFtZXMgdGhhdCBmb3JtIG5hbWVkIGFuaW1hdGlvbnMuIE9wdGlvbmFsLjwvbGk+XG5cdCAqIFx0PGxpPiBUaGUgdGFyZ2V0IHBsYXliYWNrIGZyYW1lcmF0ZS4gT3B0aW9uYWwuPC9saT5cblx0ICogPC9vbD5cblx0ICogPGgzPlNwcml0ZVNoZWV0IEZvcm1hdDwvaDM+XG5cdCAqIFNwcml0ZVNoZWV0cyBhcmUgYW4gb2JqZWN0IHdpdGggdHdvIHJlcXVpcmVkIHByb3BlcnRpZXMgKGBpbWFnZXNgIGFuZCBgZnJhbWVzYCksIGFuZCB0d28gb3B0aW9uYWwgcHJvcGVydGllc1xuXHQgKiAoYGZyYW1lcmF0ZWAgYW5kIGBhbmltYXRpb25zYCkuIFRoaXMgbWFrZXMgdGhlbSBlYXN5IHRvIGRlZmluZSBpbiBqYXZhc2NyaXB0IGNvZGUsIG9yIGluIEpTT04uXG5cdCAqXG5cdCAqIDxoND5pbWFnZXM8L2g0PlxuXHQgKiBBbiBhcnJheSBvZiBzb3VyY2UgaW1hZ2VzLiBJbWFnZXMgY2FuIGJlIGVpdGhlciBhbiBIVE1saW1hZ2Vcblx0ICogaW5zdGFuY2UsIG9yIGEgdXJpIHRvIGFuIGltYWdlLiBUaGUgZm9ybWVyIGlzIHJlY29tbWVuZGVkIHRvIGNvbnRyb2wgcHJlbG9hZGluZy5cblx0ICpcblx0ICogXHRpbWFnZXM6IFtpbWFnZTEsIFwicGF0aC90by9pbWFnZTIucG5nXCJdLFxuXHQgKlxuXHQgKiA8aDQ+ZnJhbWVzPC9oND5cblx0ICogRGVmaW5lcyB0aGUgaW5kaXZpZHVhbCBmcmFtZXMuIFRoZXJlIGFyZSB0d28gc3VwcG9ydGVkIGZvcm1hdHMgZm9yIGZyYW1lIGRhdGE6XG5cdCAqIFdoZW4gYWxsIG9mIHRoZSBmcmFtZXMgYXJlIHRoZSBzYW1lIHNpemUgKGluIGEgZ3JpZCksIHVzZSBhbiBvYmplY3Qgd2l0aCBgd2lkdGhgLCBgaGVpZ2h0YCwgYHJlZ1hgLCBgcmVnWWAsXG5cdCAqIGFuZCBgY291bnRgIHByb3BlcnRpZXMuXG5cdCAqXG5cdCAqIDx1bD5cblx0ICogIDxsaT5gd2lkdGhgICYgYGhlaWdodGAgYXJlIHJlcXVpcmVkIGFuZCBzcGVjaWZ5IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBmcmFtZXM8L2xpPlxuXHQgKiAgPGxpPmByZWdYYCAmIGByZWdZYCBpbmRpY2F0ZSB0aGUgcmVnaXN0cmF0aW9uIHBvaW50IG9yIFwib3JpZ2luXCIgb2YgdGhlIGZyYW1lczwvbGk+XG5cdCAqICA8bGk+YHNwYWNpbmdgIGluZGljYXRlIHRoZSBzcGFjaW5nIGJldHdlZW4gZnJhbWVzPC9saT5cblx0ICogIDxsaT5gbWFyZ2luYCBzcGVjaWZ5IHRoZSBtYXJnaW4gYXJvdW5kIHRoZSBpbWFnZShzKTwvbGk+XG5cdCAqICA8bGk+YGNvdW50YCBhbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhlIHRvdGFsIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIHNwcml0ZXNoZWV0OyBpZiBvbWl0dGVkLCB0aGlzIHdpbGxcblx0ICogIGJlIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHNvdXJjZSBpbWFnZXMgYW5kIHRoZSBmcmFtZXMuIEZyYW1lcyB3aWxsIGJlIGFzc2lnbmVkXG5cdCAqICBpbmRleGVzIGJhc2VkIG9uIHRoZWlyIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgaW1hZ2VzIChsZWZ0IHRvIHJpZ2h0LCB0b3AgdG8gYm90dG9tKS48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiAgXHRmcmFtZXM6IHt3aWR0aDo2NCwgaGVpZ2h0OjY0LCBjb3VudDoyMCwgcmVnWDogMzIsIHJlZ1k6NjQsIHNwYWNpbmc6MCwgbWFyZ2luOjB9XG5cdCAqXG5cdCAqIElmIHRoZSBmcmFtZXMgYXJlIG9mIGRpZmZlcmVudCBzaXplcywgdXNlIGFuIGFycmF5IG9mIGZyYW1lIGRlZmluaXRpb25zLiBFYWNoIGRlZmluaXRpb24gaXMgaXRzZWxmIGFuIGFycmF5XG5cdCAqIHdpdGggNCByZXF1aXJlZCBhbmQgMyBvcHRpb25hbCBlbnRyaWVzLCBpbiB0aGUgb3JkZXI6XG5cdCAqXG5cdCAqIDx1bD5cblx0ICogIDxsaT5UaGUgZmlyc3QgZm91ciwgYHhgLCBgeWAsIGB3aWR0aGAsIGFuZCBgaGVpZ2h0YCBhcmUgcmVxdWlyZWQgYW5kIGRlZmluZSB0aGUgZnJhbWUgcmVjdGFuZ2xlLjwvbGk+XG5cdCAqICA8bGk+VGhlIGZpZnRoLCBgaW1hZ2VJbmRleGAsIHNwZWNpZmllcyB0aGUgaW5kZXggb2YgdGhlIHNvdXJjZSBpbWFnZSAoZGVmYXVsdHMgdG8gMCk8L2xpPlxuXHQgKiAgPGxpPlRoZSBsYXN0IHR3bywgYHJlZ1hgIGFuZCBgcmVnWWAgc3BlY2lmeSB0aGUgcmVnaXN0cmF0aW9uIHBvaW50IG9mIHRoZSBmcmFtZTwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIFx0ZnJhbWVzOiBbXG5cdCAqIFx0XHQvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBpbWFnZUluZGV4KiwgcmVnWCosIHJlZ1kqXG5cdCAqIFx0XHRbNjQsIDAsIDk2LCA2NF0sXG5cdCAqIFx0XHRbMCwgMCwgNjQsIDY0LCAxLCAzMiwgMzJdXG5cdCAqIFx0XHQvLyBldGMuXG5cdCAqIFx0XVxuXHQgKlxuXHQgKiA8aDQ+YW5pbWF0aW9uczwvaDQ+XG5cdCAqIE9wdGlvbmFsLiBBbiBvYmplY3QgZGVmaW5pbmcgc2VxdWVuY2VzIG9mIGZyYW1lcyB0byBwbGF5IGFzIG5hbWVkIGFuaW1hdGlvbnMuIEVhY2ggcHJvcGVydHkgY29ycmVzcG9uZHMgdG8gYW5cblx0ICogYW5pbWF0aW9uIG9mIHRoZSBzYW1lIG5hbWUuIEVhY2ggYW5pbWF0aW9uIG11c3Qgc3BlY2lmeSB0aGUgZnJhbWVzIHRvIHBsYXksIGFuZCBtYXlcblx0ICogYWxzbyBpbmNsdWRlIGEgcmVsYXRpdmUgcGxheWJhY2sgYHNwZWVkYCAoZXguIDIgd291bGQgcGxheWJhY2sgYXQgZG91YmxlIHNwZWVkLCAwLjUgYXQgaGFsZiksIGFuZFxuXHQgKiB0aGUgbmFtZSBvZiB0aGUgYG5leHRgIGFuaW1hdGlvbiB0byBzZXF1ZW5jZSB0byBhZnRlciBpdCBjb21wbGV0ZXMuXG5cdCAqXG5cdCAqIFRoZXJlIGFyZSB0aHJlZSBmb3JtYXRzIHN1cHBvcnRlZCBmb3IgZGVmaW5pbmcgdGhlIGZyYW1lcyBpbiBhbiBhbmltYXRpb24sIHdoaWNoIGNhbiBiZSBtaXhlZCBhbmQgbWF0Y2hlZCBhcyBhcHByb3ByaWF0ZTpcblx0ICogPG9sPlxuXHQgKiBcdDxsaT5mb3IgYSBzaW5nbGUgZnJhbWUgYW5pbWF0aW9uLCB5b3UgY2FuIHNpbXBseSBzcGVjaWZ5IHRoZSBmcmFtZSBpbmRleFxuXHQgKlxuXHQgKiBcdFx0YW5pbWF0aW9uczoge1xuXHQgKiBcdFx0XHRzaXQ6IDdcblx0ICogXHRcdH1cblx0ICpcblx0ICogPC9saT5cblx0ICogPGxpPlxuXHQgKiAgICAgIGZvciBhbiBhbmltYXRpb24gb2YgY29uc2VjdXRpdmUgZnJhbWVzLCB5b3UgY2FuIHVzZSBhbiBhcnJheSB3aXRoIHR3byByZXF1aXJlZCwgYW5kIHR3byBvcHRpb25hbCBlbnRyaWVzXG5cdCAqIFx0XHRpbiB0aGUgb3JkZXI6IGBzdGFydGAsIGBlbmRgLCBgbmV4dGAsIGFuZCBgc3BlZWRgLiBUaGlzIHdpbGwgcGxheSB0aGUgZnJhbWVzIGZyb20gc3RhcnQgdG8gZW5kIGluY2x1c2l2ZS5cblx0ICpcblx0ICogXHRcdGFuaW1hdGlvbnM6IHtcblx0ICogXHRcdFx0Ly8gc3RhcnQsIGVuZCwgbmV4dCosIHNwZWVkKlxuXHQgKiBcdFx0XHRydW46IFswLCA4XSxcblx0ICogXHRcdFx0anVtcDogWzksIDEyLCBcInJ1blwiLCAyXVxuXHQgKiBcdFx0fVxuXHQgKlxuXHQgKiAgPC9saT5cblx0ICogIDxsaT5cblx0ICogICAgIGZvciBub24tY29uc2VjdXRpdmUgZnJhbWVzLCB5b3UgY2FuIHVzZSBhbiBvYmplY3Qgd2l0aCBhIGBmcmFtZXNgIHByb3BlcnR5IGRlZmluaW5nIGFuIGFycmF5IG9mIGZyYW1lXG5cdCAqICAgICBpbmRleGVzIHRvIHBsYXkgaW4gb3JkZXIuIFRoZSBvYmplY3QgY2FuIGFsc28gc3BlY2lmeSBgbmV4dGAgYW5kIGBzcGVlZGAgcHJvcGVydGllcy5cblx0ICpcblx0ICogXHRcdGFuaW1hdGlvbnM6IHtcblx0ICogXHRcdFx0d2Fsazoge1xuXHQgKiBcdFx0XHRcdGZyYW1lczogWzEsMiwzLDMsMiwxXVxuXHQgKiBcdFx0XHR9LFxuXHQgKiBcdFx0XHRzaG9vdDoge1xuXHQgKiBcdFx0XHRcdGZyYW1lczogWzEsNCw1LDZdLFxuXHQgKiBcdFx0XHRcdG5leHQ6IFwid2Fsa1wiLFxuXHQgKiBcdFx0XHRcdHNwZWVkOiAwLjVcblx0ICogXHRcdFx0fVxuXHQgKiBcdFx0fVxuXHQgKlxuXHQgKiAgPC9saT5cblx0ICogPC9vbD5cblx0ICogPHN0cm9uZz5Ob3RlOjwvc3Ryb25nPiB0aGUgYHNwZWVkYCBwcm9wZXJ0eSB3YXMgYWRkZWQgaW4gRWFzZWxKUyAwLjcuMC4gRWFybGllciB2ZXJzaW9ucyBoYWQgYSBgZnJlcXVlbmN5YFxuXHQgKiBwcm9wZXJ0eSBpbnN0ZWFkLCB3aGljaCB3YXMgdGhlIGludmVyc2Ugb2YgYHNwZWVkYC4gRm9yIGV4YW1wbGUsIGEgdmFsdWUgb2YgXCI0XCIgd291bGQgYmUgMS80IG5vcm1hbCBzcGVlZCBpblxuXHQgKiBlYXJsaWVyIHZlcnNpb25zLCBidXQgaXMgNHggbm9ybWFsIHNwZWVkIGluIEVhc2VsSlMgMC43LjArLlxuXHQgKlxuXHQgKiA8aDQ+ZnJhbWVyYXRlPC9oND5cblx0ICogT3B0aW9uYWwuIEluZGljYXRlcyB0aGUgZGVmYXVsdCBmcmFtZXJhdGUgdG8gcGxheSB0aGlzIHNwcml0ZXNoZWV0IGF0IGluIGZyYW1lcyBwZXIgc2Vjb25kLiBTZWVcblx0ICoge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXQvZnJhbWVyYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKlxuXHQgKiBcdFx0ZnJhbWVyYXRlOiAyMFxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIFNwcml0ZSBmcmFtZXJhdGUgd2lsbCBvbmx5IHdvcmsgaWYgdGhlIHN0YWdlIHVwZGF0ZSBtZXRob2QgaXMgcHJvdmlkZWQgd2l0aCB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIFx0XHRjcmVhdGVqcy5UaWNrZXIub24oXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiBcdFx0ZnVuY3Rpb24gaGFuZGxlVGljayhldmVudCkge1xuXHQgKlx0XHRcdHN0YWdlLnVwZGF0ZShldmVudCk7XG5cdCAqXHRcdH1cblx0ICpcblx0ICogPGgzPkV4YW1wbGU8L2gzPlxuXHQgKiBUbyBkZWZpbmUgYSBzaW1wbGUgc3ByaXRlIHNoZWV0LCB3aXRoIGEgc2luZ2xlIGltYWdlIFwic3ByaXRlcy5qcGdcIiBhcnJhbmdlZCBpbiBhIHJlZ3VsYXIgNTB4NTAgZ3JpZCB3aXRoIHRocmVlXG5cdCAqIGFuaW1hdGlvbnM6IFwic3RhbmRcIiBzaG93aW5nIHRoZSBmaXJzdCBmcmFtZSwgXCJydW5cIiBsb29waW5nIGZyYW1lIDEtNSBpbmNsdXNpdmUsIGFuZCBcImp1bXBcIiBwbGF5aW5nIGZyYW1lIDYtOCBhbmRcblx0ICogc2VxdWVuY2luZyBiYWNrIHRvIHJ1bi5cblx0ICpcblx0ICogXHRcdHZhciBkYXRhID0ge1xuXHQgKiBcdFx0XHRpbWFnZXM6IFtcInNwcml0ZXMuanBnXCJdLFxuXHQgKiBcdFx0XHRmcmFtZXM6IHt3aWR0aDo1MCwgaGVpZ2h0OjUwfSxcblx0ICogXHRcdFx0YW5pbWF0aW9uczoge1xuXHQgKiBcdFx0XHRcdHN0YW5kOjAsXG5cdCAqIFx0XHRcdFx0cnVuOlsxLDVdLFxuXHQgKiBcdFx0XHRcdGp1bXA6WzYsOCxcInJ1blwiXVxuXHQgKiBcdFx0XHR9XG5cdCAqIFx0XHR9O1xuXHQgKiBcdFx0dmFyIHNwcml0ZVNoZWV0ID0gbmV3IGNyZWF0ZWpzLlNwcml0ZVNoZWV0KGRhdGEpO1xuXHQgKiBcdFx0dmFyIGFuaW1hdGlvbiA9IG5ldyBjcmVhdGVqcy5TcHJpdGUoc3ByaXRlU2hlZXQsIFwicnVuXCIpO1xuXHQgKlxuXHQgKiA8aDM+R2VuZXJhdGluZyBTcHJpdGVTaGVldCBJbWFnZXM8L2gzPlxuXHQgKiBTcHJpdGVzaGVldHMgY2FuIGJlIGNyZWF0ZWQgbWFudWFsbHkgYnkgY29tYmluaW5nIGltYWdlcyBpbiBQaG90b1Nob3AsIGFuZCBzcGVjaWZ5aW5nIHRoZSBmcmFtZSBzaXplIG9yXG5cdCAqIGNvb3JkaW5hdGVzIG1hbnVhbGx5LCBob3dldmVyIHRoZXJlIGFyZSBhIG51bWJlciBvZiB0b29scyB0aGF0IGZhY2lsaXRhdGUgdGhpcy5cblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPkV4cG9ydGluZyBTcHJpdGVTaGVldHMgb3IgSFRNTDUgY29udGVudCBmcm9tIEZsYXNoIFBybyBzdXBwb3J0cyB0aGUgRWFzZWxKUyBTcHJpdGVTaGVldCBmb3JtYXQuPC9saT5cblx0ICogICAgIDxsaT5UaGUgcG9wdWxhciA8YSBocmVmPVwiaHR0cHM6Ly93d3cuY29kZWFuZHdlYi5jb20vdGV4dHVyZXBhY2tlci9lYXNlbGpzXCIgdGFyZ2V0PVwiX2JsYW5rXCI+VGV4dHVyZSBQYWNrZXI8L2E+IGhhc1xuXHQgKiAgICAgRWFzZWxKUyBzdXBwb3J0LlxuXHQgKiAgICAgPGxpPlNXRiBhbmltYXRpb25zIGluIEZsYXNoIGNhbiBiZSBleHBvcnRlZCB0byBTcHJpdGVTaGVldHMgdXNpbmcgPGEgaHJlZj1cImh0dHA6Ly9jcmVhdGVqcy5jb20vem9lXCIgdGFyZ2V0PVwiX2JsYW5rXCI+PC9hPjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIDxoMz5Dcm9zcyBPcmlnaW4gSXNzdWVzPC9oMz5cblx0ICogPHN0cm9uZz5XYXJuaW5nOjwvc3Ryb25nPiBJbWFnZXMgbG9hZGVkIGNyb3NzLW9yaWdpbiB3aWxsIHRocm93IGNyb3NzLW9yaWdpbiBzZWN1cml0eSBlcnJvcnMgd2hlbiBpbnRlcmFjdGVkIHdpdGhcblx0ICogdXNpbmc6XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5hIG1vdXNlPC9saT5cblx0ICogICAgIDxsaT5tZXRob2RzIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL2dldE9iamVjdFVuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX08L2xpPlxuXHQgKiAgICAgPGxpPkZpbHRlcnMgKHNlZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0pPC9saT5cblx0ICogICAgIDxsaT5jYWNoaW5nIChzZWUge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jYWNoZVwifX17ey9jcm9zc0xpbmt9fSk8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBZb3UgY2FuIGdldCBhcm91bmQgdGhpcyBieSBzZXR0aW5nIGBjcm9zc09yaWdpbmAgcHJvcGVydHkgb24geW91ciBpbWFnZXMgYmVmb3JlIHBhc3NpbmcgdGhlbSB0byBFYXNlbEpTLCBvclxuXHQgKiBzZXR0aW5nIHRoZSBgY3Jvc3NPcmlnaW5gIHByb3BlcnR5IG9uIFByZWxvYWRKUycgTG9hZFF1ZXVlIG9yIExvYWRJdGVtcy5cblx0ICpcblx0ICogXHRcdHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuXHQgKiBcdFx0aW1nLmNyb3NzT3JpZ2luPVwiQW5vbnltb3VzXCI7XG5cdCAqIFx0XHRpbWcuc3JjID0gXCJodHRwOi8vc2VydmVyLXdpdGgtQ09SUy1zdXBwb3J0LmNvbS9wYXRoL3RvL2ltYWdlLmpwZ1wiO1xuXHQgKlxuXHQgKiBJZiB5b3UgcGFzcyBzdHJpbmcgcGF0aHMgdG8gU3ByaXRlU2hlZXRzLCB0aGV5IHdpbGwgbm90IHdvcmsgY3Jvc3Mtb3JpZ2luLiBUaGUgc2VydmVyIHRoYXQgc3RvcmVzIHRoZSBpbWFnZSBtdXN0XG5cdCAqIHN1cHBvcnQgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzLCBvciB0aGlzIHdpbGwgbm90IHdvcmsuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBjaGVjayBvdXRcblx0ICogPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQWNjZXNzX2NvbnRyb2xfQ09SU1wiIHRhcmdldD1cIl9ibGFua1wiPkNPUlMgb3ZlcnZpZXcgb24gTUROPC9hPi5cblx0ICpcblx0ICogQGNsYXNzIFNwcml0ZVNoZWV0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgU3ByaXRlU2hlZXQgZGF0YS5cblx0ICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG5cdCAqKi9cblx0ZnVuY3Rpb24gU3ByaXRlU2hlZXQoZGF0YSkge1xuXHRcdHRoaXMuRXZlbnREaXNwYXRjaGVyX2NvbnN0cnVjdG9yKCk7XG5cblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIGFsbCBpbWFnZXMgYXJlIGZpbmlzaGVkIGxvYWRpbmcuXG5cdFx0ICogQHByb3BlcnR5IGNvbXBsZXRlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFNwZWNpZmllcyB0aGUgZnJhbWVyYXRlIHRvIHVzZSBieSBkZWZhdWx0IGZvciBTcHJpdGUgaW5zdGFuY2VzIHVzaW5nIHRoZSBTcHJpdGVTaGVldC4gU2VlIHRoZSBTcHJpdGUgY2xhc3Ncblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZnJhbWVyYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBmcmFtZXJhdGVcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5mcmFtZXJhdGUgPSAwO1xuXG5cblx0XHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9hbmltYXRpb25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2FuaW1hdGlvbnMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9mcmFtZXNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiovXG5cdFx0dGhpcy5fZnJhbWVzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW1hZ2VzXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ltYWdlcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2RhdGFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2RhdGEgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkQ291bnRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2xvYWRDb3VudCA9IDA7XG5cblx0XHQvLyBvbmx5IHVzZWQgZm9yIHNpbXBsZSBmcmFtZSBkZWZzOlxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZnJhbWVIZWlnaHRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ZyYW1lSGVpZ2h0ID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZnJhbWVXaWR0aFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fZnJhbWVXaWR0aCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX251bUZyYW1lc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fbnVtRnJhbWVzID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVnWFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fcmVnWCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3JlZ1lcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3JlZ1kgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zcGFjaW5nXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9zcGFjaW5nID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbWFyZ2luXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9tYXJnaW4gPSAwO1xuXG5cdFx0Ly8gc2V0dXA6XG5cdFx0dGhpcy5fcGFyc2VEYXRhKGRhdGEpO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNwcml0ZVNoZWV0LCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIGV2ZW50czpcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBhbGwgaW1hZ2VzIGFyZSBsb2FkZWQuICBOb3RlIHRoYXQgdGhpcyBvbmx5IGZpcmVzIGlmIHRoZSBpbWFnZXNcblx0ICogd2VyZSBub3QgZnVsbHkgbG9hZGVkIHdoZW4gdGhlIHNwcml0ZSBzaGVldCB3YXMgaW5pdGlhbGl6ZWQuIFlvdSBzaG91bGQgY2hlY2sgdGhlIGNvbXBsZXRlIHByb3BlcnR5XG5cdCAqIHRvIHByaW9yIHRvIGFkZGluZyBhIGxpc3RlbmVyLiBFeC5cblx0ICpcblx0ICogXHR2YXIgc2hlZXQgPSBuZXcgY3JlYXRlanMuU3ByaXRlU2hlZXQoZGF0YSk7XG5cdCAqIFx0aWYgKCFzaGVldC5jb21wbGV0ZSkge1xuXHQgKiBcdFx0Ly8gbm90IHByZWxvYWRlZCwgbGlzdGVuIGZvciB0aGUgY29tcGxldGUgZXZlbnQ6XG5cdCAqIFx0XHRzaGVldC5hZGRFdmVudExpc3RlbmVyKFwiY29tcGxldGVcIiwgaGFuZGxlcik7XG5cdCAqIFx0fVxuXHQgKlxuXHQgKiBAZXZlbnQgY29tcGxldGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBnZXRGcmFtZSBpcyBjYWxsZWQgd2l0aCBhIHZhbGlkIGZyYW1lIGluZGV4LiBUaGlzIGlzIHByaW1hcmlseSBpbnRlbmRlZCBmb3IgdXNlIGJ5IHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0QnVpbGRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGVuIGRvaW5nIG9uLWRlbWFuZCByZW5kZXJpbmcuXG5cdCAqIEBldmVudCBnZXRmcmFtZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGZyYW1lIGluZGV4LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZnJhbWUgVGhlIGZyYW1lIG9iamVjdCB0aGF0IGdldEZyYW1lIHdpbGwgcmV0dXJuLlxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIGFuIGltYWdlIGVuY291bnRlcnMgYW4gZXJyb3IuIEEgU3ByaXRlU2hlZXQgd2lsbCBkaXNwYXRjaCBhbiBlcnJvciBldmVudCBmb3IgZWFjaCBpbWFnZSB0aGF0XG5cdCAqIGVuY291bnRlcnMgYW4gZXJyb3IsIGFuZCB3aWxsIHN0aWxsIGRpc3BhdGNoIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXQvY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgb25jZSBhbGwgaW1hZ2VzIGFyZSBmaW5pc2hlZCBwcm9jZXNzaW5nLCBldmVuIGlmIGFuIGVycm9yIGlzIGVuY291bnRlcmVkLlxuXHQgKiBAZXZlbnQgZXJyb3Jcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIG9mIHRoZSBpbWFnZSB0aGF0IGZhaWxlZCB0byBsb2FkLlxuXHQgKiBAc2luY2UgMC44LjJcblx0ICovXG5cblxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXQvYW5pbWF0aW9uczpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEFuaW1hdGlvbnNcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5nZXRBbmltYXRpb25zID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FuaW1hdGlvbnMuc2xpY2UoKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgYXZhaWxhYmxlIGFuaW1hdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhpcyBzcHJpdGUgc2hlZXQgYXMgc3RyaW5ncy5cblx0ICogQHByb3BlcnR5IGFuaW1hdGlvbnNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdGFuaW1hdGlvbnM6IHsgZ2V0OiBwLmdldEFuaW1hdGlvbnMgfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7fVxuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGZyYW1lcyBpbiB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbiwgb3IgaW4gdGhlIHdob2xlIHNwcml0ZVxuXHQgKiBzaGVldCBpZiB0aGUgYW5pbWF0aW9uIHBhcmFtIGlzIG9taXR0ZWQuIFJldHVybnMgMCBpZiB0aGUgc3ByaXRlc2hlZXQgcmVsaWVzIG9uIGNhbGN1bGF0ZWQgZnJhbWUgY291bnRzLCBhbmRcblx0ICogdGhlIGltYWdlcyBoYXZlIG5vdCBiZWVuIGZ1bGx5IGxvYWRlZC5cblx0ICogQG1ldGhvZCBnZXROdW1GcmFtZXNcblx0ICogQHBhcmFtIHtTdHJpbmd9IGFuaW1hdGlvbiBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIGdldCBhIGZyYW1lIGNvdW50IGZvci5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGZyYW1lcyBpbiB0aGUgYW5pbWF0aW9uLCBvciBpbiB0aGUgZW50aXJlIHNwcml0ZSBzaGVldCBpZiB0aGUgYW5pbWF0aW9uIHBhcmFtIGlzIG9taXR0ZWQuXG5cdCAqL1xuXHRwLmdldE51bUZyYW1lcyA9IGZ1bmN0aW9uKGFuaW1hdGlvbikge1xuXHRcdGlmIChhbmltYXRpb24gPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2ZyYW1lcyA/IHRoaXMuX2ZyYW1lcy5sZW5ndGggOiB0aGlzLl9udW1GcmFtZXMgfHwgMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLl9kYXRhW2FuaW1hdGlvbl07XG5cdFx0XHRpZiAoZGF0YSA9PSBudWxsKSB7IHJldHVybiAwOyB9XG5cdFx0XHRlbHNlIHsgcmV0dXJuIGRhdGEuZnJhbWVzLmxlbmd0aDsgfVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBvYmplY3QgZGVmaW5pbmcgdGhlIHNwZWNpZmllZCBhbmltYXRpb24uIFRoZSByZXR1cm5lZCBvYmplY3QgY29udGFpbnM6PFVMPlxuXHQgKiBcdDxsaT5mcmFtZXM6IGFuIGFycmF5IG9mIHRoZSBmcmFtZSBpZHMgaW4gdGhlIGFuaW1hdGlvbjwvbGk+XG5cdCAqIFx0PGxpPnNwZWVkOiB0aGUgcGxheWJhY2sgc3BlZWQgZm9yIHRoaXMgYW5pbWF0aW9uPC9saT5cblx0ICogXHQ8bGk+bmFtZTogdGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbjwvbGk+XG5cdCAqIFx0PGxpPm5leHQ6IHRoZSBkZWZhdWx0IGFuaW1hdGlvbiB0byBwbGF5IG5leHQuIElmIHRoZSBhbmltYXRpb24gbG9vcHMsIHRoZSBuYW1lIGFuZCBuZXh0IHByb3BlcnR5IHdpbGwgYmUgdGhlXG5cdCAqIFx0c2FtZS48L2xpPlxuXHQgKiA8L1VMPlxuXHQgKiBAbWV0aG9kIGdldEFuaW1hdGlvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIGdldC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBhIGdlbmVyaWMgb2JqZWN0IHdpdGggZnJhbWVzLCBzcGVlZCwgbmFtZSwgYW5kIG5leHQgcHJvcGVydGllcy5cblx0ICoqL1xuXHRwLmdldEFuaW1hdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YVtuYW1lXTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgaW1hZ2UgYW5kIHNvdXJjZSByZWN0IG9mIHRoZSBzcGVjaWZpZWQgZnJhbWUuIFRoZSByZXR1cm5lZCBvYmplY3QgaGFzOjxVTD5cblx0ICogXHQ8bGk+YW4gaW1hZ2UgcHJvcGVydHkgaG9sZGluZyBhIHJlZmVyZW5jZSB0byB0aGUgaW1hZ2Ugb2JqZWN0IGluIHdoaWNoIHRoZSBmcmFtZSBpcyBmb3VuZDwvbGk+XG5cdCAqIFx0PGxpPmEgcmVjdCBwcm9wZXJ0eSBjb250YWluaW5nIGEgUmVjdGFuZ2xlIGluc3RhbmNlIHdoaWNoIGRlZmluZXMgdGhlIGJvdW5kYXJpZXMgZm9yIHRoZSBmcmFtZSB3aXRoaW4gdGhhdFxuXHQgKiBcdGltYWdlLjwvbGk+XG5cdCAqIFx0PGxpPiBBIHJlZ1ggYW5kIHJlZ1kgcHJvcGVydHkgY29ycmVzcG9uZGluZyB0byB0aGUgcmVnWC9ZIHZhbHVlcyBmb3IgdGhlIGZyYW1lLlxuXHQgKiA8L1VMPlxuXHQgKiBAbWV0aG9kIGdldEZyYW1lXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUluZGV4IFRoZSBpbmRleCBvZiB0aGUgZnJhbWUuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gYSBnZW5lcmljIG9iamVjdCB3aXRoIGltYWdlIGFuZCByZWN0IHByb3BlcnRpZXMuIFJldHVybnMgbnVsbCBpZiB0aGUgZnJhbWUgZG9lcyBub3QgZXhpc3QuXG5cdCAqKi9cblx0cC5nZXRGcmFtZSA9IGZ1bmN0aW9uKGZyYW1lSW5kZXgpIHtcblx0XHR2YXIgZnJhbWU7XG5cdFx0aWYgKHRoaXMuX2ZyYW1lcyAmJiAoZnJhbWU9dGhpcy5fZnJhbWVzW2ZyYW1lSW5kZXhdKSkgeyByZXR1cm4gZnJhbWU7IH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHt7I2Nyb3NzTGluayBcIlJlY3RhbmdsZVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZSBkZWZpbmluZyB0aGUgYm91bmRzIG9mIHRoZSBzcGVjaWZpZWQgZnJhbWUgcmVsYXRpdmVcblx0ICogdG8gdGhlIG9yaWdpbi4gRm9yIGV4YW1wbGUsIGEgOTAgeCA3MCBmcmFtZSB3aXRoIGEgcmVnWCBvZiA1MCBhbmQgYSByZWdZIG9mIDQwIHdvdWxkIHJldHVybjpcblx0ICpcblx0ICogXHRbeD0tNTAsIHk9LTQwLCB3aWR0aD05MCwgaGVpZ2h0PTcwXVxuXHQgKlxuXHQgKiBAbWV0aG9kIGdldEZyYW1lQm91bmRzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUluZGV4IFRoZSBpbmRleCBvZiB0aGUgZnJhbWUuXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBbcmVjdGFuZ2xlXSBBIFJlY3RhbmdsZSBpbnN0YW5jZSB0byBjb3B5IHRoZSB2YWx1ZXMgaW50by4gQnkgZGVmYXVsdCBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEEgUmVjdGFuZ2xlIGluc3RhbmNlLiBSZXR1cm5zIG51bGwgaWYgdGhlIGZyYW1lIGRvZXMgbm90IGV4aXN0LCBvciB0aGUgaW1hZ2UgaXMgbm90IGZ1bGx5IGxvYWRlZC5cblx0ICoqL1xuXHRwLmdldEZyYW1lQm91bmRzID0gZnVuY3Rpb24oZnJhbWVJbmRleCwgcmVjdGFuZ2xlKSB7XG5cdFx0dmFyIGZyYW1lID0gdGhpcy5nZXRGcmFtZShmcmFtZUluZGV4KTtcblx0XHRyZXR1cm4gZnJhbWUgPyAocmVjdGFuZ2xlfHxuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKCkpLnNldFZhbHVlcygtZnJhbWUucmVnWCwgLWZyYW1lLnJlZ1ksIGZyYW1lLnJlY3Qud2lkdGgsIGZyYW1lLnJlY3QuaGVpZ2h0KSA6IG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltTcHJpdGVTaGVldF1cIjtcblx0fTtcblxuXHQvKipcblx0ICogU3ByaXRlU2hlZXQgY2Fubm90IGJlIGNsb25lZC4gQSBTcHJpdGVTaGVldCBjYW4gYmUgc2hhcmVkIGJ5IG11bHRpcGxlIFNwcml0ZSBpbnN0YW5jZXMgd2l0aG91dCBjbG9uaW5nIGl0LlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRocm93KFwiU3ByaXRlU2hlZXQgY2Fubm90IGJlIGNsb25lZC5cIilcblx0fTtcblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfcGFyc2VEYXRhXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBTcHJpdGVTaGVldCBkYXRhLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fcGFyc2VEYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdHZhciBpLGwsbyxhO1xuXHRcdGlmIChkYXRhID09IG51bGwpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLmZyYW1lcmF0ZSA9IGRhdGEuZnJhbWVyYXRlfHwwO1xuXG5cdFx0Ly8gcGFyc2UgaW1hZ2VzOlxuXHRcdGlmIChkYXRhLmltYWdlcyAmJiAobD1kYXRhLmltYWdlcy5sZW5ndGgpID4gMCkge1xuXHRcdFx0YSA9IHRoaXMuX2ltYWdlcyA9IFtdO1xuXHRcdFx0Zm9yIChpPTA7IGk8bDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpbWcgPSBkYXRhLmltYWdlc1tpXTtcblx0XHRcdFx0aWYgKHR5cGVvZiBpbWcgPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdHZhciBzcmMgPSBpbWc7XG5cdFx0XHRcdFx0aW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcblx0XHRcdFx0XHRpbWcuc3JjID0gc3JjO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGEucHVzaChpbWcpO1xuXHRcdFx0XHRpZiAoIWltZy5nZXRDb250ZXh0ICYmICFpbWcubmF0dXJhbFdpZHRoKSB7XG5cdFx0XHRcdFx0dGhpcy5fbG9hZENvdW50Kys7XG5cdFx0XHRcdFx0dGhpcy5jb21wbGV0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdChmdW5jdGlvbihvLCBzcmMpIHsgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyBvLl9oYW5kbGVJbWFnZUxvYWQoc3JjKTsgfSB9KSh0aGlzLCBzcmMpO1xuXHRcdFx0XHRcdChmdW5jdGlvbihvLCBzcmMpIHsgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHsgby5faGFuZGxlSW1hZ2VFcnJvcihzcmMpOyB9IH0pKHRoaXMsIHNyYyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBwYXJzZSBmcmFtZXM6XG5cdFx0aWYgKGRhdGEuZnJhbWVzID09IG51bGwpIHsgLy8gbm90aGluZ1xuXHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhLmZyYW1lcykpIHtcblx0XHRcdHRoaXMuX2ZyYW1lcyA9IFtdO1xuXHRcdFx0YSA9IGRhdGEuZnJhbWVzO1xuXHRcdFx0Zm9yIChpPTAsbD1hLmxlbmd0aDtpPGw7aSsrKSB7XG5cdFx0XHRcdHZhciBhcnIgPSBhW2ldO1xuXHRcdFx0XHR0aGlzLl9mcmFtZXMucHVzaCh7aW1hZ2U6dGhpcy5faW1hZ2VzW2Fycls0XT9hcnJbNF06MF0sIHJlY3Q6bmV3IGNyZWF0ZWpzLlJlY3RhbmdsZShhcnJbMF0sYXJyWzFdLGFyclsyXSxhcnJbM10pLCByZWdYOmFycls1XXx8MCwgcmVnWTphcnJbNl18fDAgfSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG8gPSBkYXRhLmZyYW1lcztcblx0XHRcdHRoaXMuX2ZyYW1lV2lkdGggPSBvLndpZHRoO1xuXHRcdFx0dGhpcy5fZnJhbWVIZWlnaHQgPSBvLmhlaWdodDtcblx0XHRcdHRoaXMuX3JlZ1ggPSBvLnJlZ1h8fDA7XG5cdFx0XHR0aGlzLl9yZWdZID0gby5yZWdZfHwwO1xuXHRcdFx0dGhpcy5fc3BhY2luZyA9IG8uc3BhY2luZ3x8MDtcblx0XHRcdHRoaXMuX21hcmdpbiA9IG8ubWFyZ2lufHwwO1xuXHRcdFx0dGhpcy5fbnVtRnJhbWVzID0gby5jb3VudDtcblx0XHRcdGlmICh0aGlzLl9sb2FkQ291bnQgPT0gMCkgeyB0aGlzLl9jYWxjdWxhdGVGcmFtZXMoKTsgfVxuXHRcdH1cblxuXHRcdC8vIHBhcnNlIGFuaW1hdGlvbnM6XG5cdFx0dGhpcy5fYW5pbWF0aW9ucyA9IFtdO1xuXHRcdGlmICgobz1kYXRhLmFuaW1hdGlvbnMpICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX2RhdGEgPSB7fTtcblx0XHRcdHZhciBuYW1lO1xuXHRcdFx0Zm9yIChuYW1lIGluIG8pIHtcblx0XHRcdFx0dmFyIGFuaW0gPSB7bmFtZTpuYW1lfTtcblx0XHRcdFx0dmFyIG9iaiA9IG9bbmFtZV07XG5cdFx0XHRcdGlmICh0eXBlb2Ygb2JqID09IFwibnVtYmVyXCIpIHsgLy8gc2luZ2xlIGZyYW1lXG5cdFx0XHRcdFx0YSA9IGFuaW0uZnJhbWVzID0gW29ial07XG5cdFx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7IC8vIHNpbXBsZVxuXHRcdFx0XHRcdGlmIChvYmoubGVuZ3RoID09IDEpIHsgYW5pbS5mcmFtZXMgPSBbb2JqWzBdXTsgfVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0YW5pbS5zcGVlZCA9IG9ialszXTtcblx0XHRcdFx0XHRcdGFuaW0ubmV4dCA9IG9ialsyXTtcblx0XHRcdFx0XHRcdGEgPSBhbmltLmZyYW1lcyA9IFtdO1xuXHRcdFx0XHRcdFx0Zm9yIChpPW9ialswXTtpPD1vYmpbMV07aSsrKSB7XG5cdFx0XHRcdFx0XHRcdGEucHVzaChpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7IC8vIGNvbXBsZXhcblx0XHRcdFx0XHRhbmltLnNwZWVkID0gb2JqLnNwZWVkO1xuXHRcdFx0XHRcdGFuaW0ubmV4dCA9IG9iai5uZXh0O1xuXHRcdFx0XHRcdHZhciBmcmFtZXMgPSBvYmouZnJhbWVzO1xuXHRcdFx0XHRcdGEgPSBhbmltLmZyYW1lcyA9ICh0eXBlb2YgZnJhbWVzID09IFwibnVtYmVyXCIpID8gW2ZyYW1lc10gOiBmcmFtZXMuc2xpY2UoMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGFuaW0ubmV4dCA9PT0gdHJ1ZSB8fCBhbmltLm5leHQgPT09IHVuZGVmaW5lZCkgeyBhbmltLm5leHQgPSBuYW1lOyB9IC8vIGxvb3Bcblx0XHRcdFx0aWYgKGFuaW0ubmV4dCA9PT0gZmFsc2UgfHwgKGEubGVuZ3RoIDwgMiAmJiBhbmltLm5leHQgPT0gbmFtZSkpIHsgYW5pbS5uZXh0ID0gbnVsbDsgfSAvLyBzdG9wXG5cdFx0XHRcdGlmICghYW5pbS5zcGVlZCkgeyBhbmltLnNwZWVkID0gMTsgfVxuXHRcdFx0XHR0aGlzLl9hbmltYXRpb25zLnB1c2gobmFtZSk7XG5cdFx0XHRcdHRoaXMuX2RhdGFbbmFtZV0gPSBhbmltO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlSW1hZ2VMb2FkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9oYW5kbGVJbWFnZUxvYWQgPSBmdW5jdGlvbihzcmMpIHtcblx0XHRpZiAoLS10aGlzLl9sb2FkQ291bnQgPT0gMCkge1xuXHRcdFx0dGhpcy5fY2FsY3VsYXRlRnJhbWVzKCk7XG5cdFx0XHR0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlSW1hZ2VFcnJvclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVJbWFnZUVycm9yID0gZnVuY3Rpb24gKHNyYykge1xuXHRcdHZhciBlcnJvckV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZXJyb3JcIik7XG5cdFx0ZXJyb3JFdmVudC5zcmMgPSBzcmM7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGVycm9yRXZlbnQpO1xuXG5cdFx0Ly8gQ29tcGxldGUgaXMgc3RpbGwgZGlzcGF0Y2hlZC5cblx0XHRpZiAoLS10aGlzLl9sb2FkQ291bnQgPT0gMCkge1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jYWxjdWxhdGVGcmFtZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2NhbGN1bGF0ZUZyYW1lcyA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9mcmFtZXMgfHwgdGhpcy5fZnJhbWVXaWR0aCA9PSAwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZnJhbWVzID0gW107XG5cblx0XHR2YXIgbWF4RnJhbWVzID0gdGhpcy5fbnVtRnJhbWVzIHx8IDEwMDAwMDsgLy8gaWYgd2UgZ28gb3ZlciB0aGlzLCBzb21ldGhpbmcgaXMgd3JvbmcuXG5cdFx0dmFyIGZyYW1lQ291bnQgPSAwLCBmcmFtZVdpZHRoID0gdGhpcy5fZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQgPSB0aGlzLl9mcmFtZUhlaWdodDtcblx0XHR2YXIgc3BhY2luZyA9IHRoaXMuX3NwYWNpbmcsIG1hcmdpbiA9IHRoaXMuX21hcmdpbjtcblx0XHRcblx0XHRpbWdMb29wOlxuXHRcdGZvciAodmFyIGk9MCwgaW1ncz10aGlzLl9pbWFnZXM7IGk8aW1ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGltZyA9IGltZ3NbaV0sIGltZ1cgPSBpbWcud2lkdGgsIGltZ0ggPSBpbWcuaGVpZ2h0O1xuXG5cdFx0XHR2YXIgeSA9IG1hcmdpbjtcblx0XHRcdHdoaWxlICh5IDw9IGltZ0gtbWFyZ2luLWZyYW1lSGVpZ2h0KSB7XG5cdFx0XHRcdHZhciB4ID0gbWFyZ2luO1xuXHRcdFx0XHR3aGlsZSAoeCA8PSBpbWdXLW1hcmdpbi1mcmFtZVdpZHRoKSB7XG5cdFx0XHRcdFx0aWYgKGZyYW1lQ291bnQgPj0gbWF4RnJhbWVzKSB7IGJyZWFrIGltZ0xvb3A7IH1cblx0XHRcdFx0XHRmcmFtZUNvdW50Kys7XG5cdFx0XHRcdFx0dGhpcy5fZnJhbWVzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRpbWFnZTogaW1nLFxuXHRcdFx0XHRcdFx0XHRyZWN0OiBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKHgsIHksIGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0KSxcblx0XHRcdFx0XHRcdFx0cmVnWDogdGhpcy5fcmVnWCxcblx0XHRcdFx0XHRcdFx0cmVnWTogdGhpcy5fcmVnWVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0eCArPSBmcmFtZVdpZHRoK3NwYWNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdFx0eSArPSBmcmFtZUhlaWdodCtzcGFjaW5nO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9udW1GcmFtZXMgPSBmcmFtZUNvdW50O1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuU3ByaXRlU2hlZXQgPSBjcmVhdGVqcy5wcm9tb3RlKFNwcml0ZVNoZWV0LCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBHcmFwaGljcy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFRoZSBHcmFwaGljcyBjbGFzcyBleHBvc2VzIGFuIGVhc3kgdG8gdXNlIEFQSSBmb3IgZ2VuZXJhdGluZyB2ZWN0b3IgZHJhd2luZyBpbnN0cnVjdGlvbnMgYW5kIGRyYXdpbmcgdGhlbSB0byBhXG5cdCAqIHNwZWNpZmllZCBjb250ZXh0LiBOb3RlIHRoYXQgeW91IGNhbiB1c2UgR3JhcGhpY3Mgd2l0aG91dCBhbnkgZGVwZW5kZW5jeSBvbiB0aGUgRWFzZWxKUyBmcmFtZXdvcmsgYnkgY2FsbGluZyB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGRpcmVjdGx5LCBvciBpdCBjYW4gYmUgdXNlZCB3aXRoIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBvYmplY3QgdG8gZHJhdyB2ZWN0b3IgZ3JhcGhpY3Mgd2l0aGluIHRoZVxuXHQgKiBjb250ZXh0IG9mIGFuIEVhc2VsSlMgZGlzcGxheSBsaXN0LlxuXHQgKlxuXHQgKiBUaGVyZSBhcmUgdHdvIGFwcHJvYWNoZXMgdG8gd29ya2luZyB3aXRoIEdyYXBoaWNzIG9iamVjdDogY2FsbGluZyBtZXRob2RzIG9uIGEgR3JhcGhpY3MgaW5zdGFuY2UgKHRoZSBcIkdyYXBoaWNzIEFQSVwiKSwgb3Jcblx0ICogaW5zdGFudGlhdGluZyBHcmFwaGljcyBjb21tYW5kIG9iamVjdHMgYW5kIGFkZGluZyB0aGVtIHRvIHRoZSBncmFwaGljcyBxdWV1ZSB2aWEge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBUaGUgZm9ybWVyIGFic3RyYWN0cyB0aGUgbGF0dGVyLCBzaW1wbGlmeWluZyBiZWdpbm5pbmcgYW5kIGVuZGluZyBwYXRocywgZmlsbHMsIGFuZCBzdHJva2VzLlxuXHQgKlxuXHQgKiAgICAgIHZhciBnID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCk7XG5cdCAqICAgICAgZy5zZXRTdHJva2VTdHlsZSgxKTtcblx0ICogICAgICBnLmJlZ2luU3Ryb2tlKFwiIzAwMDAwMFwiKTtcblx0ICogICAgICBnLmJlZ2luRmlsbChcInJlZFwiKTtcblx0ICogICAgICBnLmRyYXdDaXJjbGUoMCwwLDMwKTtcblx0ICpcblx0ICogQWxsIGRyYXdpbmcgbWV0aG9kcyBpbiBHcmFwaGljcyByZXR1cm4gdGhlIEdyYXBoaWNzIGluc3RhbmNlLCBzbyB0aGV5IGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBGb3IgZXhhbXBsZSxcblx0ICogdGhlIGZvbGxvd2luZyBsaW5lIG9mIGNvZGUgd291bGQgZ2VuZXJhdGUgdGhlIGluc3RydWN0aW9ucyB0byBkcmF3IGEgcmVjdGFuZ2xlIHdpdGggYSByZWQgc3Ryb2tlIGFuZCBibHVlIGZpbGw6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5iZWdpblN0cm9rZShcInJlZFwiKS5iZWdpbkZpbGwoXCJibHVlXCIpLmRyYXdSZWN0KDIwLCAyMCwgMTAwLCA1MCk7XG5cdCAqXG5cdCAqIEVhY2ggZ3JhcGhpY3MgQVBJIGNhbGwgZ2VuZXJhdGVzIGEgY29tbWFuZCBvYmplY3QgKHNlZSBiZWxvdykuIFRoZSBsYXN0IGNvbW1hbmQgdG8gYmUgY3JlYXRlZCBjYW4gYmUgYWNjZXNzZWQgdmlhXG5cdCAqIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2NvbW1hbmQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06XG5cdCAqXG5cdCAqICAgICAgdmFyIGZpbGxDb21tYW5kID0gbXlHcmFwaGljcy5iZWdpbkZpbGwoXCJyZWRcIikuY29tbWFuZDtcblx0ICogICAgICAvLyAuLi4gbGF0ZXIsIHVwZGF0ZSB0aGUgZmlsbCBzdHlsZS9jb2xvcjpcblx0ICogICAgICBmaWxsQ29tbWFuZC5zdHlsZSA9IFwiYmx1ZVwiO1xuXHQgKiAgICAgIC8vIG9yIGNoYW5nZSBpdCB0byBhIGJpdG1hcCBmaWxsOlxuXHQgKiAgICAgIGZpbGxDb21tYW5kLmJpdG1hcChteUltYWdlKTtcblx0ICpcblx0ICogRm9yIG1vcmUgZGlyZWN0IGNvbnRyb2wgb2YgcmVuZGVyaW5nLCB5b3UgY2FuIGluc3RhbnRpYXRlIGFuZCBhcHBlbmQgY29tbWFuZCBvYmplY3RzIHRvIHRoZSBncmFwaGljcyBxdWV1ZSBkaXJlY3RseS4gSW4gdGhpcyBjYXNlLCB5b3Vcblx0ICogbmVlZCB0byBtYW5hZ2UgcGF0aCBjcmVhdGlvbiBtYW51YWxseSwgYW5kIGVuc3VyZSB0aGF0IGZpbGwvc3Ryb2tlIGlzIGFwcGxpZWQgdG8gYSBkZWZpbmVkIHBhdGg6XG5cdCAqXG5cdCAqICAgICAgLy8gc3RhcnQgYSBuZXcgcGF0aC4gR3JhcGhpY3MuYmVnaW5DbWQgaXMgYSByZXVzYWJsZSBCZWdpblBhdGggaW5zdGFuY2U6XG5cdCAqICAgICAgbXlHcmFwaGljcy5hcHBlbmQoY3JlYXRlanMuR3JhcGhpY3MuYmVnaW5DbWQpO1xuXHQgKiAgICAgIC8vIHdlIG5lZWQgdG8gZGVmaW5lIHRoZSBwYXRoIGJlZm9yZSBhcHBseWluZyB0aGUgZmlsbDpcblx0ICogICAgICB2YXIgY2lyY2xlID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzLkNpcmNsZSgwLDAsMzApO1xuXHQgKiAgICAgIG15R3JhcGhpY3MuYXBwZW5kKGNpcmNsZSk7XG5cdCAqICAgICAgLy8gZmlsbCB0aGUgcGF0aCB3ZSBqdXN0IGRlZmluZWQ6XG5cdCAqICAgICAgdmFyIGZpbGwgPSBuZXcgY3JlYXRlanMuR3JhcGhpY3MuRmlsbChcInJlZFwiKTtcblx0ICogICAgICBteUdyYXBoaWNzLmFwcGVuZChmaWxsKTtcblx0ICpcblx0ICogVGhlc2UgYXBwcm9hY2hlcyBjYW4gYmUgdXNlZCB0b2dldGhlciwgZm9yIGV4YW1wbGUgdG8gaW5zZXJ0IGEgY3VzdG9tIGNvbW1hbmQ6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5iZWdpbkZpbGwoXCJyZWRcIik7XG5cdCAqICAgICAgdmFyIGN1c3RvbUNvbW1hbmQgPSBuZXcgQ3VzdG9tU3BpcmFsQ29tbWFuZChldGMpO1xuXHQgKiAgICAgIG15R3JhcGhpY3MuYXBwZW5kKGN1c3RvbUNvbW1hbmQpO1xuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5GaWxsKFwiYmx1ZVwiKTtcblx0ICogICAgICBteUdyYXBoaWNzLmRyYXdDaXJjbGUoMCwgMCwgMzApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm8gb24gY3JlYXRpbmcgY3VzdG9tIGNvbW1hbmRzLlxuXHQgKlxuXHQgKiA8aDQ+VGlueSBBUEk8L2g0PlxuXHQgKiBUaGUgR3JhcGhpY3MgY2xhc3MgYWxzbyBpbmNsdWRlcyBhIFwidGlueSBBUElcIiwgd2hpY2ggaXMgb25lIG9yIHR3by1sZXR0ZXIgbWV0aG9kcyB0aGF0IGFyZSBzaG9ydGN1dHMgZm9yIGFsbCBvZiB0aGVcblx0ICogR3JhcGhpY3MgbWV0aG9kcy4gVGhlc2UgbWV0aG9kcyBhcmUgZ3JlYXQgZm9yIGNyZWF0aW5nIGNvbXBhY3QgaW5zdHJ1Y3Rpb25zLCBhbmQgaXMgdXNlZCBieSB0aGUgVG9vbGtpdCBmb3IgQ3JlYXRlSlNcblx0ICogdG8gZ2VuZXJhdGUgcmVhZGFibGUgY29kZS4gQWxsIHRpbnkgbWV0aG9kcyBhcmUgbWFya2VkIGFzIHByb3RlY3RlZCwgc28geW91IGNhbiB2aWV3IHRoZW0gYnkgZW5hYmxpbmcgcHJvdGVjdGVkXG5cdCAqIGRlc2NyaXB0aW9ucyBpbiB0aGUgZG9jcy5cblx0ICpcblx0ICogPHRhYmxlPlxuXHQgKiAgICAgPHRyPjx0ZD48Yj5UaW55PC9iPjwvdGQ+PHRkPjxiPk1ldGhvZDwvYj48L3RkPjx0ZD48Yj5UaW55PC9iPjwvdGQ+PHRkPjxiPk1ldGhvZDwvYj48L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPm10PC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvbW92ZVRvXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+bHQ8L3RkPiA8dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvbGluZVRvXCJ9fXt7L2Nyb3NzTGlua319PC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5hL2F0PC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXJjXCJ9fXt7L2Nyb3NzTGlua319IC8ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXJjVG9cIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5idDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlemllckN1cnZlVG9cIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5xdDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3F1YWRyYXRpY0N1cnZlVG9cIn19e3svY3Jvc3NMaW5rfX0gKGFsc28gY3VydmVUbyk8L3RkPlxuXHQgKiAgICAgPHRkPnI8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9yZWN0XCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+Y3A8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9jbG9zZVBhdGhcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5jPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvY2xlYXJcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5mPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5GaWxsXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+bGY8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkxpbmVhckdyYWRpZW50RmlsbFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPnJmPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5SYWRpYWxHcmFkaWVudEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5iZjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luQml0bWFwRmlsbFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmVmPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZW5kRmlsbFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPnNzIC8gc2Q8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zZXRTdHJva2VTdHlsZVwifX17ey9jcm9zc0xpbmt9fSAvIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3NldFN0cm9rZURhc2hcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5zPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5TdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5sczwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luTGluZWFyR3JhZGllbnRTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5yczwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luUmFkaWFsR3JhZGllbnRTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5iczwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luQml0bWFwU3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+ZXM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9lbmRTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5kcjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdSZWN0XCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+cnI8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Um91bmRSZWN0XCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+cmM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Um91bmRSZWN0Q29tcGxleFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmRjPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmRlPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0VsbGlwc2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5kcDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdQb2x5U3RhclwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPnA8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kZWNvZGVQYXRoXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogPC90YWJsZT5cblx0ICpcblx0ICogSGVyZSBpcyB0aGUgYWJvdmUgZXhhbXBsZSwgdXNpbmcgdGhlIHRpbnkgQVBJIGluc3RlYWQuXG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5zKFwicmVkXCIpLmYoXCJibHVlXCIpLnIoMjAsIDIwLCAxMDAsIDUwKTtcblx0ICpcblx0ICogQGNsYXNzIEdyYXBoaWNzXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIEdyYXBoaWNzKCkge1xuXG5cblx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBIb2xkcyBhIHJlZmVyZW5jZSB0byB0aGUgbGFzdCBjb21tYW5kIHRoYXQgd2FzIGNyZWF0ZWQgb3IgYXBwZW5kZWQuIEZvciBleGFtcGxlLCB5b3UgY291bGQgcmV0YWluIGEgcmVmZXJlbmNlXG5cdFx0ICogdG8gYSBGaWxsIGNvbW1hbmQgaW4gb3JkZXIgdG8gZHluYW1pY2FsbHkgdXBkYXRlIHRoZSBjb2xvciBsYXRlciBieSB1c2luZzpcblx0XHQgKlxuXHRcdCAqIFx0XHR2YXIgbXlGaWxsID0gbXlHcmFwaGljcy5iZWdpbkZpbGwoXCJyZWRcIikuY29tbWFuZDtcblx0XHQgKiBcdFx0Ly8gdXBkYXRlIGNvbG9yIGxhdGVyOlxuXHRcdCAqIFx0XHRteUZpbGwuc3R5bGUgPSBcInllbGxvd1wiO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IGNvbW1hbmRcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiovXG5cdFx0dGhpcy5jb21tYW5kID0gbnVsbDtcblxuXG5cdC8vIHByaXZhdGUgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3Ryb2tlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtTdHJva2V9XG5cdFx0ICoqL1xuXHRcdHRoaXMuX3N0cm9rZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3N0cm9rZVN0eWxlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtTdHJva2VTdHlsZX1cblx0XHQgKiovXG5cdFx0dGhpcy5fc3Ryb2tlU3R5bGUgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfb2xkU3Ryb2tlU3R5bGVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge1N0cm9rZVN0eWxlfVxuXHRcdCAqKi9cblx0XHR0aGlzLl9vbGRTdHJva2VTdHlsZSA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zdHJva2VEYXNoXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtTdHJva2VEYXNofVxuXHRcdCAqKi9cblx0XHR0aGlzLl9zdHJva2VEYXNoID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX29sZFN0cm9rZURhc2hcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge1N0cm9rZURhc2h9XG5cdFx0ICoqL1xuXHRcdHRoaXMuX29sZFN0cm9rZURhc2ggPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zdHJva2VJZ25vcmVTY2FsZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3N0cm9rZUlnbm9yZVNjYWxlID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ZpbGxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0ZpbGx9XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ZpbGwgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9pbnN0cnVjdGlvbnNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqKi9cblx0XHR0aGlzLl9pbnN0cnVjdGlvbnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGUgbGFzdCBpbnN0cnVjdGlvbiBpbmRleCB0aGF0IHdhcyBjb21taXR0ZWQuXG5cdFx0ICogQHByb3BlcnR5IF9jb21taXRJbmRleFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqKi9cblx0XHR0aGlzLl9jb21taXRJbmRleCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBVbmNvbW1pdHRlZCBpbnN0cnVjdGlvbnMuXG5cdFx0ICogQHByb3BlcnR5IF9hY3RpdmVJbnN0cnVjdGlvbnNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqKi9cblx0XHR0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaGF2ZSBiZWVuIGNoYW5nZXMgdG8gdGhlIGFjdGl2ZUluc3RydWN0aW9uIGxpc3Qgc2luY2UgdGhlIGxhc3QgdXBkYXRlSW5zdHJ1Y3Rpb25zIGNhbGwuXG5cdFx0ICogQHByb3BlcnR5IF9kaXJ0eVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqKi9cblx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kZXggdG8gZHJhdyBmcm9tIGlmIGEgc3RvcmUgb3BlcmF0aW9uIGhhcyBoYXBwZW5lZC5cblx0XHQgKiBAcHJvcGVydHkgX3N0b3JlSW5kZXhcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3N0b3JlSW5kZXggPSAwO1xuXG5cdC8vIHNldHVwOlxuXHRcdHRoaXMuY2xlYXIoKTtcblx0fVxuXHR2YXIgcCA9IEdyYXBoaWNzLnByb3RvdHlwZTtcblx0dmFyIEcgPSBHcmFwaGljczsgLy8gc2hvcnRjdXRcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gc3RhdGljIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyBhIENTUyBjb21wYXRpYmxlIGNvbG9yIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIFJHQiBudW1lcmljIGNvbG9yIHZhbHVlcyBpbiB0aGUgZm9ybWF0XG5cdCAqIFwicmdiYSgyNTUsMjU1LDI1NSwxLjApXCIsIG9yIGlmIGFscGhhIGlzIG51bGwgdGhlbiBpbiB0aGUgZm9ybWF0IFwicmdiKDI1NSwyNTUsMjU1KVwiLiBGb3IgZXhhbXBsZSxcblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5HcmFwaGljcy5nZXRSR0IoNTAsIDEwMCwgMTUwLCAwLjUpO1xuXHQgKiAgICAgIC8vIFJldHVybnMgXCJyZ2JhKDUwLDEwMCwxNTAsMC41KVwiXG5cdCAqXG5cdCAqIEl0IGFsc28gc3VwcG9ydHMgcGFzc2luZyBhIHNpbmdsZSBoZXggY29sb3IgdmFsdWUgYXMgdGhlIGZpcnN0IHBhcmFtLCBhbmQgYW4gb3B0aW9uYWwgYWxwaGEgdmFsdWUgYXMgdGhlIHNlY29uZFxuXHQgKiBwYXJhbS4gRm9yIGV4YW1wbGUsXG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuR3JhcGhpY3MuZ2V0UkdCKDB4RkYwMEZGLCAwLjIpO1xuXHQgKiAgICAgIC8vIFJldHVybnMgXCJyZ2JhKDI1NSwwLDI1NSwwLjIpXCJcblx0ICpcblx0ICogQG1ldGhvZCBnZXRSR0Jcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gciBUaGUgcmVkIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yLCBiZXR3ZWVuIDAgYW5kIDB4RkYgKDI1NSkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBnIFRoZSBncmVlbiBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAweEZGICgyNTUpLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgYmx1ZSBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAweEZGICgyNTUpLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FscGhhXSBUaGUgYWxwaGEgY29tcG9uZW50IGZvciB0aGUgY29sb3Igd2hlcmUgMCBpcyBmdWxseSB0cmFuc3BhcmVudCBhbmQgMSBpcyBmdWxseSBvcGFxdWUuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gQSBDU1MgY29tcGF0aWJsZSBjb2xvciBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBSR0IgbnVtZXJpYyBjb2xvciB2YWx1ZXMgaW4gdGhlIGZvcm1hdFxuXHQgKiBcInJnYmEoMjU1LDI1NSwyNTUsMS4wKVwiLCBvciBpZiBhbHBoYSBpcyBudWxsIHRoZW4gaW4gdGhlIGZvcm1hdCBcInJnYigyNTUsMjU1LDI1NSlcIi5cblx0ICoqL1xuXHRHcmFwaGljcy5nZXRSR0IgPSBmdW5jdGlvbihyLCBnLCBiLCBhbHBoYSkge1xuXHRcdGlmIChyICE9IG51bGwgJiYgYiA9PSBudWxsKSB7XG5cdFx0XHRhbHBoYSA9IGc7XG5cdFx0XHRiID0gciYweEZGO1xuXHRcdFx0ZyA9IHI+PjgmMHhGRjtcblx0XHRcdHIgPSByPj4xNiYweEZGO1xuXHRcdH1cblx0XHRpZiAoYWxwaGEgPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIFwicmdiKFwiK3IrXCIsXCIrZytcIixcIitiK1wiKVwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gXCJyZ2JhKFwiK3IrXCIsXCIrZytcIixcIitiK1wiLFwiK2FscGhhK1wiKVwiO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIENTUyBjb21wYXRpYmxlIGNvbG9yIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIEhTTCBudW1lcmljIGNvbG9yIHZhbHVlcyBpbiB0aGUgZm9ybWF0IFwiaHNsYSgzNjAsMTAwLDEwMCwxLjApXCIsXG5cdCAqIG9yIGlmIGFscGhhIGlzIG51bGwgdGhlbiBpbiB0aGUgZm9ybWF0IFwiaHNsKDM2MCwxMDAsMTAwKVwiLlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLkdyYXBoaWNzLmdldEhTTCgxNTAsIDEwMCwgNzApO1xuXHQgKiAgICAgIC8vIFJldHVybnMgXCJoc2woMTUwLDEwMCw3MClcIlxuXHQgKlxuXHQgKiBAbWV0aG9kIGdldEhTTFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBodWUgVGhlIGh1ZSBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAzNjAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uIFRoZSBzYXR1cmF0aW9uIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yLCBiZXR3ZWVuIDAgYW5kIDEwMC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxpZ2h0bmVzcyBUaGUgbGlnaHRuZXNzIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yLCBiZXR3ZWVuIDAgYW5kIDEwMC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYV0gVGhlIGFscGhhIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yIHdoZXJlIDAgaXMgZnVsbHkgdHJhbnNwYXJlbnQgYW5kIDEgaXMgZnVsbHkgb3BhcXVlLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IEEgQ1NTIGNvbXBhdGlibGUgY29sb3Igc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgSFNMIG51bWVyaWMgY29sb3IgdmFsdWVzIGluIHRoZSBmb3JtYXRcblx0ICogXCJoc2xhKDM2MCwxMDAsMTAwLDEuMClcIiwgb3IgaWYgYWxwaGEgaXMgbnVsbCB0aGVuIGluIHRoZSBmb3JtYXQgXCJoc2woMzYwLDEwMCwxMDApXCIuXG5cdCAqKi9cblx0R3JhcGhpY3MuZ2V0SFNMID0gZnVuY3Rpb24oaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGFscGhhKSB7XG5cdFx0aWYgKGFscGhhID09IG51bGwpIHtcblx0XHRcdHJldHVybiBcImhzbChcIisoaHVlJTM2MCkrXCIsXCIrc2F0dXJhdGlvbitcIiUsXCIrbGlnaHRuZXNzK1wiJSlcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFwiaHNsYShcIisoaHVlJTM2MCkrXCIsXCIrc2F0dXJhdGlvbitcIiUsXCIrbGlnaHRuZXNzK1wiJSxcIithbHBoYStcIilcIjtcblx0XHR9XG5cdH07XG5cblxuLy8gc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBBIHJldXNhYmxlIGluc3RhbmNlIG9mIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL0JlZ2luUGF0aFwifX17ey9jcm9zc0xpbmt9fSB0byBhdm9pZFxuXHQgKiB1bm5lY2Vzc2FyeSBpbnN0YW50aWF0aW9uLlxuXHQgKiBAcHJvcGVydHkgYmVnaW5DbWRcblx0ICogQHR5cGUge0dyYXBoaWNzLkJlZ2luUGF0aH1cblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdCAvLyBkZWZpbmVkIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuXG5cdC8qKlxuXHQgKiBNYXAgb2YgQmFzZTY0IGNoYXJhY3RlcnMgdG8gdmFsdWVzLiBVc2VkIGJ5IHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RlY29kZVBhdGhcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBwcm9wZXJ0eSBCQVNFXzY0XG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqIEByZWFkb25seVxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiovXG5cdEdyYXBoaWNzLkJBU0VfNjQgPSB7XCJBXCI6MCxcIkJcIjoxLFwiQ1wiOjIsXCJEXCI6MyxcIkVcIjo0LFwiRlwiOjUsXCJHXCI6NixcIkhcIjo3LFwiSVwiOjgsXCJKXCI6OSxcIktcIjoxMCxcIkxcIjoxMSxcIk1cIjoxMixcIk5cIjoxMyxcIk9cIjoxNCxcIlBcIjoxNSxcIlFcIjoxNixcIlJcIjoxNyxcIlNcIjoxOCxcIlRcIjoxOSxcIlVcIjoyMCxcIlZcIjoyMSxcIldcIjoyMixcIlhcIjoyMyxcIllcIjoyNCxcIlpcIjoyNSxcImFcIjoyNixcImJcIjoyNyxcImNcIjoyOCxcImRcIjoyOSxcImVcIjozMCxcImZcIjozMSxcImdcIjozMixcImhcIjozMyxcImlcIjozNCxcImpcIjozNSxcImtcIjozNixcImxcIjozNyxcIm1cIjozOCxcIm5cIjozOSxcIm9cIjo0MCxcInBcIjo0MSxcInFcIjo0MixcInJcIjo0MyxcInNcIjo0NCxcInRcIjo0NSxcInVcIjo0NixcInZcIjo0NyxcIndcIjo0OCxcInhcIjo0OSxcInlcIjo1MCxcInpcIjo1MSxcIjBcIjo1MixcIjFcIjo1MyxcIjJcIjo1NCxcIjNcIjo1NSxcIjRcIjo1NixcIjVcIjo1NyxcIjZcIjo1OCxcIjdcIjo1OSxcIjhcIjo2MCxcIjlcIjo2MSxcIitcIjo2MixcIi9cIjo2M307XG5cblx0LyoqXG5cdCAqIE1hcHMgbnVtZXJpYyB2YWx1ZXMgZm9yIHRoZSBjYXBzIHBhcmFtZXRlciBvZiB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zZXRTdHJva2VTdHlsZVwifX17ey9jcm9zc0xpbmt9fSB0b1xuXHQgKiBjb3JyZXNwb25kaW5nIHN0cmluZyB2YWx1ZXMuIFRoaXMgaXMgcHJpbWFyaWx5IGZvciB1c2Ugd2l0aCB0aGUgdGlueSBBUEkuIFRoZSBtYXBwaW5ncyBhcmUgYXMgZm9sbG93czogMCB0b1xuXHQgKiBcImJ1dHRcIiwgMSB0byBcInJvdW5kXCIsIGFuZCAyIHRvIFwic3F1YXJlXCIuXG5cdCAqIEZvciBleGFtcGxlLCB0byBzZXQgdGhlIGxpbmUgY2FwcyB0byBcInNxdWFyZVwiOlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3Muc3MoMTYsIDIpO1xuXHQgKlxuXHQgKiBAcHJvcGVydHkgU1RST0tFX0NBUFNfTUFQXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqIEByZWFkb25seVxuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqKi9cblx0R3JhcGhpY3MuU1RST0tFX0NBUFNfTUFQID0gW1wiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCJdO1xuXG5cdC8qKlxuXHQgKiBNYXBzIG51bWVyaWMgdmFsdWVzIGZvciB0aGUgam9pbnRzIHBhcmFtZXRlciBvZiB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zZXRTdHJva2VTdHlsZVwifX17ey9jcm9zc0xpbmt9fSB0b1xuXHQgKiBjb3JyZXNwb25kaW5nIHN0cmluZyB2YWx1ZXMuIFRoaXMgaXMgcHJpbWFyaWx5IGZvciB1c2Ugd2l0aCB0aGUgdGlueSBBUEkuIFRoZSBtYXBwaW5ncyBhcmUgYXMgZm9sbG93czogMCB0b1xuXHQgKiBcIm1pdGVyXCIsIDEgdG8gXCJyb3VuZFwiLCBhbmQgMiB0byBcImJldmVsXCIuXG5cdCAqIEZvciBleGFtcGxlLCB0byBzZXQgdGhlIGxpbmUgam9pbnRzIHRvIFwiYmV2ZWxcIjpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLnNzKDE2LCAwLCAyKTtcblx0ICpcblx0ICogQHByb3BlcnR5IFNUUk9LRV9KT0lOVFNfTUFQXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqIEByZWFkb25seVxuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqKi9cblx0R3JhcGhpY3MuU1RST0tFX0pPSU5UU19NQVAgPSBbXCJtaXRlclwiLCBcInJvdW5kXCIsIFwiYmV2ZWxcIl07XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfY3R4XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuXHQgKiovXG5cdHZhciBjYW52YXMgPSAoY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikpO1xuXHRpZiAoY2FudmFzLmdldENvbnRleHQpIHtcblx0XHRHcmFwaGljcy5fY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTtcblx0fVxuXG5cbi8vIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2luc3RydWN0aW9uczpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEluc3RydWN0aW9uc1xuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLmdldEluc3RydWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucygpO1xuXHRcdHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGdyYXBoaWNzIGluc3RydWN0aW9ucyBhcnJheS4gRWFjaCBlbnRyeSBpcyBhIGdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0IChleC4gR3JhcGhpY3MuRmlsbCwgR3JhcGhpY3MuUmVjdClcblx0ICogTW9kaWZ5aW5nIHRoZSByZXR1cm5lZCBhcnJheSBkaXJlY3RseSBpcyBub3QgcmVjb21tZW5kZWQsIGFuZCBpcyBsaWtlbHkgdG8gcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlxuXHQgKlxuXHQgKiBUaGlzIHByb3BlcnR5IGlzIG1haW5seSBpbnRlbmRlZCBmb3IgaW50cm9zcGVjdGlvbiBvZiB0aGUgaW5zdHJ1Y3Rpb25zIChleC4gZm9yIGdyYXBoaWNzIGV4cG9ydCkuXG5cdCAqIEBwcm9wZXJ0eSBpbnN0cnVjdGlvbnNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdGluc3RydWN0aW9uczogeyBnZXQ6IHAuZ2V0SW5zdHJ1Y3Rpb25zIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge31cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIEdyYXBoaWNzIGluc3RhbmNlIGhhcyBubyBkcmF3aW5nIGNvbW1hbmRzLlxuXHQgKiBAbWV0aG9kIGlzRW1wdHlcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoaXMgR3JhcGhpY3MgaW5zdGFuY2UgaGFzIG5vIGRyYXdpbmcgY29tbWFuZHMuXG5cdCAqKi9cblx0cC5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEodGhpcy5faW5zdHJ1Y3Rpb25zLmxlbmd0aCB8fCB0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMubGVuZ3RoKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgT3B0aW9uYWwgZGF0YSB0aGF0IGlzIHBhc3NlZCB0byBncmFwaGljcyBjb21tYW5kIGV4ZWMgbWV0aG9kcy4gV2hlbiBjYWxsZWQgZnJvbSBhIFNoYXBlIGluc3RhbmNlLCB0aGUgc2hhcGUgcGFzc2VzIGl0c2VsZiBhcyB0aGUgZGF0YSBwYXJhbWV0ZXIuIFRoaXMgY2FuIGJlIHVzZWQgYnkgY3VzdG9tIGdyYXBoaWMgY29tbWFuZHMgdG8gaW5zZXJ0IGNvbnRleHR1YWwgZGF0YS5cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGRhdGEpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnMoKTtcblx0XHR2YXIgaW5zdHIgPSB0aGlzLl9pbnN0cnVjdGlvbnM7XG5cdFx0Zm9yICh2YXIgaT10aGlzLl9zdG9yZUluZGV4LCBsPWluc3RyLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdGluc3RyW2ldLmV4ZWMoY3R4LCBkYXRhKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIG9ubHkgdGhlIHBhdGggZGVzY3JpYmVkIGZvciB0aGlzIEdyYXBoaWNzIGluc3RhbmNlLCBza2lwcGluZyBhbnkgbm9uLXBhdGggaW5zdHJ1Y3Rpb25zLCBpbmNsdWRpbmcgZmlsbCBhbmRcblx0ICogc3Ryb2tlIGRlc2NyaXB0aW9ucy4gVXNlZCBmb3IgPGNvZGU+RGlzcGxheU9iamVjdC5tYXNrPC9jb2RlPiB0byBkcmF3IHRoZSBjbGlwcGluZyBwYXRoLCBmb3IgZXhhbXBsZS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdBc1BhdGhcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICoqL1xuXHRwLmRyYXdBc1BhdGggPSBmdW5jdGlvbihjdHgpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnMoKTtcblx0XHR2YXIgaW5zdHIsIGluc3RycyA9IHRoaXMuX2luc3RydWN0aW9ucztcblx0XHRmb3IgKHZhciBpPXRoaXMuX3N0b3JlSW5kZXgsIGw9aW5zdHJzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdC8vIHRoZSBmaXJzdCBjb21tYW5kIGlzIGFsd2F5cyBhIGJlZ2luUGF0aCBjb21tYW5kLlxuXHRcdFx0aWYgKChpbnN0ciA9IGluc3Ryc1tpXSkucGF0aCAhPT0gZmFsc2UpIHsgaW5zdHIuZXhlYyhjdHgpOyB9XG5cdFx0fVxuXHR9O1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzIHRoYXQgbWFwIGRpcmVjdGx5IHRvIGNvbnRleHQgMkQgY2FsbHM6XG5cdC8qKlxuXHQgKiBNb3ZlcyB0aGUgZHJhd2luZyBwb2ludCB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLiBBIHRpbnkgQVBJIG1ldGhvZCBcIm10XCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgbW92ZVRvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIG1vdmUgdG8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIG1vdmUgdG8uXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5tb3ZlVG8gPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLk1vdmVUbyh4LHkpLCB0cnVlKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYSBsaW5lIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb2ludCB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLCB3aGljaCBiZWNvbWUgdGhlIG5ldyBjdXJyZW50IGRyYXdpbmdcblx0ICogcG9pbnQuIE5vdGUgdGhhdCB5b3UgKm11c3QqIGNhbGwge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvbW92ZVRvXCJ9fXt7L2Nyb3NzTGlua319IGJlZm9yZSB0aGUgZmlyc3QgYGxpbmVUbygpYC5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJsdFwiIGFsc28gZXhpc3RzLlxuXHQgKlxuXHQgKiBGb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24sIHJlYWQgdGhlXG5cdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNjb21wbGV4LXNoYXBlcy0ocGF0aHMpXCI+XG5cdCAqIHdoYXR3ZyBzcGVjPC9hPi5cblx0ICogQG1ldGhvZCBsaW5lVG9cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgZHJhdyB0by5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgZHJhdyB0by5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmxpbmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuTGluZVRvKHgseSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhbiBhcmMgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRyb2wgcG9pbnRzIGFuZCByYWRpdXMuICBGb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24sIHJlYWQgdGhlXG5cdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNkb20tY29udGV4dC0yZC1hcmN0b1wiPlxuXHQgKiB3aGF0d2cgc3BlYzwvYT4uIEEgdGlueSBBUEkgbWV0aG9kIFwiYXRcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBhcmNUb1xuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYXJjVG8gPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLkFyY1RvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYW4gYXJjIGRlZmluZWQgYnkgdGhlIHJhZGl1cywgc3RhcnRBbmdsZSBhbmQgZW5kQW5nbGUgYXJndW1lbnRzLCBjZW50ZXJlZCBhdCB0aGUgcG9zaXRpb24gKHgsIHkpLiBGb3Jcblx0ICogZXhhbXBsZSwgdG8gZHJhdyBhIGZ1bGwgY2lyY2xlIHdpdGggYSByYWRpdXMgb2YgMjAgY2VudGVyZWQgYXQgKDEwMCwgMTAwKTpcblx0ICpcblx0ICogICAgICBhcmMoMTAwLCAxMDAsIDIwLCAwLCBNYXRoLlBJKjIpO1xuXHQgKlxuXHQgKiBGb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24sIHJlYWQgdGhlXG5cdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNkb20tY29udGV4dC0yZC1hcmNcIj53aGF0d2cgc3BlYzwvYT4uXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwiYVwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGFyY1xuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEFuZ2xlIE1lYXN1cmVkIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlbmRBbmdsZSBNZWFzdXJlZCBpbiByYWRpYW5zLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFudGljbG9ja3dpc2Vcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFyYyA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuQXJjKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYSBxdWFkcmF0aWMgY3VydmUgZnJvbSB0aGUgY3VycmVudCBkcmF3aW5nIHBvaW50IHRvICh4LCB5KSB1c2luZyB0aGUgY29udHJvbCBwb2ludCAoY3B4LCBjcHkpLiBGb3IgZGV0YWlsZWRcblx0ICogaW5mb3JtYXRpb24sIHJlYWQgdGhlIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNkb20tY29udGV4dC0yZC1xdWFkcmF0aWNjdXJ2ZXRvXCI+XG5cdCAqIHdoYXR3ZyBzcGVjPC9hPi4gQSB0aW55IEFQSSBtZXRob2QgXCJxdFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIHF1YWRyYXRpY0N1cnZlVG9cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24oY3B4LCBjcHksIHgsIHkpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuUXVhZHJhdGljQ3VydmVUbyhjcHgsIGNweSwgeCwgeSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIGJlemllciBjdXJ2ZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9pbnQgdG8gKHgsIHkpIHVzaW5nIHRoZSBjb250cm9sIHBvaW50cyAoY3AxeCwgY3AxeSkgYW5kIChjcDJ4LFxuXHQgKiBjcDJ5KS4gRm9yIGRldGFpbGVkIGluZm9ybWF0aW9uLCByZWFkIHRoZVxuXHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtYmV6aWVyY3VydmV0b1wiPlxuXHQgKiB3aGF0d2cgc3BlYzwvYT4uIEEgdGlueSBBUEkgbWV0aG9kIFwiYnRcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZXppZXJDdXJ2ZVRvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDF4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDF5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5CZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYSByZWN0YW5nbGUgYXQgKHgsIHkpIHdpdGggdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0IHVzaW5nIHRoZSBjdXJyZW50IGZpbGwgYW5kL29yIHN0cm9rZS5cblx0ICogRm9yIGRldGFpbGVkIGluZm9ybWF0aW9uLCByZWFkIHRoZVxuXHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtcmVjdFwiPlxuXHQgKiB3aGF0d2cgc3BlYzwvYT4uIEEgdGlueSBBUEkgbWV0aG9kIFwiclwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIHJlY3Rcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAucmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuUmVjdCh4LCB5LCB3LCBoKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsb3NlcyB0aGUgY3VycmVudCBwYXRoLCBlZmZlY3RpdmVseSBkcmF3aW5nIGEgbGluZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9pbnQgdG8gdGhlIGZpcnN0IGRyYXdpbmcgcG9pbnQgc3BlY2lmaWVkXG5cdCAqIHNpbmNlIHRoZSBmaWxsIG9yIHN0cm9rZSB3YXMgbGFzdCBzZXQuIEEgdGlueSBBUEkgbWV0aG9kIFwiY3BcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBjbG9zZVBhdGhcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMubGVuZ3RoID8gdGhpcy5hcHBlbmQobmV3IEcuQ2xvc2VQYXRoKCkpIDogdGhpcztcblx0fTtcblxuXG4vLyBwdWJsaWMgbWV0aG9kcyB0aGF0IHJvdWdobHkgbWFwIHRvIEZsYXNoIGdyYXBoaWNzIEFQSXM6XG5cdC8qKlxuXHQgKiBDbGVhcnMgYWxsIGRyYXdpbmcgaW5zdHJ1Y3Rpb25zLCBlZmZlY3RpdmVseSByZXNldHRpbmcgdGhpcyBHcmFwaGljcyBpbnN0YW5jZS4gQW55IGxpbmUgYW5kIGZpbGwgc3R5bGVzIHdpbGwgbmVlZFxuXHQgKiB0byBiZSByZWRlZmluZWQgdG8gZHJhdyBzaGFwZXMgZm9sbG93aW5nIGEgY2xlYXIgY2FsbC4gQSB0aW55IEFQSSBtZXRob2QgXCJjXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgY2xlYXJcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5faW5zdHJ1Y3Rpb25zLmxlbmd0aCA9IHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucy5sZW5ndGggPSB0aGlzLl9jb21taXRJbmRleCA9IDA7XG5cdFx0dGhpcy5fc3Ryb2tlU3R5bGUgPSB0aGlzLl9vbGRTdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZSA9IHRoaXMuX2ZpbGwgPSB0aGlzLl9zdHJva2VEYXNoID0gdGhpcy5fb2xkU3Ryb2tlRGFzaCA9IG51bGw7XG5cdFx0dGhpcy5fZGlydHkgPSB0aGlzLl9zdHJva2VJZ25vcmVTY2FsZSA9IGZhbHNlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBmaWxsIHdpdGggdGhlIHNwZWNpZmllZCBjb2xvci4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBBIHRpbnkgQVBJIG1ldGhvZCBcImZcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpbkZpbGxcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIEEgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWUgKGV4LiBcInJlZFwiLCBcIiNGRjAwMDBcIiwgb3IgXCJyZ2JhKDI1NSwwLDAsMC41KVwiKS4gU2V0dGluZyB0b1xuXHQgKiBudWxsIHdpbGwgcmVzdWx0IGluIG5vIGZpbGwuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpbkZpbGwgPSBmdW5jdGlvbihjb2xvcikge1xuXHRcdHJldHVybiB0aGlzLl9zZXRGaWxsKGNvbG9yID8gbmV3IEcuRmlsbChjb2xvcikgOiBudWxsKTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgbGluZWFyIGdyYWRpZW50IGZpbGwgZGVmaW5lZCBieSB0aGUgbGluZSAoeDAsIHkwKSB0byAoeDEsIHkxKS4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBGb3Jcblx0ICogZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBjb2RlIGRlZmluZXMgYSBibGFjayB0byB3aGl0ZSB2ZXJ0aWNhbCBncmFkaWVudCByYW5naW5nIGZyb20gMjBweCB0byAxMjBweCwgYW5kIGRyYXdzIGFcblx0ICogc3F1YXJlIHRvIGRpc3BsYXkgaXQ6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5iZWdpbkxpbmVhckdyYWRpZW50RmlsbChbXCIjMDAwXCIsXCIjRkZGXCJdLCBbMCwgMV0sIDAsIDIwLCAwLCAxMjApLmRyYXdSZWN0KDIwLCAyMCwgMTIwLCAxMjApO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImxmXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5MaW5lYXJHcmFkaWVudEZpbGxcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lIGEgZ3JhZGllbnRcblx0ICogZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsIDAuOV0gd291bGQgZHJhd1xuXHQgKiB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luTGluZWFyR3JhZGllbnRGaWxsID0gZnVuY3Rpb24oY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgeDEsIHkxKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldEZpbGwobmV3IEcuRmlsbCgpLmxpbmVhckdyYWRpZW50KGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSByYWRpYWwgZ3JhZGllbnQgZmlsbC4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBjb2RlIGRlZmluZXMgYSByZWQgdG9cblx0ICogYmx1ZSByYWRpYWwgZ3JhZGllbnQgY2VudGVyZWQgYXQgKDEwMCwgMTAwKSwgd2l0aCBhIHJhZGl1cyBvZiA1MCwgYW5kIGRyYXdzIGEgY2lyY2xlIHRvIGRpc3BsYXkgaXQ6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5iZWdpblJhZGlhbEdyYWRpZW50RmlsbChbXCIjRjAwXCIsXCIjMDBGXCJdLCBbMCwgMV0sIDEwMCwgMTAwLCAwLCAxMDAsIDEwMCwgNTApLmRyYXdDaXJjbGUoMTAwLCAxMDAsIDUwKTtcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJyZlwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luUmFkaWFsR3JhZGllbnRGaWxsXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZVxuXHQgKiBhIGdyYWRpZW50IGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLFxuXHQgKiAwLjldIHdvdWxkIGRyYXcgdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIwIFJhZGl1cyBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIxIFJhZGl1cyBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpblJhZGlhbEdyYWRpZW50RmlsbCA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldEZpbGwobmV3IEcuRmlsbCgpLnJhZGlhbEdyYWRpZW50KGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIHBhdHRlcm4gZmlsbCB1c2luZyB0aGUgc3BlY2lmaWVkIGltYWdlLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEEgdGlueSBBUEkgbWV0aG9kIFwiYmZcIiBhbHNvXG5cdCAqIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpbkJpdG1hcEZpbGxcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50fSBpbWFnZSBUaGUgSW1hZ2UsIENhbnZhcywgb3IgVmlkZW8gb2JqZWN0IHRvIHVzZVxuXHQgKiBhcyB0aGUgcGF0dGVybi4gTXVzdCBiZSBsb2FkZWQgcHJpb3IgdG8gY3JlYXRpbmcgYSBiaXRtYXAgZmlsbCwgb3IgdGhlIGZpbGwgd2lsbCBiZSBlbXB0eS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHJlcGV0aXRpb24gT3B0aW9uYWwuIEluZGljYXRlcyB3aGV0aGVyIHRvIHJlcGVhdCB0aGUgaW1hZ2UgaW4gdGhlIGZpbGwgYXJlYS4gT25lIG9mIFwicmVwZWF0XCIsXG5cdCAqIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiBEZWZhdWx0cyB0byBcInJlcGVhdFwiLiBOb3RlIHRoYXQgRmlyZWZveCBkb2VzIG5vdCBzdXBwb3J0IFwicmVwZWF0LXhcIiBvclxuXHQgKiBcInJlcGVhdC15XCIgKGxhdGVzdCB0ZXN0cyB3ZXJlIGluIEZGIDIwLjApLCBhbmQgd2lsbCBkZWZhdWx0IHRvIFwicmVwZWF0XCIuXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeCBPcHRpb25hbC4gU3BlY2lmaWVzIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZvciB0aGUgYml0bWFwIGZpbGwuIFRoaXMgdHJhbnNmb3JtYXRpb25cblx0ICogd2lsbCBiZSBhcHBsaWVkIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQgdHJhbnNmb3JtLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5CaXRtYXBGaWxsID0gZnVuY3Rpb24oaW1hZ2UsIHJlcGV0aXRpb24sIG1hdHJpeCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRGaWxsKG5ldyBHLkZpbGwobnVsbCxtYXRyaXgpLmJpdG1hcChpbWFnZSwgcmVwZXRpdGlvbikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLCBhbmQgYmVnaW5zIGEgbmV3IG9uZSB3aXRoIG5vIGZpbGwuIEZ1bmN0aW9uYWxseSBpZGVudGljYWwgdG8gPGNvZGU+YmVnaW5GaWxsKG51bGwpPC9jb2RlPi5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJlZlwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGVuZEZpbGxcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmVuZEZpbGwgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5iZWdpbkZpbGwoKTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgc3Ryb2tlIHN0eWxlLiBMaWtlIGFsbCBkcmF3aW5nIG1ldGhvZHMsIHRoaXMgY2FuIGJlIGNoYWluZWQsIHNvIHlvdSBjYW4gZGVmaW5lXG5cdCAqIHRoZSBzdHJva2Ugc3R5bGUgYW5kIGNvbG9yIGluIGEgc2luZ2xlIGxpbmUgb2YgY29kZSBsaWtlIHNvOlxuXHQgKlxuXHQgKiBcdG15R3JhcGhpY3Muc2V0U3Ryb2tlU3R5bGUoOCxcInJvdW5kXCIpLmJlZ2luU3Ryb2tlKFwiI0YwMFwiKTtcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJzc1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIHNldFN0cm9rZVN0eWxlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0aGlja25lc3MgVGhlIHdpZHRoIG9mIHRoZSBzdHJva2UuXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBbY2Fwcz0wXSBJbmRpY2F0ZXMgdGhlIHR5cGUgb2YgY2FwcyB0byB1c2UgYXQgdGhlIGVuZCBvZiBsaW5lcy4gT25lIG9mIGJ1dHQsXG5cdCAqIHJvdW5kLCBvciBzcXVhcmUuIERlZmF1bHRzIHRvIFwiYnV0dFwiLiBBbHNvIGFjY2VwdHMgdGhlIHZhbHVlcyAwIChidXR0KSwgMSAocm91bmQpLCBhbmQgMiAoc3F1YXJlKSBmb3IgdXNlIHdpdGhcblx0ICogdGhlIHRpbnkgQVBJLlxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gW2pvaW50cz0wXSBTcGVjaWZpZXMgdGhlIHR5cGUgb2Ygam9pbnRzIHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlcmUgdHdvIGxpbmVzIG1lZXQuXG5cdCAqIE9uZSBvZiBiZXZlbCwgcm91bmQsIG9yIG1pdGVyLiBEZWZhdWx0cyB0byBcIm1pdGVyXCIuIEFsc28gYWNjZXB0cyB0aGUgdmFsdWVzIDAgKG1pdGVyKSwgMSAocm91bmQpLCBhbmQgMiAoYmV2ZWwpXG5cdCAqIGZvciB1c2Ugd2l0aCB0aGUgdGlueSBBUEkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbWl0ZXJMaW1pdD0xMF0gSWYgam9pbnRzIGlzIHNldCB0byBcIm1pdGVyXCIsIHRoZW4geW91IGNhbiBzcGVjaWZ5IGEgbWl0ZXIgbGltaXQgcmF0aW8gd2hpY2hcblx0ICogY29udHJvbHMgYXQgd2hhdCBwb2ludCBhIG1pdGVyZWQgam9pbnQgd2lsbCBiZSBjbGlwcGVkLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVTY2FsZT1mYWxzZV0gSWYgdHJ1ZSwgdGhlIHN0cm9rZSB3aWxsIGJlIGRyYXduIGF0IHRoZSBzcGVjaWZpZWQgdGhpY2tuZXNzIHJlZ2FyZGxlc3Ncblx0ICogb2YgYWN0aXZlIHRyYW5zZm9ybWF0aW9ucy5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLnNldFN0cm9rZVN0eWxlID0gZnVuY3Rpb24odGhpY2tuZXNzLCBjYXBzLCBqb2ludHMsIG1pdGVyTGltaXQsIGlnbm9yZVNjYWxlKSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKHRydWUpO1xuXHRcdHRoaXMuX3N0cm9rZVN0eWxlID0gdGhpcy5jb21tYW5kID0gbmV3IEcuU3Ryb2tlU3R5bGUodGhpY2tuZXNzLCBjYXBzLCBqb2ludHMsIG1pdGVyTGltaXQsIGlnbm9yZVNjYWxlKTtcblxuXHRcdC8vIGlnbm9yZVNjYWxlIGxpdmVzIG9uIFN0cm9rZSwgbm90IFN0cm9rZVN0eWxlLCBzbyB3ZSBkbyBhIGxpdHRsZSB0cmlja2VyeTpcblx0XHRpZiAodGhpcy5fc3Ryb2tlKSB7IHRoaXMuX3N0cm9rZS5pZ25vcmVTY2FsZSA9IGlnbm9yZVNjYWxlOyB9XG5cdFx0dGhpcy5fc3Ryb2tlSWdub3JlU2NhbGUgPSBpZ25vcmVTY2FsZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTZXRzIG9yIGNsZWFycyB0aGUgc3Ryb2tlIGRhc2ggcGF0dGVybi5cblx0ICpcblx0ICogXHRteUdyYXBoaWNzLnNldFN0cm9rZURhc2goWzIwLCAxMF0sIDApO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBgc2RgIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIHNldFN0cm9rZURhc2hcblx0ICogQHBhcmFtIHtBcnJheX0gW3NlZ21lbnRzXSBBbiBhcnJheSBzcGVjaWZ5aW5nIHRoZSBkYXNoIHBhdHRlcm4sIGFsdGVybmF0aW5nIGJldHdlZW4gbGluZSBhbmQgZ2FwLlxuXHQgKiBGb3IgZXhhbXBsZSwgYFsyMCwxMF1gIHdvdWxkIGNyZWF0ZSBhIHBhdHRlcm4gb2YgMjAgcGl4ZWwgbGluZXMgd2l0aCAxMCBwaXhlbCBnYXBzIGJldHdlZW4gdGhlbS5cblx0ICogUGFzc2luZyBudWxsIG9yIGFuIGVtcHR5IGFycmF5IHdpbGwgY2xlYXIgdGhlIGV4aXN0aW5nIHN0cm9rZSBkYXNoLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29mZnNldD0wXSBUaGUgb2Zmc2V0IG9mIHRoZSBkYXNoIHBhdHRlcm4uIEZvciBleGFtcGxlLCB5b3UgY291bGQgaW5jcmVtZW50IHRoaXMgdmFsdWUgdG8gY3JlYXRlIGEgXCJtYXJjaGluZyBhbnRzXCIgZWZmZWN0LlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuc2V0U3Ryb2tlRGFzaCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBvZmZzZXQpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnModHJ1ZSk7XG5cdFx0dGhpcy5fc3Ryb2tlRGFzaCA9IHRoaXMuY29tbWFuZCA9IG5ldyBHLlN0cm9rZURhc2goc2VnbWVudHMsIG9mZnNldCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIHN0cm9rZSB3aXRoIHRoZSBzcGVjaWZpZWQgY29sb3IuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gQSB0aW55IEFQSSBtZXRob2QgXCJzXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5TdHJva2Vcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIEEgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWUgKGV4LiBcIiNGRjAwMDBcIiwgXCJyZWRcIiwgb3IgXCJyZ2JhKDI1NSwwLDAsMC41KVwiKS4gU2V0dGluZyB0b1xuXHQgKiBudWxsIHdpbGwgcmVzdWx0IGluIG5vIHN0cm9rZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luU3Ryb2tlID0gZnVuY3Rpb24oY29sb3IpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0U3Ryb2tlKGNvbG9yID8gbmV3IEcuU3Ryb2tlKGNvbG9yKSA6IG51bGwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBsaW5lYXIgZ3JhZGllbnQgc3Ryb2tlIGRlZmluZWQgYnkgdGhlIGxpbmUgKHgwLCB5MCkgdG8gKHgxLCB5MSkuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gRm9yXG5cdCAqIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgY29kZSBkZWZpbmVzIGEgYmxhY2sgdG8gd2hpdGUgdmVydGljYWwgZ3JhZGllbnQgcmFuZ2luZyBmcm9tIDIwcHggdG8gMTIwcHgsIGFuZCBkcmF3cyBhXG5cdCAqIHNxdWFyZSB0byBkaXNwbGF5IGl0OlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3Muc2V0U3Ryb2tlU3R5bGUoMTApLlxuXHQgKiAgICAgICAgICBiZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlKFtcIiMwMDBcIixcIiNGRkZcIl0sIFswLCAxXSwgMCwgMjAsIDAsIDEyMCkuZHJhd1JlY3QoMjAsIDIwLCAxMjAsIDEyMCk7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwibHNcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZVxuXHQgKiBhIGdyYWRpZW50IGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLFxuXHQgKiAwLjldIHdvdWxkIGRyYXcgdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlID0gZnVuY3Rpb24oY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgeDEsIHkxKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldFN0cm9rZShuZXcgRy5TdHJva2UoKS5saW5lYXJHcmFkaWVudChjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCB4MSwgeTEpKTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgcmFkaWFsIGdyYWRpZW50IHN0cm9rZS4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBjb2RlIGRlZmluZXMgYSByZWQgdG9cblx0ICogYmx1ZSByYWRpYWwgZ3JhZGllbnQgY2VudGVyZWQgYXQgKDEwMCwgMTAwKSwgd2l0aCBhIHJhZGl1cyBvZiA1MCwgYW5kIGRyYXdzIGEgcmVjdGFuZ2xlIHRvIGRpc3BsYXkgaXQ6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5zZXRTdHJva2VTdHlsZSgxMClcblx0ICogICAgICAgICAgLmJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2UoW1wiI0YwMFwiLFwiIzAwRlwiXSwgWzAsIDFdLCAxMDAsIDEwMCwgMCwgMTAwLCAxMDAsIDUwKVxuXHQgKiAgICAgICAgICAuZHJhd1JlY3QoNTAsIDkwLCAxNTAsIDExMCk7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwicnNcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZVxuXHQgKiBhIGdyYWRpZW50IGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLFxuXHQgKiAwLjldIHdvdWxkIGRyYXcgdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUsIHRoZW4gZHJhdyB0aGUgc2Vjb25kIGNvbG9yXG5cdCAqIHRvIDEwMCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIwIFJhZGl1cyBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIxIFJhZGl1cyBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlID0gZnVuY3Rpb24oY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0U3Ryb2tlKG5ldyBHLlN0cm9rZSgpLnJhZGlhbEdyYWRpZW50KGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIHBhdHRlcm4gZmlsbCB1c2luZyB0aGUgc3BlY2lmaWVkIGltYWdlLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIE5vdGUgdGhhdCB1bmxpa2UgYml0bWFwIGZpbGxzLFxuXHQgKiBzdHJva2VzIGRvIG5vdCBjdXJyZW50bHkgc3VwcG9ydCBhIG1hdHJpeCBwYXJhbWV0ZXIgZHVlIHRvIGxpbWl0YXRpb25zIGluIHRoZSBjYW52YXMgQVBJLiBBIHRpbnkgQVBJIG1ldGhvZCBcImJzXCJcblx0ICogYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5CaXRtYXBTdHJva2Vcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50fSBpbWFnZSBUaGUgSW1hZ2UsIENhbnZhcywgb3IgVmlkZW8gb2JqZWN0IHRvIHVzZVxuXHQgKiBhcyB0aGUgcGF0dGVybi4gTXVzdCBiZSBsb2FkZWQgcHJpb3IgdG8gY3JlYXRpbmcgYSBiaXRtYXAgZmlsbCwgb3IgdGhlIGZpbGwgd2lsbCBiZSBlbXB0eS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtyZXBldGl0aW9uPXJlcGVhdF0gT3B0aW9uYWwuIEluZGljYXRlcyB3aGV0aGVyIHRvIHJlcGVhdCB0aGUgaW1hZ2UgaW4gdGhlIGZpbGwgYXJlYS4gT25lIG9mXG5cdCAqIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiBEZWZhdWx0cyB0byBcInJlcGVhdFwiLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5CaXRtYXBTdHJva2UgPSBmdW5jdGlvbihpbWFnZSwgcmVwZXRpdGlvbikge1xuXHRcdC8vIE5PVEU6IG1hdHJpeCBpcyBub3Qgc3VwcG9ydGVkIGZvciBzdHJva2UgYmVjYXVzZSB0cmFuc2Zvcm1zIG9uIHN0cm9rZXMgYWxzbyBhZmZlY3QgdGhlIGRyYXduIHN0cm9rZSB3aWR0aC5cblx0XHRyZXR1cm4gdGhpcy5fc2V0U3Ryb2tlKG5ldyBHLlN0cm9rZSgpLmJpdG1hcChpbWFnZSwgcmVwZXRpdGlvbikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLCBhbmQgYmVnaW5zIGEgbmV3IG9uZSB3aXRoIG5vIHN0cm9rZS4gRnVuY3Rpb25hbGx5IGlkZW50aWNhbCB0byA8Y29kZT5iZWdpblN0cm9rZShudWxsKTwvY29kZT4uXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwiZXNcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBlbmRTdHJva2Vcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmVuZFN0cm9rZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmJlZ2luU3Ryb2tlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1hcHMgdGhlIGZhbWlsaWFyIEFjdGlvblNjcmlwdCA8Y29kZT5jdXJ2ZVRvKCk8L2NvZGU+IG1ldGhvZCB0byB0aGUgZnVuY3Rpb25hbGx5IHNpbWlsYXIge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvcXVhZHJhdGljQ3VydmVUb1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBtZXRob2QgcXVhZHJhdGljQ3VydmVUb1xuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmN1cnZlVG8gPSBwLnF1YWRyYXRpY0N1cnZlVG87XG5cblx0LyoqXG5cdCAqXG5cdCAqIE1hcHMgdGhlIGZhbWlsaWFyIEFjdGlvblNjcmlwdCA8Y29kZT5kcmF3UmVjdCgpPC9jb2RlPiBtZXRob2QgdG8gdGhlIGZ1bmN0aW9uYWxseSBzaW1pbGFyIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3JlY3RcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAbWV0aG9kIGRyYXdSZWN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRyYXdSZWN0ID0gcC5yZWN0O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIHJvdW5kZWQgcmVjdGFuZ2xlIHdpdGggYWxsIGNvcm5lcnMgd2l0aCB0aGUgc3BlY2lmaWVkIHJhZGl1cy5cblx0ICogQG1ldGhvZCBkcmF3Um91bmRSZWN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgQ29ybmVyIHJhZGl1cy5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRyYXdSb3VuZFJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoLCByYWRpdXMpIHtcblx0XHRyZXR1cm4gdGhpcy5kcmF3Um91bmRSZWN0Q29tcGxleCh4LCB5LCB3LCBoLCByYWRpdXMsIHJhZGl1cywgcmFkaXVzLCByYWRpdXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIHJvdW5kZWQgcmVjdGFuZ2xlIHdpdGggZGlmZmVyZW50IGNvcm5lciByYWRpaS4gU3VwcG9ydHMgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGNvcm5lciByYWRpaS4gQSB0aW55IEFQSVxuXHQgKiBtZXRob2QgXCJyY1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGRyYXdSb3VuZFJlY3RDb21wbGV4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUgdG8gZHJhdyB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUgdG8gZHJhdyB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgVGhlIHdpZHRoIG9mIHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBUaGUgaGVpZ2h0IG9mIHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVEwgVG9wIGxlZnQgY29ybmVyIHJhZGl1cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1RSIFRvcCByaWdodCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQlIgQm90dG9tIHJpZ2h0IGNvcm5lciByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCTCBCb3R0b20gbGVmdCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZHJhd1JvdW5kUmVjdENvbXBsZXggPSBmdW5jdGlvbih4LCB5LCB3LCBoLCByYWRpdXNUTCwgcmFkaXVzVFIsIHJhZGl1c0JSLCByYWRpdXNCTCkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5Sb3VuZFJlY3QoeCwgeSwgdywgaCwgcmFkaXVzVEwsIHJhZGl1c1RSLCByYWRpdXNCUiwgcmFkaXVzQkwpKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYSBjaXJjbGUgd2l0aCB0aGUgc3BlY2lmaWVkIHJhZGl1cyBhdCAoeCwgeSkuXG5cdCAqXG5cdCAqICAgICAgdmFyIGcgPSBuZXcgY3JlYXRlanMuR3JhcGhpY3MoKTtcblx0ICpcdCAgICBnLnNldFN0cm9rZVN0eWxlKDEpO1xuXHQgKlx0ICAgIGcuYmVnaW5TdHJva2UoY3JlYXRlanMuR3JhcGhpY3MuZ2V0UkdCKDAsMCwwKSk7XG5cdCAqXHQgICAgZy5iZWdpbkZpbGwoY3JlYXRlanMuR3JhcGhpY3MuZ2V0UkdCKDI1NSwwLDApKTtcblx0ICpcdCAgICBnLmRyYXdDaXJjbGUoMCwwLDMpO1xuXHQgKlxuXHQgKlx0ICAgIHZhciBzID0gbmV3IGNyZWF0ZWpzLlNoYXBlKGcpO1xuXHQgKlx0XHRzLnggPSAxMDA7XG5cdCAqXHRcdHMueSA9IDEwMDtcblx0ICpcblx0ICpcdCAgICBzdGFnZS5hZGRDaGlsZChzKTtcblx0ICpcdCAgICBzdGFnZS51cGRhdGUoKTtcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJkY1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGRyYXdDaXJjbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggeCBjb29yZGluYXRlIGNlbnRlciBwb2ludCBvZiBjaXJjbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgY29vcmRpbmF0ZSBjZW50ZXIgcG9pbnQgb2YgY2lyY2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBjaXJjbGUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3Q2lyY2xlID0gZnVuY3Rpb24oeCwgeSwgcmFkaXVzKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLkNpcmNsZSh4LCB5LCByYWRpdXMpKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYW4gZWxsaXBzZSAob3ZhbCkgd2l0aCBhIHNwZWNpZmllZCB3aWR0aCAodykgYW5kIGhlaWdodCAoaCkuIFNpbWlsYXIgdG8ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogZXhjZXB0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGNhbiBiZSBkaWZmZXJlbnQuIEEgdGlueSBBUEkgbWV0aG9kIFwiZGVcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBkcmF3RWxsaXBzZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgbGVmdCBjb29yZGluYXRlIHBvaW50IG9mIHRoZSBlbGxpcHNlLiBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Q2lyY2xlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdoaWNoIGRyYXdzIGZyb20gY2VudGVyLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgdG9wIGNvb3JkaW5hdGUgcG9pbnQgb2YgdGhlIGVsbGlwc2UuIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2hpY2ggZHJhd3MgZnJvbSB0aGUgY2VudGVyLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgaGVpZ2h0IChob3Jpem9udGFsIGRpYW1ldGVyKSBvZiB0aGUgZWxsaXBzZS4gVGhlIGhvcml6b250YWwgcmFkaXVzIHdpbGwgYmUgaGFsZiBvZiB0aGlzXG5cdCAqIG51bWJlci5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggVGhlIHdpZHRoICh2ZXJ0aWNhbCBkaWFtZXRlcikgb2YgdGhlIGVsbGlwc2UuIFRoZSB2ZXJ0aWNhbCByYWRpdXMgd2lsbCBiZSBoYWxmIG9mIHRoaXMgbnVtYmVyLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZHJhd0VsbGlwc2UgPSBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLkVsbGlwc2UoeCwgeSwgdywgaCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIHN0YXIgaWYgcG9pbnRTaXplIGlzIGdyZWF0ZXIgdGhhbiAwLCBvciBhIHJlZ3VsYXIgcG9seWdvbiBpZiBwb2ludFNpemUgaXMgMCB3aXRoIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mXG5cdCAqIHBvaW50cy4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgY29kZSB3aWxsIGRyYXcgYSBmYW1pbGlhciA1IHBvaW50ZWQgc3RhciBzaGFwZSBjZW50ZXJlZCBhdCAxMDAsIDEwMCBhbmQgd2l0aCBhXG5cdCAqIHJhZGl1cyBvZiA1MDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLmJlZ2luRmlsbChcIiNGRjBcIikuZHJhd1BvbHlTdGFyKDEwMCwgMTAwLCA1MCwgNSwgMC42LCAtOTApO1xuXHQgKiAgICAgIC8vIE5vdGU6IC05MCBtYWtlcyB0aGUgZmlyc3QgcG9pbnQgdmVydGljYWxcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJkcFwiIGFsc28gZXhpc3RzLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGRyYXdQb2x5U3RhclxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBQb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgUG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGUgc2hhcGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgc2hhcGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzaWRlcyBUaGUgbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgc3RhciBvciBzaWRlcyBvbiB0aGUgcG9seWdvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50U2l6ZSBUaGUgZGVwdGggb3IgXCJwb2ludHktbmVzc1wiIG9mIHRoZSBzdGFyIHBvaW50cy4gQSBwb2ludFNpemUgb2YgMCB3aWxsIGRyYXcgYSByZWd1bGFyXG5cdCAqIHBvbHlnb24gKG5vIHBvaW50cyksIGEgcG9pbnRTaXplIG9mIDEgd2lsbCBkcmF3IG5vdGhpbmcgYmVjYXVzZSB0aGUgcG9pbnRzIGFyZSBpbmZpbml0ZWx5IHBvaW50eS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIFRoZSBhbmdsZSBvZiB0aGUgZmlyc3QgcG9pbnQgLyBjb3JuZXIuIEZvciBleGFtcGxlIGEgdmFsdWUgb2YgMCB3aWxsIGRyYXcgdGhlIGZpcnN0IHBvaW50XG5cdCAqIGRpcmVjdGx5IHRvIHRoZSByaWdodCBvZiB0aGUgY2VudGVyLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZHJhd1BvbHlTdGFyID0gZnVuY3Rpb24oeCwgeSwgcmFkaXVzLCBzaWRlcywgcG9pbnRTaXplLCBhbmdsZSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5Qb2x5U3Rhcih4LCB5LCByYWRpdXMsIHNpZGVzLCBwb2ludFNpemUsIGFuZ2xlKSk7XG5cdH07XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZC5cblx0LyoqXG5cdCAqIFJlbW92ZWQgaW4gZmF2b3VyIG9mIHVzaW5nIGN1c3RvbSBjb21tYW5kIG9iamVjdHMgd2l0aCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgaW5qZWN0XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblxuXHQvKipcblx0ICogQXBwZW5kcyBhIGdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0IHRvIHRoZSBncmFwaGljcyBxdWV1ZS4gQ29tbWFuZCBvYmplY3RzIGV4cG9zZSBhbiBcImV4ZWNcIiBtZXRob2Rcblx0ICogdGhhdCBhY2NlcHRzIHR3byBwYXJhbWV0ZXJzOiB0aGUgQ29udGV4dDJEIHRvIG9wZXJhdGUgb24sIGFuZCBhbiBhcmJpdHJhcnkgZGF0YSBvYmplY3QgcGFzc2VkIGludG9cblx0ICoge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd1wifX17ey9jcm9zc0xpbmt9fS4gVGhlIGxhdHRlciB3aWxsIHVzdWFsbHkgYmUgdGhlIFNoYXBlIGluc3RhbmNlIHRoYXQgY2FsbGVkIGRyYXcuXG5cdCAqXG5cdCAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgaW50ZXJuYWxseSBieSBHcmFwaGljcyBtZXRob2RzLCBzdWNoIGFzIGRyYXdDaXJjbGUsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkIGRpcmVjdGx5IHRvIGluc2VydFxuXHQgKiBidWlsdC1pbiBvciBjdXN0b20gZ3JhcGhpY3MgY29tbWFuZHMuIEZvciBleGFtcGxlOlxuXHQgKlxuXHQgKiBcdFx0Ly8gYXR0YWNoIGRhdGEgdG8gb3VyIHNoYXBlLCBzbyB3ZSBjYW4gYWNjZXNzIGl0IGR1cmluZyB0aGUgZHJhdzpcblx0ICogXHRcdG15U2hhcGUuY29sb3IgPSBcInJlZFwiO1xuXHQgKlxuXHQgKiBcdFx0Ly8gYXBwZW5kIGEgQ2lyY2xlIGNvbW1hbmQgb2JqZWN0OlxuXHQgKiBcdFx0bXlTaGFwZS5ncmFwaGljcy5hcHBlbmQobmV3IGNyZWF0ZWpzLkdyYXBoaWNzLkNpcmNsZSg1MCwgNTAsIDMwKSk7XG5cdCAqXG5cdCAqIFx0XHQvLyBhcHBlbmQgYSBjdXN0b20gY29tbWFuZCBvYmplY3Qgd2l0aCBhbiBleGVjIG1ldGhvZCB0aGF0IHNldHMgdGhlIGZpbGwgc3R5bGVcblx0ICogXHRcdC8vIGJhc2VkIG9uIHRoZSBzaGFwZSdzIGRhdGEsIGFuZCB0aGVuIGZpbGxzIHRoZSBjaXJjbGUuXG5cdCAqIFx0XHRteVNoYXBlLmdyYXBoaWNzLmFwcGVuZCh7ZXhlYzpmdW5jdGlvbihjdHgsIHNoYXBlKSB7XG5cdCAqIFx0XHRcdGN0eC5maWxsU3R5bGUgPSBzaGFwZS5jb2xvcjtcblx0ICogXHRcdFx0Y3R4LmZpbGwoKTtcblx0ICogXHRcdH19KTtcblx0ICpcblx0ICogQG1ldGhvZCBhcHBlbmRcblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbW1hbmQgQSBncmFwaGljcyBjb21tYW5kIG9iamVjdCBleHBvc2luZyBhbiBcImV4ZWNcIiBtZXRob2QuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYW4gVGhlIGNsZWFuIHBhcmFtIGlzIHByaW1hcmlseSBmb3IgaW50ZXJuYWwgdXNlLiBBIHZhbHVlIG9mIHRydWUgaW5kaWNhdGVzIHRoYXQgYSBjb21tYW5kIGRvZXMgbm90IGdlbmVyYXRlIGEgcGF0aCB0aGF0IHNob3VsZCBiZSBzdHJva2VkIG9yIGZpbGxlZC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFwcGVuZCA9IGZ1bmN0aW9uKGNvbW1hbmQsIGNsZWFuKSB7XG5cdFx0dGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLnB1c2goY29tbWFuZCk7XG5cdFx0dGhpcy5jb21tYW5kID0gY29tbWFuZDtcblx0XHRpZiAoIWNsZWFuKSB7IHRoaXMuX2RpcnR5ID0gdHJ1ZTsgfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZWNvZGVzIGEgY29tcGFjdCBlbmNvZGVkIHBhdGggc3RyaW5nIGludG8gYSBzZXJpZXMgb2YgZHJhdyBpbnN0cnVjdGlvbnMuXG5cdCAqIFRoaXMgZm9ybWF0IGlzIG5vdCBpbnRlbmRlZCB0byBiZSBodW1hbiByZWFkYWJsZSwgYW5kIGlzIG1lYW50IGZvciB1c2UgYnkgYXV0aG9yaW5nIHRvb2xzLlxuXHQgKiBUaGUgZm9ybWF0IHVzZXMgYSBiYXNlNjQgY2hhcmFjdGVyIHNldCwgd2l0aCBlYWNoIGNoYXJhY3RlciByZXByZXNlbnRpbmcgNiBiaXRzLCB0byBkZWZpbmUgYSBzZXJpZXMgb2YgZHJhd1xuXHQgKiBjb21tYW5kcy5cblx0ICpcblx0ICogRWFjaCBjb21tYW5kIGlzIGNvbXByaXNlZCBvZiBhIHNpbmdsZSBcImhlYWRlclwiIGNoYXJhY3RlciBmb2xsb3dlZCBieSBhIHZhcmlhYmxlIG51bWJlciBvZiBhbHRlcm5hdGluZyB4IGFuZCB5XG5cdCAqIHBvc2l0aW9uIHZhbHVlcy4gUmVhZGluZyB0aGUgaGVhZGVyIGJpdHMgZnJvbSBsZWZ0IHRvIHJpZ2h0IChtb3N0IHRvIGxlYXN0IHNpZ25pZmljYW50KTogYml0cyAxIHRvIDMgc3BlY2lmeSB0aGVcblx0ICogdHlwZSBvZiBvcGVyYXRpb24gKDAtbW92ZVRvLCAxLWxpbmVUbywgMi1xdWFkcmF0aWNDdXJ2ZVRvLCAzLWJlemllckN1cnZlVG8sIDQtY2xvc2VQYXRoLCA1LTcgdW51c2VkKS4gQml0IDRcblx0ICogaW5kaWNhdGVzIHdoZXRoZXIgcG9zaXRpb24gdmFsdWVzIHVzZSAxMiBiaXRzICgyIGNoYXJhY3RlcnMpIG9yIDE4IGJpdHMgKDMgY2hhcmFjdGVycyksIHdpdGggYSBvbmUgaW5kaWNhdGluZyB0aGVcblx0ICogbGF0dGVyLiBCaXRzIDUgYW5kIDYgYXJlIGN1cnJlbnRseSB1bnVzZWQuXG5cdCAqXG5cdCAqIEZvbGxvd2luZyB0aGUgaGVhZGVyIGlzIGEgc2VyaWVzIG9mIDAgKGNsb3NlUGF0aCksIDIgKG1vdmVUbywgbGluZVRvKSwgNCAocXVhZHJhdGljQ3VydmVUbyksIG9yIDYgKGJlemllckN1cnZlVG8pXG5cdCAqIHBhcmFtZXRlcnMuIFRoZXNlIHBhcmFtZXRlcnMgYXJlIGFsdGVybmF0aW5nIHgveSBwb3NpdGlvbnMgcmVwcmVzZW50ZWQgYnkgMiBvciAzIGNoYXJhY3RlcnMgKGFzIGluZGljYXRlZCBieSB0aGVcblx0ICogNHRoIGJpdCBpbiB0aGUgY29tbWFuZCBjaGFyKS4gVGhlc2UgY2hhcmFjdGVycyBjb25zaXN0IG9mIGEgMSBiaXQgc2lnbiAoMSBpcyBuZWdhdGl2ZSwgMCBpcyBwb3NpdGl2ZSksIGZvbGxvd2VkXG5cdCAqIGJ5IGFuIDExICgyIGNoYXIpIG9yIDE3ICgzIGNoYXIpIGJpdCBpbnRlZ2VyIHZhbHVlLiBBbGwgcG9zaXRpb24gdmFsdWVzIGFyZSBpbiB0ZW50aHMgb2YgYSBwaXhlbC4gRXhjZXB0IGluIHRoZVxuXHQgKiBjYXNlIG9mIG1vdmUgb3BlcmF0aW9ucyB3aGljaCBhcmUgYWJzb2x1dGUsIHRoaXMgdmFsdWUgaXMgYSBkZWx0YSBmcm9tIHRoZSBwcmV2aW91cyB4IG9yIHkgcG9zaXRpb24gKGFzXG5cdCAqIGFwcHJvcHJpYXRlKS5cblx0ICpcblx0ICogRm9yIGV4YW1wbGUsIHRoZSBzdHJpbmcgXCJBM2NBQU1BdTRBQUFcIiByZXByZXNlbnRzIGEgbGluZSBzdGFydGluZyBhdCAtMTUwLDAgYW5kIGVuZGluZyBhdCAxNTAsMC5cblx0ICogPGJyIC8+QSAtIGJpdHMgMDAwMDAwLiBGaXJzdCAzIGJpdHMgKDAwMCkgaW5kaWNhdGUgYSBtb3ZlVG8gb3BlcmF0aW9uLiA0dGggYml0ICgwKSBpbmRpY2F0ZXMgMiBjaGFycyBwZXJcblx0ICogcGFyYW1ldGVyLlxuXHQgKiA8YnIgLz5uMCAtIDExMDExMTAxMTEwMC4gQWJzb2x1dGUgeCBwb3NpdGlvbiBvZiAtMTUwLjBweC4gRmlyc3QgYml0IGluZGljYXRlcyBhIG5lZ2F0aXZlIHZhbHVlLCByZW1haW5pbmcgYml0c1xuXHQgKiBpbmRpY2F0ZSAxNTAwIHRlbnRocyBvZiBhIHBpeGVsLlxuXHQgKiA8YnIgLz5BQSAtIDAwMDAwMDAwMDAwMC4gQWJzb2x1dGUgeSBwb3NpdGlvbiBvZiAwLlxuXHQgKiA8YnIgLz5JIC0gMDAxMTAwLiBGaXJzdCAzIGJpdHMgKDAwMSkgaW5kaWNhdGUgYSBsaW5lVG8gb3BlcmF0aW9uLiA0dGggYml0ICgxKSBpbmRpY2F0ZXMgMyBjaGFycyBwZXIgcGFyYW1ldGVyLlxuXHQgKiA8YnIgLz5BdTQgLSAwMDAwMDAxMDExMTAxMTEwMDAuIEFuIHggZGVsdGEgb2YgMzAwLjBweCwgd2hpY2ggaXMgYWRkZWQgdG8gdGhlIHByZXZpb3VzIHggdmFsdWUgb2YgLTE1MC4wcHggdG9cblx0ICogcHJvdmlkZSBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvZiArMTUwLjBweC5cblx0ICogPGJyIC8+QUFBIC0gMDAwMDAwMDAwMDAwMDAwMDAwLiBBIHkgZGVsdGEgdmFsdWUgb2YgMC5cblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJwXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZGVjb2RlUGF0aFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBwYXRoIHN0cmluZyB0byBkZWNvZGUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kZWNvZGVQYXRoID0gZnVuY3Rpb24oc3RyKSB7XG5cdFx0dmFyIGluc3RydWN0aW9ucyA9IFt0aGlzLm1vdmVUbywgdGhpcy5saW5lVG8sIHRoaXMucXVhZHJhdGljQ3VydmVUbywgdGhpcy5iZXppZXJDdXJ2ZVRvLCB0aGlzLmNsb3NlUGF0aF07XG5cdFx0dmFyIHBhcmFtQ291bnQgPSBbMiwgMiwgNCwgNiwgMF07XG5cdFx0dmFyIGk9MCwgbD1zdHIubGVuZ3RoO1xuXHRcdHZhciBwYXJhbXMgPSBbXTtcblx0XHR2YXIgeD0wLCB5PTA7XG5cdFx0dmFyIGJhc2U2NCA9IEdyYXBoaWNzLkJBU0VfNjQ7XG5cblx0XHR3aGlsZSAoaTxsKSB7XG5cdFx0XHR2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG5cdFx0XHR2YXIgbiA9IGJhc2U2NFtjXTtcblx0XHRcdHZhciBmaSA9IG4+PjM7IC8vIGhpZ2hlc3Qgb3JkZXIgYml0cyAxLTMgY29kZSBmb3Igb3BlcmF0aW9uLlxuXHRcdFx0dmFyIGYgPSBpbnN0cnVjdGlvbnNbZmldO1xuXHRcdFx0Ly8gY2hlY2sgdGhhdCB3ZSBoYXZlIGEgdmFsaWQgaW5zdHJ1Y3Rpb24gJiB0aGF0IHRoZSB1bnVzZWQgYml0cyBhcmUgZW1wdHk6XG5cdFx0XHRpZiAoIWYgfHwgKG4mMykpIHsgdGhyb3coXCJiYWQgcGF0aCBkYXRhIChAXCIraStcIik6IFwiK2MpOyB9XG5cdFx0XHR2YXIgcGwgPSBwYXJhbUNvdW50W2ZpXTtcblx0XHRcdGlmICghZmkpIHsgeD15PTA7IH0gLy8gbW92ZSBvcGVyYXRpb25zIHJlc2V0IHRoZSBwb3NpdGlvbi5cblx0XHRcdHBhcmFtcy5sZW5ndGggPSAwO1xuXHRcdFx0aSsrO1xuXHRcdFx0dmFyIGNoYXJDb3VudCA9IChuPj4yJjEpKzI7ICAvLyA0dGggaGVhZGVyIGJpdCBpbmRpY2F0ZXMgbnVtYmVyIHNpemUgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHRcdFx0Zm9yICh2YXIgcD0wOyBwPHBsOyBwKyspIHtcblx0XHRcdFx0dmFyIG51bSA9IGJhc2U2NFtzdHIuY2hhckF0KGkpXTtcblx0XHRcdFx0dmFyIHNpZ24gPSAobnVtPj41KSA/IC0xIDogMTtcblx0XHRcdFx0bnVtID0gKChudW0mMzEpPDw2KXwoYmFzZTY0W3N0ci5jaGFyQXQoaSsxKV0pO1xuXHRcdFx0XHRpZiAoY2hhckNvdW50ID09IDMpIHsgbnVtID0gKG51bTw8Nil8KGJhc2U2NFtzdHIuY2hhckF0KGkrMildKTsgfVxuXHRcdFx0XHRudW0gPSBzaWduKm51bS8xMDtcblx0XHRcdFx0aWYgKHAlMikgeyB4ID0gKG51bSArPSB4KTsgfVxuXHRcdFx0XHRlbHNlIHsgeSA9IChudW0gKz0geSk7IH1cblx0XHRcdFx0cGFyYW1zW3BdID0gbnVtO1xuXHRcdFx0XHRpICs9IGNoYXJDb3VudDtcblx0XHRcdH1cblx0XHRcdGYuYXBwbHkodGhpcyxwYXJhbXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU3RvcmVzIGFsbCBncmFwaGljcyBjb21tYW5kcyBzbyB0aGV5IHdvbid0IGJlIGV4ZWN1dGVkIGluIGZ1dHVyZSBkcmF3cy4gQ2FsbGluZyBzdG9yZSgpIGEgc2Vjb25kIHRpbWUgYWRkcyB0b1xuXHQgKiB0aGUgZXhpc3Rpbmcgc3RvcmUuIFRoaXMgYWxzbyBhZmZlY3RzIGBkcmF3QXNQYXRoKClgLlxuXHQgKlxuXHQgKiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlcyB3aGVyZSB5b3UgYXJlIGNyZWF0aW5nIHZlY3RvciBncmFwaGljcyBpbiBhbiBpdGVyYXRpdmUgbWFubmVyIChleC4gZ2VuZXJhdGl2ZSBhcnQpLCBzb1xuXHQgKiB0aGF0IG9ubHkgbmV3IGdyYXBoaWNzIG5lZWQgdG8gYmUgZHJhd24gKHdoaWNoIGNhbiBwcm92aWRlIGh1Z2UgcGVyZm9ybWFuY2UgYmVuZWZpdHMpLCBidXQgeW91IHdpc2ggdG8gcmV0YWluIGFsbFxuXHQgKiBvZiB0aGUgdmVjdG9yIGluc3RydWN0aW9ucyBmb3IgbGF0ZXIgdXNlIChleC4gc2NhbGluZywgbW9kaWZ5aW5nLCBvciBleHBvcnRpbmcpLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgY2FsbGluZyBzdG9yZSgpIHdpbGwgZm9yY2UgdGhlIGFjdGl2ZSBwYXRoIChpZiBhbnkpIHRvIGJlIGVuZGVkIGluIGEgbWFubmVyIHNpbWlsYXIgdG8gY2hhbmdpbmdcblx0ICogdGhlIGZpbGwgb3Igc3Ryb2tlLlxuXHQgKlxuXHQgKiBGb3IgZXhhbXBsZSwgY29uc2lkZXIgYSBhcHBsaWNhdGlvbiB3aGVyZSB0aGUgdXNlciBkcmF3cyBsaW5lcyB3aXRoIHRoZSBtb3VzZS4gQXMgZWFjaCBsaW5lIHNlZ21lbnQgKG9yIGNvbGxlY3Rpb24gb2Zcblx0ICogc2VnbWVudHMpIGFyZSBhZGRlZCB0byBhIFNoYXBlLCBpdCBjYW4gYmUgcmFzdGVyaXplZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3VwZGF0ZUNhY2hlXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBhbmQgdGhlbiBzdG9yZWQsIHNvIHRoYXQgaXQgY2FuIGJlIHJlZHJhd24gYXQgYSBkaWZmZXJlbnQgc2NhbGUgd2hlbiB0aGUgYXBwbGljYXRpb24gaXMgcmVzaXplZCwgb3IgZXhwb3J0ZWQgdG8gU1ZHLlxuXHQgKlxuXHQgKiBcdC8vIHNldCB1cCBjYWNoZTpcblx0ICogXHRteVNoYXBlLmNhY2hlKDAsMCw1MDAsNTAwLHNjYWxlKTtcblx0ICpcblx0ICogXHQvLyB3aGVuIHRoZSB1c2VyIGRyYWdzLCBkcmF3IGEgbmV3IGxpbmU6XG5cdCAqIFx0bXlTaGFwZS5ncmFwaGljcy5tb3ZlVG8ob2xkWCxvbGRZKS5saW5lVG8obmV3WCxuZXdZKTtcblx0ICogXHQvLyB0aGVuIGRyYXcgaXQgaW50byB0aGUgZXhpc3RpbmcgY2FjaGU6XG5cdCAqIFx0bXlTaGFwZS51cGRhdGVDYWNoZShcInNvdXJjZS1vdmVyXCIpO1xuXHQgKiBcdC8vIHN0b3JlIHRoZSBuZXcgbGluZSwgc28gaXQgaXNuJ3QgcmVkcmF3biBuZXh0IHRpbWU6XG5cdCAqIFx0bXlTaGFwZS5zdG9yZSgpO1xuXHQgKlxuXHQgKiBcdC8vIHRoZW4sIHdoZW4gdGhlIHdpbmRvdyByZXNpemVzLCB3ZSBjYW4gcmUtcmVuZGVyIGF0IGEgZGlmZmVyZW50IHNjYWxlOlxuXHQgKiBcdC8vIGZpcnN0LCB1bnN0b3JlIGFsbCBvdXIgbGluZXM6XG5cdCAqIFx0bXlTaGFwZS51bnN0b3JlKCk7XG5cdCAqIFx0Ly8gdGhlbiBjYWNoZSB1c2luZyB0aGUgbmV3IHNjYWxlOlxuXHQgKiBcdG15U2hhcGUuY2FjaGUoMCwwLDUwMCw1MDAsbmV3U2NhbGUpO1xuXHQgKiBcdC8vIGZpbmFsbHksIHN0b3JlIHRoZSBleGlzdGluZyBjb21tYW5kcyBhZ2Fpbjpcblx0ICogXHRteVNoYXBlLnN0b3JlKCk7XG5cdCAqXG5cdCAqIEBtZXRob2Qgc3RvcmVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLnN0b3JlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKHRydWUpO1xuXHRcdHRoaXMuX3N0b3JlSW5kZXggPSB0aGlzLl9pbnN0cnVjdGlvbnMubGVuZ3RoO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVbnN0b3JlcyBhbnkgZ3JhcGhpY3MgY29tbWFuZHMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgc3RvcmVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3N0b3JlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHNvIHRoYXQgdGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHN1YnNlcXVlbnQgZHJhdyBjYWxscy5cblx0ICpcblx0ICogQG1ldGhvZCB1bnN0b3JlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC51bnN0b3JlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc3RvcmVJbmRleCA9IDA7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIEdyYXBoaWNzIGluc3RhbmNlLiBOb3RlIHRoYXQgdGhlIGluZGl2aWR1YWwgY29tbWFuZCBvYmplY3RzIGFyZSBub3QgY2xvbmVkLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBBIGNsb25lIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbyA9IG5ldyBHcmFwaGljcygpO1xuXHRcdG8uY29tbWFuZCA9IHRoaXMuY29tbWFuZDtcblx0XHRvLl9zdHJva2UgPSB0aGlzLl9zdHJva2U7XG5cdFx0by5fc3Ryb2tlU3R5bGUgPSB0aGlzLl9zdHJva2VTdHlsZTtcblx0XHRvLl9zdHJva2VEYXNoID0gdGhpcy5fc3Ryb2tlRGFzaDtcblx0XHRvLl9zdHJva2VJZ25vcmVTY2FsZSA9IHRoaXMuX3N0cm9rZUlnbm9yZVNjYWxlO1xuXHRcdG8uX2ZpbGwgPSB0aGlzLl9maWxsO1xuXHRcdG8uX2luc3RydWN0aW9ucyA9IHRoaXMuX2luc3RydWN0aW9ucy5zbGljZSgpO1xuXHRcdG8uX2NvbW1pdEluZGV4ID0gdGhpcy5fY29tbWl0SW5kZXg7XG5cdFx0by5fYWN0aXZlSW5zdHJ1Y3Rpb25zID0gdGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLnNsaWNlKCk7XG5cdFx0by5fZGlydHkgPSB0aGlzLl9kaXJ0eTtcblx0XHRvLl9zdG9yZUluZGV4ID0gdGhpcy5fc3RvcmVJbmRleDtcblx0XHRyZXR1cm4gbztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0dyYXBoaWNzXVwiO1xuXHR9O1xuXG5cbi8vIHRpbnkgQVBJOlxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gbW92ZVRvLlxuXHQgKiBAbWV0aG9kIG10XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIG1vdmUgdG8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIG1vdmUgdG8uXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLm10ID0gcC5tb3ZlVG87XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGxpbmVUby5cblx0ICogQG1ldGhvZCBsdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBkcmF3IHRvLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBkcmF3IHRvLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5sdCA9IHAubGluZVRvO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBhcmNUby5cblx0ICogQG1ldGhvZCBhdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5hdCA9IHAuYXJjVG87XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlemllckN1cnZlVG8uXG5cdCAqIEBtZXRob2QgYnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMXhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMXlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMnhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMnlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuYnQgPSBwLmJlemllckN1cnZlVG87XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIHF1YWRyYXRpY0N1cnZlVG8gLyBjdXJ2ZVRvLlxuXHQgKiBAbWV0aG9kIHF0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLnF0ID0gcC5xdWFkcmF0aWNDdXJ2ZVRvO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBhcmMuXG5cdCAqIEBtZXRob2QgYVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEFuZ2xlIE1lYXN1cmVkIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlbmRBbmdsZSBNZWFzdXJlZCBpbiByYWRpYW5zLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFudGljbG9ja3dpc2Vcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYSA9IHAuYXJjO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byByZWN0LlxuXHQgKiBAbWV0aG9kIHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5yID0gcC5yZWN0O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBjbG9zZVBhdGguXG5cdCAqIEBtZXRob2QgY3Bcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuY3AgPSBwLmNsb3NlUGF0aDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gY2xlYXIuXG5cdCAqIEBtZXRob2QgY1xuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5jID0gcC5jbGVhcjtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYmVnaW5GaWxsLlxuXHQgKiBAbWV0aG9kIGZcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIEEgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWUgKGV4LiBcInJlZFwiLCBcIiNGRjAwMDBcIiwgb3IgXCJyZ2JhKDI1NSwwLDAsMC41KVwiKS4gU2V0dGluZyB0b1xuXHQgKiBudWxsIHdpbGwgcmVzdWx0IGluIG5vIGZpbGwuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmYgPSBwLmJlZ2luRmlsbDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYmVnaW5MaW5lYXJHcmFkaWVudEZpbGwuXG5cdCAqIEBtZXRob2QgbGZcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lIGEgZ3JhZGllbnRcblx0ICogZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsIDAuOV0gd291bGQgZHJhd1xuXHQgKiB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAubGYgPSBwLmJlZ2luTGluZWFyR3JhZGllbnRGaWxsO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpblJhZGlhbEdyYWRpZW50RmlsbC5cblx0ICogQG1ldGhvZCByZlxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmVcblx0ICogYSBncmFkaWVudCBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSxcblx0ICogMC45XSB3b3VsZCBkcmF3IHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMCBSYWRpdXMgb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMSBSYWRpdXMgb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5yZiA9IHAuYmVnaW5SYWRpYWxHcmFkaWVudEZpbGw7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luQml0bWFwRmlsbC5cblx0ICogQG1ldGhvZCBiZlxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlIFRoZSBJbWFnZSwgQ2FudmFzLCBvciBWaWRlbyBvYmplY3QgdG8gdXNlXG5cdCAqIGFzIHRoZSBwYXR0ZXJuLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcmVwZXRpdGlvbiBPcHRpb25hbC4gSW5kaWNhdGVzIHdoZXRoZXIgdG8gcmVwZWF0IHRoZSBpbWFnZSBpbiB0aGUgZmlsbCBhcmVhLiBPbmUgb2YgXCJyZXBlYXRcIixcblx0ICogXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuIERlZmF1bHRzIHRvIFwicmVwZWF0XCIuIE5vdGUgdGhhdCBGaXJlZm94IGRvZXMgbm90IHN1cHBvcnQgXCJyZXBlYXQteFwiIG9yXG5cdCAqIFwicmVwZWF0LXlcIiAobGF0ZXN0IHRlc3RzIHdlcmUgaW4gRkYgMjAuMCksIGFuZCB3aWxsIGRlZmF1bHQgdG8gXCJyZXBlYXRcIi5cblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4IE9wdGlvbmFsLiBTcGVjaWZpZXMgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZm9yIHRoZSBiaXRtYXAgZmlsbC4gVGhpcyB0cmFuc2Zvcm1hdGlvblxuXHQgKiB3aWxsIGJlIGFwcGxpZWQgcmVsYXRpdmUgdG8gdGhlIHBhcmVudCB0cmFuc2Zvcm0uXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmJmID0gcC5iZWdpbkJpdG1hcEZpbGw7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGVuZEZpbGwuXG5cdCAqIEBtZXRob2QgZWZcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZWYgPSBwLmVuZEZpbGw7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIHNldFN0cm9rZVN0eWxlLlxuXHQgKiBAbWV0aG9kIHNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0aGlja25lc3MgVGhlIHdpZHRoIG9mIHRoZSBzdHJva2UuXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBbY2Fwcz0wXSBJbmRpY2F0ZXMgdGhlIHR5cGUgb2YgY2FwcyB0byB1c2UgYXQgdGhlIGVuZCBvZiBsaW5lcy4gT25lIG9mIGJ1dHQsXG5cdCAqIHJvdW5kLCBvciBzcXVhcmUuIERlZmF1bHRzIHRvIFwiYnV0dFwiLiBBbHNvIGFjY2VwdHMgdGhlIHZhbHVlcyAwIChidXR0KSwgMSAocm91bmQpLCBhbmQgMiAoc3F1YXJlKSBmb3IgdXNlIHdpdGhcblx0ICogdGhlIHRpbnkgQVBJLlxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gW2pvaW50cz0wXSBTcGVjaWZpZXMgdGhlIHR5cGUgb2Ygam9pbnRzIHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlcmUgdHdvIGxpbmVzIG1lZXQuXG5cdCAqIE9uZSBvZiBiZXZlbCwgcm91bmQsIG9yIG1pdGVyLiBEZWZhdWx0cyB0byBcIm1pdGVyXCIuIEFsc28gYWNjZXB0cyB0aGUgdmFsdWVzIDAgKG1pdGVyKSwgMSAocm91bmQpLCBhbmQgMiAoYmV2ZWwpXG5cdCAqIGZvciB1c2Ugd2l0aCB0aGUgdGlueSBBUEkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbWl0ZXJMaW1pdD0xMF0gSWYgam9pbnRzIGlzIHNldCB0byBcIm1pdGVyXCIsIHRoZW4geW91IGNhbiBzcGVjaWZ5IGEgbWl0ZXIgbGltaXQgcmF0aW8gd2hpY2hcblx0ICogY29udHJvbHMgYXQgd2hhdCBwb2ludCBhIG1pdGVyZWQgam9pbnQgd2lsbCBiZSBjbGlwcGVkLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVTY2FsZT1mYWxzZV0gSWYgdHJ1ZSwgdGhlIHN0cm9rZSB3aWxsIGJlIGRyYXduIGF0IHRoZSBzcGVjaWZpZWQgdGhpY2tuZXNzIHJlZ2FyZGxlc3Ncblx0ICogb2YgYWN0aXZlIHRyYW5zZm9ybWF0aW9ucy5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuc3MgPSBwLnNldFN0cm9rZVN0eWxlO1xuXHRcblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIHNldFN0cm9rZURhc2guXG5cdCAqIEBtZXRob2Qgc2Rcblx0ICogQHBhcmFtIHtBcnJheX0gW3NlZ21lbnRzXSBBbiBhcnJheSBzcGVjaWZ5aW5nIHRoZSBkYXNoIHBhdHRlcm4sIGFsdGVybmF0aW5nIGJldHdlZW4gbGluZSBhbmQgZ2FwLlxuXHQgKiBGb3IgZXhhbXBsZSwgWzIwLDEwXSB3b3VsZCBjcmVhdGUgYSBwYXR0ZXJuIG9mIDIwIHBpeGVsIGxpbmVzIHdpdGggMTAgcGl4ZWwgZ2FwcyBiZXR3ZWVuIHRoZW0uXG5cdCAqIFBhc3NpbmcgbnVsbCBvciBhbiBlbXB0eSBhcnJheSB3aWxsIGNsZWFyIGFueSBleGlzdGluZyBkYXNoLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29mZnNldD0wXSBUaGUgb2Zmc2V0IG9mIHRoZSBkYXNoIHBhdHRlcm4uIEZvciBleGFtcGxlLCB5b3UgY291bGQgaW5jcmVtZW50IHRoaXMgdmFsdWUgdG8gY3JlYXRlIGEgXCJtYXJjaGluZyBhbnRzXCIgZWZmZWN0LlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5zZCA9IHAuc2V0U3Ryb2tlRGFzaDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYmVnaW5TdHJva2UuXG5cdCAqIEBtZXRob2Qgc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQSBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZSAoZXguIFwiI0ZGMDAwMFwiLCBcInJlZFwiLCBvciBcInJnYmEoMjU1LDAsMCwwLjUpXCIpLiBTZXR0aW5nIHRvXG5cdCAqIG51bGwgd2lsbCByZXN1bHQgaW4gbm8gc3Ryb2tlLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5zID0gcC5iZWdpblN0cm9rZTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZS5cblx0ICogQG1ldGhvZCBsc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmVcblx0ICogYSBncmFkaWVudCBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSxcblx0ICogMC45XSB3b3VsZCBkcmF3IHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5scyA9IHAuYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYmVnaW5SYWRpYWxHcmFkaWVudFN0cm9rZS5cblx0ICogQG1ldGhvZCByc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmVcblx0ICogYSBncmFkaWVudCBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSxcblx0ICogMC45XSB3b3VsZCBkcmF3IHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLCB0aGVuIGRyYXcgdGhlIHNlY29uZCBjb2xvclxuXHQgKiB0byAxMDAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMCBSYWRpdXMgb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMSBSYWRpdXMgb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5ycyA9IHAuYmVnaW5SYWRpYWxHcmFkaWVudFN0cm9rZTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYmVnaW5CaXRtYXBTdHJva2UuXG5cdCAqIEBtZXRob2QgYnNcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50fSBpbWFnZSBUaGUgSW1hZ2UsIENhbnZhcywgb3IgVmlkZW8gb2JqZWN0IHRvIHVzZVxuXHQgKiBhcyB0aGUgcGF0dGVybi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtyZXBldGl0aW9uPXJlcGVhdF0gT3B0aW9uYWwuIEluZGljYXRlcyB3aGV0aGVyIHRvIHJlcGVhdCB0aGUgaW1hZ2UgaW4gdGhlIGZpbGwgYXJlYS4gT25lIG9mXG5cdCAqIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiBEZWZhdWx0cyB0byBcInJlcGVhdFwiLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5icyA9IHAuYmVnaW5CaXRtYXBTdHJva2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGVuZFN0cm9rZS5cblx0ICogQG1ldGhvZCBlc1xuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5lcyA9IHAuZW5kU3Ryb2tlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBkcmF3UmVjdC5cblx0ICogQG1ldGhvZCBkclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmRyID0gcC5kcmF3UmVjdDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZHJhd1JvdW5kUmVjdC5cblx0ICogQG1ldGhvZCByclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gd1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIENvcm5lciByYWRpdXMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnJyID0gcC5kcmF3Um91bmRSZWN0O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBkcmF3Um91bmRSZWN0Q29tcGxleC5cblx0ICogQG1ldGhvZCByY1xuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlIHRvIGRyYXcgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlIHRvIGRyYXcgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSB3aWR0aCBvZiB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggVGhlIGhlaWdodCBvZiB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1RMIFRvcCBsZWZ0IGNvcm5lciByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUUiBUb3AgcmlnaHQgY29ybmVyIHJhZGl1cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JSIEJvdHRvbSByaWdodCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQkwgQm90dG9tIGxlZnQgY29ybmVyIHJhZGl1cy5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAucmMgPSBwLmRyYXdSb3VuZFJlY3RDb21wbGV4O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBkcmF3Q2lyY2xlLlxuXHQgKiBAbWV0aG9kIGRjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IHggY29vcmRpbmF0ZSBjZW50ZXIgcG9pbnQgb2YgY2lyY2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSB5IGNvb3JkaW5hdGUgY2VudGVyIHBvaW50IG9mIGNpcmNsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgY2lyY2xlLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5kYyA9IHAuZHJhd0NpcmNsZTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZHJhd0VsbGlwc2UuXG5cdCAqIEBtZXRob2QgZGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGxlZnQgY29vcmRpbmF0ZSBwb2ludCBvZiB0aGUgZWxsaXBzZS4gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IGZyb20ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGljaCBkcmF3cyBmcm9tIGNlbnRlci5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHRvcCBjb29yZGluYXRlIHBvaW50IG9mIHRoZSBlbGxpcHNlLiBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Q2lyY2xlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdoaWNoIGRyYXdzIGZyb20gdGhlIGNlbnRlci5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgVGhlIGhlaWdodCAoaG9yaXpvbnRhbCBkaWFtZXRlcikgb2YgdGhlIGVsbGlwc2UuIFRoZSBob3Jpem9udGFsIHJhZGl1cyB3aWxsIGJlIGhhbGYgb2YgdGhpc1xuXHQgKiBudW1iZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIFRoZSB3aWR0aCAodmVydGljYWwgZGlhbWV0ZXIpIG9mIHRoZSBlbGxpcHNlLiBUaGUgdmVydGljYWwgcmFkaXVzIHdpbGwgYmUgaGFsZiBvZiB0aGlzIG51bWJlci5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZGUgPSBwLmRyYXdFbGxpcHNlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBkcmF3UG9seVN0YXIuXG5cdCAqIEBtZXRob2QgZHBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggUG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGUgc2hhcGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2lkZXMgVGhlIG51bWJlciBvZiBwb2ludHMgb24gdGhlIHN0YXIgb3Igc2lkZXMgb24gdGhlIHBvbHlnb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludFNpemUgVGhlIGRlcHRoIG9yIFwicG9pbnR5LW5lc3NcIiBvZiB0aGUgc3RhciBwb2ludHMuIEEgcG9pbnRTaXplIG9mIDAgd2lsbCBkcmF3IGEgcmVndWxhclxuXHQgKiBwb2x5Z29uIChubyBwb2ludHMpLCBhIHBvaW50U2l6ZSBvZiAxIHdpbGwgZHJhdyBub3RoaW5nIGJlY2F1c2UgdGhlIHBvaW50cyBhcmUgaW5maW5pdGVseSBwb2ludHkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBUaGUgYW5nbGUgb2YgdGhlIGZpcnN0IHBvaW50IC8gY29ybmVyLiBGb3IgZXhhbXBsZSBhIHZhbHVlIG9mIDAgd2lsbCBkcmF3IHRoZSBmaXJzdCBwb2ludFxuXHQgKiBkaXJlY3RseSB0byB0aGUgcmlnaHQgb2YgdGhlIGNlbnRlci5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZHAgPSBwLmRyYXdQb2x5U3RhcjtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZGVjb2RlUGF0aC5cblx0ICogQG1ldGhvZCBwXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHBhdGggc3RyaW5nIHRvIGRlY29kZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAucCA9IHAuZGVjb2RlUGF0aDtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF91cGRhdGVJbnN0cnVjdGlvbnNcblx0ICogQHBhcmFtIGNvbW1pdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fdXBkYXRlSW5zdHJ1Y3Rpb25zID0gZnVuY3Rpb24oY29tbWl0KSB7XG5cdFx0dmFyIGluc3RyID0gdGhpcy5faW5zdHJ1Y3Rpb25zLCBhY3RpdmUgPSB0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMsIGNvbW1pdEluZGV4ID0gdGhpcy5fY29tbWl0SW5kZXg7XG5cblx0XHRpZiAodGhpcy5fZGlydHkgJiYgYWN0aXZlLmxlbmd0aCkge1xuXHRcdFx0aW5zdHIubGVuZ3RoID0gY29tbWl0SW5kZXg7IC8vIHJlbW92ZSBvbGQsIHVuY29tbWl0dGVkIGNvbW1hbmRzXG5cdFx0XHRpbnN0ci5wdXNoKEdyYXBoaWNzLmJlZ2luQ21kKTtcblxuXHRcdFx0dmFyIGwgPSBhY3RpdmUubGVuZ3RoLCBsbCA9IGluc3RyLmxlbmd0aDtcblx0XHRcdGluc3RyLmxlbmd0aCA9IGxsK2w7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IGluc3RyW2krbGxdID0gYWN0aXZlW2ldOyB9XG5cblx0XHRcdGlmICh0aGlzLl9maWxsKSB7IGluc3RyLnB1c2godGhpcy5fZmlsbCk7IH1cblx0XHRcdGlmICh0aGlzLl9zdHJva2UpIHtcblx0XHRcdFx0Ly8gZG9lc24ndCBuZWVkIHRvIGJlIHJlLWFwcGxpZWQgaWYgaXQgaGFzbid0IGNoYW5nZWQuXG5cdFx0XHRcdGlmICh0aGlzLl9zdHJva2VEYXNoICE9PSB0aGlzLl9vbGRTdHJva2VEYXNoKSB7XG5cdFx0XHRcdFx0dGhpcy5fb2xkU3Ryb2tlRGFzaCA9IHRoaXMuX3N0cm9rZURhc2g7XG5cdFx0XHRcdFx0aW5zdHIucHVzaCh0aGlzLl9zdHJva2VEYXNoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fc3Ryb2tlU3R5bGUgIT09IHRoaXMuX29sZFN0cm9rZVN0eWxlKSB7XG5cdFx0XHRcdFx0dGhpcy5fb2xkU3Ryb2tlU3R5bGUgPSB0aGlzLl9zdHJva2VTdHlsZTtcblx0XHRcdFx0XHRpbnN0ci5wdXNoKHRoaXMuX3N0cm9rZVN0eWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbnN0ci5wdXNoKHRoaXMuX3N0cm9rZSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKGNvbW1pdCkge1xuXHRcdFx0YWN0aXZlLmxlbmd0aCA9IDA7XG5cdFx0XHR0aGlzLl9jb21taXRJbmRleCA9IGluc3RyLmxlbmd0aDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3NldEZpbGxcblx0ICogQHBhcmFtIGZpbGxcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3NldEZpbGwgPSBmdW5jdGlvbihmaWxsKSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKHRydWUpO1xuXHRcdHRoaXMuY29tbWFuZCA9IHRoaXMuX2ZpbGwgPSBmaWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXRTdHJva2Vcblx0ICogQHBhcmFtIHN0cm9rZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fc2V0U3Ryb2tlID0gZnVuY3Rpb24oc3Ryb2tlKSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKHRydWUpO1xuXHRcdGlmICh0aGlzLmNvbW1hbmQgPSB0aGlzLl9zdHJva2UgPSBzdHJva2UpIHtcblx0XHRcdHN0cm9rZS5pZ25vcmVTY2FsZSA9IHRoaXMuX3N0cm9rZUlnbm9yZVNjYWxlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuLy8gQ29tbWFuZCBPYmplY3RzOlxuXHQvKipcblx0ICogQG5hbWVzcGFjZSBHcmFwaGljc1xuXHQgKi9cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvbGluZVRvXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljc1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgTGluZVRvXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuTGluZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5saW5lVG8odGhpcy54LHRoaXMueSk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvbW92ZVRvXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBNb3ZlVG9cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5Nb3ZlVG8gPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4Lm1vdmVUbyh0aGlzLngsIHRoaXMueSk7IH07XG5cblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcmNUb1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgQXJjVG9cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4MVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeTFcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHgyXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5MlxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5BcmNUbyA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcblx0XHR0aGlzLngxID0geDE7IHRoaXMueTEgPSB5MTtcblx0XHR0aGlzLngyID0geDI7IHRoaXMueTIgPSB5Mjtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmFyY1RvKHRoaXMueDEsIHRoaXMueTEsIHRoaXMueDIsIHRoaXMueTIsIHRoaXMucmFkaXVzKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcmNcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIEFyY1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRBbmdsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZW5kQW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFudGljbG9ja3dpc2Vcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgc3RhcnRBbmdsZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgZW5kQW5nbGVcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGFudGljbG9ja3dpc2Vcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLkFyYyA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHRcdHRoaXMuc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGU7IHRoaXMuZW5kQW5nbGUgPSBlbmRBbmdsZTtcblx0XHR0aGlzLmFudGljbG9ja3dpc2UgPSAhIWFudGljbG9ja3dpc2U7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5hcmModGhpcy54LCB0aGlzLnksIHRoaXMucmFkaXVzLCB0aGlzLnN0YXJ0QW5nbGUsIHRoaXMuZW5kQW5nbGUsIHRoaXMuYW50aWNsb2Nrd2lzZSk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvcXVhZHJhdGljQ3VydmVUb1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgUXVhZHJhdGljQ3VydmVUb1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBjcHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNweVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuUXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKGNweCwgY3B5LCB4LCB5KSB7XG5cdFx0dGhpcy5jcHggPSBjcHg7IHRoaXMuY3B5ID0gY3B5O1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHRoaXMuY3B4LCB0aGlzLmNweSwgdGhpcy54LCB0aGlzLnkpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlemllckN1cnZlVG9cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIEJlemllckN1cnZlVG9cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDF4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDF5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBjcDF4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBjcDF5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBjcDJ4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBjcDJ5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5CZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSkge1xuXHRcdHRoaXMuY3AxeCA9IGNwMXg7IHRoaXMuY3AxeSA9IGNwMXk7XG5cdFx0dGhpcy5jcDJ4ID0gY3AyeDsgdGhpcy5jcDJ5ID0gY3AyeTtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHguYmV6aWVyQ3VydmVUbyh0aGlzLmNwMXgsIHRoaXMuY3AxeSwgdGhpcy5jcDJ4LCB0aGlzLmNwMnksIHRoaXMueCwgdGhpcy55KTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9yZWN0XCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBSZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gd1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaFxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgd1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgaFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHRcdHRoaXMudyA9IHc7IHRoaXMuaCA9IGg7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5yZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLncsIHRoaXMuaCk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvY2xvc2VQYXRoXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBDbG9zZVBhdGhcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5DbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmNsb3NlUGF0aCgpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdCB0byBiZWdpbiBhIG5ldyBwYXRoLiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3NcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIEJlZ2luUGF0aFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLkJlZ2luUGF0aCA9IGZ1bmN0aW9uKCkge1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHguYmVnaW5QYXRoKCk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5GaWxsXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBGaWxsXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgQSB2YWxpZCBDb250ZXh0MkQgZmlsbFN0eWxlLlxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXhcblx0ICoqL1xuXHQvKipcblx0ICogQSB2YWxpZCBDb250ZXh0MkQgZmlsbFN0eWxlLlxuXHQgKiBAcHJvcGVydHkgc3R5bGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IG1hdHJpeFxuXHQgKiBAdHlwZSBNYXRyaXgyRFxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHRwID0gKEcuRmlsbCA9IGZ1bmN0aW9uKHN0eWxlLCBtYXRyaXgpIHtcblx0XHR0aGlzLnN0eWxlID0gc3R5bGU7XG5cdFx0dGhpcy5tYXRyaXggPSBtYXRyaXg7XG5cdH0pLnByb3RvdHlwZTtcblx0cC5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0aWYgKCF0aGlzLnN0eWxlKSB7IHJldHVybjsgfVxuXHRcdGN0eC5maWxsU3R5bGUgPSB0aGlzLnN0eWxlO1xuXHRcdHZhciBtdHggPSB0aGlzLm1hdHJpeDtcblx0XHRpZiAobXR4KSB7IGN0eC5zYXZlKCk7IGN0eC50cmFuc2Zvcm0obXR4LmEsIG10eC5iLCBtdHguYywgbXR4LmQsIG10eC50eCwgbXR4LnR5KTsgfVxuXHRcdGN0eC5maWxsKCk7XG5cdFx0aWYgKG10eCkgeyBjdHgucmVzdG9yZSgpOyB9XG5cdH07XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbGluZWFyIGdyYWRpZW50IHN0eWxlIGFuZCBhc3NpZ25zIGl0IHRvIHt7I2Nyb3NzTGluayBcIkZpbGwvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkxpbmVhckdyYWRpZW50RmlsbFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCBsaW5lYXJHcmFkaWVudFxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnNcblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MFxuXHQgKiBAcGFyYW0ge051bWJlcn0geTBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcmV0dXJuIHtGaWxsfSBSZXR1cm5zIHRoaXMgRmlsbCBvYmplY3QgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXG5cdCAqL1xuXHRwLmxpbmVhckdyYWRpZW50ID0gZnVuY3Rpb24oY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgeDEsIHkxKSB7XG5cdFx0dmFyIG8gPSB0aGlzLnN0eWxlID0gIEdyYXBoaWNzLl9jdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeDAsIHkwLCB4MSwgeTEpO1xuXHRcdGZvciAodmFyIGk9MCwgbD1jb2xvcnMubGVuZ3RoOyBpPGw7IGkrKykgeyBvLmFkZENvbG9yU3RvcChyYXRpb3NbaV0sIGNvbG9yc1tpXSk7IH1cblx0XHRvLnByb3BzID0ge2NvbG9yczpjb2xvcnMsIHJhdGlvczpyYXRpb3MsIHgwOngwLCB5MDp5MCwgeDE6eDEsIHkxOnkxLCB0eXBlOlwibGluZWFyXCJ9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIHJhZGlhbCBncmFkaWVudCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB7eyNjcm9zc0xpbmsgXCJGaWxsL3N0eWxlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5SYWRpYWxHcmFkaWVudEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgcmFkaWFsR3JhZGllbnRcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geDBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMFxuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMVxuXHQgKiBAcmV0dXJuIHtGaWxsfSBSZXR1cm5zIHRoaXMgRmlsbCBvYmplY3QgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXG5cdCAqL1xuXHRwLnJhZGlhbEdyYWRpZW50ID0gZnVuY3Rpb24oY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpIHtcblx0XHR2YXIgbyA9IHRoaXMuc3R5bGUgPSAgR3JhcGhpY3MuX2N0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKTtcblx0XHRmb3IgKHZhciBpPTAsIGw9Y29sb3JzLmxlbmd0aDsgaTxsOyBpKyspIHsgby5hZGRDb2xvclN0b3AocmF0aW9zW2ldLCBjb2xvcnNbaV0pOyB9XG5cdFx0by5wcm9wcyA9IHtjb2xvcnM6Y29sb3JzLCByYXRpb3M6cmF0aW9zLCB4MDp4MCwgeTA6eTAsIHIwOnIwLCB4MTp4MSwgeTE6eTEsIHIxOnIxLCB0eXBlOlwicmFkaWFsXCJ9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIGJpdG1hcCBmaWxsIHN0eWxlIGFuZCBhc3NpZ25zIGl0IHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJGaWxsL3N0eWxlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5CaXRtYXBGaWxsXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGJpdG1hcFxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlICBNdXN0IGJlIGxvYWRlZCBwcmlvciB0byBjcmVhdGluZyBhIGJpdG1hcCBmaWxsLCBvciB0aGUgZmlsbCB3aWxsIGJlIGVtcHR5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3JlcGV0aXRpb25dIE9uZSBvZjogcmVwZWF0LCByZXBlYXQteCwgcmVwZWF0LXksIG9yIG5vLXJlcGVhdC5cblx0ICogQHJldHVybiB7RmlsbH0gUmV0dXJucyB0aGlzIEZpbGwgb2JqZWN0IGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKi9cblx0cC5iaXRtYXAgPSBmdW5jdGlvbihpbWFnZSwgcmVwZXRpdGlvbikge1xuXHRcdGlmIChpbWFnZS5uYXR1cmFsV2lkdGggfHwgaW1hZ2UuZ2V0Q29udGV4dCB8fCBpbWFnZS5yZWFkeVN0YXRlID49IDIpIHtcblx0XHRcdHZhciBvID0gdGhpcy5zdHlsZSA9IEdyYXBoaWNzLl9jdHguY3JlYXRlUGF0dGVybihpbWFnZSwgcmVwZXRpdGlvbiB8fCBcIlwiKTtcblx0XHRcdG8ucHJvcHMgPSB7aW1hZ2U6IGltYWdlLCByZXBldGl0aW9uOiByZXBldGl0aW9uLCB0eXBlOiBcImJpdG1hcFwifTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdHAucGF0aCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luU3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBTdHJva2Vcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSBBIHZhbGlkIENvbnRleHQyRCBmaWxsU3R5bGUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlU2NhbGVcblx0ICoqL1xuXHQvKipcblx0ICogQSB2YWxpZCBDb250ZXh0MkQgc3Ryb2tlU3R5bGUuXG5cdCAqIEBwcm9wZXJ0eSBzdHlsZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgaWdub3JlU2NhbGVcblx0ICogQHR5cGUgQm9vbGVhblxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHRwID0gKEcuU3Ryb2tlID0gZnVuY3Rpb24oc3R5bGUsIGlnbm9yZVNjYWxlKSB7XG5cdFx0dGhpcy5zdHlsZSA9IHN0eWxlO1xuXHRcdHRoaXMuaWdub3JlU2NhbGUgPSBpZ25vcmVTY2FsZTtcblx0fSkucHJvdG90eXBlO1xuXHRwLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAoIXRoaXMuc3R5bGUpIHsgcmV0dXJuOyB9XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zdHlsZTtcblx0XHRpZiAodGhpcy5pZ25vcmVTY2FsZSkgeyBjdHguc2F2ZSgpOyBjdHguc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKTsgfVxuXHRcdGN0eC5zdHJva2UoKTtcblx0XHRpZiAodGhpcy5pZ25vcmVTY2FsZSkgeyBjdHgucmVzdG9yZSgpOyB9XG5cdH07XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbGluZWFyIGdyYWRpZW50IHN0eWxlIGFuZCBhc3NpZ25zIGl0IHRvIHt7I2Nyb3NzTGluayBcIlN0cm9rZS9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luTGluZWFyR3JhZGllbnRTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgbGluZWFyR3JhZGllbnRcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geDBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHJldHVybiB7RmlsbH0gUmV0dXJucyB0aGlzIFN0cm9rZSBvYmplY3QgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXG5cdCAqL1xuXHRwLmxpbmVhckdyYWRpZW50ID0gRy5GaWxsLnByb3RvdHlwZS5saW5lYXJHcmFkaWVudDtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSByYWRpYWwgZ3JhZGllbnQgc3R5bGUgYW5kIGFzc2lnbnMgaXQgdG8ge3sjY3Jvc3NMaW5rIFwiU3Ryb2tlL3N0eWxlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5SYWRpYWxHcmFkaWVudFN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCByYWRpYWxHcmFkaWVudFxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnNcblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MFxuXHQgKiBAcGFyYW0ge051bWJlcn0geTBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIxXG5cdCAqIEByZXR1cm4ge0ZpbGx9IFJldHVybnMgdGhpcyBTdHJva2Ugb2JqZWN0IGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKi9cblx0cC5yYWRpYWxHcmFkaWVudCA9IEcuRmlsbC5wcm90b3R5cGUucmFkaWFsR3JhZGllbnQ7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgYml0bWFwIGZpbGwgc3R5bGUgYW5kIGFzc2lnbnMgaXQgdG8ge3sjY3Jvc3NMaW5rIFwiU3Ryb2tlL3N0eWxlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5CaXRtYXBTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgYml0bWFwXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1hZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmd9IFtyZXBldGl0aW9uXSBPbmUgb2Y6IHJlcGVhdCwgcmVwZWF0LXgsIHJlcGVhdC15LCBvciBuby1yZXBlYXQuXG5cdCAqIEByZXR1cm4ge0ZpbGx9IFJldHVybnMgdGhpcyBTdHJva2Ugb2JqZWN0IGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKi9cblx0cC5iaXRtYXAgPSBHLkZpbGwucHJvdG90eXBlLmJpdG1hcDtcblx0cC5wYXRoID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc2V0U3Ryb2tlU3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFN0cm9rZVN0eWxlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0ICogQHBhcmFtIHtTdHJpbmd9IFtjYXBzPWJ1dHRdXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbam9pbnRzPW1pdGVyXVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21pdGVyTGltaXQ9MTBdXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZVNjYWxlPWZhbHNlXVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgd2lkdGhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogT25lIG9mOiBidXR0LCByb3VuZCwgc3F1YXJlXG5cdCAqIEBwcm9wZXJ0eSBjYXBzXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKi9cblx0LyoqXG5cdCAqIE9uZSBvZjogcm91bmQsIGJldmVsLCBtaXRlclxuXHQgKiBAcHJvcGVydHkgam9pbnRzXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBtaXRlckxpbWl0XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHRwID0gKEcuU3Ryb2tlU3R5bGUgPSBmdW5jdGlvbih3aWR0aCwgY2Fwcywgam9pbnRzLCBtaXRlckxpbWl0LCBpZ25vcmVTY2FsZSkge1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmNhcHMgPSBjYXBzO1xuXHRcdHRoaXMuam9pbnRzID0gam9pbnRzO1xuXHRcdHRoaXMubWl0ZXJMaW1pdCA9IG1pdGVyTGltaXQ7XG5cdFx0dGhpcy5pZ25vcmVTY2FsZSA9IGlnbm9yZVNjYWxlO1xuXHR9KS5wcm90b3R5cGU7XG5cdHAuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGN0eC5saW5lV2lkdGggPSAodGhpcy53aWR0aCA9PSBudWxsID8gXCIxXCIgOiB0aGlzLndpZHRoKTtcblx0XHRjdHgubGluZUNhcCA9ICh0aGlzLmNhcHMgPT0gbnVsbCA/IFwiYnV0dFwiIDogKGlzTmFOKHRoaXMuY2FwcykgPyB0aGlzLmNhcHMgOiBHcmFwaGljcy5TVFJPS0VfQ0FQU19NQVBbdGhpcy5jYXBzXSkpO1xuXHRcdGN0eC5saW5lSm9pbiA9ICh0aGlzLmpvaW50cyA9PSBudWxsID8gXCJtaXRlclwiIDogKGlzTmFOKHRoaXMuam9pbnRzKSA/IHRoaXMuam9pbnRzIDogR3JhcGhpY3MuU1RST0tFX0pPSU5UU19NQVBbdGhpcy5qb2ludHNdKSk7XG5cdFx0Y3R4Lm1pdGVyTGltaXQgPSAodGhpcy5taXRlckxpbWl0ID09IG51bGwgPyBcIjEwXCIgOiB0aGlzLm1pdGVyTGltaXQpO1xuXHRcdGN0eC5pZ25vcmVTY2FsZSA9ICh0aGlzLmlnbm9yZVNjYWxlID09IG51bGwgPyBmYWxzZSA6IHRoaXMuaWdub3JlU2NhbGUpO1xuXHR9O1xuXHRwLnBhdGggPSBmYWxzZTtcblx0XG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3NldFN0cm9rZURhc2hcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFN0cm9rZURhc2hcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtzZWdtZW50c11cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXQ9MF1cblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHNlZ21lbnRzXG5cdCAqIEB0eXBlIEFycmF5XG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IG9mZnNldFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuU3Ryb2tlRGFzaCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBvZmZzZXQpIHtcblx0XHR0aGlzLnNlZ21lbnRzID0gc2VnbWVudHM7XG5cdFx0dGhpcy5vZmZzZXQgPSBvZmZzZXR8fDA7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkgeyAvLyBmZWF0dXJlIGRldGVjdGlvbi5cblx0XHRcdGN0eC5zZXRMaW5lRGFzaCh0aGlzLnNlZ21lbnRzfHwgRy5TdHJva2VEYXNoLkVNUFRZX1NFR01FTlRTKTsgLy8gaW5zdGVhZCBvZiBbXSB0byByZWR1Y2UgY2h1cm4uXG5cdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSB0aGlzLm9mZnNldHx8MDtcblx0XHR9XG5cdH07XG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCB2YWx1ZSBmb3Igc2VnbWVudHMgKGllLiBubyBkYXNoKS5cblx0ICogQHByb3BlcnR5IEVNUFRZX1NFR01FTlRTXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqIEByZWFkb25seVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICoqL1xuXHRHLlN0cm9rZURhc2guRU1QVFlfU0VHTUVOVFMgPSBbXTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Um91bmRSZWN0Q29tcGxleFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgUm91bmRSZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gd1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVExcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1RSXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCUlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQkxcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHdcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c1RMXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNUUlxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzQlJcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c0JMXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5Sb3VuZFJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoLCByYWRpdXNUTCwgcmFkaXVzVFIsIHJhZGl1c0JSLCByYWRpdXNCTCkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdFx0dGhpcy53ID0gdzsgdGhpcy5oID0gaDtcblx0XHR0aGlzLnJhZGl1c1RMID0gcmFkaXVzVEw7IHRoaXMucmFkaXVzVFIgPSByYWRpdXNUUjtcblx0XHR0aGlzLnJhZGl1c0JSID0gcmFkaXVzQlI7IHRoaXMucmFkaXVzQkwgPSByYWRpdXNCTDtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgbWF4ID0gKHc8aD93OmgpLzI7XG5cdFx0dmFyIG1UTD0wLCBtVFI9MCwgbUJSPTAsIG1CTD0wO1xuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB3ID0gdGhpcy53LCBoID0gdGhpcy5oO1xuXHRcdHZhciByVEwgPSB0aGlzLnJhZGl1c1RMLCByVFIgPSB0aGlzLnJhZGl1c1RSLCByQlIgPSB0aGlzLnJhZGl1c0JSLCByQkwgPSB0aGlzLnJhZGl1c0JMO1xuXG5cdFx0aWYgKHJUTCA8IDApIHsgclRMICo9IChtVEw9LTEpOyB9XG5cdFx0aWYgKHJUTCA+IG1heCkgeyByVEwgPSBtYXg7IH1cblx0XHRpZiAoclRSIDwgMCkgeyByVFIgKj0gKG1UUj0tMSk7IH1cblx0XHRpZiAoclRSID4gbWF4KSB7IHJUUiA9IG1heDsgfVxuXHRcdGlmIChyQlIgPCAwKSB7IHJCUiAqPSAobUJSPS0xKTsgfVxuXHRcdGlmIChyQlIgPiBtYXgpIHsgckJSID0gbWF4OyB9XG5cdFx0aWYgKHJCTCA8IDApIHsgckJMICo9IChtQkw9LTEpOyB9XG5cdFx0aWYgKHJCTCA+IG1heCkgeyByQkwgPSBtYXg7IH1cblxuXHRcdGN0eC5tb3ZlVG8oeCt3LXJUUiwgeSk7XG5cdFx0Y3R4LmFyY1RvKHgrdytyVFIqbVRSLCB5LXJUUiptVFIsIHgrdywgeStyVFIsIHJUUik7XG5cdFx0Y3R4LmxpbmVUbyh4K3csIHkraC1yQlIpO1xuXHRcdGN0eC5hcmNUbyh4K3crckJSKm1CUiwgeStoK3JCUiptQlIsIHgrdy1yQlIsIHkraCwgckJSKTtcblx0XHRjdHgubGluZVRvKHgrckJMLCB5K2gpO1xuXHRcdGN0eC5hcmNUbyh4LXJCTCptQkwsIHkraCtyQkwqbUJMLCB4LCB5K2gtckJMLCByQkwpO1xuXHRcdGN0eC5saW5lVG8oeCwgeStyVEwpO1xuXHRcdGN0eC5hcmNUbyh4LXJUTCptVEwsIHktclRMKm1UTCwgeCtyVEwsIHksIHJUTCk7XG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIENpcmNsZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5DaXJjbGUgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHguYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnJhZGl1cywgMCwgTWF0aC5QSSoyKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3RWxsaXBzZVwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgRWxsaXBzZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHdcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLkVsbGlwc2UgPSBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0XHR0aGlzLncgPSB3OyB0aGlzLmggPSBoO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuXHRcdHZhciB3ID0gdGhpcy53LCBoID0gdGhpcy5oO1xuXG5cdFx0dmFyIGsgPSAwLjU1MjI4NDg7XG5cdFx0dmFyIG94ID0gKHcgLyAyKSAqIGs7XG5cdFx0dmFyIG95ID0gKGggLyAyKSAqIGs7XG5cdFx0dmFyIHhlID0geCArIHc7XG5cdFx0dmFyIHllID0geSArIGg7XG5cdFx0dmFyIHhtID0geCArIHcgLyAyO1xuXHRcdHZhciB5bSA9IHkgKyBoIC8gMjtcblxuXHRcdGN0eC5tb3ZlVG8oeCwgeW0pO1xuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHltLW95LCB4bS1veCwgeSwgeG0sIHkpO1xuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKHhtK294LCB5LCB4ZSwgeW0tb3ksIHhlLCB5bSk7XG5cdFx0Y3R4LmJlemllckN1cnZlVG8oeGUsIHltK295LCB4bStveCwgeWUsIHhtLCB5ZSk7XG5cdFx0Y3R4LmJlemllckN1cnZlVG8oeG0tb3gsIHllLCB4LCB5bStveSwgeCwgeW0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdQb2x5U3RhclwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgUG9seVN0YXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNpZGVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludFNpemVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHNpZGVzXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBwb2ludFNpemVcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGFuZ2xlXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5Qb2x5U3RhciA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cywgc2lkZXMsIHBvaW50U2l6ZSwgYW5nbGUpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHRcdHRoaXMuc2lkZXMgPSBzaWRlcztcblx0XHR0aGlzLnBvaW50U2l6ZSA9IHBvaW50U2l6ZTtcblx0XHR0aGlzLmFuZ2xlID0gYW5nbGU7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG5cdFx0dmFyIHJhZGl1cyA9IHRoaXMucmFkaXVzO1xuXHRcdHZhciBhbmdsZSA9ICh0aGlzLmFuZ2xlfHwwKS8xODAqTWF0aC5QSTtcblx0XHR2YXIgc2lkZXMgPSB0aGlzLnNpZGVzO1xuXHRcdHZhciBwcyA9IDEtKHRoaXMucG9pbnRTaXplfHwwKTtcblx0XHR2YXIgYSA9IE1hdGguUEkvc2lkZXM7XG5cblx0XHRjdHgubW92ZVRvKHgrTWF0aC5jb3MoYW5nbGUpKnJhZGl1cywgeStNYXRoLnNpbihhbmdsZSkqcmFkaXVzKTtcblx0XHRmb3IgKHZhciBpPTA7IGk8c2lkZXM7IGkrKykge1xuXHRcdFx0YW5nbGUgKz0gYTtcblx0XHRcdGlmIChwcyAhPSAxKSB7XG5cdFx0XHRcdGN0eC5saW5lVG8oeCtNYXRoLmNvcyhhbmdsZSkqcmFkaXVzKnBzLCB5K01hdGguc2luKGFuZ2xlKSpyYWRpdXMqcHMpO1xuXHRcdFx0fVxuXHRcdFx0YW5nbGUgKz0gYTtcblx0XHRcdGN0eC5saW5lVG8oeCtNYXRoLmNvcyhhbmdsZSkqcmFkaXVzLCB5K01hdGguc2luKGFuZ2xlKSpyYWRpdXMpO1xuXHRcdH1cblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdH07XG5cblx0Ly8gZG9jY2VkIGFib3ZlLlxuXHRHcmFwaGljcy5iZWdpbkNtZCA9IG5ldyBHLkJlZ2luUGF0aCgpOyAvLyBzbyB3ZSBkb24ndCBoYXZlIHRvIGluc3RhbnRpYXRlIG11bHRpcGxlIGluc3RhbmNlcy5cblxuXG5cdGNyZWF0ZWpzLkdyYXBoaWNzID0gR3JhcGhpY3M7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRGlzcGxheU9iamVjdC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIERpc3BsYXlPYmplY3QgaXMgYW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBzaG91bGQgbm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5LiBJbnN0ZWFkIGNvbnN0cnVjdCBzdWJjbGFzc2VzIHN1Y2ggYXNcblx0ICoge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJCaXRtYXBcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogRGlzcGxheU9iamVjdCBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIGRpc3BsYXkgY2xhc3NlcyBpbiB0aGUgRWFzZWxKUyBsaWJyYXJ5LiBJdCBkZWZpbmVzIHRoZSBjb3JlIHByb3BlcnRpZXMgYW5kXG5cdCAqIG1ldGhvZHMgdGhhdCBhcmUgc2hhcmVkIGJldHdlZW4gYWxsIGRpc3BsYXkgb2JqZWN0cywgc3VjaCBhcyB0cmFuc2Zvcm1hdGlvbiBwcm9wZXJ0aWVzICh4LCB5LCBzY2FsZVgsIHNjYWxlWSwgZXRjKSxcblx0ICogY2FjaGluZywgYW5kIG1vdXNlIGhhbmRsZXJzLlxuXHQgKiBAY2xhc3MgRGlzcGxheU9iamVjdFxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gRGlzcGxheU9iamVjdCgpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgYWxwaGEgKHRyYW5zcGFyZW5jeSkgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuIDAgaXMgZnVsbHkgdHJhbnNwYXJlbnQsIDEgaXMgZnVsbHkgb3BhcXVlLlxuXHRcdCAqIEBwcm9wZXJ0eSBhbHBoYVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqKi9cblx0XHR0aGlzLmFscGhhID0gMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgYSBjYWNoZSBpcyBhY3RpdmUsIHRoaXMgcmV0dXJucyB0aGUgY2FudmFzIHRoYXQgaG9sZHMgdGhlIGNhY2hlZCB2ZXJzaW9uIG9mIHRoaXMgZGlzcGxheSBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJjYWNoZVwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBjYWNoZUNhbnZhc1xuXHRcdCAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMuY2FjaGVDYW52YXMgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGFuIElEIG51bWJlciB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhlIGN1cnJlbnQgY2FjaGUgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWQgdG9cblx0XHQgKiBkZXRlcm1pbmUgaWYgdGhlIGNhY2hlIGhhcyBjaGFuZ2VkIHNpbmNlIGEgcHJldmlvdXMgY2hlY2suXG5cdFx0ICogQHByb3BlcnR5IGNhY2hlSURcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmNhY2hlSUQgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBVbmlxdWUgSUQgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuIE1ha2VzIGRpc3BsYXkgb2JqZWN0cyBlYXNpZXIgZm9yIHNvbWUgdXNlcy5cblx0XHQgKiBAcHJvcGVydHkgaWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IC0xXG5cdFx0ICoqL1xuXHRcdHRoaXMuaWQgPSBjcmVhdGVqcy5VSUQuZ2V0KCk7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRvIGluY2x1ZGUgdGhpcyBvYmplY3Qgd2hlbiBydW5uaW5nIG1vdXNlIGludGVyYWN0aW9ucy4gU2V0dGluZyB0aGlzIHRvIGBmYWxzZWAgZm9yIGNoaWxkcmVuXG5cdFx0ICogb2YgYSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0gd2lsbCBjYXVzZSBldmVudHMgb24gdGhlIENvbnRhaW5lciB0byBub3QgZmlyZSB3aGVuIHRoYXQgY2hpbGQgaXNcblx0XHQgKiBjbGlja2VkLiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgdG8gYGZhbHNlYCBkb2VzIG5vdCBwcmV2ZW50IHRoZSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBtZXRob2QgZnJvbSByZXR1cm5pbmcgdGhlIGNoaWxkLlxuXHRcdCAqXG5cdFx0ICogPHN0cm9uZz5Ob3RlOjwvc3Ryb25nPiBJbiBFYXNlbEpTIDAuNy4wLCB0aGUgbW91c2VFbmFibGVkIHByb3BlcnR5IHdpbGwgbm90IHdvcmsgcHJvcGVybHkgd2l0aCBuZXN0ZWQgQ29udGFpbmVycy4gUGxlYXNlXG5cdFx0ICogY2hlY2sgb3V0IHRoZSBsYXRlc3QgTkVYVCB2ZXJzaW9uIGluIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vQ3JlYXRlSlMvRWFzZWxKUy90cmVlL21hc3Rlci9saWJcIj5HaXRIdWI8L2E+IGZvciBhbiB1cGRhdGVkIHZlcnNpb24gd2l0aCB0aGlzIGlzc3VlIHJlc29sdmVkLiBUaGUgZml4IHdpbGwgYmVcblx0XHQgKiBwcm92aWRlZCBpbiB0aGUgbmV4dCByZWxlYXNlIG9mIEVhc2VsSlMuXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlRW5hYmxlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiovXG5cdFx0dGhpcy5tb3VzZUVuYWJsZWQgPSB0cnVlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIElmIGZhbHNlLCB0aGUgdGljayB3aWxsIG5vdCBydW4gb24gdGhpcyBkaXNwbGF5IG9iamVjdCAob3IgaXRzIGNoaWxkcmVuKS4gVGhpcyBjYW4gcHJvdmlkZSBzb21lIHBlcmZvcm1hbmNlIGJlbmVmaXRzLlxuXHRcdCAqIEluIGFkZGl0aW9uIHRvIHByZXZlbnRpbmcgdGhlIFwidGlja1wiIGV2ZW50IGZyb20gYmVpbmcgZGlzcGF0Y2hlZCwgaXQgd2lsbCBhbHNvIHByZXZlbnQgdGljayByZWxhdGVkIHVwZGF0ZXNcblx0XHQgKiBvbiBzb21lIGRpc3BsYXkgb2JqZWN0cyAoZXguIFNwcml0ZSAmIE1vdmllQ2xpcCBmcmFtZSBhZHZhbmNpbmcsIERPTUVsZW1lbnQgdmlzaWJpbGl0eSBoYW5kbGluZykuXG5cdFx0ICogQHByb3BlcnR5IHRpY2tFbmFibGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiovXG5cdFx0dGhpcy50aWNrRW5hYmxlZCA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9wdGlvbmFsIG5hbWUgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuIEluY2x1ZGVkIGluIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvdG9TdHJpbmdcIn19e3svY3Jvc3NMaW5rfX0gLiBVc2VmdWwgZm9yXG5cdFx0ICogZGVidWdnaW5nLlxuXHRcdCAqIEBwcm9wZXJ0eSBuYW1lXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMubmFtZSA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEEgcmVmZXJlbmNlIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0gb2JqZWN0IHRoYXRcblx0XHQgKiBjb250YWlucyB0aGlzIGRpc3BsYXkgb2JqZWN0LCBvciBudWxsIGlmIGl0IGhhcyBub3QgYmVlbiBhZGRlZFxuXHRcdCAqIHRvIG9uZS5cblx0XHQgKiBAcHJvcGVydHkgcGFyZW50XG5cdFx0ICogQGZpbmFsXG5cdFx0ICogQHR5cGUge0NvbnRhaW5lcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMucGFyZW50ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGxlZnQgb2Zmc2V0IGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0J3MgcmVnaXN0cmF0aW9uIHBvaW50LiBGb3IgZXhhbXBsZSwgdG8gbWFrZSBhIDEwMHgxMDBweCBCaXRtYXAgcm90YXRlXG5cdFx0ICogYXJvdW5kIGl0cyBjZW50ZXIsIHlvdSB3b3VsZCBzZXQgcmVnWCBhbmQge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9yZWdZOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHRvIDUwLlxuXHRcdCAqIEBwcm9wZXJ0eSByZWdYXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMucmVnWCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB5IG9mZnNldCBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdCdzIHJlZ2lzdHJhdGlvbiBwb2ludC4gRm9yIGV4YW1wbGUsIHRvIG1ha2UgYSAxMDB4MTAwcHggQml0bWFwIHJvdGF0ZSBhcm91bmRcblx0XHQgKiBpdHMgY2VudGVyLCB5b3Ugd291bGQgc2V0IHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvcmVnWDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBhbmQgcmVnWSB0byA1MC5cblx0XHQgKiBAcHJvcGVydHkgcmVnWVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLnJlZ1kgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgcm90YXRpb24gaW4gZGVncmVlcyBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgcm90YXRpb25cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5yb3RhdGlvbiA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBmYWN0b3IgdG8gc3RyZXRjaCB0aGlzIGRpc3BsYXkgb2JqZWN0IGhvcml6b250YWxseS4gRm9yIGV4YW1wbGUsIHNldHRpbmcgc2NhbGVYIHRvIDIgd2lsbCBzdHJldGNoIHRoZSBkaXNwbGF5XG5cdFx0ICogb2JqZWN0IHRvIHR3aWNlIGl0cyBub21pbmFsIHdpZHRoLiBUbyBob3Jpem9udGFsbHkgZmxpcCBhbiBvYmplY3QsIHNldCB0aGUgc2NhbGUgdG8gYSBuZWdhdGl2ZSBudW1iZXIuXG5cdFx0ICogQHByb3BlcnR5IHNjYWxlWFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqKi9cblx0XHR0aGlzLnNjYWxlWCA9IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBmYWN0b3IgdG8gc3RyZXRjaCB0aGlzIGRpc3BsYXkgb2JqZWN0IHZlcnRpY2FsbHkuIEZvciBleGFtcGxlLCBzZXR0aW5nIHNjYWxlWSB0byAwLjUgd2lsbCBzdHJldGNoIHRoZSBkaXNwbGF5XG5cdFx0ICogb2JqZWN0IHRvIGhhbGYgaXRzIG5vbWluYWwgaGVpZ2h0LiBUbyB2ZXJ0aWNhbGx5IGZsaXAgYW4gb2JqZWN0LCBzZXQgdGhlIHNjYWxlIHRvIGEgbmVnYXRpdmUgbnVtYmVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBzY2FsZVlcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiovXG5cdFx0dGhpcy5zY2FsZVkgPSAxO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgZmFjdG9yIHRvIHNrZXcgdGhpcyBkaXNwbGF5IG9iamVjdCBob3Jpem9udGFsbHkuXG5cdFx0ICogQHByb3BlcnR5IHNrZXdYXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuc2tld1ggPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgZmFjdG9yIHRvIHNrZXcgdGhpcyBkaXNwbGF5IG9iamVjdCB2ZXJ0aWNhbGx5LlxuXHRcdCAqIEBwcm9wZXJ0eSBza2V3WVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLnNrZXdZID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQSBzaGFkb3cgb2JqZWN0IHRoYXQgZGVmaW5lcyB0aGUgc2hhZG93IHRvIHJlbmRlciBvbiB0aGlzIGRpc3BsYXkgb2JqZWN0LiBTZXQgdG8gYG51bGxgIHRvIHJlbW92ZSBhIHNoYWRvdy4gSWZcblx0XHQgKiBudWxsLCB0aGlzIHByb3BlcnR5IGlzIGluaGVyaXRlZCBmcm9tIHRoZSBwYXJlbnQgY29udGFpbmVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBzaGFkb3dcblx0XHQgKiBAdHlwZSB7U2hhZG93fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5zaGFkb3cgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGRpc3BsYXkgb2JqZWN0IHNob3VsZCBiZSByZW5kZXJlZCB0byB0aGUgY2FudmFzIGFuZCBpbmNsdWRlZCB3aGVuIHJ1bm5pbmcgdGhlIFN0YWdlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHRcdCAqIEBwcm9wZXJ0eSB2aXNpYmxlXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgeCAoaG9yaXpvbnRhbCkgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LCByZWxhdGl2ZSB0byBpdHMgcGFyZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSB4XG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMueCA9IDA7XG5cdFxuXHRcdC8qKiBUaGUgeSAodmVydGljYWwpIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5IG9iamVjdCwgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC5cblx0XHQgKiBAcHJvcGVydHkgeVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLnkgPSAwO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIElmIHNldCwgZGVmaW5lcyB0aGUgdHJhbnNmb3JtYXRpb24gZm9yIHRoaXMgZGlzcGxheSBvYmplY3QsIG92ZXJyaWRpbmcgYWxsIG90aGVyIHRyYW5zZm9ybWF0aW9uIHByb3BlcnRpZXNcblx0XHQgKiAoeCwgeSwgcm90YXRpb24sIHNjYWxlLCBza2V3KS5cblx0XHQgKiBAcHJvcGVydHkgdHJhbnNmb3JtTWF0cml4XG5cdFx0ICogQHR5cGUge01hdHJpeDJEfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy50cmFuc2Zvcm1NYXRyaXggPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb21wb3NpdGUgb3BlcmF0aW9uIGluZGljYXRlcyBob3cgdGhlIHBpeGVscyBvZiB0aGlzIGRpc3BsYXkgb2JqZWN0IHdpbGwgYmUgY29tcG9zaXRlZCB3aXRoIHRoZSBlbGVtZW50c1xuXHRcdCAqIGJlaGluZCBpdC4gSWYgYG51bGxgLCB0aGlzIHByb3BlcnR5IGlzIGluaGVyaXRlZCBmcm9tIHRoZSBwYXJlbnQgY29udGFpbmVyLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0XHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjY29tcG9zaXRpbmdcIj5cblx0XHQgKiB3aGF0d2cgc3BlYyBvbiBjb21wb3NpdGluZzwvYT4uXG5cdFx0ICogQHByb3BlcnR5IGNvbXBvc2l0ZU9wZXJhdGlvblxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCBzaG91bGQgYmUgZHJhd24gdG8gYSB3aG9sZSBwaXhlbCB3aGVuXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiU3RhZ2Uvc25hcFRvUGl4ZWxFbmFibGVkXCJ9fXt7L2Nyb3NzTGlua319IGlzIHRydWUuIFRvIGVuYWJsZS9kaXNhYmxlIHNuYXBwaW5nIG9uIHdob2xlXG5cdFx0ICogY2F0ZWdvcmllcyBvZiBkaXNwbGF5IG9iamVjdHMsIHNldCB0aGlzIHZhbHVlIG9uIHRoZSBwcm90b3R5cGUgKEV4LiBUZXh0LnByb3RvdHlwZS5zbmFwVG9QaXhlbCA9IHRydWUpLlxuXHRcdCAqIEBwcm9wZXJ0eSBzbmFwVG9QaXhlbFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiovXG5cdFx0dGhpcy5zbmFwVG9QaXhlbCA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIEZpbHRlciBvYmplY3RzIHRvIGFwcGx5IHRvIHRoaXMgZGlzcGxheSBvYmplY3QuIEZpbHRlcnMgYXJlIG9ubHkgYXBwbGllZCAvIHVwZGF0ZWQgd2hlbiB7eyNjcm9zc0xpbmsgXCJjYWNoZVwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIG9yIHt7I2Nyb3NzTGluayBcInVwZGF0ZUNhY2hlXCJ9fXt7L2Nyb3NzTGlua319IGlzIGNhbGxlZCBvbiB0aGUgZGlzcGxheSBvYmplY3QsIGFuZCBvbmx5IGFwcGx5IHRvIHRoZSBhcmVhIHRoYXQgaXNcblx0XHQgKiBjYWNoZWQuXG5cdFx0ICogQHByb3BlcnR5IGZpbHRlcnNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLmZpbHRlcnMgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEEgU2hhcGUgaW5zdGFuY2UgdGhhdCBkZWZpbmVzIGEgdmVjdG9yIG1hc2sgKGNsaXBwaW5nIHBhdGgpIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LiAgVGhlIHNoYXBlJ3MgdHJhbnNmb3JtYXRpb25cblx0XHQgKiB3aWxsIGJlIGFwcGxpZWQgcmVsYXRpdmUgdG8gdGhlIGRpc3BsYXkgb2JqZWN0J3MgcGFyZW50IGNvb3JkaW5hdGVzIChhcyBpZiBpdCB3ZXJlIGEgY2hpbGQgb2YgdGhlIHBhcmVudCkuXG5cdFx0ICogQHByb3BlcnR5IG1hc2tcblx0XHQgKiBAdHlwZSB7U2hhcGV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMubWFzayA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQSBkaXNwbGF5IG9iamVjdCB0aGF0IHdpbGwgYmUgdGVzdGVkIHdoZW4gY2hlY2tpbmcgbW91c2UgaW50ZXJhY3Rpb25zIG9yIHRlc3Rpbmcge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL2dldE9iamVjdHNVbmRlclBvaW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIFRoZSBoaXQgYXJlYSB3aWxsIGhhdmUgaXRzIHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQgcmVsYXRpdmUgdG8gdGhpcyBkaXNwbGF5IG9iamVjdCdzIGNvb3JkaW5hdGUgc3BhY2UgKGFzIHRob3VnaFxuXHRcdCAqIHRoZSBoaXQgdGVzdCBvYmplY3Qgd2VyZSBhIGNoaWxkIG9mIHRoaXMgZGlzcGxheSBvYmplY3QgYW5kIHJlbGF0aXZlIHRvIGl0cyByZWdYL1kpLiBUaGUgaGl0QXJlYSB3aWxsIGJlIHRlc3RlZFxuXHRcdCAqIHVzaW5nIG9ubHkgaXRzIG93biBgYWxwaGFgIHZhbHVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGFscGhhIHZhbHVlIG9uIHRoZSB0YXJnZXQgZGlzcGxheSBvYmplY3QsIG9yIHRoZSB0YXJnZXQnc1xuXHRcdCAqIGFuY2VzdG9ycyAocGFyZW50cykuXG5cdFx0ICogXG5cdFx0ICogSWYgc2V0IG9uIGEge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319LCBjaGlsZHJlbiBvZiB0aGUgQ29udGFpbmVyIHdpbGwgbm90IHJlY2VpdmUgbW91c2UgZXZlbnRzLlxuXHRcdCAqIFRoaXMgaXMgc2ltaWxhciB0byBzZXR0aW5nIHt7I2Nyb3NzTGluayBcIm1vdXNlQ2hpbGRyZW5cIn19e3svY3Jvc3NMaW5rfX0gdG8gZmFsc2UuXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgaGl0QXJlYSBpcyBOT1QgY3VycmVudGx5IHVzZWQgYnkgdGhlIGBoaXRUZXN0KClgIG1ldGhvZCwgbm9yIGlzIGl0IHN1cHBvcnRlZCBmb3Ige3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IGhpdEFyZWFcblx0XHQgKiBAdHlwZSB7RGlzcGxheU9iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5oaXRBcmVhID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBIENTUyBjdXJzb3IgKGV4LiBcInBvaW50ZXJcIiwgXCJoZWxwXCIsIFwidGV4dFwiLCBldGMpIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgdXNlciBob3ZlcnMgb3ZlciB0aGlzIGRpc3BsYXlcblx0XHQgKiBvYmplY3QuIFlvdSBtdXN0IGVuYWJsZSBtb3VzZW92ZXIgZXZlbnRzIHVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJTdGFnZS9lbmFibGVNb3VzZU92ZXJcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHRvXG5cdFx0ICogdXNlIHRoaXMgcHJvcGVydHkuIFNldHRpbmcgYSBub24tbnVsbCBjdXJzb3Igb24gYSBDb250YWluZXIgd2lsbCBvdmVycmlkZSB0aGUgY3Vyc29yIHNldCBvbiBpdHMgZGVzY2VuZGFudHMuXG5cdFx0ICogQHByb3BlcnR5IGN1cnNvclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuY3Vyc29yID0gbnVsbDtcblx0XG5cdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9jYWNoZU9mZnNldFhcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2NhY2hlT2Zmc2V0WCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfY2FjaGVPZmZzZXRZXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLl9jYWNoZU9mZnNldFkgPSAwO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZmlsdGVyT2Zmc2V0WFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5fZmlsdGVyT2Zmc2V0WCA9IDA7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9maWx0ZXJPZmZzZXRZXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLl9maWx0ZXJPZmZzZXRZID0gMDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2NhY2hlU2NhbGVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2NhY2hlU2NhbGUgPSAxO1xuXHRcblx0XHQvKipcblx0XHQqIEBwcm9wZXJ0eSBfY2FjaGVEYXRhVVJMSURcblx0XHQqIEBwcm90ZWN0ZWRcblx0XHQqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0KiBAZGVmYXVsdCAwXG5cdFx0Ki9cblx0XHR0aGlzLl9jYWNoZURhdGFVUkxJRCA9IDA7XG5cdFx0XG5cdFx0LyoqXG5cdFx0KiBAcHJvcGVydHkgX2NhY2hlRGF0YVVSTFxuXHRcdCogQHByb3RlY3RlZFxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0IG51bGxcblx0XHQqL1xuXHRcdHRoaXMuX2NhY2hlRGF0YVVSTCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJvcHNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0Rpc3BsYXlPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLl9wcm9wcyA9IG5ldyBjcmVhdGVqcy5EaXNwbGF5UHJvcHMoKTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9yZWN0YW5nbGVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge1JlY3RhbmdsZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3JlY3RhbmdsZSA9IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoKTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9ib3VuZHNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge1JlY3RhbmdsZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2JvdW5kcyA9IG51bGw7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoRGlzcGxheU9iamVjdCwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblx0XG4vLyBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIExpc3Rpbmcgb2YgbW91c2UgZXZlbnQgbmFtZXMuIFVzZWQgaW4gX2hhc01vdXNlRXZlbnRMaXN0ZW5lci5cblx0ICogQHByb3BlcnR5IF9NT1VTRV9FVkVOVFNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICoqL1xuXHREaXNwbGF5T2JqZWN0Ll9NT1VTRV9FVkVOVFMgPSBbXCJjbGlja1wiLFwiZGJsY2xpY2tcIixcIm1vdXNlZG93blwiLFwibW91c2VvdXRcIixcIm1vdXNlb3ZlclwiLFwicHJlc3Ntb3ZlXCIsXCJwcmVzc3VwXCIsXCJyb2xsb3V0XCIsXCJyb2xsb3ZlclwiXTtcblxuXHQvKipcblx0ICogU3VwcHJlc3NlcyBlcnJvcnMgZ2VuZXJhdGVkIHdoZW4gdXNpbmcgZmVhdHVyZXMgbGlrZSBoaXRUZXN0LCBtb3VzZSBldmVudHMsIGFuZCB7eyNjcm9zc0xpbmsgXCJnZXRPYmplY3RzVW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aXRoIGNyb3NzIGRvbWFpbiBjb250ZW50LlxuXHQgKiBAcHJvcGVydHkgc3VwcHJlc3NDcm9zc0RvbWFpbkVycm9yc1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKiovXG5cdERpc3BsYXlPYmplY3Quc3VwcHJlc3NDcm9zc0RvbWFpbkVycm9ycyA9IGZhbHNlO1xuXHRcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfc25hcFRvUGl4ZWxFbmFibGVkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICoqL1xuXHREaXNwbGF5T2JqZWN0Ll9zbmFwVG9QaXhlbEVuYWJsZWQgPSBmYWxzZTsgLy8gc3RhZ2Uuc25hcFRvUGl4ZWxFbmFibGVkIGlzIHRlbXBvcmFyaWx5IGNvcGllZCBoZXJlIGR1cmluZyBhIGRyYXcgdG8gcHJvdmlkZSBnbG9iYWwgYWNjZXNzLlxuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2hpdFRlc3RDYW52YXNcblx0ICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50IHwgT2JqZWN0fVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IF9oaXRUZXN0Q29udGV4dFxuXHQgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHR2YXIgY2FudmFzID0gY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7IC8vIHByZXZlbnQgZXJyb3JzIG9uIGxvYWQgaW4gYnJvd3NlcnMgd2l0aG91dCBjYW52YXMuXG5cdGlmIChjYW52YXMuZ2V0Q29udGV4dCkge1xuXHRcdERpc3BsYXlPYmplY3QuX2hpdFRlc3RDYW52YXMgPSBjYW52YXM7XG5cdFx0RGlzcGxheU9iamVjdC5faGl0VGVzdENvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfbmV4dENhY2hlSURcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0RGlzcGxheU9iamVjdC5fbmV4dENhY2hlSUQgPSAxO1xuXG5cbi8vIGV2ZW50czpcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZWlyIGxlZnQgbW91c2UgYnV0dG9uIG92ZXIgdGhlIGRpc3BsYXkgb2JqZWN0LiBTZWUgdGhlIFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IG1vdXNlZG93blxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZWlyIGxlZnQgbW91c2UgYnV0dG9uIGFuZCB0aGVuIHJlbGVhc2VzIGl0IHdoaWxlIG92ZXIgdGhlIGRpc3BsYXkgb2JqZWN0LlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgY2xpY2tcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIgZG91YmxlIGNsaWNrcyB0aGVpciBsZWZ0IG1vdXNlIGJ1dHRvbiBvdmVyIHRoaXMgZGlzcGxheSBvYmplY3QuXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBkYmxjbGlja1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlcidzIG1vdXNlIGVudGVycyB0aGlzIGRpc3BsYXkgb2JqZWN0LiBUaGlzIGV2ZW50IG11c3QgYmUgZW5hYmxlZCB1c2luZyBcblx0ICoge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319LiBTZWUgYWxzbyB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JvbGxvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgbW91c2VvdmVyXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyJ3MgbW91c2UgbGVhdmVzIHRoaXMgZGlzcGxheSBvYmplY3QuIFRoaXMgZXZlbnQgbXVzdCBiZSBlbmFibGVkIHVzaW5nIFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTdGFnZS9lbmFibGVNb3VzZU92ZXJcIn19e3svY3Jvc3NMaW5rfX0uIFNlZSBhbHNvIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvcm9sbG91dDpldmVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IG1vdXNlb3V0XG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogVGhpcyBldmVudCBpcyBzaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LCB3aXRoIHRoZSBmb2xsb3dpbmdcblx0ICogZGlmZmVyZW5jZXM6IGl0IGRvZXMgbm90IGJ1YmJsZSwgYW5kIGl0IGNvbnNpZGVycyB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzIGFzIGFuXG5cdCAqIGFnZ3JlZ2F0ZSBvZiB0aGVpciBjb250ZW50LlxuXHQgKiBcblx0ICogRm9yIGV4YW1wbGUsIG15Q29udGFpbmVyIGNvbnRhaW5zIHR3byBvdmVybGFwcGluZyBjaGlsZHJlbjogc2hhcGVBIGFuZCBzaGFwZUIuIFRoZSB1c2VyIG1vdmVzIHRoZWlyIG1vdXNlIG92ZXJcblx0ICogc2hhcGVBIGFuZCB0aGVuIGRpcmVjdGx5IG9uIHRvIHNoYXBlQi4gV2l0aCBhIGxpc3RlbmVyIGZvciB7eyNjcm9zc0xpbmsgXCJtb3VzZW92ZXI6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gb25cblx0ICogbXlDb250YWluZXIsIHR3byBldmVudHMgd291bGQgYmUgcmVjZWl2ZWQsIGVhY2ggdGFyZ2V0aW5nIGEgY2hpbGQgZWxlbWVudDo8T0w+XG5cdCAqIDxMST53aGVuIHRoZSBtb3VzZSBlbnRlcnMgc2hhcGVBICh0YXJnZXQ9c2hhcGVBKTwvTEk+XG5cdCAqIDxMST53aGVuIHRoZSBtb3VzZSBlbnRlcnMgc2hhcGVCICh0YXJnZXQ9c2hhcGVCKTwvTEk+XG5cdCAqIDwvT0w+XG5cdCAqIEhvd2V2ZXIsIHdpdGggYSBsaXN0ZW5lciBmb3IgXCJyb2xsb3ZlclwiIGluc3RlYWQsIG9ubHkgYSBzaW5nbGUgZXZlbnQgaXMgcmVjZWl2ZWQgd2hlbiB0aGUgbW91c2UgZmlyc3QgZW50ZXJzXG5cdCAqIHRoZSBhZ2dyZWdhdGUgbXlDb250YWluZXIgY29udGVudCAodGFyZ2V0PW15Q29udGFpbmVyKS5cblx0ICogXG5cdCAqIFRoaXMgZXZlbnQgbXVzdCBiZSBlbmFibGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIlN0YWdlL2VuYWJsZU1vdXNlT3ZlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IHJvbGxvdmVyXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogVGhpcyBldmVudCBpcyBzaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VvdXQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0sIHdpdGggdGhlIGZvbGxvd2luZ1xuXHQgKiBkaWZmZXJlbmNlczogaXQgZG9lcyBub3QgYnViYmxlLCBhbmQgaXQgY29uc2lkZXJzIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgYXMgYW5cblx0ICogYWdncmVnYXRlIG9mIHRoZWlyIGNvbnRlbnQuXG5cdCAqIFxuXHQgKiBGb3IgZXhhbXBsZSwgbXlDb250YWluZXIgY29udGFpbnMgdHdvIG92ZXJsYXBwaW5nIGNoaWxkcmVuOiBzaGFwZUEgYW5kIHNoYXBlQi4gVGhlIHVzZXIgbW92ZXMgdGhlaXIgbW91c2Ugb3ZlclxuXHQgKiBzaGFwZUEsIHRoZW4gZGlyZWN0bHkgb24gdG8gc2hhcGVCLCB0aGVuIG9mZiBib3RoLiBXaXRoIGEgbGlzdGVuZXIgZm9yIHt7I2Nyb3NzTGluayBcIm1vdXNlb3V0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9uIG15Q29udGFpbmVyLCB0d28gZXZlbnRzIHdvdWxkIGJlIHJlY2VpdmVkLCBlYWNoIHRhcmdldGluZyBhIGNoaWxkIGVsZW1lbnQ6PE9MPlxuXHQgKiA8TEk+d2hlbiB0aGUgbW91c2UgbGVhdmVzIHNoYXBlQSAodGFyZ2V0PXNoYXBlQSk8L0xJPlxuXHQgKiA8TEk+d2hlbiB0aGUgbW91c2UgbGVhdmVzIHNoYXBlQiAodGFyZ2V0PXNoYXBlQik8L0xJPlxuXHQgKiA8L09MPlxuXHQgKiBIb3dldmVyLCB3aXRoIGEgbGlzdGVuZXIgZm9yIFwicm9sbG91dFwiIGluc3RlYWQsIG9ubHkgYSBzaW5nbGUgZXZlbnQgaXMgcmVjZWl2ZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzXG5cdCAqIHRoZSBhZ2dyZWdhdGUgbXlDb250YWluZXIgY29udGVudCAodGFyZ2V0PW15Q29udGFpbmVyKS5cblx0ICogXG5cdCAqIFRoaXMgZXZlbnQgbXVzdCBiZSBlbmFibGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIlN0YWdlL2VuYWJsZU1vdXNlT3ZlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IHJvbGxvdXRcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBBZnRlciBhIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2Vkb3duOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IG9jY3VycyBvbiBhIGRpc3BsYXkgb2JqZWN0LCBhIHByZXNzbW92ZVxuXHQgKiBldmVudCB3aWxsIGJlIGdlbmVyYXRlZCBvbiB0aGF0IG9iamVjdCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgdW50aWwgdGhlIG1vdXNlIHByZXNzIGlzIHJlbGVhc2VkLiBUaGlzIGNhbiBiZVxuXHQgKiB1c2VmdWwgZm9yIGRyYWdnaW5nIGFuZCBzaW1pbGFyIG9wZXJhdGlvbnMuXG5cdCAqIEBldmVudCBwcmVzc21vdmVcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBBZnRlciBhIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2Vkb3duOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IG9jY3VycyBvbiBhIGRpc3BsYXkgb2JqZWN0LCBhIHByZXNzdXAgZXZlbnRcblx0ICogd2lsbCBiZSBnZW5lcmF0ZWQgb24gdGhhdCBvYmplY3Qgd2hlbiB0aGF0IG1vdXNlIHByZXNzIGlzIHJlbGVhc2VkLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIGRyYWdnaW5nIGFuZCBzaW1pbGFyXG5cdCAqIG9wZXJhdGlvbnMuXG5cdCAqIEBldmVudCBwcmVzc3VwXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBkaXNwbGF5IG9iamVjdCBpcyBhZGRlZCB0byBhIHBhcmVudCBjb250YWluZXIuXG5cdCAqIEBldmVudCBhZGRlZFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBkaXNwbGF5IG9iamVjdCBpcyByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBjb250YWluZXIuXG5cdCAqIEBldmVudCByZW1vdmVkXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIG9uIGVhY2ggZGlzcGxheSBvYmplY3Qgb24gYSBzdGFnZSB3aGVuZXZlciB0aGUgc3RhZ2UgdXBkYXRlcy4gVGhpcyBvY2N1cnMgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZVxuXHQgKiByZW5kZXJpbmcgKGRyYXcpIHBhc3MuIFdoZW4ge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdXBkYXRlXCJ9fXt7L2Nyb3NzTGlua319IGlzIGNhbGxlZCwgZmlyc3QgYWxsIGRpc3BsYXkgb2JqZWN0cyBvblxuXHQgKiB0aGUgc3RhZ2UgZGlzcGF0Y2ggdGhlIHRpY2sgZXZlbnQsIHRoZW4gYWxsIG9mIHRoZSBkaXNwbGF5IG9iamVjdHMgYXJlIGRyYXduIHRvIHN0YWdlLiBDaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXJcblx0ICoge3sjY3Jvc3NMaW5rIFwidGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBkaXNwYXRjaGVkIGluIG9yZGVyIG9mIHRoZWlyIGRlcHRoIHByaW9yIHRvIHRoZSBldmVudCBiZWluZ1xuXHQgKiBkaXNwYXRjaGVkIG9uIHRoZWlyIHBhcmVudC5cblx0ICogQGV2ZW50IHRpY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgQW4gYXJyYXkgY29udGFpbmluZyBhbnkgYXJndW1lbnRzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIFN0YWdlLnVwZGF0ZSgpIG1ldGhvZC4gRm9yXG5cdCAqICAgICAgZXhhbXBsZSBpZiB5b3UgY2FsbGVkIHN0YWdlLnVwZGF0ZShcImhlbGxvXCIpLCB0aGVuIHRoZSBwYXJhbXMgd291bGQgYmUgW1wiaGVsbG9cIl0uXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0XG5cdFxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9zdGFnZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldFN0YWdlXG5cdCAqIEByZXR1cm4ge1N0YWdlfVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdHAuZ2V0U3RhZ2UgPSBmdW5jdGlvbigpIHtcblx0XHQvLyB1c2VzIGR5bmFtaWMgYWNjZXNzIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcztcblx0XHR2YXIgbyA9IHRoaXMsIF9TdGFnZSA9IGNyZWF0ZWpzW1wiU3RhZ2VcIl07XG5cdFx0d2hpbGUgKG8ucGFyZW50KSB7IG8gPSBvLnBhcmVudDsgfVxuXHRcdGlmIChvIGluc3RhbmNlb2YgX1N0YWdlKSB7IHJldHVybiBvOyB9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIFN0YWdlIGluc3RhbmNlIHRoYXQgdGhpcyBkaXNwbGF5IG9iamVjdCB3aWxsIGJlIHJlbmRlcmVkIG9uLCBvciBudWxsIGlmIGl0IGhhcyBub3QgYmVlbiBhZGRlZCB0byBvbmUuXG5cdCAqIEBwcm9wZXJ0eSBzdGFnZVxuXHQgKiBAdHlwZSB7U3RhZ2V9XG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXHRcdFx0c3RhZ2U6IHsgZ2V0OiBwLmdldFN0YWdlIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge31cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxuXHQgKiBSZXR1cm5zIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZUNhY2hlPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS4gRm9yIGV4YW1wbGUsXG5cdCAqIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFjayBpbnRvIGl0c2VsZikuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdHZhciBjYWNoZUNhbnZhcyA9IHRoaXMuY2FjaGVDYW52YXM7XG5cdFx0aWYgKGlnbm9yZUNhY2hlIHx8ICFjYWNoZUNhbnZhcykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9jYWNoZVNjYWxlO1xuXHRcdGN0eC5kcmF3SW1hZ2UoY2FjaGVDYW52YXMsIHRoaXMuX2NhY2hlT2Zmc2V0WCt0aGlzLl9maWx0ZXJPZmZzZXRYLCB0aGlzLl9jYWNoZU9mZnNldFkrdGhpcy5fZmlsdGVyT2Zmc2V0WSwgY2FjaGVDYW52YXMud2lkdGgvc2NhbGUsIGNhY2hlQ2FudmFzLmhlaWdodC9zY2FsZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQXBwbGllcyB0aGlzIGRpc3BsYXkgb2JqZWN0J3MgdHJhbnNmb3JtYXRpb24sIGFscGhhLCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24sIGNsaXBwaW5nIHBhdGggKG1hc2spLCBhbmQgc2hhZG93XG5cdCAqIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC4gVGhpcyBpcyB0eXBpY2FsbHkgY2FsbGVkIHByaW9yIHRvIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvZHJhd1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCB1cGRhdGVDb250ZXh0XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCB0byB1cGRhdGUuXG5cdCAqKi9cblx0cC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIG89dGhpcywgbWFzaz1vLm1hc2ssIG10eD0gby5fcHJvcHMubWF0cml4O1xuXHRcdFxuXHRcdGlmIChtYXNrICYmIG1hc2suZ3JhcGhpY3MgJiYgIW1hc2suZ3JhcGhpY3MuaXNFbXB0eSgpKSB7XG5cdFx0XHRtYXNrLmdldE1hdHJpeChtdHgpO1xuXHRcdFx0Y3R4LnRyYW5zZm9ybShtdHguYSwgIG10eC5iLCBtdHguYywgbXR4LmQsIG10eC50eCwgbXR4LnR5KTtcblx0XHRcdFxuXHRcdFx0bWFzay5ncmFwaGljcy5kcmF3QXNQYXRoKGN0eCk7XG5cdFx0XHRjdHguY2xpcCgpO1xuXHRcdFx0XG5cdFx0XHRtdHguaW52ZXJ0KCk7XG5cdFx0XHRjdHgudHJhbnNmb3JtKG10eC5hLCAgbXR4LmIsIG10eC5jLCBtdHguZCwgbXR4LnR4LCBtdHgudHkpO1xuXHRcdH1cblx0XHRcblx0XHR0aGlzLmdldE1hdHJpeChtdHgpO1xuXHRcdHZhciB0eCA9IG10eC50eCwgdHkgPSBtdHgudHk7XG5cdFx0aWYgKERpc3BsYXlPYmplY3QuX3NuYXBUb1BpeGVsRW5hYmxlZCAmJiBvLnNuYXBUb1BpeGVsKSB7XG5cdFx0XHR0eCA9IHR4ICsgKHR4IDwgMCA/IC0wLjUgOiAwLjUpIHwgMDtcblx0XHRcdHR5ID0gdHkgKyAodHkgPCAwID8gLTAuNSA6IDAuNSkgfCAwO1xuXHRcdH1cblx0XHRjdHgudHJhbnNmb3JtKG10eC5hLCAgbXR4LmIsIG10eC5jLCBtdHguZCwgdHgsIHR5KTtcblx0XHRjdHguZ2xvYmFsQWxwaGEgKj0gby5hbHBoYTtcblx0XHRpZiAoby5jb21wb3NpdGVPcGVyYXRpb24pIHsgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IG8uY29tcG9zaXRlT3BlcmF0aW9uOyB9XG5cdFx0aWYgKG8uc2hhZG93KSB7IHRoaXMuX2FwcGx5U2hhZG93KGN0eCwgby5zaGFkb3cpOyB9XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIGEgbmV3IGNhbnZhcywgd2hpY2ggaXMgdGhlbiB1c2VkIGZvciBzdWJzZXF1ZW50IGRyYXdzLiBGb3IgY29tcGxleCBjb250ZW50XG5cdCAqIHRoYXQgZG9lcyBub3QgY2hhbmdlIGZyZXF1ZW50bHkgKGV4LiBhIENvbnRhaW5lciB3aXRoIG1hbnkgY2hpbGRyZW4gdGhhdCBkbyBub3QgbW92ZSwgb3IgYSBjb21wbGV4IHZlY3RvciBTaGFwZSksXG5cdCAqIHRoaXMgY2FuIHByb3ZpZGUgZm9yIG11Y2ggZmFzdGVyIHJlbmRlcmluZyBiZWNhdXNlIHRoZSBjb250ZW50IGRvZXMgbm90IG5lZWQgdG8gYmUgcmUtcmVuZGVyZWQgZWFjaCB0aWNrLiBUaGVcblx0ICogY2FjaGVkIGRpc3BsYXkgb2JqZWN0IGNhbiBiZSBtb3ZlZCwgcm90YXRlZCwgZmFkZWQsIGV0YyBmcmVlbHksIGhvd2V2ZXIgaWYgaXRzIGNvbnRlbnQgY2hhbmdlcywgeW91IG11c3Rcblx0ICogbWFudWFsbHkgdXBkYXRlIHRoZSBjYWNoZSBieSBjYWxsaW5nIDxjb2RlPnVwZGF0ZUNhY2hlKCk8L2NvZGU+IG9yIDxjb2RlPmNhY2hlKCk8L2NvZGU+IGFnYWluLiBZb3UgbXVzdCBzcGVjaWZ5XG5cdCAqIHRoZSBjYWNoZSBhcmVhIHZpYSB0aGUgeCwgeSwgdywgYW5kIGggcGFyYW1ldGVycy4gVGhpcyBkZWZpbmVzIHRoZSByZWN0YW5nbGUgdGhhdCB3aWxsIGJlIHJlbmRlcmVkIGFuZCBjYWNoZWRcblx0ICogdXNpbmcgdGhpcyBkaXNwbGF5IG9iamVjdCdzIGNvb3JkaW5hdGVzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIEZvciBleGFtcGxlIGlmIHlvdSBkZWZpbmVkIGEgU2hhcGUgdGhhdCBkcmV3IGEgY2lyY2xlIGF0IDAsIDAgd2l0aCBhIHJhZGl1cyBvZiAyNTpcblx0ICpcblx0ICogICAgICB2YXIgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcblx0ICogICAgICBzaGFwZS5ncmFwaGljcy5iZWdpbkZpbGwoXCIjZmYwMDAwXCIpLmRyYXdDaXJjbGUoMCwgMCwgMjUpO1xuXHQgKiAgICAgIG15U2hhcGUuY2FjaGUoLTI1LCAtMjUsIDUwLCA1MCk7XG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBmaWx0ZXJzIG5lZWQgdG8gYmUgZGVmaW5lZCA8ZW0+YmVmb3JlPC9lbT4gdGhlIGNhY2hlIGlzIGFwcGxpZWQuIENoZWNrIG91dCB0aGUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGNsYXNzIGZvciBtb3JlIGluZm9ybWF0aW9uLiBTb21lIGZpbHRlcnMgKGV4LiBCbHVyRmlsdGVyKSB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIHNjYWxlIHBhcmFtLlxuXHQgKiBcblx0ICogVXN1YWxseSwgdGhlIHJlc3VsdGluZyBjYWNoZUNhbnZhcyB3aWxsIGhhdmUgdGhlIGRpbWVuc2lvbnMgd2lkdGgqc2NhbGUgYnkgaGVpZ2h0KnNjYWxlLCBob3dldmVyIHNvbWUgZmlsdGVycyAoZXguIEJsdXJGaWx0ZXIpXG5cdCAqIHdpbGwgYWRkIHBhZGRpbmcgdG8gdGhlIGNhbnZhcyBkaW1lbnNpb25zLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGNhY2hlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgb3JpZ2luIGZvciB0aGUgY2FjaGUgcmVnaW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIG9yaWdpbiBmb3IgdGhlIGNhY2hlIHJlZ2lvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgY2FjaGUgcmVnaW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGNhY2hlIHJlZ2lvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZT0xXSBUaGUgc2NhbGUgYXQgd2hpY2ggdGhlIGNhY2hlIHdpbGwgYmUgY3JlYXRlZC4gRm9yIGV4YW1wbGUsIGlmIHlvdSBjYWNoZSBhIHZlY3RvciBzaGFwZSB1c2luZ1xuXHQgKiBcdG15U2hhcGUuY2FjaGUoMCwwLDEwMCwxMDAsMikgdGhlbiB0aGUgcmVzdWx0aW5nIGNhY2hlQ2FudmFzIHdpbGwgYmUgMjAweDIwMCBweC4gVGhpcyBsZXRzIHlvdSBzY2FsZSBhbmQgcm90YXRlXG5cdCAqIFx0Y2FjaGVkIGVsZW1lbnRzIHdpdGggZ3JlYXRlciBmaWRlbGl0eS4gRGVmYXVsdCBpcyAxLlxuXHQgKiovXG5cdHAuY2FjaGUgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzY2FsZSkge1xuXHRcdC8vIGRyYXcgdG8gY2FudmFzLlxuXHRcdHNjYWxlID0gc2NhbGV8fDE7XG5cdFx0aWYgKCF0aGlzLmNhY2hlQ2FudmFzKSB7IHRoaXMuY2FjaGVDYW52YXMgPSBjcmVhdGVqcy5jcmVhdGVDYW52YXM/Y3JlYXRlanMuY3JlYXRlQ2FudmFzKCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTsgfVxuXHRcdHRoaXMuX2NhY2hlV2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9jYWNoZUhlaWdodCA9IGhlaWdodDtcblx0XHR0aGlzLl9jYWNoZU9mZnNldFggPSB4O1xuXHRcdHRoaXMuX2NhY2hlT2Zmc2V0WSA9IHk7XG5cdFx0dGhpcy5fY2FjaGVTY2FsZSA9IHNjYWxlO1xuXHRcdHRoaXMudXBkYXRlQ2FjaGUoKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVkcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgdG8gaXRzIGNhY2hlLiBDYWxsaW5nIHVwZGF0ZUNhY2hlIHdpdGhvdXQgYW4gYWN0aXZlIGNhY2hlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG5cdCAqIElmIGNvbXBvc2l0ZU9wZXJhdGlvbiBpcyBudWxsIHRoZSBjdXJyZW50IGNhY2hlIHdpbGwgYmUgY2xlYXJlZCBwcmlvciB0byBkcmF3aW5nLiBPdGhlcndpc2UgdGhlIGRpc3BsYXkgb2JqZWN0XG5cdCAqIHdpbGwgYmUgZHJhd24gb3ZlciB0aGUgZXhpc3RpbmcgY2FjaGUgdXNpbmcgdGhlIHNwZWNpZmllZCBjb21wb3NpdGVPcGVyYXRpb24uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogQ2xlYXIgdGhlIGN1cnJlbnQgZ3JhcGhpY3Mgb2YgYSBjYWNoZWQgc2hhcGUsIGRyYXcgc29tZSBuZXcgaW5zdHJ1Y3Rpb25zLCBhbmQgdGhlbiB1cGRhdGUgdGhlIGNhY2hlLiBUaGUgbmV3IGxpbmVcblx0ICogd2lsbCBiZSBkcmF3biBvbiB0b3Agb2YgdGhlIG9sZCBvbmUuXG5cdCAqXG5cdCAqICAgICAgLy8gTm90IHNob3duOiBDcmVhdGluZyB0aGUgc2hhcGUsIGFuZCBjYWNoaW5nIGl0LlxuXHQgKiAgICAgIHNoYXBlSW5zdGFuY2UuY2xlYXIoKTtcblx0ICogICAgICBzaGFwZUluc3RhbmNlLnNldFN0cm9rZVN0eWxlKDMpLmJlZ2luU3Ryb2tlKFwiI2ZmMDAwMFwiKS5tb3ZlVG8oMTAwLCAxMDApLmxpbmVUbygyMDAsMjAwKTtcblx0ICogICAgICBzaGFwZUluc3RhbmNlLnVwZGF0ZUNhY2hlKCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgdXBkYXRlQ2FjaGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvc2l0ZU9wZXJhdGlvbiBUaGUgY29tcG9zaXRlT3BlcmF0aW9uIHRvIHVzZSwgb3IgbnVsbCB0byBjbGVhciB0aGUgY2FjaGUgYW5kIHJlZHJhdyBpdC5cblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2NvbXBvc2l0aW5nXCI+XG5cdCAqIHdoYXR3ZyBzcGVjIG9uIGNvbXBvc2l0aW5nPC9hPi5cblx0ICoqL1xuXHRwLnVwZGF0ZUNhY2hlID0gZnVuY3Rpb24oY29tcG9zaXRlT3BlcmF0aW9uKSB7XG5cdFx0dmFyIGNhY2hlQ2FudmFzID0gdGhpcy5jYWNoZUNhbnZhcztcblx0XHRpZiAoIWNhY2hlQ2FudmFzKSB7IHRocm93IFwiY2FjaGUoKSBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgdXBkYXRlQ2FjaGUoKVwiOyB9XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fY2FjaGVTY2FsZSwgb2ZmWCA9IHRoaXMuX2NhY2hlT2Zmc2V0WCpzY2FsZSwgb2ZmWSA9IHRoaXMuX2NhY2hlT2Zmc2V0WSpzY2FsZTtcblx0XHR2YXIgdyA9IHRoaXMuX2NhY2hlV2lkdGgsIGggPSB0aGlzLl9jYWNoZUhlaWdodCwgY3R4ID0gY2FjaGVDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdFxuXHRcdHZhciBmQm91bmRzID0gdGhpcy5fZ2V0RmlsdGVyQm91bmRzKCk7XG5cdFx0b2ZmWCArPSAodGhpcy5fZmlsdGVyT2Zmc2V0WCA9IGZCb3VuZHMueCk7XG5cdFx0b2ZmWSArPSAodGhpcy5fZmlsdGVyT2Zmc2V0WSA9IGZCb3VuZHMueSk7XG5cdFx0XG5cdFx0dyA9IE1hdGguY2VpbCh3KnNjYWxlKSArIGZCb3VuZHMud2lkdGg7XG5cdFx0aCA9IE1hdGguY2VpbChoKnNjYWxlKSArIGZCb3VuZHMuaGVpZ2h0O1xuXHRcdGlmICh3ICE9IGNhY2hlQ2FudmFzLndpZHRoIHx8IGggIT0gY2FjaGVDYW52YXMuaGVpZ2h0KSB7XG5cdFx0XHQvLyBUT0RPOiBpdCB3b3VsZCBiZSBuaWNlIHRvIHByZXNlcnZlIHRoZSBjb250ZW50IGlmIHRoZXJlIGlzIGEgY29tcG9zaXRlT3BlcmF0aW9uLlxuXHRcdFx0Y2FjaGVDYW52YXMud2lkdGggPSB3O1xuXHRcdFx0Y2FjaGVDYW52YXMuaGVpZ2h0ID0gaDtcblx0XHR9IGVsc2UgaWYgKCFjb21wb3NpdGVPcGVyYXRpb24pIHtcblx0XHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgdysxLCBoKzEpO1xuXHRcdH1cblx0XHRcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb247XG5cdFx0Y3R4LnNldFRyYW5zZm9ybShzY2FsZSwgMCwgMCwgc2NhbGUsIC1vZmZYLCAtb2ZmWSk7XG5cdFx0dGhpcy5kcmF3KGN0eCwgdHJ1ZSk7XG5cdFx0Ly8gVE9ETzogZmlsdGVycyBhbmQgY2FjaGUgc2NhbGUgZG9uJ3QgcGxheSB3ZWxsIHRvZ2V0aGVyIGF0IHByZXNlbnQuXG5cdFx0dGhpcy5fYXBwbHlGaWx0ZXJzKCk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR0aGlzLmNhY2hlSUQgPSBEaXNwbGF5T2JqZWN0Ll9uZXh0Q2FjaGVJRCsrO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIGN1cnJlbnQgY2FjaGUuIFNlZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2NhY2hlXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIHVuY2FjaGVcblx0ICoqL1xuXHRwLnVuY2FjaGUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9jYWNoZURhdGFVUkwgPSB0aGlzLmNhY2hlQ2FudmFzID0gbnVsbDtcblx0XHR0aGlzLmNhY2hlSUQgPSB0aGlzLl9jYWNoZU9mZnNldFggPSB0aGlzLl9jYWNoZU9mZnNldFkgPSB0aGlzLl9maWx0ZXJPZmZzZXRYID0gdGhpcy5fZmlsdGVyT2Zmc2V0WSA9IDA7XG5cdFx0dGhpcy5fY2FjaGVTY2FsZSA9IDE7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIGRhdGEgVVJMIGZvciB0aGUgY2FjaGUsIG9yIG51bGwgaWYgdGhpcyBkaXNwbGF5IG9iamVjdCBpcyBub3QgY2FjaGVkLlxuXHQgKiBVc2VzIGNhY2hlSUQgdG8gZW5zdXJlIGEgbmV3IGRhdGEgVVJMIGlzIG5vdCBnZW5lcmF0ZWQgaWYgdGhlIGNhY2hlIGhhcyBub3QgY2hhbmdlZC5cblx0ICogQG1ldGhvZCBnZXRDYWNoZURhdGFVUkxcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgaW1hZ2UgZGF0YSB1cmwgZm9yIHRoZSBjYWNoZS5cblx0ICoqL1xuXHRwLmdldENhY2hlRGF0YVVSTCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5jYWNoZUNhbnZhcykgeyByZXR1cm4gbnVsbDsgfVxuXHRcdGlmICh0aGlzLmNhY2hlSUQgIT0gdGhpcy5fY2FjaGVEYXRhVVJMSUQpIHsgdGhpcy5fY2FjaGVEYXRhVVJMID0gdGhpcy5jYWNoZUNhbnZhcy50b0RhdGFVUkwoKTsgfVxuXHRcdHJldHVybiB0aGlzLl9jYWNoZURhdGFVUkw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgdGhlIHNwZWNpZmllZCB4IGFuZCB5IHBvc2l0aW9uIGZyb20gdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhlIGRpc3BsYXkgb2JqZWN0XG5cdCAqIHRvIHRoZSBnbG9iYWwgKHN0YWdlKSBjb29yZGluYXRlIHNwYWNlLiBGb3IgZXhhbXBsZSwgdGhpcyBjb3VsZCBiZSB1c2VkIHRvIHBvc2l0aW9uIGFuIEhUTUwgbGFiZWxcblx0ICogb3ZlciBhIHNwZWNpZmljIHBvaW50IG9uIGEgbmVzdGVkIGRpc3BsYXkgb2JqZWN0LiBSZXR1cm5zIGEgUG9pbnQgaW5zdGFuY2Ugd2l0aCB4IGFuZCB5IHByb3BlcnRpZXNcblx0ICogY29ycmVsYXRpbmcgdG8gdGhlIHRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzIG9uIHRoZSBzdGFnZS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QueCA9IDMwMDtcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnkgPSAyMDA7XG5cdCAqICAgICAgc3RhZ2UuYWRkQ2hpbGQoZGlzcGxheU9iamVjdCk7XG5cdCAqICAgICAgdmFyIHBvaW50ID0gZGlzcGxheU9iamVjdC5sb2NhbFRvR2xvYmFsKDEwMCwgMTAwKTtcblx0ICogICAgICAvLyBSZXN1bHRzIGluIHg9NDAwLCB5PTMwMFxuXHQgKlxuXHQgKiBAbWV0aG9kIGxvY2FsVG9HbG9iYWxcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBkaXNwbGF5IG9iamVjdCB0byB0cmFuc2Zvcm0uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgZGlzcGxheSBvYmplY3QgdG8gdHJhbnNmb3JtLlxuXHQgKiBAcGFyYW0ge1BvaW50IHwgT2JqZWN0fSBbcHRdIEFuIG9iamVjdCB0byBjb3B5IHRoZSByZXN1bHQgaW50by4gSWYgb21pdHRlZCBhIG5ldyBQb2ludCBvYmplY3Qgd2l0aCB4L3kgcHJvcGVydGllcyB3aWxsIGJlIHJldHVybmVkLiBcblx0ICogQHJldHVybiB7UG9pbnR9IEEgUG9pbnQgaW5zdGFuY2Ugd2l0aCB4IGFuZCB5IHByb3BlcnRpZXMgY29ycmVsYXRpbmcgdG8gdGhlIHRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzXG5cdCAqIG9uIHRoZSBzdGFnZS5cblx0ICoqL1xuXHRwLmxvY2FsVG9HbG9iYWwgPSBmdW5jdGlvbih4LCB5LCBwdCkge1xuXHRcdHJldHVybiB0aGlzLmdldENvbmNhdGVuYXRlZE1hdHJpeCh0aGlzLl9wcm9wcy5tYXRyaXgpLnRyYW5zZm9ybVBvaW50KHgseSwgcHR8fG5ldyBjcmVhdGVqcy5Qb2ludCgpKTtcblx0fTtcblxuXHQvKipcblx0ICogVHJhbnNmb3JtcyB0aGUgc3BlY2lmaWVkIHggYW5kIHkgcG9zaXRpb24gZnJvbSB0aGUgZ2xvYmFsIChzdGFnZSkgY29vcmRpbmF0ZSBzcGFjZSB0byB0aGVcblx0ICogY29vcmRpbmF0ZSBzcGFjZSBvZiB0aGUgZGlzcGxheSBvYmplY3QuIEZvciBleGFtcGxlLCB0aGlzIGNvdWxkIGJlIHVzZWQgdG8gZGV0ZXJtaW5lXG5cdCAqIHRoZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uIHdpdGhpbiB0aGUgZGlzcGxheSBvYmplY3QuIFJldHVybnMgYSBQb2ludCBpbnN0YW5jZSB3aXRoIHggYW5kIHkgcHJvcGVydGllc1xuXHQgKiBjb3JyZWxhdGluZyB0byB0aGUgdHJhbnNmb3JtZWQgcG9zaXRpb24gaW4gdGhlIGRpc3BsYXkgb2JqZWN0J3MgY29vcmRpbmF0ZSBzcGFjZS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QueCA9IDMwMDtcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnkgPSAyMDA7XG5cdCAqICAgICAgc3RhZ2UuYWRkQ2hpbGQoZGlzcGxheU9iamVjdCk7XG5cdCAqICAgICAgdmFyIHBvaW50ID0gZGlzcGxheU9iamVjdC5nbG9iYWxUb0xvY2FsKDEwMCwgMTAwKTtcblx0ICogICAgICAvLyBSZXN1bHRzIGluIHg9LTIwMCwgeT0tMTAwXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2xvYmFsVG9Mb2NhbFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiBvbiB0aGUgc3RhZ2UgdG8gdHJhbnNmb3JtLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBvbiB0aGUgc3RhZ2UgdG8gdHJhbnNmb3JtLlxuXHQgKiBAcGFyYW0ge1BvaW50IHwgT2JqZWN0fSBbcHRdIEFuIG9iamVjdCB0byBjb3B5IHRoZSByZXN1bHQgaW50by4gSWYgb21pdHRlZCBhIG5ldyBQb2ludCBvYmplY3Qgd2l0aCB4L3kgcHJvcGVydGllcyB3aWxsIGJlIHJldHVybmVkLiBcblx0ICogQHJldHVybiB7UG9pbnR9IEEgUG9pbnQgaW5zdGFuY2Ugd2l0aCB4IGFuZCB5IHByb3BlcnRpZXMgY29ycmVsYXRpbmcgdG8gdGhlIHRyYW5zZm9ybWVkIHBvc2l0aW9uIGluIHRoZVxuXHQgKiBkaXNwbGF5IG9iamVjdCdzIGNvb3JkaW5hdGUgc3BhY2UuXG5cdCAqKi9cblx0cC5nbG9iYWxUb0xvY2FsID0gZnVuY3Rpb24oeCwgeSwgcHQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDb25jYXRlbmF0ZWRNYXRyaXgodGhpcy5fcHJvcHMubWF0cml4KS5pbnZlcnQoKS50cmFuc2Zvcm1Qb2ludCh4LHksIHB0fHxuZXcgY3JlYXRlanMuUG9pbnQoKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgdGhlIHNwZWNpZmllZCB4IGFuZCB5IHBvc2l0aW9uIGZyb20gdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhpcyBkaXNwbGF5IG9iamVjdCB0byB0aGUgY29vcmRpbmF0ZVxuXHQgKiBzcGFjZSBvZiB0aGUgdGFyZ2V0IGRpc3BsYXkgb2JqZWN0LiBSZXR1cm5zIGEgUG9pbnQgaW5zdGFuY2Ugd2l0aCB4IGFuZCB5IHByb3BlcnRpZXMgY29ycmVsYXRpbmcgdG8gdGhlXG5cdCAqIHRyYW5zZm9ybWVkIHBvc2l0aW9uIGluIHRoZSB0YXJnZXQncyBjb29yZGluYXRlIHNwYWNlLiBFZmZlY3RpdmVseSB0aGUgc2FtZSBhcyB1c2luZyB0aGUgZm9sbG93aW5nIGNvZGUgd2l0aFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2xvY2FsVG9HbG9iYWxcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvZ2xvYmFsVG9Mb2NhbFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogICAgICB2YXIgcHQgPSB0aGlzLmxvY2FsVG9HbG9iYWwoeCwgeSk7XG5cdCAqICAgICAgcHQgPSB0YXJnZXQuZ2xvYmFsVG9Mb2NhbChwdC54LCBwdC55KTtcblx0ICpcblx0ICogQG1ldGhvZCBsb2NhbFRvTG9jYWxcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBkaXNwbGF5IG9iamVjdCB0byB0cmFuc2Zvcm0uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIG9uIHRoZSBzb3VyY2UgZGlzcGxheSBvYmplY3QgdG8gdHJhbnNmb3JtLlxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IGRpc3BsYXkgb2JqZWN0IHRvIHdoaWNoIHRoZSBjb29yZGluYXRlcyB3aWxsIGJlIHRyYW5zZm9ybWVkLlxuXHQgKiBAcGFyYW0ge1BvaW50IHwgT2JqZWN0fSBbcHRdIEFuIG9iamVjdCB0byBjb3B5IHRoZSByZXN1bHQgaW50by4gSWYgb21pdHRlZCBhIG5ldyBQb2ludCBvYmplY3Qgd2l0aCB4L3kgcHJvcGVydGllcyB3aWxsIGJlIHJldHVybmVkLiBcblx0ICogQHJldHVybiB7UG9pbnR9IFJldHVybnMgYSBQb2ludCBpbnN0YW5jZSB3aXRoIHggYW5kIHkgcHJvcGVydGllcyBjb3JyZWxhdGluZyB0byB0aGUgdHJhbnNmb3JtZWQgcG9zaXRpb25cblx0ICogaW4gdGhlIHRhcmdldCdzIGNvb3JkaW5hdGUgc3BhY2UuXG5cdCAqKi9cblx0cC5sb2NhbFRvTG9jYWwgPSBmdW5jdGlvbih4LCB5LCB0YXJnZXQsIHB0KSB7XG5cdFx0cHQgPSB0aGlzLmxvY2FsVG9HbG9iYWwoeCwgeSwgcHQpO1xuXHRcdHJldHVybiB0YXJnZXQuZ2xvYmFsVG9Mb2NhbChwdC54LCBwdC55LCBwdCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IG1ldGhvZCB0byBxdWlja2x5IHNldCB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMgb24gdGhlIGRpc3BsYXkgb2JqZWN0LiBBbGwgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwuXG5cdCAqIE9taXR0ZWQgcGFyYW1ldGVycyB3aWxsIGhhdmUgdGhlIGRlZmF1bHQgdmFsdWUgc2V0LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5zZXRUcmFuc2Zvcm0oMTAwLCAxMDAsIDIsIDIpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFRyYW5zZm9ybVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gVGhlIGhvcml6b250YWwgdHJhbnNsYXRpb24gKHggcG9zaXRpb24pIGluIHBpeGVsc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gVGhlIHZlcnRpY2FsIHRyYW5zbGF0aW9uICh5IHBvc2l0aW9uKSBpbiBwaXhlbHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZVg9MV0gVGhlIGhvcml6b250YWwgc2NhbGUsIGFzIGEgcGVyY2VudGFnZSBvZiAxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVZPTFdIHRoZSB2ZXJ0aWNhbCBzY2FsZSwgYXMgYSBwZXJjZW50YWdlIG9mIDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyb3RhdGlvbj0wXSBUaGUgcm90YXRpb24sIGluIGRlZ3JlZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtza2V3WD0wXSBUaGUgaG9yaXpvbnRhbCBza2V3IGZhY3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NrZXdZPTBdIFRoZSB2ZXJ0aWNhbCBza2V3IGZhY3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3JlZ1g9MF0gVGhlIGhvcml6b250YWwgcmVnaXN0cmF0aW9uIHBvaW50IGluIHBpeGVsc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3JlZ1k9MF0gVGhlIHZlcnRpY2FsIHJlZ2lzdHJhdGlvbiBwb2ludCBpbiBwaXhlbHNcblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gUmV0dXJucyB0aGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIGNvbW1hbmRzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24oeCwgeSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCBza2V3WCwgc2tld1ksIHJlZ1gsIHJlZ1kpIHtcblx0XHR0aGlzLnggPSB4IHx8IDA7XG5cdFx0dGhpcy55ID0geSB8fCAwO1xuXHRcdHRoaXMuc2NhbGVYID0gc2NhbGVYID09IG51bGwgPyAxIDogc2NhbGVYO1xuXHRcdHRoaXMuc2NhbGVZID0gc2NhbGVZID09IG51bGwgPyAxIDogc2NhbGVZO1xuXHRcdHRoaXMucm90YXRpb24gPSByb3RhdGlvbiB8fCAwO1xuXHRcdHRoaXMuc2tld1ggPSBza2V3WCB8fCAwO1xuXHRcdHRoaXMuc2tld1kgPSBza2V3WSB8fCAwO1xuXHRcdHRoaXMucmVnWCA9IHJlZ1ggfHwgMDtcblx0XHR0aGlzLnJlZ1kgPSByZWdZIHx8IDA7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIG1hdHJpeCBiYXNlZCBvbiB0aGlzIG9iamVjdCdzIGN1cnJlbnQgdHJhbnNmb3JtLlxuXHQgKiBAbWV0aG9kIGdldE1hdHJpeFxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXggT3B0aW9uYWwuIEEgTWF0cml4MkQgb2JqZWN0IHRvIHBvcHVsYXRlIHdpdGggdGhlIGNhbGN1bGF0ZWQgdmFsdWVzLiBJZiBudWxsLCBhIG5ld1xuXHQgKiBNYXRyaXggb2JqZWN0IGlzIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gQSBtYXRyaXggcmVwcmVzZW50aW5nIHRoaXMgZGlzcGxheSBvYmplY3QncyB0cmFuc2Zvcm0uXG5cdCAqKi9cblx0cC5nZXRNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgbyA9IHRoaXMsIG10eCA9IG1hdHJpeCYmbWF0cml4LmlkZW50aXR5KCkgfHwgbmV3IGNyZWF0ZWpzLk1hdHJpeDJEKCk7XG5cdFx0cmV0dXJuIG8udHJhbnNmb3JtTWF0cml4ID8gIG10eC5jb3B5KG8udHJhbnNmb3JtTWF0cml4KSA6IG10eC5hcHBlbmRUcmFuc2Zvcm0oby54LCBvLnksIG8uc2NhbGVYLCBvLnNjYWxlWSwgby5yb3RhdGlvbiwgby5za2V3WCwgby5za2V3WSwgby5yZWdYLCBvLnJlZ1kpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIE1hdHJpeDJEIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGNvbWJpbmVkIHRyYW5zZm9ybSBvZiB0aGUgZGlzcGxheSBvYmplY3QgYW5kIGFsbCBvZiBpdHNcblx0ICogcGFyZW50IENvbnRhaW5lcnMgdXAgdG8gdGhlIGhpZ2hlc3QgbGV2ZWwgYW5jZXN0b3IgKHVzdWFsbHkgdGhlIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319KS4gVGhpcyBjYW5cblx0ICogYmUgdXNlZCB0byB0cmFuc2Zvcm0gcG9zaXRpb25zIGJldHdlZW4gY29vcmRpbmF0ZSBzcGFjZXMsIHN1Y2ggYXMgd2l0aCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2xvY2FsVG9HbG9iYWxcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYW5kIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvZ2xvYmFsVG9Mb2NhbFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBnZXRDb25jYXRlbmF0ZWRNYXRyaXhcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gW21hdHJpeF0gQSB7eyNjcm9zc0xpbmsgXCJNYXRyaXgyRFwifX17ey9jcm9zc0xpbmt9fSBvYmplY3QgdG8gcG9wdWxhdGUgd2l0aCB0aGUgY2FsY3VsYXRlZCB2YWx1ZXMuXG5cdCAqIElmIG51bGwsIGEgbmV3IE1hdHJpeDJEIG9iamVjdCBpcyByZXR1cm5lZC5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoZSBjb21iaW5lZCBtYXRyaXguXG5cdCAqKi9cblx0cC5nZXRDb25jYXRlbmF0ZWRNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgbyA9IHRoaXMsIG10eCA9IHRoaXMuZ2V0TWF0cml4KG1hdHJpeCk7XG5cdFx0d2hpbGUgKG8gPSBvLnBhcmVudCkge1xuXHRcdFx0bXR4LnByZXBlbmRNYXRyaXgoby5nZXRNYXRyaXgoby5fcHJvcHMubWF0cml4KSk7XG5cdFx0fVxuXHRcdHJldHVybiBtdHg7XG5cdH07XG5cdFxuXHQvKipcblx0ICogR2VuZXJhdGVzIGEgRGlzcGxheVByb3BzIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGNvbWJpbmVkIGRpc3BsYXkgcHJvcGVydGllcyBvZiB0aGUgIG9iamVjdCBhbmQgYWxsIG9mIGl0c1xuXHQgKiBwYXJlbnQgQ29udGFpbmVycyB1cCB0byB0aGUgaGlnaGVzdCBsZXZlbCBhbmNlc3RvciAodXN1YWxseSB0aGUge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0pLlxuXHQgKiBAbWV0aG9kIGdldENvbmNhdGVuYXRlZERpc3BsYXlQcm9wc1xuXHQgKiBAcGFyYW0ge0Rpc3BsYXlQcm9wc30gW3Byb3BzXSBBIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlQcm9wc1wifX17ey9jcm9zc0xpbmt9fSBvYmplY3QgdG8gcG9wdWxhdGUgd2l0aCB0aGUgY2FsY3VsYXRlZCB2YWx1ZXMuXG5cdCAqIElmIG51bGwsIGEgbmV3IERpc3BsYXlQcm9wcyBvYmplY3QgaXMgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlQcm9wc30gVGhlIGNvbWJpbmVkIGRpc3BsYXkgcHJvcGVydGllcy5cblx0ICoqL1xuXHRwLmdldENvbmNhdGVuYXRlZERpc3BsYXlQcm9wcyA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0cHJvcHMgPSBwcm9wcyA/IHByb3BzLmlkZW50aXR5KCkgOiBuZXcgY3JlYXRlanMuRGlzcGxheVByb3BzKCk7XG5cdFx0dmFyIG8gPSB0aGlzLCBtdHggPSBvLmdldE1hdHJpeChwcm9wcy5tYXRyaXgpOyBcblx0XHRkbyB7XG5cdFx0XHRwcm9wcy5wcmVwZW5kKG8udmlzaWJsZSwgby5hbHBoYSwgby5zaGFkb3csIG8uY29tcG9zaXRlT3BlcmF0aW9uKTtcblx0XHRcdFxuXHRcdFx0Ly8gd2UgZG8gdGhpcyB0byBhdm9pZCBwcm9ibGVtcyB3aXRoIHRoZSBtYXRyaXggYmVpbmcgdXNlZCBmb3IgYm90aCBvcGVyYXRpb25zIHdoZW4gby5fcHJvcHMubWF0cml4IGlzIHBhc3NlZCBpbiBhcyB0aGUgcHJvcHMgcGFyYW0uXG5cdFx0XHQvLyB0aGlzIGNvdWxkIGJlIHNpbXBsaWZpZWQgKGllLiBqdXN0IGRvbmUgYXMgcGFydCBvZiB0aGUgcHJlcGVuZCBhYm92ZSkgaWYgd2Ugc3dpdGNoZWQgdG8gdXNpbmcgYSBwb29sLlxuXHRcdFx0aWYgKG8gIT0gdGhpcykgeyBtdHgucHJlcGVuZE1hdHJpeChvLmdldE1hdHJpeChvLl9wcm9wcy5tYXRyaXgpKTsgfVxuXHRcdH0gd2hpbGUgKG8gPSBvLnBhcmVudCk7XG5cdFx0cmV0dXJuIHByb3BzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUZXN0cyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRlcnNlY3RzIHRoZSBzcGVjaWZpZWQgcG9pbnQgaW4gPGVtPmxvY2FsPC9lbT4gY29vcmRpbmF0ZXMgKGllLiBkcmF3cyBhIHBpeGVsXG5cdCAqIHdpdGggYWxwaGEgPiAwIGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24pLiBUaGlzIGlnbm9yZXMgdGhlIGFscGhhLCBzaGFkb3csIGhpdEFyZWEsIG1hc2ssIGFuZCBjb21wb3NpdGVPcGVyYXRpb25cblx0ICogb2YgdGhlIGRpc3BsYXkgb2JqZWN0LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqIFx0XHR2YXIgbXlTaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuXHQgKiBcdFx0bXlTaGFwZS5ncmFwaGljcy5iZWdpbkZpbGwoXCJyZWRcIikuZHJhd1JlY3QoMTAwLCAxMDAsIDIwLCA1MCk7XG5cdCAqXG5cdCAqIFx0XHRjb25zb2xlLmxvZyhteVNoYXBlLmhpdFRlc3QoMTAsMTApOyAvLyBmYWxzZVxuXHQgKiBcdFx0Y29uc29sZS5sb2cobXlTaGFwZS5oaXRUZXN0KDExMCwgMjUpOyAvLyB0cnVlXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0byB1c2UgU3RhZ2UgY29vcmRpbmF0ZXMgKHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvbW91c2VYOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319KSwgdGhleSBtdXN0XG5cdCAqIGZpcnN0IGJlIGNvbnZlcnRlZCB0byBsb2NhbCBjb29yZGluYXRlczpcblx0ICpcblx0ICogICAgICBzdGFnZS5hZGRFdmVudExpc3RlbmVyKFwic3RhZ2Vtb3VzZWRvd25cIiwgaGFuZGxlTW91c2VEb3duKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcblx0ICogICAgICBcdHZhciBwID0gbXlTaGFwZS5nbG9iYWxUb0xvY2FsKHN0YWdlLm1vdXNlWCwgc3RhZ2UubW91c2VZKTtcblx0ICogICAgICAgICAgdmFyIGhpdCA9IG15U2hhcGUuaGl0VGVzdChwLngsIHAueSk7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBTaGFwZS10by1zaGFwZSBjb2xsaXNpb24gaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgRWFzZWxKUy5cblx0ICpcblx0ICogQG1ldGhvZCBoaXRUZXN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIHRvIGNoZWNrIGluIHRoZSBkaXNwbGF5IG9iamVjdCdzIGxvY2FsIGNvb3JkaW5hdGVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhIHZpc2libGUgcG9ydGlvbiBvZiB0aGUgRGlzcGxheU9iamVjdCBpbnRlcnNlY3QgdGhlIHNwZWNpZmllZFxuXHQgKiBsb2NhbCBQb2ludC5cblx0Ki9cblx0cC5oaXRUZXN0ID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHZhciBjdHggPSBEaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q29udGV4dDtcblx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIC14LCAteSk7XG5cdFx0dGhpcy5kcmF3KGN0eCk7XG5cblx0XHR2YXIgaGl0ID0gdGhpcy5fdGVzdEhpdChjdHgpO1xuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCAyLCAyKTtcblx0XHRyZXR1cm4gaGl0O1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFByb3ZpZGVzIGEgY2hhaW5hYmxlIHNob3J0Y3V0IG1ldGhvZCBmb3Igc2V0dGluZyBhIG51bWJlciBvZiBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBteUdyYXBoaWNzID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCkuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3Q2lyY2xlKDAsIDAsIDI1KTtcblx0ICogICAgICB2YXIgc2hhcGUgPSBzdGFnZS5hZGRDaGlsZChuZXcgY3JlYXRlanMuU2hhcGUoKSkuc2V0KHtncmFwaGljczpteUdyYXBoaWNzLCB4OjEwMCwgeToxMDAsIGFscGhhOjAuNX0pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgRGlzcGxheU9iamVjdCBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gUmV0dXJucyB0aGUgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuc2V0ID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7IHRoaXNbbl0gPSBwcm9wc1tuXTsgfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSByZWN0YW5nbGUgcmVwcmVzZW50aW5nIHRoaXMgb2JqZWN0J3MgYm91bmRzIGluIGl0cyBsb2NhbCBjb29yZGluYXRlIHN5c3RlbSAoaWUuIHdpdGggbm8gdHJhbnNmb3JtYXRpb24pLlxuXHQgKiBPYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGNhY2hlZCB3aWxsIHJldHVybiB0aGUgYm91bmRzIG9mIHRoZSBjYWNoZS5cblx0ICogXG5cdCAqIE5vdCBhbGwgZGlzcGxheSBvYmplY3RzIGNhbiBjYWxjdWxhdGUgdGhlaXIgb3duIGJvdW5kcyAoZXguIFNoYXBlKS4gRm9yIHRoZXNlIG9iamVjdHMsIHlvdSBjYW4gdXNlIFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3NldEJvdW5kc1wifX17ey9jcm9zc0xpbmt9fSBzbyB0aGF0IHRoZXkgYXJlIGluY2x1ZGVkIHdoZW4gY2FsY3VsYXRpbmcgQ29udGFpbmVyXG5cdCAqIGJvdW5kcy5cblx0ICogXG5cdCAqIDx0YWJsZT5cblx0ICogXHQ8dHI+PHRkPjxiPkFsbDwvYj48L3RkPjx0ZD5cblx0ICogXHRcdEFsbCBkaXNwbGF5IG9iamVjdHMgc3VwcG9ydCBzZXR0aW5nIGJvdW5kcyBtYW51YWxseSB1c2luZyBzZXRCb3VuZHMoKS4gTGlrZXdpc2UsIGRpc3BsYXkgb2JqZWN0cyB0aGF0XG5cdCAqIFx0XHRoYXZlIGJlZW4gY2FjaGVkIHVzaW5nIGNhY2hlKCkgd2lsbCByZXR1cm4gdGhlIGJvdW5kcyBvZiB0aGVpciBjYWNoZS4gTWFudWFsIGFuZCBjYWNoZSBib3VuZHMgd2lsbCBvdmVycmlkZVxuXHQgKiBcdFx0dGhlIGF1dG9tYXRpYyBjYWxjdWxhdGlvbnMgbGlzdGVkIGJlbG93LlxuXHQgKiBcdDwvdGQ+PC90cj5cblx0ICogXHQ8dHI+PHRkPjxiPkJpdG1hcDwvYj48L3RkPjx0ZD5cblx0ICogXHRcdFJldHVybnMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHNvdXJjZVJlY3QgKGlmIHNwZWNpZmllZCkgb3IgaW1hZ2UsIGV4dGVuZGluZyBmcm9tICh4PTAseT0wKS5cblx0ICogXHQ8L3RkPjwvdHI+XG5cdCAqIFx0PHRyPjx0ZD48Yj5TcHJpdGU8L2I+PC90ZD48dGQ+XG5cdCAqIFx0XHRSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgZnJhbWUuIE1heSBoYXZlIG5vbi16ZXJvIHgveSBpZiBhIGZyYW1lIHJlZ2lzdHJhdGlvbiBwb2ludCB3YXMgc3BlY2lmaWVkXG5cdCAqIFx0XHRpbiB0aGUgc3ByaXRlc2hlZXQgZGF0YS4gU2VlIGFsc28ge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXQvZ2V0RnJhbWVCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogXHQ8L3RkPjwvdHI+XG5cdCAqIFx0PHRyPjx0ZD48Yj5Db250YWluZXI8L2I+PC90ZD48dGQ+XG5cdCAqIFx0XHRSZXR1cm5zIHRoZSBhZ2dyZWdhdGUgKGNvbWJpbmVkKSBib3VuZHMgb2YgYWxsIGNoaWxkcmVuIHRoYXQgcmV0dXJuIGEgbm9uLW51bGwgdmFsdWUgZnJvbSBnZXRCb3VuZHMoKS5cblx0ICogXHQ8L3RkPjwvdHI+XG5cdCAqIFx0PHRyPjx0ZD48Yj5TaGFwZTwvYj48L3RkPjx0ZD5cblx0ICogXHRcdERvZXMgbm90IGN1cnJlbnRseSBzdXBwb3J0IGF1dG9tYXRpYyBib3VuZHMgY2FsY3VsYXRpb25zLiBVc2Ugc2V0Qm91bmRzKCkgdG8gbWFudWFsbHkgZGVmaW5lIGJvdW5kcy5cblx0ICogXHQ8L3RkPjwvdHI+XG5cdCAqIFx0PHRyPjx0ZD48Yj5UZXh0PC9iPjwvdGQ+PHRkPlxuXHQgKiBcdFx0UmV0dXJucyBhcHByb3hpbWF0ZSBib3VuZHMuIEhvcml6b250YWwgdmFsdWVzICh4L3dpZHRoKSBhcmUgcXVpdGUgYWNjdXJhdGUsIGJ1dCB2ZXJ0aWNhbCB2YWx1ZXMgKHkvaGVpZ2h0KSBhcmVcblx0ICogXHRcdG5vdCwgZXNwZWNpYWxseSB3aGVuIHVzaW5nIHRleHRCYXNlbGluZSB2YWx1ZXMgb3RoZXIgdGhhbiBcInRvcFwiLlxuXHQgKiBcdDwvdGQ+PC90cj5cblx0ICogXHQ8dHI+PHRkPjxiPkJpdG1hcFRleHQ8L2I+PC90ZD48dGQ+XG5cdCAqIFx0XHRSZXR1cm5zIGFwcHJveGltYXRlIGJvdW5kcy4gVmFsdWVzIHdpbGwgYmUgbW9yZSBhY2N1cmF0ZSBpZiBzcHJpdGVzaGVldCBmcmFtZSByZWdpc3RyYXRpb24gcG9pbnRzIGFyZSBjbG9zZVxuXHQgKiBcdFx0dG8gKHg9MCx5PTApLlxuXHQgKiBcdDwvdGQ+PC90cj5cblx0KiA8L3RhYmxlPlxuXHQgKiBcblx0ICogQm91bmRzIGNhbiBiZSBleHBlbnNpdmUgdG8gY2FsY3VsYXRlIGZvciBzb21lIG9iamVjdHMgKGV4LiB0ZXh0LCBvciBjb250YWluZXJzIHdpdGggbWFueSBjaGlsZHJlbiksIGFuZFxuXHQgKiBhcmUgcmVjYWxjdWxhdGVkIGVhY2ggdGltZSB5b3UgY2FsbCBnZXRCb3VuZHMoKS4gWW91IGNhbiBwcmV2ZW50IHJlY2FsY3VsYXRpb24gb24gc3RhdGljIG9iamVjdHMgYnkgc2V0dGluZyB0aGVcblx0ICogYm91bmRzIGV4cGxpY2l0bHk6XG5cdCAqIFxuXHQgKiBcdHZhciBib3VuZHMgPSBvYmouZ2V0Qm91bmRzKCk7XG5cdCAqIFx0b2JqLnNldEJvdW5kcyhib3VuZHMueCwgYm91bmRzLnksIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XG5cdCAqIFx0Ly8gZ2V0Qm91bmRzIHdpbGwgbm93IHVzZSB0aGUgc2V0IHZhbHVlcywgaW5zdGVhZCBvZiByZWNhbGN1bGF0aW5nXG5cdCAqIFxuXHQgKiBUbyByZWR1Y2UgbWVtb3J5IGltcGFjdCwgdGhlIHJldHVybmVkIFJlY3RhbmdsZSBpbnN0YW5jZSBtYXkgYmUgcmV1c2VkIGludGVybmFsbHk7IGNsb25lIHRoZSBpbnN0YW5jZSBvciBjb3B5IGl0c1xuXHQgKiB2YWx1ZXMgaWYgeW91IG5lZWQgdG8gcmV0YWluIGl0LlxuXHQgKiBcblx0ICogXHR2YXIgbXlCb3VuZHMgPSBvYmouZ2V0Qm91bmRzKCkuY2xvbmUoKTtcblx0ICogXHQvLyBPUjpcblx0ICogXHRteVJlY3QuY29weShvYmouZ2V0Qm91bmRzKCkpO1xuXHQgKiBcblx0ICogQG1ldGhvZCBnZXRCb3VuZHNcblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBBIFJlY3RhbmdsZSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIGJvdW5kcywgb3IgbnVsbCBpZiBib3VuZHMgYXJlIG5vdCBhdmFpbGFibGUgZm9yIHRoaXNcblx0ICogb2JqZWN0LlxuXHQgKiovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2JvdW5kcykgeyByZXR1cm4gdGhpcy5fcmVjdGFuZ2xlLmNvcHkodGhpcy5fYm91bmRzKTsgfVxuXHRcdHZhciBjYWNoZUNhbnZhcyA9IHRoaXMuY2FjaGVDYW52YXM7XG5cdFx0aWYgKGNhY2hlQ2FudmFzKSB7XG5cdFx0XHR2YXIgc2NhbGUgPSB0aGlzLl9jYWNoZVNjYWxlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlY3RhbmdsZS5zZXRWYWx1ZXModGhpcy5fY2FjaGVPZmZzZXRYLCB0aGlzLl9jYWNoZU9mZnNldFksIGNhY2hlQ2FudmFzLndpZHRoL3NjYWxlLCBjYWNoZUNhbnZhcy5oZWlnaHQvc2NhbGUpO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgcmVjdGFuZ2xlIHJlcHJlc2VudGluZyB0aGlzIG9iamVjdCdzIGJvdW5kcyBpbiBpdHMgcGFyZW50J3MgY29vcmRpbmF0ZSBzeXN0ZW0gKGllLiB3aXRoIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWVkKS5cblx0ICogT2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBjYWNoZWQgd2lsbCByZXR1cm4gdGhlIHRyYW5zZm9ybWVkIGJvdW5kcyBvZiB0aGUgY2FjaGUuXG5cdCAqIFxuXHQgKiBOb3QgYWxsIGRpc3BsYXkgb2JqZWN0cyBjYW4gY2FsY3VsYXRlIHRoZWlyIG93biBib3VuZHMgKGV4LiBTaGFwZSkuIEZvciB0aGVzZSBvYmplY3RzLCB5b3UgY2FuIHVzZSBcblx0ICoge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9zZXRCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0gc28gdGhhdCB0aGV5IGFyZSBpbmNsdWRlZCB3aGVuIGNhbGN1bGF0aW5nIENvbnRhaW5lclxuXHQgKiBib3VuZHMuXG5cdCAqIFxuXHQgKiBUbyByZWR1Y2UgbWVtb3J5IGltcGFjdCwgdGhlIHJldHVybmVkIFJlY3RhbmdsZSBpbnN0YW5jZSBtYXkgYmUgcmV1c2VkIGludGVybmFsbHk7IGNsb25lIHRoZSBpbnN0YW5jZSBvciBjb3B5IGl0c1xuXHQgKiB2YWx1ZXMgaWYgeW91IG5lZWQgdG8gcmV0YWluIGl0LlxuXHQgKiBcblx0ICogQ29udGFpbmVyIGluc3RhbmNlcyBjYWxjdWxhdGUgYWdncmVnYXRlIGJvdW5kcyBmb3IgYWxsIGNoaWxkcmVuIHRoYXQgcmV0dXJuIGJvdW5kcyB2aWEgZ2V0Qm91bmRzLlxuXHQgKiBAbWV0aG9kIGdldFRyYW5zZm9ybWVkQm91bmRzXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQSBSZWN0YW5nbGUgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBib3VuZHMsIG9yIG51bGwgaWYgYm91bmRzIGFyZSBub3QgYXZhaWxhYmxlIGZvciB0aGlzIG9iamVjdC5cblx0ICoqL1xuXHRwLmdldFRyYW5zZm9ybWVkQm91bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldEJvdW5kcygpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEFsbG93cyB5b3UgdG8gbWFudWFsbHkgc3BlY2lmeSB0aGUgYm91bmRzIG9mIGFuIG9iamVjdCB0aGF0IGVpdGhlciBjYW5ub3QgY2FsY3VsYXRlIHRoZWlyIG93biBib3VuZHMgKGV4LiBTaGFwZSAmXG5cdCAqIFRleHQpIGZvciBmdXR1cmUgcmVmZXJlbmNlLCBvciBzbyB0aGUgb2JqZWN0IGNhbiBiZSBpbmNsdWRlZCBpbiBDb250YWluZXIgYm91bmRzLiBNYW51YWxseSBzZXQgYm91bmRzIHdpbGwgYWx3YXlzXG5cdCAqIG92ZXJyaWRlIGNhbGN1bGF0ZWQgYm91bmRzLlxuXHQgKiBcblx0ICogVGhlIGJvdW5kcyBzaG91bGQgYmUgc3BlY2lmaWVkIGluIHRoZSBvYmplY3QncyBsb2NhbCAodW50cmFuc2Zvcm1lZCkgY29vcmRpbmF0ZXMuIEZvciBleGFtcGxlLCBhIFNoYXBlIGluc3RhbmNlXG5cdCAqIHdpdGggYSAyNXB4IHJhZGl1cyBjaXJjbGUgY2VudGVyZWQgYXQgMCwwIHdvdWxkIGhhdmUgYm91bmRzIG9mICgtMjUsIC0yNSwgNTAsIDUwKS5cblx0ICogQG1ldGhvZCBzZXRCb3VuZHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggb3JpZ2luIG9mIHRoZSBib3VuZHMuIFBhc3MgbnVsbCB0byByZW1vdmUgdGhlIG1hbnVhbCBib3VuZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IG9yaWdpbiBvZiB0aGUgYm91bmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBib3VuZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgYm91bmRzLlxuXHQgKiovXG5cdHAuc2V0Qm91bmRzID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdGlmICh4ID09IG51bGwpIHsgdGhpcy5fYm91bmRzID0geDsgfVxuXHRcdHRoaXMuX2JvdW5kcyA9ICh0aGlzLl9ib3VuZHMgfHwgbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSgpKS5zZXRWYWx1ZXMoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIERpc3BsYXlPYmplY3QuIFNvbWUgcHJvcGVydGllcyB0aGF0IGFyZSBzcGVjaWZpYyB0byB0aGlzIGluc3RhbmNlJ3MgY3VycmVudCBjb250ZXh0IGFyZVxuXHQgKiByZXZlcnRlZCB0byB0aGVpciBkZWZhdWx0cyAoZm9yIGV4YW1wbGUgLnBhcmVudCkuIENhY2hlcyBhcmUgbm90IG1haW50YWluZWQgYWNyb3NzIGNsb25lcywgYW5kIHNvbWUgZWxlbWVudHNcblx0ICogYXJlIGNvcGllZCBieSByZWZlcmVuY2UgKG1hc2tzLCBpbmRpdmlkdWFsIGZpbHRlciBpbnN0YW5jZXMsIGhpdCBhcmVhKVxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IEEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgRGlzcGxheU9iamVjdCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lUHJvcHMobmV3IERpc3BsYXlPYmplY3QoKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltEaXNwbGF5T2JqZWN0IChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvLyBzZXBhcmF0ZWQgc28gaXQgY2FuIGJlIHVzZWQgbW9yZSBlYXNpbHkgaW4gc3ViY2xhc3Nlczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2Nsb25lUHJvcHNcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBvIFRoZSBEaXNwbGF5T2JqZWN0IGluc3RhbmNlIHdoaWNoIHdpbGwgaGF2ZSBwcm9wZXJ0aWVzIGZyb20gdGhlIGN1cnJlbnQgRGlzcGxheU9iamVjdFxuXHQgKiBpbnN0YW5jZSBjb3BpZWQgaW50by5cblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fY2xvbmVQcm9wcyA9IGZ1bmN0aW9uKG8pIHtcblx0XHRvLmFscGhhID0gdGhpcy5hbHBoYTtcblx0XHRvLm1vdXNlRW5hYmxlZCA9IHRoaXMubW91c2VFbmFibGVkO1xuXHRcdG8udGlja0VuYWJsZWQgPSB0aGlzLnRpY2tFbmFibGVkO1xuXHRcdG8ubmFtZSA9IHRoaXMubmFtZTtcblx0XHRvLnJlZ1ggPSB0aGlzLnJlZ1g7XG5cdFx0by5yZWdZID0gdGhpcy5yZWdZO1xuXHRcdG8ucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuXHRcdG8uc2NhbGVYID0gdGhpcy5zY2FsZVg7XG5cdFx0by5zY2FsZVkgPSB0aGlzLnNjYWxlWTtcblx0XHRvLnNoYWRvdyA9IHRoaXMuc2hhZG93O1xuXHRcdG8uc2tld1ggPSB0aGlzLnNrZXdYO1xuXHRcdG8uc2tld1kgPSB0aGlzLnNrZXdZO1xuXHRcdG8udmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcblx0XHRvLnggID0gdGhpcy54O1xuXHRcdG8ueSA9IHRoaXMueTtcblx0XHRvLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdG8uc25hcFRvUGl4ZWwgPSB0aGlzLnNuYXBUb1BpeGVsO1xuXHRcdG8uZmlsdGVycyA9IHRoaXMuZmlsdGVycz09bnVsbD9udWxsOnRoaXMuZmlsdGVycy5zbGljZSgwKTtcblx0XHRvLm1hc2sgPSB0aGlzLm1hc2s7XG5cdFx0by5oaXRBcmVhID0gdGhpcy5oaXRBcmVhO1xuXHRcdG8uY3Vyc29yID0gdGhpcy5jdXJzb3I7XG5cdFx0by5fYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9hcHBseVNoYWRvd1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtTaGFkb3d9IHNoYWRvd1xuXHQgKiovXG5cdHAuX2FwcGx5U2hhZG93ID0gZnVuY3Rpb24oY3R4LCBzaGFkb3cpIHtcblx0XHRzaGFkb3cgPSBzaGFkb3cgfHwgU2hhZG93LmlkZW50aXR5O1xuXHRcdGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvdy5jb2xvcjtcblx0XHRjdHguc2hhZG93T2Zmc2V0WCA9IHNoYWRvdy5vZmZzZXRYO1xuXHRcdGN0eC5zaGFkb3dPZmZzZXRZID0gc2hhZG93Lm9mZnNldFk7XG5cdFx0Y3R4LnNoYWRvd0JsdXIgPSBzaGFkb3cuYmx1cjtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfdGlja1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZ0T2JqIEFuIGV2ZW50IG9iamVjdCB0aGF0IHdpbGwgYmUgZGlzcGF0Y2hlZCB0byBhbGwgdGljayBsaXN0ZW5lcnMuIFRoaXMgb2JqZWN0IGlzIHJldXNlZCBiZXR3ZWVuIGRpc3BhdGNoZXJzIHRvIHJlZHVjZSBjb25zdHJ1Y3Rpb24gJiBHQyBjb3N0cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3RpY2sgPSBmdW5jdGlvbihldnRPYmopIHtcblx0XHQvLyBiZWNhdXNlIHRpY2sgY2FuIGJlIHJlYWxseSBwZXJmb3JtYW5jZSBzZW5zaXRpdmUsIGNoZWNrIGZvciBsaXN0ZW5lcnMgYmVmb3JlIGNhbGxpbmcgZGlzcGF0Y2hFdmVudC5cblx0XHR2YXIgbHMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0aWYgKGxzICYmIGxzW1widGlja1wiXSkge1xuXHRcdFx0Ly8gcmVzZXQgJiByZXVzZSB0aGUgZXZlbnQgb2JqZWN0IHRvIGF2b2lkIGNvbnN0cnVjdGlvbiAvIEdDIGNvc3RzOlxuXHRcdFx0ZXZ0T2JqLnRhcmdldCA9IG51bGw7XG5cdFx0XHRldnRPYmoucHJvcGFnYXRpb25TdG9wcGVkID0gZXZ0T2JqLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2dE9iaik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF90ZXN0SGl0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiovXG5cdHAuX3Rlc3RIaXQgPSBmdW5jdGlvbihjdHgpIHtcblx0XHR0cnkge1xuXHRcdFx0dmFyIGhpdCA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YVszXSA+IDE7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKCFEaXNwbGF5T2JqZWN0LnN1cHByZXNzQ3Jvc3NEb21haW5FcnJvcnMpIHtcblx0XHRcdFx0dGhyb3cgXCJBbiBlcnJvciBoYXMgb2NjdXJyZWQuIFRoaXMgaXMgbW9zdCBsaWtlbHkgZHVlIHRvIHNlY3VyaXR5IHJlc3RyaWN0aW9ucyBvbiByZWFkaW5nIGNhbnZhcyBwaXhlbCBkYXRhIHdpdGggbG9jYWwgb3IgY3Jvc3MtZG9tYWluIGltYWdlcy5cIjtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGhpdDtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfYXBwbHlGaWx0ZXJzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9hcHBseUZpbHRlcnMgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuZmlsdGVycyB8fCB0aGlzLmZpbHRlcnMubGVuZ3RoID09IDAgfHwgIXRoaXMuY2FjaGVDYW52YXMpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoO1xuXHRcdHZhciBjdHggPSB0aGlzLmNhY2hlQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHR2YXIgdyA9IHRoaXMuY2FjaGVDYW52YXMud2lkdGg7XG5cdFx0dmFyIGggPSB0aGlzLmNhY2hlQ2FudmFzLmhlaWdodDtcblx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7XG5cdFx0XHR0aGlzLmZpbHRlcnNbaV0uYXBwbHlGaWx0ZXIoY3R4LCAwLCAwLCB3LCBoKTtcblx0XHR9XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0RmlsdGVyQm91bmRzXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldEZpbHRlckJvdW5kcyA9IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgbCwgZmlsdGVycyA9IHRoaXMuZmlsdGVycywgYm91bmRzID0gdGhpcy5fcmVjdGFuZ2xlLnNldFZhbHVlcygwLDAsMCwwKTtcblx0XHRpZiAoIWZpbHRlcnMgfHwgIShsPWZpbHRlcnMubGVuZ3RoKSkgeyByZXR1cm4gYm91bmRzOyB9XG5cdFx0XG5cdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIGYgPSB0aGlzLmZpbHRlcnNbaV07XG5cdFx0XHRmLmdldEJvdW5kcyYmZi5nZXRCb3VuZHMoYm91bmRzKTtcblx0XHR9XG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRCb3VuZHNcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlVHJhbnNmb3JtIElmIHRydWUsIGRvZXMgbm90IGFwcGx5IHRoaXMgb2JqZWN0J3MgdHJhbnNmb3JtLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nZXRCb3VuZHMgPSBmdW5jdGlvbihtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSl7XG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybUJvdW5kcyh0aGlzLmdldEJvdW5kcygpLCBtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfdHJhbnNmb3JtQm91bmRzXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBib3VuZHNcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlVHJhbnNmb3JtXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3RyYW5zZm9ybUJvdW5kcyA9IGZ1bmN0aW9uKGJvdW5kcywgbWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pIHtcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gYm91bmRzOyB9XG5cdFx0dmFyIHggPSBib3VuZHMueCwgeSA9IGJvdW5kcy55LCB3aWR0aCA9IGJvdW5kcy53aWR0aCwgaGVpZ2h0ID0gYm91bmRzLmhlaWdodCwgbXR4ID0gdGhpcy5fcHJvcHMubWF0cml4O1xuXHRcdG10eCA9IGlnbm9yZVRyYW5zZm9ybSA/IG10eC5pZGVudGl0eSgpIDogdGhpcy5nZXRNYXRyaXgobXR4KTtcblx0XHRcblx0XHRpZiAoeCB8fCB5KSB7IG10eC5hcHBlbmRUcmFuc2Zvcm0oMCwwLDEsMSwwLDAsMCwteCwteSk7IH0gLy8gVE9ETzogc2ltcGxpZnkgdGhpcy5cblx0XHRpZiAobWF0cml4KSB7IG10eC5wcmVwZW5kTWF0cml4KG1hdHJpeCk7IH1cblx0XHRcblx0XHR2YXIgeF9hID0gd2lkdGgqbXR4LmEsIHhfYiA9IHdpZHRoKm10eC5iO1xuXHRcdHZhciB5X2MgPSBoZWlnaHQqbXR4LmMsIHlfZCA9IGhlaWdodCptdHguZDtcblx0XHR2YXIgdHggPSBtdHgudHgsIHR5ID0gbXR4LnR5O1xuXHRcdFxuXHRcdHZhciBtaW5YID0gdHgsIG1heFggPSB0eCwgbWluWSA9IHR5LCBtYXhZID0gdHk7XG5cblx0XHRpZiAoKHggPSB4X2EgKyB0eCkgPCBtaW5YKSB7IG1pblggPSB4OyB9IGVsc2UgaWYgKHggPiBtYXhYKSB7IG1heFggPSB4OyB9XG5cdFx0aWYgKCh4ID0geF9hICsgeV9jICsgdHgpIDwgbWluWCkgeyBtaW5YID0geDsgfSBlbHNlIGlmICh4ID4gbWF4WCkgeyBtYXhYID0geDsgfVxuXHRcdGlmICgoeCA9IHlfYyArIHR4KSA8IG1pblgpIHsgbWluWCA9IHg7IH0gZWxzZSBpZiAoeCA+IG1heFgpIHsgbWF4WCA9IHg7IH1cblx0XHRcblx0XHRpZiAoKHkgPSB4X2IgKyB0eSkgPCBtaW5ZKSB7IG1pblkgPSB5OyB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7IG1heFkgPSB5OyB9XG5cdFx0aWYgKCh5ID0geF9iICsgeV9kICsgdHkpIDwgbWluWSkgeyBtaW5ZID0geTsgfSBlbHNlIGlmICh5ID4gbWF4WSkgeyBtYXhZID0geTsgfVxuXHRcdGlmICgoeSA9IHlfZCArIHR5KSA8IG1pblkpIHsgbWluWSA9IHk7IH0gZWxzZSBpZiAoeSA+IG1heFkpIHsgbWF4WSA9IHk7IH1cblx0XHRcblx0XHRyZXR1cm4gYm91bmRzLnNldFZhbHVlcyhtaW5YLCBtaW5ZLCBtYXhYLW1pblgsIG1heFktbWluWSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IGhhcyBhbnkgbW91c2UgZXZlbnQgbGlzdGVuZXJzIG9yIGEgY3Vyc29yLlxuXHQgKiBAbWV0aG9kIF9pc01vdXNlT3BhcXVlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9oYXNNb3VzZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgZXZ0cyA9IERpc3BsYXlPYmplY3QuX01PVVNFX0VWRU5UUztcblx0XHRmb3IgKHZhciBpPSAwLCBsPWV2dHMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihldnRzW2ldKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gISF0aGlzLmN1cnNvcjtcblx0fTtcblxuXHRjcmVhdGVqcy5EaXNwbGF5T2JqZWN0ID0gY3JlYXRlanMucHJvbW90ZShEaXNwbGF5T2JqZWN0LCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDb250YWluZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXG4vLyBjb25zdHJ1Y3Rvcjpcbi8qKlxuICogQSBDb250YWluZXIgaXMgYSBuZXN0YWJsZSBkaXNwbGF5IGxpc3QgdGhhdCBhbGxvd3MgeW91IHRvIHdvcmsgd2l0aCBjb21wb3VuZCBkaXNwbGF5IGVsZW1lbnRzLiBGb3IgIGV4YW1wbGUgeW91IGNvdWxkXG4gKiBncm91cCBhcm0sIGxlZywgdG9yc28gYW5kIGhlYWQge3sjY3Jvc3NMaW5rIFwiQml0bWFwXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcyB0b2dldGhlciBpbnRvIGEgUGVyc29uIENvbnRhaW5lciwgYW5kXG4gKiB0cmFuc2Zvcm0gdGhlbSBhcyBhIGdyb3VwLCB3aGlsZSBzdGlsbCBiZWluZyBhYmxlIHRvIG1vdmUgdGhlIGluZGl2aWR1YWwgcGFydHMgcmVsYXRpdmUgdG8gZWFjaCBvdGhlci4gQ2hpbGRyZW4gb2ZcbiAqIGNvbnRhaW5lcnMgaGF2ZSB0aGVpciA8Y29kZT50cmFuc2Zvcm08L2NvZGU+IGFuZCA8Y29kZT5hbHBoYTwvY29kZT4gcHJvcGVydGllcyBjb25jYXRlbmF0ZWQgd2l0aCB0aGVpciBwYXJlbnRcbiAqIENvbnRhaW5lci5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgYSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSB3aXRoIHg9MTAwIGFuZCBhbHBoYT0wLjUsIHBsYWNlZCBpbiBhIENvbnRhaW5lciB3aXRoIDxjb2RlPng9NTA8L2NvZGU+XG4gKiBhbmQgPGNvZGU+YWxwaGE9MC43PC9jb2RlPiB3aWxsIGJlIHJlbmRlcmVkIHRvIHRoZSBjYW52YXMgYXQgPGNvZGU+eD0xNTA8L2NvZGU+IGFuZCA8Y29kZT5hbHBoYT0wLjM1PC9jb2RlPi5cbiAqIENvbnRhaW5lcnMgaGF2ZSBzb21lIG92ZXJoZWFkLCBzbyB5b3UgZ2VuZXJhbGx5IHNob3VsZG4ndCBjcmVhdGUgYSBDb250YWluZXIgdG8gaG9sZCBhIHNpbmdsZSBjaGlsZC5cbiAqXG4gKiA8aDQ+RXhhbXBsZTwvaDQ+XG4gKlxuICogICAgICB2YXIgY29udGFpbmVyID0gbmV3IGNyZWF0ZWpzLkNvbnRhaW5lcigpO1xuICogICAgICBjb250YWluZXIuYWRkQ2hpbGQoYml0bWFwSW5zdGFuY2UsIHNoYXBlSW5zdGFuY2UpO1xuICogICAgICBjb250YWluZXIueCA9IDEwMDtcbiAqXG4gKiBAY2xhc3MgQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqKi9cblx0ZnVuY3Rpb24gQ29udGFpbmVyKCkge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgYXJyYXkgb2YgY2hpbGRyZW4gaW4gdGhlIGRpc3BsYXkgbGlzdC4gWW91IHNob3VsZCB1c3VhbGx5IHVzZSB0aGUgY2hpbGQgbWFuYWdlbWVudCBtZXRob2RzIHN1Y2ggYXNcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvYWRkQ2hpbGRcIn19e3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9yZW1vdmVDaGlsZFwifX17ey9jcm9zc0xpbmt9fSxcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvc3dhcENoaWxkcmVuXCJ9fXt7L2Nyb3NzTGlua319LCBldGMsIHJhdGhlciB0aGFuIGFjY2Vzc2luZyB0aGlzIGRpcmVjdGx5LCBidXQgaXQgaXNcblx0XHQgKiBpbmNsdWRlZCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0XHQgKiBAcHJvcGVydHkgY2hpbGRyZW5cblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lciBhcmUgaW5kZXBlbmRlbnRseSBlbmFibGVkIGZvciBtb3VzZS9wb2ludGVyIGludGVyYWN0aW9uLlxuXHRcdCAqIElmIGZhbHNlLCB0aGUgY2hpbGRyZW4gd2lsbCBiZSBhZ2dyZWdhdGVkIHVuZGVyIHRoZSBjb250YWluZXIgLSBmb3IgZXhhbXBsZSwgYSBjbGljayBvbiBhIGNoaWxkIHNoYXBlIHdvdWxkXG5cdFx0ICogdHJpZ2dlciBhIGNsaWNrIGV2ZW50IG9uIHRoZSBjb250YWluZXIuXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlQ2hpbGRyZW5cblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLm1vdXNlQ2hpbGRyZW4gPSB0cnVlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIElmIGZhbHNlLCB0aGUgdGljayB3aWxsIG5vdCBiZSBwcm9wYWdhdGVkIHRvIGNoaWxkcmVuIG9mIHRoaXMgQ29udGFpbmVyLiBUaGlzIGNhbiBwcm92aWRlIHNvbWUgcGVyZm9ybWFuY2UgYmVuZWZpdHMuXG5cdFx0ICogSW4gYWRkaXRpb24gdG8gcHJldmVudGluZyB0aGUgXCJ0aWNrXCIgZXZlbnQgZnJvbSBiZWluZyBkaXNwYXRjaGVkLCBpdCB3aWxsIGFsc28gcHJldmVudCB0aWNrIHJlbGF0ZWQgdXBkYXRlc1xuXHRcdCAqIG9uIHNvbWUgZGlzcGxheSBvYmplY3RzIChleC4gU3ByaXRlICYgTW92aWVDbGlwIGZyYW1lIGFkdmFuY2luZywgRE9NRWxlbWVudCB2aXNpYmlsaXR5IGhhbmRsaW5nKS5cblx0XHQgKiBAcHJvcGVydHkgdGlja0NoaWxkcmVuXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiovXG5cdFx0dGhpcy50aWNrQ2hpbGRyZW4gPSB0cnVlO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKENvbnRhaW5lciwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cdFxuXHRcbi8vIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9udW1DaGlsZHJlbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldE51bUNoaWxkcmVuXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLmdldE51bUNoaWxkcmVuID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhlIGNvbnRhaW5lci5cblx0ICogQHByb3BlcnR5IG51bUNoaWxkcmVuXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXHRcdFx0bnVtQ2hpbGRyZW46IHsgZ2V0OiBwLmdldE51bUNoaWxkcmVuIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge31cblx0XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQ29uc3RydWN0b3IgYWxpYXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLlxuXHQgKiBTdWJjbGFzc2VzIHNob3VsZCBiZSB1cGRhdGVkIHRvIHVzZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBgY3JlYXRlanMucHJvbW90ZSgpYFxuXHQgKiovXG5cdHAuaW5pdGlhbGl6ZSA9IENvbnRhaW5lcjsgLy8gVE9ETzogZGVwcmVjYXRlZC5cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzQ29udGVudCA9IHRoaXMuY2FjaGVDYW52YXMgfHwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDAgJiYgaGFzQ29udGVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZUNhY2hlPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS5cblx0ICogRm9yIGV4YW1wbGUsIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFja1xuXHQgKiBpbnRvIGl0c2VsZikuXG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFxuXHRcdC8vIHRoaXMgZW5zdXJlcyB3ZSBkb24ndCBoYXZlIGlzc3VlcyB3aXRoIGRpc3BsYXkgbGlzdCBjaGFuZ2VzIHRoYXQgb2NjdXIgZHVyaW5nIGEgZHJhdzpcblx0XHR2YXIgbGlzdCA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcblx0XHRmb3IgKHZhciBpPTAsbD1saXN0Lmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGxpc3RbaV07XG5cdFx0XHRpZiAoIWNoaWxkLmlzVmlzaWJsZSgpKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcblx0XHRcdC8vIGRyYXcgdGhlIGNoaWxkOlxuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGNoaWxkLnVwZGF0ZUNvbnRleHQoY3R4KTtcblx0XHRcdGNoaWxkLmRyYXcoY3R4KTtcblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEFkZHMgYSBjaGlsZCB0byB0aGUgdG9wIG9mIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogXHRcdGNvbnRhaW5lci5hZGRDaGlsZChiaXRtYXBJbnN0YW5jZSk7XG5cdCAqXG5cdCAqIFlvdSBjYW4gYWxzbyBhZGQgbXVsdGlwbGUgY2hpbGRyZW4gYXQgb25jZTpcblx0ICpcblx0ICogXHRcdGNvbnRhaW5lci5hZGRDaGlsZChiaXRtYXBJbnN0YW5jZSwgc2hhcGVJbnN0YW5jZSwgdGV4dEluc3RhbmNlKTtcblx0ICpcblx0ICogQG1ldGhvZCBhZGRDaGlsZFxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkIFRoZSBkaXNwbGF5IG9iamVjdCB0byBhZGQuXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB0aGF0IHdhcyBhZGRlZCwgb3IgdGhlIGxhc3QgY2hpbGQgaWYgbXVsdGlwbGUgY2hpbGRyZW4gd2VyZSBhZGRlZC5cblx0ICoqL1xuXHRwLmFkZENoaWxkID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0XHRpZiAoY2hpbGQgPT0gbnVsbCkgeyByZXR1cm4gY2hpbGQ7IH1cblx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKGwgPiAxKSB7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IHRoaXMuYWRkQ2hpbGQoYXJndW1lbnRzW2ldKTsgfVxuXHRcdFx0cmV0dXJuIGFyZ3VtZW50c1tsLTFdO1xuXHRcdH1cblx0XHRpZiAoY2hpbGQucGFyZW50KSB7IGNoaWxkLnBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7IH1cblx0XHRjaGlsZC5wYXJlbnQgPSB0aGlzO1xuXHRcdHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cdFx0Y2hpbGQuZGlzcGF0Y2hFdmVudChcImFkZGVkXCIpO1xuXHRcdHJldHVybiBjaGlsZDtcblx0fTtcblxuXHQvKipcblx0ICogQWRkcyBhIGNoaWxkIHRvIHRoZSBkaXNwbGF5IGxpc3QgYXQgdGhlIHNwZWNpZmllZCBpbmRleCwgYnVtcGluZyBjaGlsZHJlbiBhdCBlcXVhbCBvciBncmVhdGVyIGluZGV4ZXMgdXAgb25lLCBhbmRcblx0ICogc2V0dGluZyBpdHMgcGFyZW50IHRvIHRoaXMgQ29udGFpbmVyLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgYWRkQ2hpbGRBdChjaGlsZDEsIGluZGV4KTtcblx0ICpcblx0ICogWW91IGNhbiBhbHNvIGFkZCBtdWx0aXBsZSBjaGlsZHJlbiwgc3VjaCBhczpcblx0ICpcblx0ICogICAgICBhZGRDaGlsZEF0KGNoaWxkMSwgY2hpbGQyLCAuLi4sIGluZGV4KTtcblx0ICpcblx0ICogVGhlIGluZGV4IG11c3QgYmUgYmV0d2VlbiAwIGFuZCBudW1DaGlsZHJlbi4gRm9yIGV4YW1wbGUsIHRvIGFkZCBteVNoYXBlIHVuZGVyIG90aGVyU2hhcGUgaW4gdGhlIGRpc3BsYXkgbGlzdCxcblx0ICogeW91IGNvdWxkIHVzZTpcblx0ICpcblx0ICogICAgICBjb250YWluZXIuYWRkQ2hpbGRBdChteVNoYXBlLCBjb250YWluZXIuZ2V0Q2hpbGRJbmRleChvdGhlclNoYXBlKSk7XG5cdCAqXG5cdCAqIFRoaXMgd291bGQgYWxzbyBidW1wIG90aGVyU2hhcGUncyBpbmRleCB1cCBieSBvbmUuIEZhaWxzIHNpbGVudGx5IGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgYWRkQ2hpbGRBdFxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkIFRoZSBkaXNwbGF5IG9iamVjdCB0byBhZGQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gYWRkIHRoZSBjaGlsZCBhdC5cblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gUmV0dXJucyB0aGUgbGFzdCBjaGlsZCB0aGF0IHdhcyBhZGRlZCwgb3IgdGhlIGxhc3QgY2hpbGQgaWYgbXVsdGlwbGUgY2hpbGRyZW4gd2VyZSBhZGRlZC5cblx0ICoqL1xuXHRwLmFkZENoaWxkQXQgPSBmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcblx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0dmFyIGluZHggPSBhcmd1bWVudHNbbC0xXTsgLy8gY2FuJ3QgdXNlIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGluZGV4IHBhcmFtIG9yIGl0IHJlcGxhY2VzIGFyZ3VtZW50c1sxXVxuXHRcdGlmIChpbmR4IDwgMCB8fCBpbmR4ID4gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHsgcmV0dXJuIGFyZ3VtZW50c1tsLTJdOyB9XG5cdFx0aWYgKGwgPiAyKSB7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bC0xOyBpKyspIHsgdGhpcy5hZGRDaGlsZEF0KGFyZ3VtZW50c1tpXSwgaW5keCtpKTsgfVxuXHRcdFx0cmV0dXJuIGFyZ3VtZW50c1tsLTJdO1xuXHRcdH1cblx0XHRpZiAoY2hpbGQucGFyZW50KSB7IGNoaWxkLnBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7IH1cblx0XHRjaGlsZC5wYXJlbnQgPSB0aGlzO1xuXHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7XG5cdFx0Y2hpbGQuZGlzcGF0Y2hFdmVudChcImFkZGVkXCIpO1xuXHRcdHJldHVybiBjaGlsZDtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGNoaWxkIGZyb20gdGhlIGRpc3BsYXkgbGlzdC4gTm90ZSB0aGF0IGl0IGlzIGZhc3RlciB0byB1c2UgcmVtb3ZlQ2hpbGRBdCgpIGlmIHRoZSBpbmRleCBpc1xuXHQgKiBhbHJlYWR5IGtub3duLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcblx0ICpcblx0ICogWW91IGNhbiBhbHNvIHJlbW92ZSBtdWx0aXBsZSBjaGlsZHJlbjpcblx0ICpcblx0ICogICAgICByZW1vdmVDaGlsZChjaGlsZDEsIGNoaWxkMiwgLi4uKTtcblx0ICpcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBjaGlsZCAob3IgY2hpbGRyZW4pIHdhcyByZW1vdmVkLCBvciBmYWxzZSBpZiBpdCB3YXMgbm90IGluIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZCBUaGUgY2hpbGQgdG8gcmVtb3ZlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBjaGlsZCAob3IgY2hpbGRyZW4pIHdhcyByZW1vdmVkLCBvciBmYWxzZSBpZiBpdCB3YXMgbm90IGluIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqKi9cblx0cC5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG5cdFx0dmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdGlmIChsID4gMSkge1xuXHRcdFx0dmFyIGdvb2QgPSB0cnVlO1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyBnb29kID0gZ29vZCAmJiB0aGlzLnJlbW92ZUNoaWxkKGFyZ3VtZW50c1tpXSk7IH1cblx0XHRcdHJldHVybiBnb29kO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVDaGlsZEF0KGNyZWF0ZWpzLmluZGV4T2YodGhpcy5jaGlsZHJlbiwgY2hpbGQpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBmcm9tIHRoZSBkaXNwbGF5IGxpc3QsIGFuZCBzZXRzIGl0cyBwYXJlbnQgdG8gbnVsbC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZEF0KDIpO1xuXHQgKlxuXHQgKiBZb3UgY2FuIGFsc28gcmVtb3ZlIG11bHRpcGxlIGNoaWxkcmVuOlxuXHQgKlxuXHQgKiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZCgyLCA3LCAuLi4pXG5cdCAqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hpbGQgKG9yIGNoaWxkcmVuKSB3YXMgcmVtb3ZlZCwgb3IgZmFsc2UgaWYgYW55IGluZGV4IHdhcyBvdXQgb2YgcmFuZ2UuXG5cdCAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRBdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBjaGlsZCB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGNoaWxkIChvciBjaGlsZHJlbikgd2FzIHJlbW92ZWQsIG9yIGZhbHNlIGlmIGFueSBpbmRleCB3YXMgb3V0IG9mIHJhbmdlLlxuXHQgKiovXG5cdHAucmVtb3ZlQ2hpbGRBdCA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdGlmIChsID4gMSkge1xuXHRcdFx0dmFyIGEgPSBbXTtcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHsgYVtpXSA9IGFyZ3VtZW50c1tpXTsgfVxuXHRcdFx0YS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGItYTsgfSk7XG5cdFx0XHR2YXIgZ29vZCA9IHRydWU7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IGdvb2QgPSBnb29kICYmIHRoaXMucmVtb3ZlQ2hpbGRBdChhW2ldKTsgfVxuXHRcdFx0cmV0dXJuIGdvb2Q7XG5cdFx0fVxuXHRcdGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLmNoaWxkcmVuLmxlbmd0aC0xKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baW5kZXhdO1xuXHRcdGlmIChjaGlsZCkgeyBjaGlsZC5wYXJlbnQgPSBudWxsOyB9XG5cdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdGNoaWxkLmRpc3BhdGNoRXZlbnQoXCJyZW1vdmVkXCIpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogXHRjb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcblx0ICpcblx0ICogQG1ldGhvZCByZW1vdmVBbGxDaGlsZHJlblxuXHQgKiovXG5cdHAucmVtb3ZlQWxsQ2hpbGRyZW4gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIga2lkcyA9IHRoaXMuY2hpbGRyZW47XG5cdFx0d2hpbGUgKGtpZHMubGVuZ3RoKSB7IHRoaXMucmVtb3ZlQ2hpbGRBdCgwKTsgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY29udGFpbmVyLmdldENoaWxkQXQoMik7XG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0Q2hpbGRBdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBjaGlsZCB0byByZXR1cm4uXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gY2hpbGQgYXQgdGhlIGluZGV4LlxuXHQgKiovXG5cdHAuZ2V0Q2hpbGRBdCA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hpbGRyZW5baW5kZXhdO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNoaWxkIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxuXHQgKiBAbWV0aG9kIGdldENoaWxkQnlOYW1lXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjaGlsZCB0byByZXR1cm4uXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cblx0ICoqL1xuXHRwLmdldENoaWxkQnlOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuXHRcdHZhciBraWRzID0gdGhpcy5jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpPTAsbD1raWRzLmxlbmd0aDtpPGw7aSsrKSB7XG5cdFx0XHRpZihraWRzW2ldLm5hbWUgPT0gbmFtZSkgeyByZXR1cm4ga2lkc1tpXTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogUGVyZm9ybXMgYW4gYXJyYXkgc29ydCBvcGVyYXRpb24gb24gdGhlIGNoaWxkIGxpc3QuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlOiBEaXNwbGF5IGNoaWxkcmVuIHdpdGggYSBoaWdoZXIgeSBpbiBmcm9udC48L2g0PlxuXHQgKiBcblx0ICogICAgICB2YXIgc29ydEZ1bmN0aW9uID0gZnVuY3Rpb24ob2JqMSwgb2JqMiwgb3B0aW9ucykge1xuXHQgKiAgICAgICAgICBpZiAob2JqMS55ID4gb2JqMi55KSB7IHJldHVybiAxOyB9XG5cdCAqICAgICAgICAgIGlmIChvYmoxLnkgPCBvYmoyLnkpIHsgcmV0dXJuIC0xOyB9XG5cdCAqICAgICAgICAgIHJldHVybiAwO1xuXHQgKiAgICAgIH1cblx0ICogICAgICBjb250YWluZXIuc29ydENoaWxkcmVuKHNvcnRGdW5jdGlvbik7XG5cdCAqXG5cdCAqIEBtZXRob2Qgc29ydENoaWxkcmVuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRGdW5jdGlvbiB0aGUgZnVuY3Rpb24gdG8gdXNlIHRvIHNvcnQgdGhlIGNoaWxkIGxpc3QuIFNlZSBKYXZhU2NyaXB0J3MgPGNvZGU+QXJyYXkuc29ydDwvY29kZT5cblx0ICogZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy5cblx0ICoqL1xuXHRwLnNvcnRDaGlsZHJlbiA9IGZ1bmN0aW9uKHNvcnRGdW5jdGlvbikge1xuXHRcdHRoaXMuY2hpbGRyZW4uc29ydChzb3J0RnVuY3Rpb24pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgc3BlY2lmaWVkIGNoaWxkIGluIHRoZSBkaXNwbGF5IGxpc3QsIG9yIC0xIGlmIGl0IGlzIG5vdCBpbiB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIGluZGV4ID0gY29udGFpbmVyLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGdldENoaWxkSW5kZXhcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZCBUaGUgY2hpbGQgdG8gcmV0dXJuIHRoZSBpbmRleCBvZi5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIHNwZWNpZmllZCBjaGlsZC4gLTEgaWYgdGhlIGNoaWxkIGlzIG5vdCBmb3VuZC5cblx0ICoqL1xuXHRwLmdldENoaWxkSW5kZXggPSBmdW5jdGlvbihjaGlsZCkge1xuXHRcdHJldHVybiBjcmVhdGVqcy5pbmRleE9mKHRoaXMuY2hpbGRyZW4sIGNoaWxkKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTd2FwcyB0aGUgY2hpbGRyZW4gYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzLiBGYWlscyBzaWxlbnRseSBpZiBlaXRoZXIgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuXHQgKiBAbWV0aG9kIHN3YXBDaGlsZHJlbkF0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4MlxuXHQgKiovXG5cdHAuc3dhcENoaWxkcmVuQXQgPSBmdW5jdGlvbihpbmRleDEsIGluZGV4Mikge1xuXHRcdHZhciBraWRzID0gdGhpcy5jaGlsZHJlbjtcblx0XHR2YXIgbzEgPSBraWRzW2luZGV4MV07XG5cdFx0dmFyIG8yID0ga2lkc1tpbmRleDJdO1xuXHRcdGlmICghbzEgfHwgIW8yKSB7IHJldHVybjsgfVxuXHRcdGtpZHNbaW5kZXgxXSA9IG8yO1xuXHRcdGtpZHNbaW5kZXgyXSA9IG8xO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFN3YXBzIHRoZSBzcGVjaWZpZWQgY2hpbGRyZW4ncyBkZXB0aCBpbiB0aGUgZGlzcGxheSBsaXN0LiBGYWlscyBzaWxlbnRseSBpZiBlaXRoZXIgY2hpbGQgaXMgbm90IGEgY2hpbGQgb2YgdGhpc1xuXHQgKiBDb250YWluZXIuXG5cdCAqIEBtZXRob2Qgc3dhcENoaWxkcmVuXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQxXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQyXG5cdCAqKi9cblx0cC5zd2FwQ2hpbGRyZW4gPSBmdW5jdGlvbihjaGlsZDEsIGNoaWxkMikge1xuXHRcdHZhciBraWRzID0gdGhpcy5jaGlsZHJlbjtcblx0XHR2YXIgaW5kZXgxLGluZGV4Mjtcblx0XHRmb3IgKHZhciBpPTAsbD1raWRzLmxlbmd0aDtpPGw7aSsrKSB7XG5cdFx0XHRpZiAoa2lkc1tpXSA9PSBjaGlsZDEpIHsgaW5kZXgxID0gaTsgfVxuXHRcdFx0aWYgKGtpZHNbaV0gPT0gY2hpbGQyKSB7IGluZGV4MiA9IGk7IH1cblx0XHRcdGlmIChpbmRleDEgIT0gbnVsbCAmJiBpbmRleDIgIT0gbnVsbCkgeyBicmVhazsgfVxuXHRcdH1cblx0XHRpZiAoaT09bCkgeyByZXR1cm47IH0gLy8gVE9ETzogdGhyb3cgZXJyb3I/XG5cdFx0a2lkc1tpbmRleDFdID0gY2hpbGQyO1xuXHRcdGtpZHNbaW5kZXgyXSA9IGNoaWxkMTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDaGFuZ2VzIHRoZSBkZXB0aCBvZiB0aGUgc3BlY2lmaWVkIGNoaWxkLiBGYWlscyBzaWxlbnRseSBpZiB0aGUgY2hpbGQgaXMgbm90IGEgY2hpbGQgb2YgdGhpcyBjb250YWluZXIsIG9yIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4ICBcblx0ICogQG1ldGhvZCBzZXRDaGlsZEluZGV4XG5cdCAqKi9cblx0cC5zZXRDaGlsZEluZGV4ID0gZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG5cdFx0dmFyIGtpZHMgPSB0aGlzLmNoaWxkcmVuLCBsPWtpZHMubGVuZ3RoO1xuXHRcdGlmIChjaGlsZC5wYXJlbnQgIT0gdGhpcyB8fCBpbmRleCA8IDAgfHwgaW5kZXggPj0gbCkgeyByZXR1cm47IH1cblx0XHRmb3IgKHZhciBpPTA7aTxsO2krKykge1xuXHRcdFx0aWYgKGtpZHNbaV0gPT0gY2hpbGQpIHsgYnJlYWs7IH1cblx0XHR9XG5cdFx0aWYgKGk9PWwgfHwgaSA9PSBpbmRleCkgeyByZXR1cm47IH1cblx0XHRraWRzLnNwbGljZShpLDEpO1xuXHRcdGtpZHMuc3BsaWNlKGluZGV4LDAsY2hpbGQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBkaXNwbGF5IG9iamVjdCBlaXRoZXIgaXMgdGhpcyBjb250YWluZXIgb3IgaXMgYSBkZXNjZW5kZW50IChjaGlsZCwgZ3JhbmRjaGlsZCwgZXRjKVxuXHQgKiBvZiB0aGlzIGNvbnRhaW5lci5cblx0ICogQG1ldGhvZCBjb250YWluc1xuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkIFRoZSBEaXNwbGF5T2JqZWN0IHRvIGJlIGNoZWNrZWQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNwZWNpZmllZCBkaXNwbGF5IG9iamVjdCBlaXRoZXIgaXMgdGhpcyBjb250YWluZXIgb3IgaXMgYSBkZXNjZW5kZW50LlxuXHQgKiovXG5cdHAuY29udGFpbnMgPSBmdW5jdGlvbihjaGlsZCkge1xuXHRcdHdoaWxlIChjaGlsZCkge1xuXHRcdFx0aWYgKGNoaWxkID09IHRoaXMpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdGNoaWxkID0gY2hpbGQucGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRlc3RzIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IGludGVyc2VjdHMgdGhlIHNwZWNpZmllZCBsb2NhbCBwb2ludCAoaWUuIGRyYXdzIGEgcGl4ZWwgd2l0aCBhbHBoYSA+IDAgYXQgdGhlXG5cdCAqIHNwZWNpZmllZCBwb3NpdGlvbikuIFRoaXMgaWdub3JlcyB0aGUgYWxwaGEsIHNoYWRvdyBhbmQgY29tcG9zaXRlT3BlcmF0aW9uIG9mIHRoZSBkaXNwbGF5IG9iamVjdCwgYW5kIGFsbFxuXHQgKiB0cmFuc2Zvcm0gcHJvcGVydGllcyBpbmNsdWRpbmcgcmVnWC9ZLlxuXHQgKiBAbWV0aG9kIGhpdFRlc3Rcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gdG8gY2hlY2sgaW4gdGhlIGRpc3BsYXkgb2JqZWN0J3MgbG9jYWwgY29vcmRpbmF0ZXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIHRvIGNoZWNrIGluIHRoZSBkaXNwbGF5IG9iamVjdCdzIGxvY2FsIGNvb3JkaW5hdGVzLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZXJlIGlzIGEgdmlzaWJsZSBzZWN0aW9uIG9mIGEgRGlzcGxheU9iamVjdCB0aGF0IG92ZXJsYXBzIHRoZSBzcGVjaWZpZWRcblx0ICogY29vcmRpbmF0ZXMuXG5cdCAqKi9cblx0cC5oaXRUZXN0ID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdC8vIFRPRE86IG9wdGltaXplIHRvIHVzZSB0aGUgZmFzdCBjYWNoZSBjaGVjayB3aGVyZSBwb3NzaWJsZS5cblx0XHRyZXR1cm4gKHRoaXMuZ2V0T2JqZWN0VW5kZXJQb2ludCh4LCB5KSAhPSBudWxsKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgZGlzcGxheSBvYmplY3RzIHVuZGVyIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZXMgdGhhdCBhcmUgaW4gdGhpcyBjb250YWluZXIncyBkaXNwbGF5XG5cdCAqIGxpc3QuIFRoaXMgcm91dGluZSBpZ25vcmVzIGFueSBkaXNwbGF5IG9iamVjdHMgd2l0aCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlRW5hYmxlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBzZXQgdG8gYGZhbHNlYC4gVGhlIGFycmF5IHdpbGwgYmUgc29ydGVkIGluIG9yZGVyIG9mIHZpc3VhbCBkZXB0aCwgd2l0aCB0aGUgdG9wLW1vc3QgZGlzcGxheSBvYmplY3QgYXQgaW5kZXggMC5cblx0ICogVGhpcyB1c2VzIHNoYXBlIGJhc2VkIGhpdCBkZXRlY3Rpb24sIGFuZCBjYW4gYmUgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbiB0byBydW4sIHNvIGl0IGlzIGJlc3QgdG8gdXNlIGl0IGNhcmVmdWxseS5cblx0ICogRm9yIGV4YW1wbGUsIGlmIHRlc3RpbmcgZm9yIG9iamVjdHMgdW5kZXIgdGhlIG1vdXNlLCB0ZXN0IG9uIHRpY2sgKGluc3RlYWQgb2Ygb24ge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZW1vdmU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0pLFxuXHQgKiBhbmQgb25seSBpZiB0aGUgbW91c2UncyBwb3NpdGlvbiBoYXMgY2hhbmdlZC5cblx0ICogXG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5CeSBkZWZhdWx0IChtb2RlPTApIHRoaXMgbWV0aG9kIGV2YWx1YXRlcyBhbGwgZGlzcGxheSBvYmplY3RzLjwvbGk+XG5cdCAqICAgICA8bGk+Qnkgc2V0dGluZyB0aGUgYG1vZGVgIHBhcmFtZXRlciB0byBgMWAsIHRoZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlRW5hYmxlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBcdFx0YW5kIHt7I2Nyb3NzTGluayBcIm1vdXNlQ2hpbGRyZW46cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydGllcyB3aWxsIGJlIHJlc3BlY3RlZC48L2xpPlxuXHQgKiBcdCAgIDxsaT5TZXR0aW5nIHRoZSBgbW9kZWAgdG8gYDJgIGFkZGl0aW9uYWxseSBleGNsdWRlcyBkaXNwbGF5IG9iamVjdHMgdGhhdCBkbyBub3QgaGF2ZSBhY3RpdmUgbW91c2UgZXZlbnRcblx0ICogXHQgICBcdGxpc3RlbmVycyBvciBhIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Q6Y3Vyc29yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5LiBUaGF0IGlzLCBvbmx5IG9iamVjdHNcblx0ICogXHQgICBcdHRoYXQgd291bGQgbm9ybWFsbHkgaW50ZXJjZXB0IG1vdXNlIGludGVyYWN0aW9uIHdpbGwgYmUgaW5jbHVkZWQuIFRoaXMgY2FuIHNpZ25pZmljYW50bHkgaW1wcm92ZSBwZXJmb3JtYW5jZVxuXHQgKiBcdCAgIFx0aW4gc29tZSBjYXNlcyBieSByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIGRpc3BsYXkgb2JqZWN0cyB0aGF0IG5lZWQgdG8gYmUgdGVzdGVkLjwvbGk+XG5cdCAqIDwvbGk+XG5cdCAqIFxuXHQgKiBUaGlzIG1ldGhvZCBhY2NvdW50cyBmb3IgYm90aCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2hpdEFyZWE6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbWFzazpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBnZXRPYmplY3RzVW5kZXJQb2ludFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyIHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXIgdG8gdGVzdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttb2RlPTBdIFRoZSBtb2RlIHRvIHVzZSB0byBkZXRlcm1pbmUgd2hpY2ggZGlzcGxheSBvYmplY3RzIHRvIGluY2x1ZGUuIDAtYWxsLCAxLXJlc3BlY3QgbW91c2VFbmFibGVkL21vdXNlQ2hpbGRyZW4sIDItb25seSBtb3VzZSBvcGFxdWUgb2JqZWN0cy5cblx0ICogQHJldHVybiB7QXJyYXl9IEFuIEFycmF5IG9mIERpc3BsYXlPYmplY3RzIHVuZGVyIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZXMuXG5cdCAqKi9cblx0cC5nZXRPYmplY3RzVW5kZXJQb2ludCA9IGZ1bmN0aW9uKHgsIHksIG1vZGUpIHtcblx0XHR2YXIgYXJyID0gW107XG5cdFx0dmFyIHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHkpO1xuXHRcdHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KHB0LngsIHB0LnksIGFyciwgbW9kZT4wLCBtb2RlPT0xKTtcblx0XHRyZXR1cm4gYXJyO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9nZXRPYmplY3RzVW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fSwgYnV0IHJldHVybnMgb25seSB0aGUgdG9wLW1vc3QgZGlzcGxheVxuXHQgKiBvYmplY3QuIFRoaXMgcnVucyBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIDxjb2RlPmdldE9iamVjdHNVbmRlclBvaW50KCk8L2NvZGU+LCBidXQgaXMgc3RpbGwgcG90ZW50aWFsbHkgYW4gZXhwZW5zaXZlXG5cdCAqIG9wZXJhdGlvbi4gU2VlIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9nZXRPYmplY3RzVW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCBnZXRPYmplY3RVbmRlclBvaW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXIgdG8gdGVzdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gaW4gdGhlIGNvbnRhaW5lciB0byB0ZXN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbW9kZSBUaGUgbW9kZSB0byB1c2UgdG8gZGV0ZXJtaW5lIHdoaWNoIGRpc3BsYXkgb2JqZWN0cyB0byBpbmNsdWRlLiAgMC1hbGwsIDEtcmVzcGVjdCBtb3VzZUVuYWJsZWQvbW91c2VDaGlsZHJlbiwgMi1vbmx5IG1vdXNlIG9wYXF1ZSBvYmplY3RzLlxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBUaGUgdG9wLW1vc3QgZGlzcGxheSBvYmplY3QgdW5kZXIgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlcy5cblx0ICoqL1xuXHRwLmdldE9iamVjdFVuZGVyUG9pbnQgPSBmdW5jdGlvbih4LCB5LCBtb2RlKSB7XG5cdFx0dmFyIHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHkpO1xuXHRcdHJldHVybiB0aGlzLl9nZXRPYmplY3RzVW5kZXJQb2ludChwdC54LCBwdC55LCBudWxsLCBtb2RlPjAsIG1vZGU9PTEpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIERvY2NlZCBpbiBzdXBlcmNsYXNzLlxuXHQgKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0Qm91bmRzKG51bGwsIHRydWUpO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBEb2NjZWQgaW4gc3VwZXJjbGFzcy5cblx0ICovXG5cdHAuZ2V0VHJhbnNmb3JtZWRCb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0Qm91bmRzKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIENvbnRhaW5lci4gU29tZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHNwZWNpZmljIHRvIHRoaXMgaW5zdGFuY2UncyBjdXJyZW50IGNvbnRleHQgYXJlXG5cdCAqIHJldmVydGVkIHRvIHRoZWlyIGRlZmF1bHRzIChmb3IgZXhhbXBsZSAucGFyZW50KS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWN1cnNpdmU9ZmFsc2VdIElmIHRydWUsIGFsbCBvZiB0aGUgZGVzY2VuZGFudHMgb2YgdGhpcyBjb250YWluZXIgd2lsbCBiZSBjbG9uZWQgcmVjdXJzaXZlbHkuIElmIGZhbHNlLCB0aGVcblx0ICogcHJvcGVydGllcyBvZiB0aGUgY29udGFpbmVyIHdpbGwgYmUgY2xvbmVkLCBidXQgdGhlIG5ldyBpbnN0YW5jZSB3aWxsIG5vdCBoYXZlIGFueSBjaGlsZHJlbi5cblx0ICogQHJldHVybiB7Q29udGFpbmVyfSBBIGNsb25lIG9mIHRoZSBjdXJyZW50IENvbnRhaW5lciBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24ocmVjdXJzaXZlKSB7XG5cdFx0dmFyIG8gPSB0aGlzLl9jbG9uZVByb3BzKG5ldyBDb250YWluZXIoKSk7XG5cdFx0aWYgKHJlY3Vyc2l2ZSkgeyB0aGlzLl9jbG9uZUNoaWxkcmVuKG8pOyB9XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltDb250YWluZXIgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF90aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldnRPYmogQW4gZXZlbnQgb2JqZWN0IHRoYXQgd2lsbCBiZSBkaXNwYXRjaGVkIHRvIGFsbCB0aWNrIGxpc3RlbmVycy4gVGhpcyBvYmplY3QgaXMgcmV1c2VkIGJldHdlZW4gZGlzcGF0Y2hlcnMgdG8gcmVkdWNlIGNvbnN0cnVjdGlvbiAmIEdDIGNvc3RzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fdGljayA9IGZ1bmN0aW9uKGV2dE9iaikge1xuXHRcdGlmICh0aGlzLnRpY2tDaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaT10aGlzLmNoaWxkcmVuLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcblx0XHRcdFx0aWYgKGNoaWxkLnRpY2tFbmFibGVkICYmIGNoaWxkLl90aWNrKSB7IGNoaWxkLl90aWNrKGV2dE9iaik7IH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X190aWNrKGV2dE9iaik7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmVjdXJzaXZlbHkgY2xvbmVzIGFsbCBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lciwgYW5kIGFkZHMgdGhlbSB0byB0aGUgdGFyZ2V0IGNvbnRhaW5lci5cblx0ICogQG1ldGhvZCBjbG9uZUNoaWxkcmVuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtDb250YWluZXJ9IG8gVGhlIHRhcmdldCBjb250YWluZXIuXG5cdCAqKi9cblx0cC5fY2xvbmVDaGlsZHJlbiA9IGZ1bmN0aW9uKG8pIHtcblx0XHRpZiAoby5jaGlsZHJlbi5sZW5ndGgpIHsgby5yZW1vdmVBbGxDaGlsZHJlbigpOyB9XG5cdFx0dmFyIGFyciA9IG8uY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaT0wLCBsPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIGNsb25lID0gdGhpcy5jaGlsZHJlbltpXS5jbG9uZSh0cnVlKTtcblx0XHRcdGNsb25lLnBhcmVudCA9IG87XG5cdFx0XHRhcnIucHVzaChjbG9uZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRPYmplY3RzVW5kZXJQb2ludFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJcblx0ICogQHBhcmFtIHtCb29sZWFufSBtb3VzZSBJZiB0cnVlLCBpdCB3aWxsIHJlc3BlY3QgbW91c2UgaW50ZXJhY3Rpb24gcHJvcGVydGllcyBsaWtlIG1vdXNlRW5hYmxlZCwgbW91c2VDaGlsZHJlbiwgYW5kIGFjdGl2ZSBsaXN0ZW5lcnMuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWN0aXZlTGlzdGVuZXIgSWYgdHJ1ZSwgdGhlcmUgaXMgYW4gYWN0aXZlIG1vdXNlIGV2ZW50IGxpc3RlbmVyIG9uIGEgcGFyZW50IG9iamVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGN1cnJlbnREZXB0aCBJbmRpY2F0ZXMgdGhlIGN1cnJlbnQgZGVwdGggb2YgdGhlIHNlYXJjaC5cblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldE9iamVjdHNVbmRlclBvaW50ID0gZnVuY3Rpb24oeCwgeSwgYXJyLCBtb3VzZSwgYWN0aXZlTGlzdGVuZXIsIGN1cnJlbnREZXB0aCkge1xuXHRcdGN1cnJlbnREZXB0aCA9IGN1cnJlbnREZXB0aCB8fCAwO1xuXHRcdGlmICghY3VycmVudERlcHRoICYmICF0aGlzLl90ZXN0TWFzayh0aGlzLCB4LCB5KSkgeyByZXR1cm4gbnVsbDsgfVxuXHRcdHZhciBtdHgsIGN0eCA9IGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QuX2hpdFRlc3RDb250ZXh0O1xuXHRcdGFjdGl2ZUxpc3RlbmVyID0gYWN0aXZlTGlzdGVuZXIgfHwgKG1vdXNlJiZ0aGlzLl9oYXNNb3VzZUV2ZW50TGlzdGVuZXIoKSk7XG5cblx0XHQvLyBkcmF3IGNoaWxkcmVuIG9uZSBhdCBhIHRpbWUsIGFuZCBjaGVjayBpZiB3ZSBnZXQgYSBoaXQ6XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiwgbCA9IGNoaWxkcmVuLmxlbmd0aDtcblx0XHRmb3IgKHZhciBpPWwtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblx0XHRcdHZhciBoaXRBcmVhID0gY2hpbGQuaGl0QXJlYTtcblx0XHRcdGlmICghY2hpbGQudmlzaWJsZSB8fCAoIWhpdEFyZWEgJiYgIWNoaWxkLmlzVmlzaWJsZSgpKSB8fCAobW91c2UgJiYgIWNoaWxkLm1vdXNlRW5hYmxlZCkpIHsgY29udGludWU7IH1cblx0XHRcdGlmICghaGl0QXJlYSAmJiAhdGhpcy5fdGVzdE1hc2soY2hpbGQsIHgsIHkpKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcblx0XHRcdC8vIGlmIGEgY2hpbGQgY29udGFpbmVyIGhhcyBhIGhpdEFyZWEgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaXRzIGhpdEFyZWEsIHNvIHdlIGNhbiB0cmVhdCBpdCBhcyBhIG5vcm1hbCBETzpcblx0XHRcdGlmICghaGl0QXJlYSAmJiBjaGlsZCBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gY2hpbGQuX2dldE9iamVjdHNVbmRlclBvaW50KHgsIHksIGFyciwgbW91c2UsIGFjdGl2ZUxpc3RlbmVyLCBjdXJyZW50RGVwdGgrMSk7XG5cdFx0XHRcdGlmICghYXJyICYmIHJlc3VsdCkgeyByZXR1cm4gKG1vdXNlICYmICF0aGlzLm1vdXNlQ2hpbGRyZW4pID8gdGhpcyA6IHJlc3VsdDsgfVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKG1vdXNlICYmICFhY3RpdmVMaXN0ZW5lciAmJiAhY2hpbGQuX2hhc01vdXNlRXZlbnRMaXN0ZW5lcigpKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBUT0RPOiBjYW4gd2UgcGFzcyBkaXNwbGF5UHJvcHMgZm9yd2FyZCwgdG8gYXZvaWQgaGF2aW5nIHRvIGNhbGN1bGF0ZSB0aGlzIGJhY2t3YXJkcyBldmVyeSB0aW1lPyBJdCdzIGtpbmQgb2YgYSBtaXhlZCBiYWcuIFdoZW4gd2UncmUgb25seSBodW50aW5nIGZvciBET3Mgd2l0aCBldmVudCBsaXN0ZW5lcnMsIGl0IG1heSBub3QgbWFrZSBzZW5zZS5cblx0XHRcdFx0dmFyIHByb3BzID0gY2hpbGQuZ2V0Q29uY2F0ZW5hdGVkRGlzcGxheVByb3BzKGNoaWxkLl9wcm9wcyk7XG5cdFx0XHRcdG10eCA9IHByb3BzLm1hdHJpeDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChoaXRBcmVhKSB7XG5cdFx0XHRcdFx0bXR4LmFwcGVuZE1hdHJpeChoaXRBcmVhLmdldE1hdHJpeChoaXRBcmVhLl9wcm9wcy5tYXRyaXgpKTtcblx0XHRcdFx0XHRwcm9wcy5hbHBoYSA9IGhpdEFyZWEuYWxwaGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IHByb3BzLmFscGhhO1xuXHRcdFx0XHRjdHguc2V0VHJhbnNmb3JtKG10eC5hLCAgbXR4LmIsIG10eC5jLCBtdHguZCwgbXR4LnR4LXgsIG10eC50eS15KTtcblx0XHRcdFx0KGhpdEFyZWF8fGNoaWxkKS5kcmF3KGN0eCk7XG5cdFx0XHRcdGlmICghdGhpcy5fdGVzdEhpdChjdHgpKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0XHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgMiwgMik7XG5cdFx0XHRcdGlmIChhcnIpIHsgYXJyLnB1c2goY2hpbGQpOyB9XG5cdFx0XHRcdGVsc2UgeyByZXR1cm4gKG1vdXNlICYmICF0aGlzLm1vdXNlQ2hpbGRyZW4pID8gdGhpcyA6IGNoaWxkOyB9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX3Rlc3RNYXNrXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gdGFyZ2V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoZSB4L3kgaXMgd2l0aGluIHRoZSBtYXNrZWQgcmVnaW9uLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fdGVzdE1hc2sgPSBmdW5jdGlvbih0YXJnZXQsIHgsIHkpIHtcblx0XHR2YXIgbWFzayA9IHRhcmdldC5tYXNrO1xuXHRcdGlmICghbWFzayB8fCAhbWFzay5ncmFwaGljcyB8fCBtYXNrLmdyYXBoaWNzLmlzRW1wdHkoKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFxuXHRcdHZhciBtdHggPSB0aGlzLl9wcm9wcy5tYXRyaXgsIHBhcmVudCA9IHRhcmdldC5wYXJlbnQ7XG5cdFx0bXR4ID0gcGFyZW50ID8gcGFyZW50LmdldENvbmNhdGVuYXRlZE1hdHJpeChtdHgpIDogbXR4LmlkZW50aXR5KCk7XG5cdFx0bXR4ID0gbWFzay5nZXRNYXRyaXgobWFzay5fcHJvcHMubWF0cml4KS5wcmVwZW5kTWF0cml4KG10eCk7XG5cdFx0XG5cdFx0dmFyIGN0eCA9IGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QuX2hpdFRlc3RDb250ZXh0O1xuXHRcdGN0eC5zZXRUcmFuc2Zvcm0obXR4LmEsICBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgteCwgbXR4LnR5LXkpO1xuXHRcdFxuXHRcdC8vIGRyYXcgdGhlIG1hc2sgYXMgYSBzb2xpZCBmaWxsOlxuXHRcdG1hc2suZ3JhcGhpY3MuZHJhd0FzUGF0aChjdHgpO1xuXHRcdGN0eC5maWxsU3R5bGUgPSBcIiMwMDBcIjtcblx0XHRjdHguZmlsbCgpO1xuXHRcdFxuXHRcdGlmICghdGhpcy5fdGVzdEhpdChjdHgpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCAyLCAyKTtcblx0XHRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRCb3VuZHNcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlVHJhbnNmb3JtIElmIHRydWUsIGRvZXMgbm90IGFwcGx5IHRoaXMgb2JqZWN0J3MgdHJhbnNmb3JtLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nZXRCb3VuZHMgPSBmdW5jdGlvbihtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLkRpc3BsYXlPYmplY3RfZ2V0Qm91bmRzKCk7XG5cdFx0aWYgKGJvdW5kcykgeyByZXR1cm4gdGhpcy5fdHJhbnNmb3JtQm91bmRzKGJvdW5kcywgbWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pOyB9XG5cdFx0XG5cdFx0dmFyIG10eCA9IHRoaXMuX3Byb3BzLm1hdHJpeDtcblx0XHRtdHggPSBpZ25vcmVUcmFuc2Zvcm0gPyBtdHguaWRlbnRpdHkoKSA6IHRoaXMuZ2V0TWF0cml4KG10eCk7XG5cdFx0aWYgKG1hdHJpeCkgeyBtdHgucHJlcGVuZE1hdHJpeChtYXRyaXgpOyB9XG5cdFx0XG5cdFx0dmFyIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgcmVjdD1udWxsO1xuXHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoIWNoaWxkLnZpc2libGUgfHwgIShib3VuZHMgPSBjaGlsZC5fZ2V0Qm91bmRzKG10eCkpKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRpZiAocmVjdCkgeyByZWN0LmV4dGVuZChib3VuZHMueCwgYm91bmRzLnksIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7IH1cblx0XHRcdGVsc2UgeyByZWN0ID0gYm91bmRzLmNsb25lKCk7IH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlY3Q7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5Db250YWluZXIgPSBjcmVhdGVqcy5wcm9tb3RlKENvbnRhaW5lciwgXCJEaXNwbGF5T2JqZWN0XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFN0YWdlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQSBzdGFnZSBpcyB0aGUgcm9vdCBsZXZlbCB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGEgZGlzcGxheSBsaXN0LiBFYWNoIHRpbWUgaXRzIHt7I2Nyb3NzTGluayBcIlN0YWdlL3RpY2tcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kIGlzIGNhbGxlZCwgaXQgd2lsbCByZW5kZXIgaXRzIGRpc3BsYXkgbGlzdCB0byBpdHMgdGFyZ2V0IGNhbnZhcy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBhIHN0YWdlLCBhZGRzIGEgY2hpbGQgdG8gaXQsIHRoZW4gdXNlcyB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX0gdG8gdXBkYXRlIHRoZSBjaGlsZFxuXHQgKiBhbmQgcmVkcmF3IHRoZSBzdGFnZSB1c2luZyB7eyNjcm9zc0xpbmsgXCJTdGFnZS91cGRhdGVcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqICAgICAgdmFyIHN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKFwiY2FudmFzRWxlbWVudElkXCIpO1xuXHQgKiAgICAgIHZhciBpbWFnZSA9IG5ldyBjcmVhdGVqcy5CaXRtYXAoXCJpbWFnZVBhdGgucG5nXCIpO1xuXHQgKiAgICAgIHN0YWdlLmFkZENoaWxkKGltYWdlKTtcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlVGljayhldmVudCkge1xuXHQgKiAgICAgICAgICBpbWFnZS54ICs9IDEwO1xuXHQgKiAgICAgICAgICBzdGFnZS51cGRhdGUoKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBjbGFzcyBTdGFnZVxuXHQgKiBAZXh0ZW5kcyBDb250YWluZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnQgfCBTdHJpbmcgfCBPYmplY3R9IGNhbnZhcyBBIGNhbnZhcyBvYmplY3QgdGhhdCB0aGUgU3RhZ2Ugd2lsbCByZW5kZXIgdG8sIG9yIHRoZSBzdHJpbmcgaWRcblx0ICogb2YgYSBjYW52YXMgb2JqZWN0IGluIHRoZSBjdXJyZW50IGRvY3VtZW50LlxuXHQgKiovXG5cdGZ1bmN0aW9uIFN0YWdlKGNhbnZhcykge1xuXHRcdHRoaXMuQ29udGFpbmVyX2NvbnN0cnVjdG9yKCk7XG5cdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN0YWdlIHNob3VsZCBhdXRvbWF0aWNhbGx5IGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGVhY2ggcmVuZGVyLiBZb3UgY2FuIHNldCB0aGlzIHRvIDxjb2RlPmZhbHNlPC9jb2RlPlxuXHRcdCAqIHRvIG1hbnVhbGx5IGNvbnRyb2wgY2xlYXJpbmcgKGZvciBnZW5lcmF0aXZlIGFydCwgb3Igd2hlbiBwb2ludGluZyBtdWx0aXBsZSBzdGFnZXMgYXQgdGhlIHNhbWUgY2FudmFzIGZvclxuXHRcdCAqIGV4YW1wbGUpLlxuXHRcdCAqXG5cdFx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHRcdCAqXG5cdFx0ICogICAgICB2YXIgc3RhZ2UgPSBuZXcgY3JlYXRlanMuU3RhZ2UoXCJjYW52YXNJZFwiKTtcblx0XHQgKiAgICAgIHN0YWdlLmF1dG9DbGVhciA9IGZhbHNlO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IGF1dG9DbGVhclxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICoqL1xuXHRcdHRoaXMuYXV0b0NsZWFyID0gdHJ1ZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGNhbnZhcyB0aGUgc3RhZ2Ugd2lsbCByZW5kZXIgdG8uIE11bHRpcGxlIHN0YWdlcyBjYW4gc2hhcmUgYSBzaW5nbGUgY2FudmFzLCBidXQgeW91IG11c3QgZGlzYWJsZSBhdXRvQ2xlYXIgZm9yIGFsbCBidXQgdGhlXG5cdFx0ICogZmlyc3Qgc3RhZ2UgdGhhdCB3aWxsIGJlIHRpY2tlZCAob3IgdGhleSB3aWxsIGNsZWFyIGVhY2ggb3RoZXIncyByZW5kZXIpLlxuXHRcdCAqXG5cdFx0ICogV2hlbiBjaGFuZ2luZyB0aGUgY2FudmFzIHByb3BlcnR5IHlvdSBtdXN0IGRpc2FibGUgdGhlIGV2ZW50cyBvbiB0aGUgb2xkIGNhbnZhcywgYW5kIGVuYWJsZSBldmVudHMgb24gdGhlXG5cdFx0ICogbmV3IGNhbnZhcyBvciBtb3VzZSBldmVudHMgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZC4gRm9yIGV4YW1wbGU6XG5cdFx0ICpcblx0XHQgKiAgICAgIG15U3RhZ2UuZW5hYmxlRE9NRXZlbnRzKGZhbHNlKTtcblx0XHQgKiAgICAgIG15U3RhZ2UuY2FudmFzID0gYW5vdGhlckNhbnZhcztcblx0XHQgKiAgICAgIG15U3RhZ2UuZW5hYmxlRE9NRXZlbnRzKHRydWUpO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IGNhbnZhc1xuXHRcdCAqIEB0eXBlIEhUTUxDYW52YXNFbGVtZW50IHwgT2JqZWN0XG5cdFx0ICoqL1xuXHRcdHRoaXMuY2FudmFzID0gKHR5cGVvZiBjYW52YXMgPT0gXCJzdHJpbmdcIikgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXMpIDogY2FudmFzO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCBtb3VzZSBYIHBvc2l0aW9uIG9uIHRoZSBjYW52YXMuIElmIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGNhbnZhcywgdGhpcyB3aWxsIGluZGljYXRlIHRoZSBtb3N0IHJlY2VudFxuXHRcdCAqIHBvc2l0aW9uIG92ZXIgdGhlIGNhbnZhcywgYW5kIG1vdXNlSW5Cb3VuZHMgd2lsbCBiZSBzZXQgdG8gZmFsc2UuXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlWFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLm1vdXNlWCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IG1vdXNlIFkgcG9zaXRpb24gb24gdGhlIGNhbnZhcy4gSWYgdGhlIG1vdXNlIGxlYXZlcyB0aGUgY2FudmFzLCB0aGlzIHdpbGwgaW5kaWNhdGUgdGhlIG1vc3QgcmVjZW50XG5cdFx0ICogcG9zaXRpb24gb3ZlciB0aGUgY2FudmFzLCBhbmQgbW91c2VJbkJvdW5kcyB3aWxsIGJlIHNldCB0byBmYWxzZS5cblx0XHQgKiBAcHJvcGVydHkgbW91c2VZXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMubW91c2VZID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIHRoZSBhcmVhIG9mIHRoZSBzdGFnZSB0byBhZmZlY3Qgd2hlbiBjYWxsaW5nIHVwZGF0ZS4gVGhpcyBjYW4gYmUgdXNlIHRvIHNlbGVjdGl2ZWx5XG5cdFx0ICogcmUtZHJhdyBzcGVjaWZpYyByZWdpb25zIG9mIHRoZSBjYW52YXMuIElmIG51bGwsIHRoZSB3aG9sZSBjYW52YXMgYXJlYSBpcyBkcmF3bi5cblx0XHQgKiBAcHJvcGVydHkgZHJhd1JlY3Rcblx0XHQgKiBAdHlwZSB7UmVjdGFuZ2xlfVxuXHRcdCAqL1xuXHRcdHRoaXMuZHJhd1JlY3QgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciBkaXNwbGF5IG9iamVjdHMgc2hvdWxkIGJlIHJlbmRlcmVkIG9uIHdob2xlIHBpeGVscy4gWW91IGNhbiBzZXQgdGhlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9zbmFwVG9QaXhlbFwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBvZlxuXHRcdCAqIGRpc3BsYXkgb2JqZWN0cyB0byBmYWxzZSB0byBlbmFibGUvZGlzYWJsZSB0aGlzIGJlaGF2aW91ciBvbiBhIHBlciBpbnN0YW5jZSBiYXNpcy5cblx0XHQgKiBAcHJvcGVydHkgc25hcFRvUGl4ZWxFbmFibGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICoqL1xuXHRcdHRoaXMuc25hcFRvUGl4ZWxFbmFibGVkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtb3VzZSBpcyBjdXJyZW50bHkgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIGNhbnZhcy5cblx0XHQgKiBAcHJvcGVydHkgbW91c2VJbkJvdW5kc1xuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqKi9cblx0XHR0aGlzLm1vdXNlSW5Cb3VuZHMgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgdGljayBjYWxsYmFja3Mgd2lsbCBiZSBjYWxsZWQgb24gYWxsIGRpc3BsYXkgb2JqZWN0cyBvbiB0aGUgc3RhZ2UgcHJpb3IgdG8gcmVuZGVyaW5nIHRvIHRoZSBjYW52YXMuXG5cdFx0ICogQHByb3BlcnR5IHRpY2tPblVwZGF0ZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICoqL1xuXHRcdHRoaXMudGlja09uVXBkYXRlID0gdHJ1ZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgbW91c2UgbW92ZSBldmVudHMgd2lsbCBjb250aW51ZSB0byBiZSBjYWxsZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSB0YXJnZXQgY2FudmFzLiBTZWVcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJTdGFnZS9tb3VzZUluQm91bmRzOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LCBhbmQge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIHgveS9yYXdYL3Jhd1kuXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlTW92ZU91dHNpZGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiovXG5cdFx0dGhpcy5tb3VzZU1vdmVPdXRzaWRlID0gZmFsc2U7XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUHJldmVudHMgc2VsZWN0aW9uIG9mIG90aGVyIGVsZW1lbnRzIGluIHRoZSBodG1sIHBhZ2UgaWYgdGhlIHVzZXIgY2xpY2tzIGFuZCBkcmFncywgb3IgZG91YmxlIGNsaWNrcyBvbiB0aGUgY2FudmFzLlxuXHRcdCAqIFRoaXMgd29ya3MgYnkgY2FsbGluZyBgcHJldmVudERlZmF1bHQoKWAgb24gYW55IG1vdXNlZG93biBldmVudHMgKG9yIHRvdWNoIGVxdWl2YWxlbnQpIG9yaWdpbmF0aW5nIG9uIHRoZSBjYW52YXMuXG5cdFx0ICogQHByb3BlcnR5IHByZXZlbnRTZWxlY3Rpb25cblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLnByZXZlbnRTZWxlY3Rpb24gPSB0cnVlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgaGl0QXJlYSBwcm9wZXJ0eSBpcyBub3Qgc3VwcG9ydGVkIGZvciBTdGFnZS5cblx0XHQgKiBAcHJvcGVydHkgaGl0QXJlYVxuXHRcdCAqIEB0eXBlIHtEaXNwbGF5T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHQgXG5cdFx0IFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgb2JqZWN0cyB3aXRoIGRhdGEgZm9yIGVhY2ggYWN0aXZlIHBvaW50ZXIgaWQuIEVhY2ggb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cdFx0ICogeCwgeSwgZXZlbnQsIHRhcmdldCwgb3ZlclRhcmdldCwgb3ZlclgsIG92ZXJZLCBpbkJvdW5kcywgcG9zRXZ0T2JqIChuYXRpdmUgZXZlbnQgdGhhdCBsYXN0IHVwZGF0ZWQgcG9zaXRpb24pXG5cdFx0ICogQHByb3BlcnR5IF9wb2ludGVyRGF0YVxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wb2ludGVyRGF0YSA9IHt9O1xuXHRcblx0XHQvKipcblx0XHQgKiBOdW1iZXIgb2YgYWN0aXZlIHBvaW50ZXJzLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcG9pbnRlckNvdW50XG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3BvaW50ZXJDb3VudCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBJRCBvZiB0aGUgcHJpbWFyeSBwb2ludGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJpbWFyeVBvaW50ZXJJRFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wcmltYXJ5UG9pbnRlcklEID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9tb3VzZU92ZXJJbnRlcnZhbElEXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9tb3VzZU92ZXJJbnRlcnZhbElEID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX25leHRTdGFnZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBTdGFnZVxuXHRcdCAqKi9cblx0XHR0aGlzLl9uZXh0U3RhZ2UgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJldlN0YWdlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIFN0YWdlXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3ByZXZTdGFnZSA9IG51bGw7XG5cdFx0XG5cdFx0XG5cdC8vIGluaXRpYWxpemU6XG5cdFx0dGhpcy5lbmFibGVET01FdmVudHModHJ1ZSk7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU3RhZ2UsIGNyZWF0ZWpzLkNvbnRhaW5lcik7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIGV2ZW50czpcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgbW91c2Ugb3ZlciB0aGUgY2FudmFzLlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgc3RhZ2Vtb3VzZW1vdmVcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGVpciBsZWZ0IG1vdXNlIGJ1dHRvbiBvbiB0aGUgY2FudmFzLiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgc3RhZ2Vtb3VzZWRvd25cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIgdGhlIHVzZXIgcHJlc3NlcyBzb21ld2hlcmUgb24gdGhlIHN0YWdlLCB0aGVuIHJlbGVhc2VzIHRoZSBtb3VzZSBidXR0b24gYW55d2hlcmUgdGhhdCB0aGUgcGFnZSBjYW4gZGV0ZWN0IGl0ICh0aGlzIHZhcmllcyBzbGlnaHRseSBiZXR3ZWVuIGJyb3dzZXJzKS5cblx0ICogWW91IGNhbiB1c2Uge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvbW91c2VJbkJvdW5kczpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSB0byBjaGVjayB3aGV0aGVyIHRoZSBtb3VzZSBpcyBjdXJyZW50bHkgd2l0aGluIHRoZSBzdGFnZSBib3VuZHMuXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBzdGFnZW1vdXNldXBcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIG1vdXNlIG1vdmVzIGZyb20gd2l0aGluIHRoZSBjYW52YXMgYXJlYSAobW91c2VJbkJvdW5kcyA9PSB0cnVlKSB0byBvdXRzaWRlIGl0IChtb3VzZUluQm91bmRzID09IGZhbHNlKS5cblx0ICogVGhpcyBpcyBjdXJyZW50bHkgb25seSBkaXNwYXRjaGVkIGZvciBtb3VzZSBpbnB1dCAobm90IHRvdWNoKS4gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IG1vdXNlbGVhdmVcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIG1vdXNlIG1vdmVzIGludG8gdGhlIGNhbnZhcyBhcmVhIChtb3VzZUluQm91bmRzID09IGZhbHNlKSBmcm9tIG91dHNpZGUgaXQgKG1vdXNlSW5Cb3VuZHMgPT0gdHJ1ZSkuXG5cdCAqIFRoaXMgaXMgY3VycmVudGx5IG9ubHkgZGlzcGF0Y2hlZCBmb3IgbW91c2UgaW5wdXQgKG5vdCB0b3VjaCkuIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBtb3VzZWVudGVyXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBlYWNoIHVwZGF0ZSBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIHRpY2sgZXZlbnQgaXMgcHJvcGFnYXRlZCB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqIFlvdSBjYW4gY2FsbCBwcmV2ZW50RGVmYXVsdCBvbiB0aGUgZXZlbnQgb2JqZWN0IHRvIGNhbmNlbCBwcm9wYWdhdGluZyB0aGUgdGljayBldmVudC5cblx0ICogQGV2ZW50IHRpY2tzdGFydFxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgZWFjaCB1cGRhdGUgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHRpY2sgZXZlbnQgaXMgcHJvcGFnYXRlZCB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuIERvZXMgbm90IGZpcmUgaWZcblx0ICogdGlja09uVXBkYXRlIGlzIGZhbHNlLiBQcmVjZWRlcyB0aGUgXCJkcmF3c3RhcnRcIiBldmVudC5cblx0ICogQGV2ZW50IHRpY2tlbmRcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIGVhY2ggdXBkYXRlIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY2FudmFzIGlzIGNsZWFyZWQgYW5kIHRoZSBkaXNwbGF5IGxpc3QgaXMgZHJhd24gdG8gaXQuXG5cdCAqIFlvdSBjYW4gY2FsbCBwcmV2ZW50RGVmYXVsdCBvbiB0aGUgZXZlbnQgb2JqZWN0IHRvIGNhbmNlbCB0aGUgZHJhdy5cblx0ICogQGV2ZW50IGRyYXdzdGFydFxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgZWFjaCB1cGRhdGUgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGRpc3BsYXkgbGlzdCBpcyBkcmF3biB0byB0aGUgY2FudmFzIGFuZCB0aGUgY2FudmFzIGNvbnRleHQgaXMgcmVzdG9yZWQuXG5cdCAqIEBldmVudCBkcmF3ZW5kXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblxuXHQgXG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogU3BlY2lmaWVzIGEgdGFyZ2V0IHN0YWdlIHRoYXQgd2lsbCBoYXZlIG1vdXNlIC8gdG91Y2ggaW50ZXJhY3Rpb25zIHJlbGF5ZWQgdG8gaXQgYWZ0ZXIgdGhpcyBzdGFnZSBoYW5kbGVzIHRoZW0uXG5cdCAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBpbiBjYXNlcyB3aGVyZSB5b3UgaGF2ZSBtdWx0aXBsZSBsYXllcmVkIGNhbnZhc2VzIGFuZCB3YW50IHVzZXIgaW50ZXJhY3Rpb25zXG5cdCAqIGV2ZW50cyB0byBwYXNzIHRocm91Z2guIEZvciBleGFtcGxlLCB0aGlzIHdvdWxkIHJlbGF5IG1vdXNlIGV2ZW50cyBmcm9tIHRvcFN0YWdlIHRvIGJvdHRvbVN0YWdlOlxuXHQgKlxuXHQgKiAgICAgIHRvcFN0YWdlLm5leHRTdGFnZSA9IGJvdHRvbVN0YWdlO1xuXHQgKlxuXHQgKiBUbyBkaXNhYmxlIHJlbGF5aW5nLCBzZXQgbmV4dFN0YWdlIHRvIG51bGwuXG5cdCAqIFxuXHQgKiBNb3VzZU92ZXIsIE1vdXNlT3V0LCBSb2xsT3ZlciwgYW5kIFJvbGxPdXQgaW50ZXJhY3Rpb25zIGFyZSBhbHNvIHBhc3NlZCB0aHJvdWdoIHVzaW5nIHRoZSBtb3VzZSBvdmVyIHNldHRpbmdzXG5cdCAqIG9mIHRoZSB0b3AtbW9zdCBzdGFnZSwgYnV0IGFyZSBvbmx5IHByb2Nlc3NlZCBpZiB0aGUgdGFyZ2V0IHN0YWdlIGhhcyBtb3VzZSBvdmVyIGludGVyYWN0aW9ucyBlbmFibGVkLlxuXHQgKiBDb25zaWRlcmF0aW9ucyB3aGVuIHVzaW5nIHJvbGwgb3ZlciBpbiByZWxheSB0YXJnZXRzOjxPTD5cblx0ICogPExJPiBUaGUgdG9wLW1vc3QgKGZpcnN0KSBzdGFnZSBtdXN0IGhhdmUgbW91c2Ugb3ZlciBpbnRlcmFjdGlvbnMgZW5hYmxlZCAodmlhIGVuYWJsZU1vdXNlT3Zlcik8L0xJPlxuXHQgKiA8TEk+IEFsbCBzdGFnZXMgdGhhdCB3aXNoIHRvIHBhcnRpY2lwYXRlIGluIG1vdXNlIG92ZXIgaW50ZXJhY3Rpb24gbXVzdCBlbmFibGUgdGhlbSB2aWEgZW5hYmxlTW91c2VPdmVyPC9MST5cblx0ICogPExJPiBBbGwgcmVsYXkgdGFyZ2V0cyB3aWxsIHNoYXJlIHRoZSBmcmVxdWVuY3kgdmFsdWUgb2YgdGhlIHRvcC1tb3N0IHN0YWdlPC9MST5cblx0ICogPC9PTD5cblx0ICogVG8gaWxsdXN0cmF0ZSwgaW4gdGhpcyBleGFtcGxlIHRoZSB0YXJnZXRTdGFnZSB3b3VsZCBwcm9jZXNzIG1vdXNlIG92ZXIgaW50ZXJhY3Rpb25zIGF0IDEwaHogKGRlc3BpdGUgcGFzc2luZ1xuXHQgKiAzMCBhcyBpdCdzIGRlc2lyZWQgZnJlcXVlbmN5KTpcblx0ICogXHR0b3BTdGFnZS5uZXh0U3RhZ2UgPSB0YXJnZXRTdGFnZTtcblx0ICogXHR0b3BTdGFnZS5lbmFibGVNb3VzZU92ZXIoMTApO1xuXHQgKiBcdHRhcmdldFN0YWdlLmVuYWJsZU1vdXNlT3ZlcigzMCk7XG5cdCAqIFxuXHQgKiBJZiB0aGUgdGFyZ2V0IHN0YWdlJ3MgY2FudmFzIGlzIGNvbXBsZXRlbHkgY292ZXJlZCBieSB0aGlzIHN0YWdlJ3MgY2FudmFzLCB5b3UgbWF5IGFsc28gd2FudCB0byBkaXNhYmxlIGl0c1xuXHQgKiBET00gZXZlbnRzIHVzaW5nOlxuXHQgKiBcblx0ICpcdHRhcmdldFN0YWdlLmVuYWJsZURPTUV2ZW50cyhmYWxzZSk7XG5cdCAqIFxuXHQgKiBAcHJvcGVydHkgbmV4dFN0YWdlXG5cdCAqIEB0eXBlIHtTdGFnZX1cblx0ICoqL1xuXHRwLl9nZXRfbmV4dFN0YWdlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25leHRTdGFnZTtcblx0fTtcblx0cC5fc2V0X25leHRTdGFnZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuX25leHRTdGFnZSkgeyB0aGlzLl9uZXh0U3RhZ2UuX3ByZXZTdGFnZSA9IG51bGw7IH1cblx0XHRpZiAodmFsdWUpIHsgdmFsdWUuX3ByZXZTdGFnZSA9IHRoaXM7IH1cblx0XHR0aGlzLl9uZXh0U3RhZ2UgPSB2YWx1ZTtcblx0fTtcblx0XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXHRcdFx0bmV4dFN0YWdlOiB7IGdldDogcC5fZ2V0X25leHRTdGFnZSwgc2V0OiBwLl9zZXRfbmV4dFN0YWdlIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge30gLy8gVE9ETzogdXNlIExvZ1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogRWFjaCB0aW1lIHRoZSB1cGRhdGUgbWV0aG9kIGlzIGNhbGxlZCwgdGhlIHN0YWdlIHdpbGwgY2FsbCB7eyNjcm9zc0xpbmsgXCJTdGFnZS90aWNrXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHVubGVzcyB7eyNjcm9zc0xpbmsgXCJTdGFnZS90aWNrT25VcGRhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgc2V0IHRvIGZhbHNlLFxuXHQgKiBhbmQgdGhlbiByZW5kZXIgdGhlIGRpc3BsYXkgbGlzdCB0byB0aGUgY2FudmFzLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHVwZGF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBQcm9wcyBvYmplY3QgdG8gcGFzcyB0byBgdGljaygpYC4gU2hvdWxkIHVzdWFsbHkgYmUgYSB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgb2JqZWN0LCBvciBzaW1pbGFyIG9iamVjdCB3aXRoIGEgZGVsdGEgcHJvcGVydHkuXG5cdCAqKi9cblx0cC51cGRhdGUgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdGlmICghdGhpcy5jYW52YXMpIHsgcmV0dXJuOyB9XG5cdFx0aWYgKHRoaXMudGlja09uVXBkYXRlKSB7IHRoaXMudGljayhwcm9wcyk7IH1cblx0XHRpZiAodGhpcy5kaXNwYXRjaEV2ZW50KFwiZHJhd3N0YXJ0XCIsIGZhbHNlLCB0cnVlKSA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9XG5cdFx0Y3JlYXRlanMuRGlzcGxheU9iamVjdC5fc25hcFRvUGl4ZWxFbmFibGVkID0gdGhpcy5zbmFwVG9QaXhlbEVuYWJsZWQ7XG5cdFx0dmFyIHIgPSB0aGlzLmRyYXdSZWN0LCBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRpZiAodGhpcy5hdXRvQ2xlYXIpIHtcblx0XHRcdGlmIChyKSB7IGN0eC5jbGVhclJlY3Qoci54LCByLnksIHIud2lkdGgsIHIuaGVpZ2h0KTsgfVxuXHRcdFx0ZWxzZSB7IGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgrMSwgdGhpcy5jYW52YXMuaGVpZ2h0KzEpOyB9XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0aWYgKHRoaXMuZHJhd1JlY3QpIHtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5yZWN0KHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7XG5cdFx0XHRjdHguY2xpcCgpO1xuXHRcdH1cblx0XHR0aGlzLnVwZGF0ZUNvbnRleHQoY3R4KTtcblx0XHR0aGlzLmRyYXcoY3R4LCBmYWxzZSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJkcmF3ZW5kXCIpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFByb3BhZ2F0ZXMgYSB0aWNrIGV2ZW50IHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC4gVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSB7eyNjcm9zc0xpbmsgXCJTdGFnZS91cGRhdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogdW5sZXNzIHt7I2Nyb3NzTGluayBcIlN0YWdlL3RpY2tPblVwZGF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpcyBzZXQgdG8gZmFsc2UuXG5cdCAqXG5cdCAqIElmIGEgcHJvcHMgb2JqZWN0IGlzIHBhc3NlZCB0byBgdGljaygpYCwgdGhlbiBhbGwgb2YgaXRzIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIGV2ZW50IG9iamVjdCB0aGF0IGlzXG5cdCAqIHByb3BhZ2F0ZWQgdG8gbGlzdGVuZXJzLlxuXHQgKlxuXHQgKiBTb21lIHRpbWUtYmFzZWQgZmVhdHVyZXMgaW4gRWFzZWxKUyAoZm9yIGV4YW1wbGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2ZyYW1lcmF0ZVwifX17ey9jcm9zc0xpbmt9fSByZXF1aXJlIHRoYXRcblx0ICogYSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBvYmplY3QgKG9yIGVxdWl2YWxlbnQgb2JqZWN0IHdpdGggYSBkZWx0YSBwcm9wZXJ0eSkgYmVcblx0ICogcGFzc2VkIGFzIHRoZSBgcHJvcHNgIHBhcmFtZXRlciB0byBgdGljaygpYC4gRm9yIGV4YW1wbGU6XG5cdCAqXG5cdCAqIFx0VGlja2VyLm9uKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogXHRmdW5jdGlvbiBoYW5kbGVUaWNrKGV2dE9iaikge1xuXHQgKiBcdFx0Ly8gY2xvbmUgdGhlIGV2ZW50IG9iamVjdCBmcm9tIFRpY2tlciwgYW5kIGFkZCBzb21lIGN1c3RvbSBkYXRhIHRvIGl0OlxuXHQgKiBcdFx0dmFyIGV2dCA9IGV2dE9iai5jbG9uZSgpLnNldCh7Z3JlZXRpbmc6XCJoZWxsb1wiLCBuYW1lOlwid29ybGRcIn0pO1xuXHQgKiBcdFx0XG5cdCAqIFx0XHQvLyBwYXNzIGl0IHRvIHN0YWdlLnVwZGF0ZSgpOlxuXHQgKiBcdFx0bXlTdGFnZS51cGRhdGUoZXZ0KTsgLy8gc3Vic2VxdWVudGx5IGNhbGxzIHRpY2soKSB3aXRoIHRoZSBzYW1lIHBhcmFtXG5cdCAqIFx0fVxuXHQgKiBcdFxuXHQgKiBcdC8vIC4uLlxuXHQgKiBcdG15RGlzcGxheU9iamVjdC5vbihcInRpY2tcIiwgaGFuZGxlRGlzcGxheU9iamVjdFRpY2spO1xuXHQgKiBcdGZ1bmN0aW9uIGhhbmRsZURpc3BsYXlPYmplY3RUaWNrKGV2dCkge1xuXHQgKiBcdFx0Y29uc29sZS5sb2coZXZ0LmRlbHRhKTsgLy8gdGhlIGRlbHRhIHByb3BlcnR5IGZyb20gdGhlIFRpY2tlciB0aWNrIGV2ZW50IG9iamVjdFxuXHQgKiBcdFx0Y29uc29sZS5sb2coZXZ0LmdyZWV0aW5nLCBldnQubmFtZSk7IC8vIGN1c3RvbSBkYXRhOiBcImhlbGxvIHdvcmxkXCJcblx0ICogXHR9XG5cdCAqIFxuXHQgKiBAbWV0aG9kIHRpY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gQW4gb2JqZWN0IHdpdGggcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBjb3BpZWQgdG8gdGhlIGV2ZW50IG9iamVjdC4gU2hvdWxkIHVzdWFsbHkgYmUgYSBUaWNrZXIgZXZlbnQgb2JqZWN0LCBvciBzaW1pbGFyIG9iamVjdCB3aXRoIGEgZGVsdGEgcHJvcGVydHkuXG5cdCAqKi9cblx0cC50aWNrID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRpZiAoIXRoaXMudGlja0VuYWJsZWQgfHwgdGhpcy5kaXNwYXRjaEV2ZW50KFwidGlja3N0YXJ0XCIsIGZhbHNlLCB0cnVlKSA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIGV2dE9iaiA9IG5ldyBjcmVhdGVqcy5FdmVudChcInRpY2tcIik7XG5cdFx0aWYgKHByb3BzKSB7XG5cdFx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7XG5cdFx0XHRcdGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShuKSkgeyBldnRPYmpbbl0gPSBwcm9wc1tuXTsgfVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl90aWNrKGV2dE9iaik7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwidGlja2VuZFwiKTtcblx0fTtcblxuXHQvKipcblx0ICogRGVmYXVsdCBldmVudCBoYW5kbGVyIHRoYXQgY2FsbHMgdGhlIFN0YWdlIHt7I2Nyb3NzTGluayBcIlN0YWdlL3VwZGF0ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2Qgd2hlbiBhIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBpcyByZWNlaXZlZC4gVGhpcyBhbGxvd3MgeW91IHRvIHJlZ2lzdGVyIGEgU3RhZ2UgaW5zdGFuY2UgYXMgYSBldmVudCBsaXN0ZW5lciBvbiB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZGlyZWN0bHksIHVzaW5nOlxuXHQgKlxuXHQgKiAgICAgIFRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBteVN0YWdlXCIpO1xuXHQgKlxuXHQgKiBOb3RlIHRoYXQgaWYgeW91IHN1YnNjcmliZSB0byB0aWNrcyB1c2luZyB0aGlzIHBhdHRlcm4sIHRoZW4gdGhlIHRpY2sgZXZlbnQgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIHRocm91Z2ggdG9cblx0ICogZGlzcGxheSBvYmplY3QgdGljayBoYW5kbGVycywgaW5zdGVhZCBvZiA8Y29kZT5kZWx0YTwvY29kZT4gYW5kIDxjb2RlPnBhdXNlZDwvY29kZT4gcGFyYW1ldGVycy5cblx0ICogQHByb3BlcnR5IGhhbmRsZUV2ZW50XG5cdCAqIEB0eXBlIEZ1bmN0aW9uXG5cdCAqKi9cblx0cC5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGV2dCkge1xuXHRcdGlmIChldnQudHlwZSA9PSBcInRpY2tcIikgeyB0aGlzLnVwZGF0ZShldnQpOyB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFycyB0aGUgdGFyZ2V0IGNhbnZhcy4gVXNlZnVsIGlmIHt7I2Nyb3NzTGluayBcIlN0YWdlL2F1dG9DbGVhcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpcyBzZXQgdG8gYGZhbHNlYC5cblx0ICogQG1ldGhvZCBjbGVhclxuXHQgKiovXG5cdHAuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuY2FudmFzKSB7IHJldHVybjsgfVxuXHRcdHZhciBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoKzEsIHRoaXMuY2FudmFzLmhlaWdodCsxKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGRhdGEgdXJsIHRoYXQgY29udGFpbnMgYSBCYXNlNjQtZW5jb2RlZCBpbWFnZSBvZiB0aGUgY29udGVudHMgb2YgdGhlIHN0YWdlLiBUaGUgcmV0dXJuZWQgZGF0YSB1cmwgY2FuXG5cdCAqIGJlIHNwZWNpZmllZCBhcyB0aGUgc3JjIHZhbHVlIG9mIGFuIGltYWdlIGVsZW1lbnQuXG5cdCAqIEBtZXRob2QgdG9EYXRhVVJMXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFja2dyb3VuZENvbG9yXSBUaGUgYmFja2dyb3VuZCBjb2xvciB0byBiZSB1c2VkIGZvciB0aGUgZ2VuZXJhdGVkIGltYWdlLiBBbnkgdmFsaWQgQ1NTIGNvbG9yXG5cdCAqIHZhbHVlIGlzIGFsbG93ZWQuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgdHJhbnNwYXJlbnQgYmFja2dyb3VuZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFttaW1lVHlwZT1cImltYWdlL3BuZ1wiXSBUaGUgTUlNRSB0eXBlIG9mIHRoZSBpbWFnZSBmb3JtYXQgdG8gYmUgY3JlYXRlLiBUaGUgZGVmYXVsdCBpcyBcImltYWdlL3BuZ1wiLiBJZiBhbiB1bmtub3duIE1JTUUgdHlwZVxuXHQgKiBpcyBwYXNzZWQgaW4sIG9yIGlmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIHNwZWNpZmllZCBNSU1FIHR5cGUsIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZC5cblx0ICogQHJldHVybiB7U3RyaW5nfSBhIEJhc2U2NCBlbmNvZGVkIGltYWdlLlxuXHQgKiovXG5cdHAudG9EYXRhVVJMID0gZnVuY3Rpb24oYmFja2dyb3VuZENvbG9yLCBtaW1lVHlwZSkge1xuXHRcdHZhciBkYXRhLCBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLCB3ID0gdGhpcy5jYW52YXMud2lkdGgsIGggPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG5cblx0XHRpZiAoYmFja2dyb3VuZENvbG9yKSB7XG5cdFx0XHRkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3LCBoKTtcblx0XHRcdHZhciBjb21wb3NpdGVPcGVyYXRpb24gPSBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tb3ZlclwiO1xuXHRcdFx0XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuXHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIHcsIGgpO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVVJMID0gdGhpcy5jYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlfHxcImltYWdlL3BuZ1wiKTtcblxuXHRcdGlmKGJhY2tncm91bmRDb2xvcikge1xuXHRcdFx0Y3R4LnB1dEltYWdlRGF0YShkYXRhLCAwLCAwKTtcblx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb247XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGFVUkw7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgKGJ5IHBhc3NpbmcgYSBmcmVxdWVuY3kgb2YgMCkgbW91c2Ugb3ZlciAoe3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZW92ZXI6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYW5kIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VvdXQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0pIGFuZCByb2xsIG92ZXIgZXZlbnRzICh7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JvbGxvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JvbGxvdXQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0pIGZvciB0aGlzIHN0YWdlJ3MgZGlzcGxheSBsaXN0LiBUaGVzZSBldmVudHMgY2FuXG5cdCAqIGJlIGV4cGVuc2l2ZSB0byBnZW5lcmF0ZSwgc28gdGhleSBhcmUgZGlzYWJsZWQgYnkgZGVmYXVsdC4gVGhlIGZyZXF1ZW5jeSBvZiB0aGUgZXZlbnRzIGNhbiBiZSBjb250cm9sbGVkXG5cdCAqIGluZGVwZW5kZW50bHkgb2YgbW91c2UgbW92ZSBldmVudHMgdmlhIHRoZSBvcHRpb25hbCBgZnJlcXVlbmN5YCBwYXJhbWV0ZXIuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgc3RhZ2UgPSBuZXcgY3JlYXRlanMuU3RhZ2UoXCJjYW52YXNJZFwiKTtcblx0ICogICAgICBzdGFnZS5lbmFibGVNb3VzZU92ZXIoMTApOyAvLyAxMCB1cGRhdGVzIHBlciBzZWNvbmRcblx0ICpcblx0ICogQG1ldGhvZCBlbmFibGVNb3VzZU92ZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtmcmVxdWVuY3k9MjBdIE9wdGlvbmFsIHBhcmFtIHNwZWNpZnlpbmcgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHBlciBzZWNvbmQgdG8gYnJvYWRjYXN0XG5cdCAqIG1vdXNlIG92ZXIvb3V0IGV2ZW50cy4gU2V0IHRvIDAgdG8gZGlzYWJsZSBtb3VzZSBvdmVyIGV2ZW50cyBjb21wbGV0ZWx5LiBNYXhpbXVtIGlzIDUwLiBBIGxvd2VyIGZyZXF1ZW5jeSBpcyBsZXNzXG5cdCAqIHJlc3BvbnNpdmUsIGJ1dCB1c2VzIGxlc3MgQ1BVLlxuXHQgKiovXG5cdHAuZW5hYmxlTW91c2VPdmVyID0gZnVuY3Rpb24oZnJlcXVlbmN5KSB7XG5cdFx0aWYgKHRoaXMuX21vdXNlT3ZlckludGVydmFsSUQpIHtcblx0XHRcdGNsZWFySW50ZXJ2YWwodGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCk7XG5cdFx0XHR0aGlzLl9tb3VzZU92ZXJJbnRlcnZhbElEID0gbnVsbDtcblx0XHRcdGlmIChmcmVxdWVuY3kgPT0gMCkge1xuXHRcdFx0XHR0aGlzLl90ZXN0TW91c2VPdmVyKHRydWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoZnJlcXVlbmN5ID09IG51bGwpIHsgZnJlcXVlbmN5ID0gMjA7IH1cblx0XHRlbHNlIGlmIChmcmVxdWVuY3kgPD0gMCkgeyByZXR1cm47IH1cblx0XHR2YXIgbyA9IHRoaXM7XG5cdFx0dGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCl7IG8uX3Rlc3RNb3VzZU92ZXIoKTsgfSwgMTAwMC9NYXRoLm1pbig1MCxmcmVxdWVuY3kpKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgc3RhZ2UgYWRkcyB0byBET00gZWxlbWVudHMgKHdpbmRvdywgZG9jdW1lbnQgYW5kIGNhbnZhcykuIEl0IGlzIGdvb2Rcblx0ICogcHJhY3RpY2UgdG8gZGlzYWJsZSBldmVudHMgd2hlbiBkaXNwb3Npbmcgb2YgYSBTdGFnZSBpbnN0YW5jZSwgb3RoZXJ3aXNlIHRoZSBzdGFnZSB3aWxsIGNvbnRpbnVlIHRvIHJlY2VpdmVcblx0ICogZXZlbnRzIGZyb20gdGhlIHBhZ2UuXG5cdCAqXG5cdCAqIFdoZW4gY2hhbmdpbmcgdGhlIGNhbnZhcyBwcm9wZXJ0eSB5b3UgbXVzdCBkaXNhYmxlIHRoZSBldmVudHMgb24gdGhlIG9sZCBjYW52YXMsIGFuZCBlbmFibGUgZXZlbnRzIG9uIHRoZVxuXHQgKiBuZXcgY2FudmFzIG9yIG1vdXNlIGV2ZW50cyB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkLiBGb3IgZXhhbXBsZTpcblx0ICpcblx0ICogICAgICBteVN0YWdlLmVuYWJsZURPTUV2ZW50cyhmYWxzZSk7XG5cdCAqICAgICAgbXlTdGFnZS5jYW52YXMgPSBhbm90aGVyQ2FudmFzO1xuXHQgKiAgICAgIG15U3RhZ2UuZW5hYmxlRE9NRXZlbnRzKHRydWUpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGVuYWJsZURPTUV2ZW50c1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtlbmFibGU9dHJ1ZV0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGV2ZW50cy4gRGVmYXVsdCBpcyB0cnVlLlxuXHQgKiovXG5cdHAuZW5hYmxlRE9NRXZlbnRzID0gZnVuY3Rpb24oZW5hYmxlKSB7XG5cdFx0aWYgKGVuYWJsZSA9PSBudWxsKSB7IGVuYWJsZSA9IHRydWU7IH1cblx0XHR2YXIgbiwgbywgbHMgPSB0aGlzLl9ldmVudExpc3RlbmVycztcblx0XHRpZiAoIWVuYWJsZSAmJiBscykge1xuXHRcdFx0Zm9yIChuIGluIGxzKSB7XG5cdFx0XHRcdG8gPSBsc1tuXTtcblx0XHRcdFx0by50LnJlbW92ZUV2ZW50TGlzdGVuZXIobiwgby5mLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9ldmVudExpc3RlbmVycyA9IG51bGw7XG5cdFx0fSBlbHNlIGlmIChlbmFibGUgJiYgIWxzICYmIHRoaXMuY2FudmFzKSB7XG5cdFx0XHR2YXIgdCA9IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyID8gd2luZG93IDogZG9jdW1lbnQ7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0bHMgPSB0aGlzLl9ldmVudExpc3RlbmVycyA9IHt9O1xuXHRcdFx0bHNbXCJtb3VzZXVwXCJdID0ge3Q6dCwgZjpmdW5jdGlvbihlKSB7IF90aGlzLl9oYW5kbGVNb3VzZVVwKGUpfSB9O1xuXHRcdFx0bHNbXCJtb3VzZW1vdmVcIl0gPSB7dDp0LCBmOmZ1bmN0aW9uKGUpIHsgX3RoaXMuX2hhbmRsZU1vdXNlTW92ZShlKX0gfTtcblx0XHRcdGxzW1wiZGJsY2xpY2tcIl0gPSB7dDp0aGlzLmNhbnZhcywgZjpmdW5jdGlvbihlKSB7IF90aGlzLl9oYW5kbGVEb3VibGVDbGljayhlKX0gfTtcblx0XHRcdGxzW1wibW91c2Vkb3duXCJdID0ge3Q6dGhpcy5jYW52YXMsIGY6ZnVuY3Rpb24oZSkgeyBfdGhpcy5faGFuZGxlTW91c2VEb3duKGUpfSB9O1xuXG5cdFx0XHRmb3IgKG4gaW4gbHMpIHtcblx0XHRcdFx0byA9IGxzW25dO1xuXHRcdFx0XHRvLnQuYWRkRXZlbnRMaXN0ZW5lcihuLCBvLmYsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0YWdlIGluc3RhbmNlcyBjYW5ub3QgYmUgY2xvbmVkLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRocm93KFwiU3RhZ2UgY2Fubm90IGJlIGNsb25lZC5cIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltTdGFnZSAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldEVsZW1lbnRSZWN0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZVxuXHQgKiovXG5cdHAuX2dldEVsZW1lbnRSZWN0ID0gZnVuY3Rpb24oZSkge1xuXHRcdHZhciBib3VuZHM7XG5cdFx0dHJ5IHsgYm91bmRzID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgfSAvLyB0aGlzIGNhbiBmYWlsIG9uIGRpc2Nvbm5lY3RlZCBET00gZWxlbWVudHMgaW4gSUU5XG5cdFx0Y2F0Y2ggKGVycikgeyBib3VuZHMgPSB7dG9wOiBlLm9mZnNldFRvcCwgbGVmdDogZS5vZmZzZXRMZWZ0LCB3aWR0aDplLm9mZnNldFdpZHRoLCBoZWlnaHQ6ZS5vZmZzZXRIZWlnaHR9OyB9XG5cblx0XHR2YXIgb2ZmWCA9ICh3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuc2Nyb2xsTGVmdCB8fCAwKSAtIChkb2N1bWVudC5jbGllbnRMZWZ0IHx8IGRvY3VtZW50LmJvZHkuY2xpZW50TGVmdCB8fCAwKTtcblx0XHR2YXIgb2ZmWSA9ICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuc2Nyb2xsVG9wIHx8IDApIC0gKGRvY3VtZW50LmNsaWVudFRvcCAgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRUb3AgIHx8IDApO1xuXG5cdFx0dmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gZ2V0Q29tcHV0ZWRTdHlsZShlLG51bGwpIDogZS5jdXJyZW50U3R5bGU7IC8vIElFIDw5IGNvbXBhdGliaWxpdHkuXG5cdFx0dmFyIHBhZEwgPSBwYXJzZUludChzdHlsZXMucGFkZGluZ0xlZnQpK3BhcnNlSW50KHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgpO1xuXHRcdHZhciBwYWRUID0gcGFyc2VJbnQoc3R5bGVzLnBhZGRpbmdUb3ApK3BhcnNlSW50KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCk7XG5cdFx0dmFyIHBhZFIgPSBwYXJzZUludChzdHlsZXMucGFkZGluZ1JpZ2h0KStwYXJzZUludChzdHlsZXMuYm9yZGVyUmlnaHRXaWR0aCk7XG5cdFx0dmFyIHBhZEIgPSBwYXJzZUludChzdHlsZXMucGFkZGluZ0JvdHRvbSkrcGFyc2VJbnQoc3R5bGVzLmJvcmRlckJvdHRvbVdpZHRoKTtcblxuXHRcdC8vIG5vdGU6IGluIHNvbWUgYnJvd3NlcnMgYm91bmRzIHByb3BlcnRpZXMgYXJlIHJlYWQgb25seS5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bGVmdDogYm91bmRzLmxlZnQrb2ZmWCtwYWRMLFxuXHRcdFx0cmlnaHQ6IGJvdW5kcy5yaWdodCtvZmZYLXBhZFIsXG5cdFx0XHR0b3A6IGJvdW5kcy50b3Arb2ZmWStwYWRULFxuXHRcdFx0Ym90dG9tOiBib3VuZHMuYm90dG9tK29mZlktcGFkQlxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0UG9pbnRlckRhdGFcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaWRcblx0ICoqL1xuXHRwLl9nZXRQb2ludGVyRGF0YSA9IGZ1bmN0aW9uKGlkKSB7XG5cdFx0dmFyIGRhdGEgPSB0aGlzLl9wb2ludGVyRGF0YVtpZF07XG5cdFx0aWYgKCFkYXRhKSB7IGRhdGEgPSB0aGlzLl9wb2ludGVyRGF0YVtpZF0gPSB7eDowLHk6MH07IH1cblx0XHRyZXR1cm4gZGF0YTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlTW91c2VNb3ZlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG5cdCAqKi9cblx0cC5faGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24oZSkge1xuXHRcdGlmKCFlKXsgZSA9IHdpbmRvdy5ldmVudDsgfVxuXHRcdHRoaXMuX2hhbmRsZVBvaW50ZXJNb3ZlKC0xLCBlLCBlLnBhZ2VYLCBlLnBhZ2VZKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlUG9pbnRlck1vdmVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaWRcblx0ICogQHBhcmFtIHtFdmVudH0gZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFnZVhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VZXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IG93bmVyIEluZGljYXRlcyB0aGF0IHRoZSBldmVudCBoYXMgYWxyZWFkeSBiZWVuIGNhcHR1cmVkICYgaGFuZGxlZCBieSB0aGUgaW5kaWNhdGVkIHN0YWdlLlxuXHQgKiovXG5cdHAuX2hhbmRsZVBvaW50ZXJNb3ZlID0gZnVuY3Rpb24oaWQsIGUsIHBhZ2VYLCBwYWdlWSwgb3duZXIpIHtcblx0XHRpZiAodGhpcy5fcHJldlN0YWdlICYmIG93bmVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9IC8vIHJlZHVuZGFudCBsaXN0ZW5lci5cblx0XHRpZiAoIXRoaXMuY2FudmFzKSB7IHJldHVybjsgfVxuXHRcdHZhciBuZXh0U3RhZ2U9dGhpcy5fbmV4dFN0YWdlLCBvPXRoaXMuX2dldFBvaW50ZXJEYXRhKGlkKTtcblxuXHRcdHZhciBpbkJvdW5kcyA9IG8uaW5Cb3VuZHM7XG5cdFx0dGhpcy5fdXBkYXRlUG9pbnRlclBvc2l0aW9uKGlkLCBlLCBwYWdlWCwgcGFnZVkpO1xuXHRcdGlmIChpbkJvdW5kcyB8fCBvLmluQm91bmRzIHx8IHRoaXMubW91c2VNb3ZlT3V0c2lkZSkge1xuXHRcdFx0aWYgKGlkID09PSAtMSAmJiBvLmluQm91bmRzID09ICFpbkJvdW5kcykge1xuXHRcdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGhpcywgKGluQm91bmRzID8gXCJtb3VzZWxlYXZlXCIgOiBcIm1vdXNlZW50ZXJcIiksIGZhbHNlLCBpZCwgbywgZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudCh0aGlzLCBcInN0YWdlbW91c2Vtb3ZlXCIsIGZhbHNlLCBpZCwgbywgZSk7XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQoby50YXJnZXQsIFwicHJlc3Ntb3ZlXCIsIHRydWUsIGlkLCBvLCBlKTtcblx0XHR9XG5cdFx0XG5cdFx0bmV4dFN0YWdlJiZuZXh0U3RhZ2UuX2hhbmRsZVBvaW50ZXJNb3ZlKGlkLCBlLCBwYWdlWCwgcGFnZVksIG51bGwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF91cGRhdGVQb2ludGVyUG9zaXRpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaWRcblx0ICogQHBhcmFtIHtFdmVudH0gZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFnZVhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VZXG5cdCAqKi9cblx0cC5fdXBkYXRlUG9pbnRlclBvc2l0aW9uID0gZnVuY3Rpb24oaWQsIGUsIHBhZ2VYLCBwYWdlWSkge1xuXHRcdHZhciByZWN0ID0gdGhpcy5fZ2V0RWxlbWVudFJlY3QodGhpcy5jYW52YXMpO1xuXHRcdHBhZ2VYIC09IHJlY3QubGVmdDtcblx0XHRwYWdlWSAtPSByZWN0LnRvcDtcblxuXHRcdHZhciB3ID0gdGhpcy5jYW52YXMud2lkdGg7XG5cdFx0dmFyIGggPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG5cdFx0cGFnZVggLz0gKHJlY3QucmlnaHQtcmVjdC5sZWZ0KS93O1xuXHRcdHBhZ2VZIC89IChyZWN0LmJvdHRvbS1yZWN0LnRvcCkvaDtcblx0XHR2YXIgbyA9IHRoaXMuX2dldFBvaW50ZXJEYXRhKGlkKTtcblx0XHRpZiAoby5pbkJvdW5kcyA9IChwYWdlWCA+PSAwICYmIHBhZ2VZID49IDAgJiYgcGFnZVggPD0gdy0xICYmIHBhZ2VZIDw9IGgtMSkpIHtcblx0XHRcdG8ueCA9IHBhZ2VYO1xuXHRcdFx0by55ID0gcGFnZVk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLm1vdXNlTW92ZU91dHNpZGUpIHtcblx0XHRcdG8ueCA9IHBhZ2VYIDwgMCA/IDAgOiAocGFnZVggPiB3LTEgPyB3LTEgOiBwYWdlWCk7XG5cdFx0XHRvLnkgPSBwYWdlWSA8IDAgPyAwIDogKHBhZ2VZID4gaC0xID8gaC0xIDogcGFnZVkpO1xuXHRcdH1cblxuXHRcdG8ucG9zRXZ0T2JqID0gZTtcblx0XHRvLnJhd1ggPSBwYWdlWDtcblx0XHRvLnJhd1kgPSBwYWdlWTtcblxuXHRcdGlmIChpZCA9PT0gdGhpcy5fcHJpbWFyeVBvaW50ZXJJRCB8fCBpZCA9PT0gLTEpIHtcblx0XHRcdHRoaXMubW91c2VYID0gby54O1xuXHRcdFx0dGhpcy5tb3VzZVkgPSBvLnk7XG5cdFx0XHR0aGlzLm1vdXNlSW5Cb3VuZHMgPSBvLmluQm91bmRzO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlTW91c2VVcFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuXHQgKiovXG5cdHAuX2hhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbihlKSB7XG5cdFx0dGhpcy5faGFuZGxlUG9pbnRlclVwKC0xLCBlLCBmYWxzZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVBvaW50ZXJVcFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xlYXJcblx0ICogQHBhcmFtIHtTdGFnZX0gb3duZXIgSW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWQgJiBoYW5kbGVkIGJ5IHRoZSBpbmRpY2F0ZWQgc3RhZ2UuXG5cdCAqKi9cblx0cC5faGFuZGxlUG9pbnRlclVwID0gZnVuY3Rpb24oaWQsIGUsIGNsZWFyLCBvd25lcikge1xuXHRcdHZhciBuZXh0U3RhZ2UgPSB0aGlzLl9uZXh0U3RhZ2UsIG8gPSB0aGlzLl9nZXRQb2ludGVyRGF0YShpZCk7XG5cdFx0aWYgKHRoaXMuX3ByZXZTdGFnZSAmJiBvd25lciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfSAvLyByZWR1bmRhbnQgbGlzdGVuZXIuXG5cdFx0XG5cdFx0dmFyIHRhcmdldD1udWxsLCBvVGFyZ2V0ID0gby50YXJnZXQ7XG5cdFx0aWYgKCFvd25lciAmJiAob1RhcmdldCB8fCBuZXh0U3RhZ2UpKSB7IHRhcmdldCA9IHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KG8ueCwgby55LCBudWxsLCB0cnVlKTsgfVxuXHRcdFxuXHRcdGlmIChvLmRvd24pIHsgdGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRoaXMsIFwic3RhZ2Vtb3VzZXVwXCIsIGZhbHNlLCBpZCwgbywgZSwgdGFyZ2V0KTsgby5kb3duID0gZmFsc2U7IH1cblx0XHRcblx0XHRpZiAodGFyZ2V0ID09IG9UYXJnZXQpIHsgdGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG9UYXJnZXQsIFwiY2xpY2tcIiwgdHJ1ZSwgaWQsIG8sIGUpOyB9XG5cdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG9UYXJnZXQsIFwicHJlc3N1cFwiLCB0cnVlLCBpZCwgbywgZSk7XG5cdFx0XG5cdFx0aWYgKGNsZWFyKSB7XG5cdFx0XHRpZiAoaWQ9PXRoaXMuX3ByaW1hcnlQb2ludGVySUQpIHsgdGhpcy5fcHJpbWFyeVBvaW50ZXJJRCA9IG51bGw7IH1cblx0XHRcdGRlbGV0ZSh0aGlzLl9wb2ludGVyRGF0YVtpZF0pO1xuXHRcdH0gZWxzZSB7IG8udGFyZ2V0ID0gbnVsbDsgfVxuXHRcdFxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVQb2ludGVyVXAoaWQsIGUsIGNsZWFyLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1vdXNlRG93blxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuXHQgKiovXG5cdHAuX2hhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uKGUpIHtcblx0XHR0aGlzLl9oYW5kbGVQb2ludGVyRG93bigtMSwgZSwgZS5wYWdlWCwgZS5wYWdlWSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVBvaW50ZXJEb3duXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICoqL1xuXHRwLl9oYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uKGlkLCBlLCBwYWdlWCwgcGFnZVksIG93bmVyKSB7XG5cdFx0aWYgKHRoaXMucHJldmVudFNlbGVjdGlvbikgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cblx0XHRpZiAodGhpcy5fcHJpbWFyeVBvaW50ZXJJRCA9PSBudWxsIHx8IGlkID09PSAtMSkgeyB0aGlzLl9wcmltYXJ5UG9pbnRlcklEID0gaWQ7IH0gLy8gbW91c2UgYWx3YXlzIHRha2VzIG92ZXIuXG5cdFx0XG5cdFx0aWYgKHBhZ2VZICE9IG51bGwpIHsgdGhpcy5fdXBkYXRlUG9pbnRlclBvc2l0aW9uKGlkLCBlLCBwYWdlWCwgcGFnZVkpOyB9XG5cdFx0dmFyIHRhcmdldCA9IG51bGwsIG5leHRTdGFnZSA9IHRoaXMuX25leHRTdGFnZSwgbyA9IHRoaXMuX2dldFBvaW50ZXJEYXRhKGlkKTtcblx0XHRpZiAoIW93bmVyKSB7IHRhcmdldCA9IG8udGFyZ2V0ID0gdGhpcy5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQoby54LCBvLnksIG51bGwsIHRydWUpOyB9XG5cblx0XHRpZiAoby5pbkJvdW5kcykgeyB0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGhpcywgXCJzdGFnZW1vdXNlZG93blwiLCBmYWxzZSwgaWQsIG8sIGUsIHRhcmdldCk7IG8uZG93biA9IHRydWU7IH1cblx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGFyZ2V0LCBcIm1vdXNlZG93blwiLCB0cnVlLCBpZCwgbywgZSk7XG5cdFx0XG5cdFx0bmV4dFN0YWdlJiZuZXh0U3RhZ2UuX2hhbmRsZVBvaW50ZXJEb3duKGlkLCBlLCBwYWdlWCwgcGFnZVksIG93bmVyIHx8IHRhcmdldCAmJiB0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfdGVzdE1vdXNlT3ZlclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNsZWFyIElmIHRydWUsIGNsZWFycyB0aGUgbW91c2VvdmVyIC8gcm9sbG92ZXIgKGllLiBubyB0YXJnZXQpXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IG93bmVyIEluZGljYXRlcyB0aGF0IHRoZSBldmVudCBoYXMgYWxyZWFkeSBiZWVuIGNhcHR1cmVkICYgaGFuZGxlZCBieSB0aGUgaW5kaWNhdGVkIHN0YWdlLlxuXHQgKiBAcGFyYW0ge1N0YWdlfSBldmVudFRhcmdldCBUaGUgc3RhZ2UgdGhhdCB0aGUgY3Vyc29yIGlzIGFjdGl2ZWx5IG92ZXIuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl90ZXN0TW91c2VPdmVyID0gZnVuY3Rpb24oY2xlYXIsIG93bmVyLCBldmVudFRhcmdldCkge1xuXHRcdGlmICh0aGlzLl9wcmV2U3RhZ2UgJiYgb3duZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH0gLy8gcmVkdW5kYW50IGxpc3RlbmVyLlxuXHRcdFxuXHRcdHZhciBuZXh0U3RhZ2UgPSB0aGlzLl9uZXh0U3RhZ2U7XG5cdFx0aWYgKCF0aGlzLl9tb3VzZU92ZXJJbnRlcnZhbElEKSB7XG5cdFx0XHQvLyBub3QgZW5hYmxlZCBmb3IgbW91c2VvdmVyLCBidXQgc2hvdWxkIHN0aWxsIHJlbGF5IHRoZSBldmVudC5cblx0XHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl90ZXN0TW91c2VPdmVyKGNsZWFyLCBvd25lciwgZXZlbnRUYXJnZXQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgbyA9IHRoaXMuX2dldFBvaW50ZXJEYXRhKC0xKTtcblx0XHQvLyBvbmx5IHVwZGF0ZSBpZiB0aGUgbW91c2UgcG9zaXRpb24gaGFzIGNoYW5nZWQuIFRoaXMgcHJvdmlkZXMgYSBsb3Qgb2Ygb3B0aW1pemF0aW9uLCBidXQgaGFzIHNvbWUgdHJhZGUtb2Zmcy5cblx0XHRpZiAoIW8gfHwgKCFjbGVhciAmJiB0aGlzLm1vdXNlWCA9PSB0aGlzLl9tb3VzZU92ZXJYICYmIHRoaXMubW91c2VZID09IHRoaXMuX21vdXNlT3ZlclkgJiYgdGhpcy5tb3VzZUluQm91bmRzKSkgeyByZXR1cm47IH1cblx0XHRcblx0XHR2YXIgZSA9IG8ucG9zRXZ0T2JqO1xuXHRcdHZhciBpc0V2ZW50VGFyZ2V0ID0gZXZlbnRUYXJnZXQgfHwgZSYmKGUudGFyZ2V0ID09IHRoaXMuY2FudmFzKTtcblx0XHR2YXIgdGFyZ2V0PW51bGwsIGNvbW1vbiA9IC0xLCBjdXJzb3I9XCJcIiwgdCwgaSwgbDtcblx0XHRcblx0XHRpZiAoIW93bmVyICYmIChjbGVhciB8fCB0aGlzLm1vdXNlSW5Cb3VuZHMgJiYgaXNFdmVudFRhcmdldCkpIHtcblx0XHRcdHRhcmdldCA9IHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KHRoaXMubW91c2VYLCB0aGlzLm1vdXNlWSwgbnVsbCwgdHJ1ZSk7XG5cdFx0XHR0aGlzLl9tb3VzZU92ZXJYID0gdGhpcy5tb3VzZVg7XG5cdFx0XHR0aGlzLl9tb3VzZU92ZXJZID0gdGhpcy5tb3VzZVk7XG5cdFx0fVxuXG5cdFx0dmFyIG9sZExpc3QgPSB0aGlzLl9tb3VzZU92ZXJUYXJnZXR8fFtdO1xuXHRcdHZhciBvbGRUYXJnZXQgPSBvbGRMaXN0W29sZExpc3QubGVuZ3RoLTFdO1xuXHRcdHZhciBsaXN0ID0gdGhpcy5fbW91c2VPdmVyVGFyZ2V0ID0gW107XG5cblx0XHQvLyBnZW5lcmF0ZSBhbmNlc3RvciBsaXN0IGFuZCBjaGVjayBmb3IgY3Vyc29yOlxuXHRcdHQgPSB0YXJnZXQ7XG5cdFx0d2hpbGUgKHQpIHtcblx0XHRcdGxpc3QudW5zaGlmdCh0KTtcblx0XHRcdGlmICghY3Vyc29yKSB7IGN1cnNvciA9IHQuY3Vyc29yOyB9XG5cdFx0XHR0ID0gdC5wYXJlbnQ7XG5cdFx0fVxuXHRcdHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcblx0XHRpZiAoIW93bmVyICYmIGV2ZW50VGFyZ2V0KSB7IGV2ZW50VGFyZ2V0LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7IH1cblxuXHRcdC8vIGZpbmQgY29tbW9uIGFuY2VzdG9yOlxuXHRcdGZvciAoaT0wLGw9bGlzdC5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRpZiAobGlzdFtpXSAhPSBvbGRMaXN0W2ldKSB7IGJyZWFrOyB9XG5cdFx0XHRjb21tb24gPSBpO1xuXHRcdH1cblxuXHRcdGlmIChvbGRUYXJnZXQgIT0gdGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQob2xkVGFyZ2V0LCBcIm1vdXNlb3V0XCIsIHRydWUsIC0xLCBvLCBlLCB0YXJnZXQpO1xuXHRcdH1cblxuXHRcdGZvciAoaT1vbGRMaXN0Lmxlbmd0aC0xOyBpPmNvbW1vbjsgaS0tKSB7XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQob2xkTGlzdFtpXSwgXCJyb2xsb3V0XCIsIGZhbHNlLCAtMSwgbywgZSwgdGFyZ2V0KTtcblx0XHR9XG5cblx0XHRmb3IgKGk9bGlzdC5sZW5ndGgtMTsgaT5jb21tb247IGktLSkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KGxpc3RbaV0sIFwicm9sbG92ZXJcIiwgZmFsc2UsIC0xLCBvLCBlLCBvbGRUYXJnZXQpO1xuXHRcdH1cblxuXHRcdGlmIChvbGRUYXJnZXQgIT0gdGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGFyZ2V0LCBcIm1vdXNlb3ZlclwiLCB0cnVlLCAtMSwgbywgZSwgb2xkVGFyZ2V0KTtcblx0XHR9XG5cdFx0XG5cdFx0bmV4dFN0YWdlJiZuZXh0U3RhZ2UuX3Rlc3RNb3VzZU92ZXIoY2xlYXIsIG93bmVyIHx8IHRhcmdldCAmJiB0aGlzLCBldmVudFRhcmdldCB8fCBpc0V2ZW50VGFyZ2V0ICYmIHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVEb3VibGVDbGlja1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICoqL1xuXHRwLl9oYW5kbGVEb3VibGVDbGljayA9IGZ1bmN0aW9uKGUsIG93bmVyKSB7XG5cdFx0dmFyIHRhcmdldD1udWxsLCBuZXh0U3RhZ2U9dGhpcy5fbmV4dFN0YWdlLCBvPXRoaXMuX2dldFBvaW50ZXJEYXRhKC0xKTtcblx0XHRpZiAoIW93bmVyKSB7XG5cdFx0XHR0YXJnZXQgPSB0aGlzLl9nZXRPYmplY3RzVW5kZXJQb2ludChvLngsIG8ueSwgbnVsbCwgdHJ1ZSk7XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGFyZ2V0LCBcImRibGNsaWNrXCIsIHRydWUsIC0xLCBvLCBlKTtcblx0XHR9XG5cdFx0bmV4dFN0YWdlJiZuZXh0U3RhZ2UuX2hhbmRsZURvdWJsZUNsaWNrKGUsIG93bmVyIHx8IHRhcmdldCAmJiB0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZGlzcGF0Y2hNb3VzZUV2ZW50XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSB0YXJnZXRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcblx0ICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludGVySWRcblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHBhcmFtIHtNb3VzZUV2ZW50fSBbbmF0aXZlRXZlbnRdXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gW3JlbGF0ZWRUYXJnZXRdXG5cdCAqKi9cblx0cC5fZGlzcGF0Y2hNb3VzZUV2ZW50ID0gZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBidWJibGVzLCBwb2ludGVySWQsIG8sIG5hdGl2ZUV2ZW50LCByZWxhdGVkVGFyZ2V0KSB7XG5cdFx0Ly8gVE9ETzogbWlnaHQgYmUgd29ydGggZWl0aGVyIHJldXNpbmcgTW91c2VFdmVudCBpbnN0YW5jZXMsIG9yIGFkZGluZyBhIHdpbGxUcmlnZ2VyIG1ldGhvZCB0byBhdm9pZCBHQy5cblx0XHRpZiAoIXRhcmdldCB8fCAoIWJ1YmJsZXMgJiYgIXRhcmdldC5oYXNFdmVudExpc3RlbmVyKHR5cGUpKSkgeyByZXR1cm47IH1cblx0XHQvKlxuXHRcdC8vIFRPRE86IGFjY291bnQgZm9yIHN0YWdlIHRyYW5zZm9ybWF0aW9ucz9cblx0XHR0aGlzLl9tdHggPSB0aGlzLmdldENvbmNhdGVuYXRlZE1hdHJpeCh0aGlzLl9tdHgpLmludmVydCgpO1xuXHRcdHZhciBwdCA9IHRoaXMuX210eC50cmFuc2Zvcm1Qb2ludChvLngsIG8ueSk7XG5cdFx0dmFyIGV2dCA9IG5ldyBjcmVhdGVqcy5Nb3VzZUV2ZW50KHR5cGUsIGJ1YmJsZXMsIGZhbHNlLCBwdC54LCBwdC55LCBuYXRpdmVFdmVudCwgcG9pbnRlcklkLCBwb2ludGVySWQ9PXRoaXMuX3ByaW1hcnlQb2ludGVySUQgfHwgcG9pbnRlcklkPT0tMSwgby5yYXdYLCBvLnJhd1kpO1xuXHRcdCovXG5cdFx0dmFyIGV2dCA9IG5ldyBjcmVhdGVqcy5Nb3VzZUV2ZW50KHR5cGUsIGJ1YmJsZXMsIGZhbHNlLCBvLngsIG8ueSwgbmF0aXZlRXZlbnQsIHBvaW50ZXJJZCwgcG9pbnRlcklkID09PSB0aGlzLl9wcmltYXJ5UG9pbnRlcklEIHx8IHBvaW50ZXJJZCA9PT0gLTEsIG8ucmF3WCwgby5yYXdZLCByZWxhdGVkVGFyZ2V0KTtcblx0XHR0YXJnZXQuZGlzcGF0Y2hFdmVudChldnQpO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuU3RhZ2UgPSBjcmVhdGVqcy5wcm9tb3RlKFN0YWdlLCBcIkNvbnRhaW5lclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBCaXRtYXAuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XG5cdC8qKlxuXHQgKiBBIEJpdG1hcCByZXByZXNlbnRzIGFuIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIGluIHRoZSBkaXNwbGF5IGxpc3QuIEEgQml0bWFwIGNhbiBiZSBpbnN0YW50aWF0ZWQgdXNpbmcgYW4gZXhpc3Rpbmdcblx0ICogSFRNTCBlbGVtZW50LCBvciBhIHN0cmluZy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBiaXRtYXAgPSBuZXcgY3JlYXRlanMuQml0bWFwKFwiaW1hZ2VQYXRoLmpwZ1wiKTtcblx0ICpcblx0ICogPHN0cm9uZz5Ob3Rlczo8L3N0cm9uZz5cblx0ICogPG9sPlxuXHQgKiAgICAgPGxpPldoZW4gYSBzdHJpbmcgcGF0aCBvciBpbWFnZSB0YWcgdGhhdCBpcyBub3QgeWV0IGxvYWRlZCBpcyB1c2VkLCB0aGUgc3RhZ2UgbWF5IG5lZWQgdG8gYmUgcmVkcmF3biBiZWZvcmUgaXRcblx0ICogICAgICB3aWxsIGJlIGRpc3BsYXllZC48L2xpPlxuXHQgKiAgICAgPGxpPkJpdG1hcHMgd2l0aCBhbiBTVkcgc291cmNlIGN1cnJlbnRseSB3aWxsIG5vdCByZXNwZWN0IGFuIGFscGhhIHZhbHVlIG90aGVyIHRoYW4gMCBvciAxLiBUbyBnZXQgYXJvdW5kIHRoaXMsXG5cdCAqICAgICB0aGUgQml0bWFwIGNhbiBiZSBjYWNoZWQuPC9saT5cblx0ICogICAgIDxsaT5CaXRtYXBzIHdpdGggYW4gU1ZHIHNvdXJjZSB3aWxsIHRhaW50IHRoZSBjYW52YXMgd2l0aCBjcm9zcy1vcmlnaW4gZGF0YSwgd2hpY2ggcHJldmVudHMgaW50ZXJhY3Rpdml0eS4gVGhpc1xuXHQgKiAgICAgaGFwcGVucyBpbiBhbGwgYnJvd3NlcnMgZXhjZXB0IHJlY2VudCBGaXJlZm94IGJ1aWxkcy48L2xpPlxuXHQgKiAgICAgPGxpPkltYWdlcyBsb2FkZWQgY3Jvc3Mtb3JpZ2luIHdpbGwgdGhyb3cgY3Jvc3Mtb3JpZ2luIHNlY3VyaXR5IGVycm9ycyB3aGVuIGludGVyYWN0ZWQgd2l0aCB1c2luZyBhIG1vdXNlLCB1c2luZ1xuXHQgKiAgICAgbWV0aG9kcyBzdWNoIGFzIGBnZXRPYmplY3RVbmRlclBvaW50YCwgb3IgdXNpbmcgZmlsdGVycywgb3IgY2FjaGluZy4gWW91IGNhbiBnZXQgYXJvdW5kIHRoaXMgYnkgc2V0dGluZ1xuXHQgKiAgICAgYGNyb3NzT3JpZ2luYCBmbGFncyBvbiB5b3VyIGltYWdlcyBiZWZvcmUgcGFzc2luZyB0aGVtIHRvIEVhc2VsSlMsIGVnOiBgaW1nLmNyb3NzT3JpZ2luPVwiQW5vbnltb3VzXCI7YDwvbGk+XG5cdCAqIDwvb2w+XG5cdCAqXG5cdCAqIEBjbGFzcyBCaXRtYXBcblx0ICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50IHwgU3RyaW5nfSBpbWFnZU9yVXJpIFRoZSBzb3VyY2Ugb2JqZWN0IG9yIFVSSSB0byBhbiBpbWFnZSB0b1xuXHQgKiBkaXNwbGF5LiBUaGlzIGNhbiBiZSBlaXRoZXIgYW4gSW1hZ2UsIENhbnZhcywgb3IgVmlkZW8gb2JqZWN0LCBvciBhIHN0cmluZyBVUkkgdG8gYW4gaW1hZ2UgZmlsZSB0byBsb2FkIGFuZCB1c2UuXG5cdCAqIElmIGl0IGlzIGEgVVJJLCBhIG5ldyBJbWFnZSBvYmplY3Qgd2lsbCBiZSBjb25zdHJ1Y3RlZCBhbmQgYXNzaWduZWQgdG8gdGhlIC5pbWFnZSBwcm9wZXJ0eS5cblx0ICoqL1xuXHRmdW5jdGlvbiBCaXRtYXAoaW1hZ2VPclVyaSkge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgaW1hZ2UgdG8gcmVuZGVyLiBUaGlzIGNhbiBiZSBhbiBJbWFnZSwgYSBDYW52YXMsIG9yIGEgVmlkZW8uIE5vdCBhbGwgYnJvd3NlcnMgKGVzcGVjaWFsbHlcblx0XHQgKiBtb2JpbGUgYnJvd3NlcnMpIHN1cHBvcnQgZHJhd2luZyB2aWRlbyB0byBhIGNhbnZhcy5cblx0XHQgKiBAcHJvcGVydHkgaW1hZ2Vcblx0XHQgKiBAdHlwZSBIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50XG5cdFx0ICoqL1xuXHRcdGlmICh0eXBlb2YgaW1hZ2VPclVyaSA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR0aGlzLmltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcblx0XHRcdHRoaXMuaW1hZ2Uuc3JjID0gaW1hZ2VPclVyaTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5pbWFnZSA9IGltYWdlT3JVcmk7XG5cdFx0fVxuXHRcblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgYW4gYXJlYSBvZiB0aGUgc291cmNlIGltYWdlIHRvIGRyYXcuIElmIG9taXR0ZWQsIHRoZSB3aG9sZSBpbWFnZSB3aWxsIGJlIGRyYXduLlxuXHRcdCAqIE5vdGUgdGhhdCB2aWRlbyBzb3VyY2VzIG11c3QgaGF2ZSBhIHdpZHRoIC8gaGVpZ2h0IHNldCB0byB3b3JrIGNvcnJlY3RseSB3aXRoIGBzb3VyY2VSZWN0YC5cblx0XHQgKiBAcHJvcGVydHkgc291cmNlUmVjdFxuXHRcdCAqIEB0eXBlIFJlY3RhbmdsZVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnNvdXJjZVJlY3QgPSBudWxsO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEJpdG1hcCwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cdFxuXHRcbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQ29uc3RydWN0b3IgYWxpYXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLlxuXHQgKiBTdWJjbGFzc2VzIHNob3VsZCBiZSB1cGRhdGVkIHRvIHVzZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBgY3JlYXRlanMucHJvbW90ZSgpYFxuXHQgKiovXG5cdHAuaW5pdGlhbGl6ZSA9IEJpdG1hcDsgLy8gVE9ETzogZGVwcmVjYXRlZC5cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xuXHQgKiovXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGltYWdlID0gdGhpcy5pbWFnZTtcblx0XHR2YXIgaGFzQ29udGVudCA9IHRoaXMuY2FjaGVDYW52YXMgfHwgKGltYWdlICYmIChpbWFnZS5uYXR1cmFsV2lkdGggfHwgaW1hZ2UuZ2V0Q29udGV4dCB8fCBpbWFnZS5yZWFkeVN0YXRlID49IDIpKTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlQ2FjaGU9ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLlxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXG5cdCAqIGludG8gaXRzZWxmKS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0aWYgKHRoaXMuRGlzcGxheU9iamVjdF9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpIHx8ICF0aGlzLmltYWdlKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dmFyIGltZyA9IHRoaXMuaW1hZ2UsIHJlY3QgPSB0aGlzLnNvdXJjZVJlY3Q7XG5cdFx0aWYgKHJlY3QpIHtcblx0XHRcdC8vIHNvbWUgYnJvd3NlcnMgY2hva2Ugb24gb3V0IG9mIGJvdW5kIHZhbHVlcywgc28gd2UnbGwgZml4IHRoZW06XG5cdFx0XHR2YXIgeDEgPSByZWN0LngsIHkxID0gcmVjdC55LCB4MiA9IHgxICsgcmVjdC53aWR0aCwgeTIgPSB5MSArIHJlY3QuaGVpZ2h0LCB4ID0gMCwgeSA9IDAsIHcgPSBpbWcud2lkdGgsIGggPSBpbWcuaGVpZ2h0O1xuXHRcdFx0aWYgKHgxIDwgMCkgeyB4IC09IHgxOyB4MSA9IDA7IH1cblx0XHRcdGlmICh4MiA+IHcpIHsgeDIgPSB3OyB9XG5cdFx0XHRpZiAoeTEgPCAwKSB7IHkgLT0geTE7IHkxID0gMDsgfVxuXHRcdFx0aWYgKHkyID4gaCkgeyB5MiA9IGg7IH1cblx0XHRcdGN0eC5kcmF3SW1hZ2UoaW1nLCB4MSwgeTEsIHgyLXgxLCB5Mi15MSwgeCwgeSwgeDIteDEsIHkyLXkxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdC8vTm90ZSwgdGhlIGRvYyBzZWN0aW9ucyBiZWxvdyBkb2N1bWVudCB1c2luZyB0aGUgc3BlY2lmaWVkIEFQSXMgKGZyb20gRGlzcGxheU9iamVjdCkgIGZyb21cblx0Ly9CaXRtYXAuIFRoaXMgaXMgd2h5IHRoZXkgaGF2ZSBubyBtZXRob2QgaW1wbGVtZW50YXRpb25zLlxuXHRcblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBCaXRtYXAgaXMgYWxyZWFkeSBpbiBhIHNpbXBsZSBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBCaXRtYXAgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIDxiPm5vdDwvYj4gY2FjaGUgQml0bWFwIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICpcblx0ICogPHN0cm9uZz5Ib3dldmVyOiBJZiB5b3Ugd2FudCB0byB1c2UgYSBmaWx0ZXIgb24gYSBCaXRtYXAsIHlvdSA8ZW0+TVVTVDwvZW0+IGNhY2hlIGl0LCBvciBpdCB3aWxsIG5vdCB3b3JrLjwvc3Ryb25nPlxuXHQgKiBUbyBzZWUgdGhlIEFQSSBmb3IgY2FjaGluZywgcGxlYXNlIHZpc2l0IHRoZSBEaXNwbGF5T2JqZWN0IHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAbWV0aG9kIGNhY2hlXG5cdCAqKi9cblx0XG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgQml0bWFwIGlzIGFscmVhZHkgaW4gYSBzaW1wbGUgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgQml0bWFwIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCA8Yj5ub3Q8L2I+IGNhY2hlIEJpdG1hcCBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqXG5cdCAqIDxzdHJvbmc+SG93ZXZlcjogSWYgeW91IHdhbnQgdG8gdXNlIGEgZmlsdGVyIG9uIGEgQml0bWFwLCB5b3UgPGVtPk1VU1Q8L2VtPiBjYWNoZSBpdCwgb3IgaXQgd2lsbCBub3Qgd29yay48L3N0cm9uZz5cblx0ICogVG8gc2VlIHRoZSBBUEkgZm9yIGNhY2hpbmcsIHBsZWFzZSB2aXNpdCB0aGUgRGlzcGxheU9iamVjdCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2NhY2hlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICogQG1ldGhvZCB1cGRhdGVDYWNoZVxuXHQgKiovXG5cdFxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIEJpdG1hcCBpcyBhbHJlYWR5IGluIGEgc2ltcGxlIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIEJpdG1hcCBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgPGI+bm90PC9iPiBjYWNoZSBCaXRtYXAgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKlxuXHQgKiA8c3Ryb25nPkhvd2V2ZXI6IElmIHlvdSB3YW50IHRvIHVzZSBhIGZpbHRlciBvbiBhIEJpdG1hcCwgeW91IDxlbT5NVVNUPC9lbT4gY2FjaGUgaXQsIG9yIGl0IHdpbGwgbm90IHdvcmsuPC9zdHJvbmc+XG5cdCAqIFRvIHNlZSB0aGUgQVBJIGZvciBjYWNoaW5nLCBwbGVhc2UgdmlzaXQgdGhlIERpc3BsYXlPYmplY3Qge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jYWNoZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBtZXRob2QgdW5jYWNoZVxuXHQgKiovXG5cblx0LyoqXG5cdCAqIERvY2NlZCBpbiBzdXBlcmNsYXNzLlxuXHQgKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IHRoaXMuRGlzcGxheU9iamVjdF9nZXRCb3VuZHMoKTtcblx0XHRpZiAocmVjdCkgeyByZXR1cm4gcmVjdDsgfVxuXHRcdHZhciBpbWFnZSA9IHRoaXMuaW1hZ2UsIG8gPSB0aGlzLnNvdXJjZVJlY3QgfHwgaW1hZ2U7XG5cdFx0dmFyIGhhc0NvbnRlbnQgPSAoaW1hZ2UgJiYgKGltYWdlLm5hdHVyYWxXaWR0aCB8fCBpbWFnZS5nZXRDb250ZXh0IHx8IGltYWdlLnJlYWR5U3RhdGUgPj0gMikpO1xuXHRcdHJldHVybiBoYXNDb250ZW50ID8gdGhpcy5fcmVjdGFuZ2xlLnNldFZhbHVlcygwLCAwLCBvLndpZHRoLCBvLmhlaWdodCkgOiBudWxsO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgQml0bWFwIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0JpdG1hcH0gYSBjbG9uZSBvZiB0aGUgQml0bWFwIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbyA9IG5ldyBCaXRtYXAodGhpcy5pbWFnZSk7XG5cdFx0aWYgKHRoaXMuc291cmNlUmVjdCkgeyBvLnNvdXJjZVJlY3QgPSB0aGlzLnNvdXJjZVJlY3QuY2xvbmUoKTsgfVxuXHRcdHRoaXMuX2Nsb25lUHJvcHMobyk7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0JpdG1hcCAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cdFxuXHRjcmVhdGVqcy5CaXRtYXAgPSBjcmVhdGVqcy5wcm9tb3RlKEJpdG1hcCwgXCJEaXNwbGF5T2JqZWN0XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNwcml0ZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIERpc3BsYXlzIGEgZnJhbWUgb3Igc2VxdWVuY2Ugb2YgZnJhbWVzIChpZS4gYW4gYW5pbWF0aW9uKSBmcm9tIGEgU3ByaXRlU2hlZXQgaW5zdGFuY2UuIEEgc3ByaXRlIHNoZWV0IGlzIGEgc2VyaWVzIG9mXG5cdCAqIGltYWdlcyAodXN1YWxseSBhbmltYXRpb24gZnJhbWVzKSBjb21iaW5lZCBpbnRvIGEgc2luZ2xlIGltYWdlLiBGb3IgZXhhbXBsZSwgYW4gYW5pbWF0aW9uIGNvbnNpc3Rpbmcgb2YgOCAxMDB4MTAwXG5cdCAqIGltYWdlcyBjb3VsZCBiZSBjb21iaW5lZCBpbnRvIGEgNDAweDIwMCBzcHJpdGUgc2hlZXQgKDQgZnJhbWVzIGFjcm9zcyBieSAyIGhpZ2gpLiBZb3UgY2FuIGRpc3BsYXkgaW5kaXZpZHVhbCBmcmFtZXMsXG5cdCAqIHBsYXkgZnJhbWVzIGFzIGFuIGFuaW1hdGlvbiwgYW5kIGV2ZW4gc2VxdWVuY2UgYW5pbWF0aW9ucyB0b2dldGhlci5cblx0ICpcblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzZXR0aW5nIHVwIGZyYW1lcyBhbmQgYW5pbWF0aW9ucy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBjcmVhdGVqcy5TcHJpdGUoc3ByaXRlU2hlZXQpO1xuXHQgKiAgICAgIGluc3RhbmNlLmdvdG9BbmRTdG9wKFwiZnJhbWVOYW1lXCIpO1xuXHQgKlxuXHQgKiBVbnRpbCB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319IGlzIGNhbGxlZCxcblx0ICogb25seSB0aGUgZmlyc3QgZGVmaW5lZCBmcmFtZSBkZWZpbmVkIGluIHRoZSBzcHJpdGUgc2hlZXQgd2lsbCBiZSBkaXNwbGF5ZWQuXG5cdCAqXG5cdCAqIEBjbGFzcyBTcHJpdGVcblx0ICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3ByaXRlU2hlZXQgVGhlIFNwcml0ZVNoZWV0IGluc3RhbmNlIHRvIHBsYXkgYmFjay4gVGhpcyBpbmNsdWRlcyB0aGUgc291cmNlIGltYWdlKHMpLCBmcmFtZVxuXHQgKiBkaW1lbnNpb25zLCBhbmQgZnJhbWUgZGF0YS4gU2VlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFtmcmFtZU9yQW5pbWF0aW9uXSBUaGUgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbiB0byBwbGF5IGluaXRpYWxseS5cblx0ICoqL1xuXHRmdW5jdGlvbiBTcHJpdGUoc3ByaXRlU2hlZXQsIGZyYW1lT3JBbmltYXRpb24pIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGZyYW1lIGluZGV4IHRoYXQgd2lsbCBiZSBkcmF3biB3aGVuIGRyYXcgaXMgY2FsbGVkLiBOb3RlIHRoYXQgd2l0aCBzb21lIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogZGVmaW5pdGlvbnMsIHRoaXMgd2lsbCBhZHZhbmNlIG5vbi1zZXF1ZW50aWFsbHkuIFRoaXMgd2lsbCBhbHdheXMgYmUgYW4gaW50ZWdlciB2YWx1ZS5cblx0XHQgKiBAcHJvcGVydHkgY3VycmVudEZyYW1lXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMuY3VycmVudEZyYW1lID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IHBsYXlpbmcgYW5pbWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBjdXJyZW50QW5pbWF0aW9uXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZmluYWxcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogUHJldmVudHMgdGhlIGFuaW1hdGlvbiBmcm9tIGFkdmFuY2luZyBlYWNoIHRpY2sgYXV0b21hdGljYWxseS4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCBjcmVhdGUgYSBzcHJpdGVcblx0XHQgKiBzaGVldCBvZiBpY29ucywgc2V0IHBhdXNlZCB0byB0cnVlLCBhbmQgZGlzcGxheSB0aGUgYXBwcm9wcmlhdGUgaWNvbiBieSBzZXR0aW5nIDxjb2RlPmN1cnJlbnRGcmFtZTwvY29kZT4uXG5cdFx0ICogQHByb3BlcnR5IHBhdXNlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICoqL1xuXHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIFNwcml0ZVNoZWV0IGluc3RhbmNlIHRvIHBsYXkgYmFjay4gVGhpcyBpbmNsdWRlcyB0aGUgc291cmNlIGltYWdlLCBmcmFtZSBkaW1lbnNpb25zLCBhbmQgZnJhbWVcblx0XHQgKiBkYXRhLiBTZWUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdFx0ICogQHByb3BlcnR5IHNwcml0ZVNoZWV0XG5cdFx0ICogQHR5cGUge1Nwcml0ZVNoZWV0fVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLnNwcml0ZVNoZWV0ID0gc3ByaXRlU2hlZXQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNwZWNpZmllcyB0aGUgY3VycmVudCBmcmFtZSBpbmRleCB3aXRoaW4gdGhlIGN1cnJlbnRseSBwbGF5aW5nIGFuaW1hdGlvbi4gV2hlbiBwbGF5aW5nIG5vcm1hbGx5LCB0aGlzIHdpbGwgaW5jcmVhc2Vcblx0XHQgKiBmcm9tIDAgdG8gbi0xLCB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBjdXJyZW50IGFuaW1hdGlvbi5cblx0XHQgKlxuXHRcdCAqIFRoaXMgY291bGQgYmUgYSBub24taW50ZWdlciB2YWx1ZSBpZlxuXHRcdCAqIHVzaW5nIHRpbWUtYmFzZWQgcGxheWJhY2sgKHNlZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZnJhbWVyYXRlXCJ9fXt7L2Nyb3NzTGlua319LCBvciBpZiB0aGUgYW5pbWF0aW9uJ3Mgc3BlZWQgaXNcblx0XHQgKiBub3QgYW4gaW50ZWdlci5cblx0XHQgKiBAcHJvcGVydHkgY3VycmVudEFuaW1hdGlvbkZyYW1lXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQnkgZGVmYXVsdCBTcHJpdGUgaW5zdGFuY2VzIGFkdmFuY2Ugb25lIGZyYW1lIHBlciB0aWNrLiBTcGVjaWZ5aW5nIGEgZnJhbWVyYXRlIGZvciB0aGUgU3ByaXRlIChvciBpdHMgcmVsYXRlZFxuXHRcdCAqIFNwcml0ZVNoZWV0KSB3aWxsIGNhdXNlIGl0IHRvIGFkdmFuY2UgYmFzZWQgb24gZWxhcHNlZCB0aW1lIGJldHdlZW4gdGlja3MgYXMgYXBwcm9wcmlhdGUgdG8gbWFpbnRhaW4gdGhlIHRhcmdldFxuXHRcdCAqIGZyYW1lcmF0ZS5cblx0XHQgKlxuXHRcdCAqIEZvciBleGFtcGxlLCBpZiBhIFNwcml0ZSB3aXRoIGEgZnJhbWVyYXRlIG9mIDEwIGlzIHBsYWNlZCBvbiBhIFN0YWdlIGJlaW5nIHVwZGF0ZWQgYXQgNDBmcHMsIHRoZW4gdGhlIFNwcml0ZSB3aWxsXG5cdFx0ICogYWR2YW5jZSByb3VnaGx5IG9uZSBmcmFtZSBldmVyeSA0IHRpY2tzLiBUaGlzIHdpbGwgbm90IGJlIGV4YWN0LCBiZWNhdXNlIHRoZSB0aW1lIGJldHdlZW4gZWFjaCB0aWNrIHdpbGxcblx0XHQgKiB2YXJ5IHNsaWdodGx5IGJldHdlZW4gZnJhbWVzLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBmZWF0dXJlIGlzIGRlcGVuZGVudCBvbiB0aGUgdGljayBldmVudCBvYmplY3QgKG9yIGFuIG9iamVjdCB3aXRoIGFuIGFwcHJvcHJpYXRlIFwiZGVsdGFcIiBwcm9wZXJ0eSkgYmVpbmdcblx0XHQgKiBwYXNzZWQgaW50byB7eyNjcm9zc0xpbmsgXCJTdGFnZS91cGRhdGVcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IGZyYW1lcmF0ZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLmZyYW1lcmF0ZSA9IDA7XG5cdFxuXHRcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnQgYW5pbWF0aW9uIG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgX2FuaW1hdGlvblxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5fYW5pbWF0aW9uID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQ3VycmVudCBmcmFtZSBpbmRleC5cblx0XHQgKiBAcHJvcGVydHkgX2N1cnJlbnRGcmFtZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5fY3VycmVudEZyYW1lID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTa2lwcyB0aGUgbmV4dCBhdXRvIGFkdmFuY2UuIFVzZWQgYnkgZ290b0FuZFBsYXkgdG8gYXZvaWQgaW1tZWRpYXRlbHkganVtcGluZyB0byB0aGUgbmV4dCBmcmFtZVxuXHRcdCAqIEBwcm9wZXJ0eSBfc2tpcEFkdmFuY2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiovXG5cdFx0dGhpcy5fc2tpcEFkdmFuY2UgPSBmYWxzZTtcblx0XHRcblx0XHRcblx0XHRpZiAoZnJhbWVPckFuaW1hdGlvbiAhPSBudWxsKSB7IHRoaXMuZ290b0FuZFBsYXkoZnJhbWVPckFuaW1hdGlvbik7IH1cblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTcHJpdGUsIGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QpO1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RvciBhbGlhcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMuXG5cdCAqIFN1YmNsYXNzZXMgc2hvdWxkIGJlIHVwZGF0ZWQgdG8gdXNlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRzXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIGBjcmVhdGVqcy5wcm9tb3RlKClgXG5cdCAqKi9cblx0cC5pbml0aWFsaXplID0gU3ByaXRlOyAvLyBUT0RPOiBEZXByZWNhdGVkLiBUaGlzIGlzIGZvciBiYWNrd2FyZHMgc3VwcG9ydCBvZiBGbGFzaENDIHNwcml0ZXNoZWV0IGV4cG9ydC5cblxuXG4vLyBldmVudHM6XG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gYW4gYW5pbWF0aW9uIHJlYWNoZXMgaXRzIGVuZHMuXG5cdCAqIEBldmVudCBhbmltYXRpb25lbmRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRoYXQganVzdCBlbmRlZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IG5leHQgVGhlIG5hbWUgb2YgdGhlIG5leHQgYW5pbWF0aW9uIHRoYXQgd2lsbCBiZSBwbGF5ZWQsIG9yIG51bGwuIFRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyBuYW1lIGlmIHRoZSBhbmltYXRpb24gaXMgbG9vcGluZy5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIGFueSB0aW1lIHRoZSBjdXJyZW50IGZyYW1lIGNoYW5nZXMuIEZvciBleGFtcGxlLCB0aGlzIGNvdWxkIGJlIGR1ZSB0byBhdXRvbWF0aWMgYWR2YW5jZW1lbnQgb24gYSB0aWNrLFxuXHQgKiBvciBjYWxsaW5nIGdvdG9BbmRQbGF5KCkgb3IgZ290b0FuZFN0b3AoKS5cblx0ICogQGV2ZW50IGNoYW5nZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqL1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xuXHQgKiovXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhc0NvbnRlbnQgPSB0aGlzLmNhY2hlQ2FudmFzIHx8IHRoaXMuc3ByaXRlU2hlZXQuY29tcGxldGU7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDAgJiYgaGFzQ29udGVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlQ2FjaGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuXG5cdCAqIEZvciBleGFtcGxlLCB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2tcblx0ICogaW50byBpdHNlbGYpLlxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHR0aGlzLl9ub3JtYWxpemVGcmFtZSgpO1xuXHRcdHZhciBvID0gdGhpcy5zcHJpdGVTaGVldC5nZXRGcmFtZSh0aGlzLl9jdXJyZW50RnJhbWV8MCk7XG5cdFx0aWYgKCFvKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHZhciByZWN0ID0gby5yZWN0O1xuXHRcdGlmIChyZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KSB7IGN0eC5kcmF3SW1hZ2Uoby5pbWFnZSwgcmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCAtby5yZWdYLCAtby5yZWdZLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7IH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvL05vdGUsIHRoZSBkb2Mgc2VjdGlvbnMgYmVsb3cgZG9jdW1lbnQgdXNpbmcgdGhlIHNwZWNpZmllZCBBUElzIChmcm9tIERpc3BsYXlPYmplY3QpICBmcm9tXG5cdC8vQml0bWFwLiBUaGlzIGlzIHdoeSB0aGV5IGhhdmUgbm8gbWV0aG9kIGltcGxlbWVudGF0aW9ucy5cblxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIFNwcml0ZSBpcyBhbHJlYWR5IGluIGEgcmFzdGVyIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIFNwcml0ZSBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgbm90IGNhY2hlIFNwcml0ZSBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqIEBtZXRob2QgY2FjaGVcblx0ICoqL1xuXG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgU3ByaXRlIGlzIGFscmVhZHkgaW4gYSByYXN0ZXIgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgU3ByaXRlIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCBub3QgY2FjaGUgU3ByaXRlIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICogQG1ldGhvZCB1cGRhdGVDYWNoZVxuXHQgKiovXG5cblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBTcHJpdGUgaXMgYWxyZWFkeSBpbiBhIHJhc3RlciBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBTcHJpdGUgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIG5vdCBjYWNoZSBTcHJpdGUgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKiBAbWV0aG9kIHVuY2FjaGVcblx0ICoqL1xuXG5cdC8qKlxuXHQgKiBQbGF5ICh1bnBhdXNlKSB0aGUgY3VycmVudCBhbmltYXRpb24uIFRoZSBTcHJpdGUgd2lsbCBiZSBwYXVzZWQgaWYgZWl0aGVyIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9zdG9wXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9yIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kU3RvcFwifX17ey9jcm9zc0xpbmt9fSBpcyBjYWxsZWQuIFNpbmdsZSBmcmFtZSBhbmltYXRpb25zIHdpbGwgcmVtYWluXG5cdCAqIHVuY2hhbmdlZC5cblx0ICogQG1ldGhvZCBwbGF5XG5cdCAqKi9cblx0cC5wbGF5ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcCBwbGF5aW5nIGEgcnVubmluZyBhbmltYXRpb24uIFRoZSBTcHJpdGUgd2lsbCBiZSBwbGF5aW5nIGlmIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpcyBjYWxsZWQuIE5vdGUgdGhhdCBjYWxsaW5nIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvcGxheVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aWxsIHJlc3VtZSBwbGF5YmFjay5cblx0ICogQG1ldGhvZCBzdG9wXG5cdCAqKi9cblx0cC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHBhdXNlZCB0byBmYWxzZSBhbmQgcGxheXMgdGhlIHNwZWNpZmllZCBhbmltYXRpb24gbmFtZSwgbmFtZWQgZnJhbWUsIG9yIGZyYW1lIG51bWJlci5cblx0ICogQG1ldGhvZCBnb3RvQW5kUGxheVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGZyYW1lT3JBbmltYXRpb24gVGhlIGZyYW1lIG51bWJlciBvciBhbmltYXRpb24gbmFtZSB0aGF0IHRoZSBwbGF5aGVhZCBzaG91bGQgbW92ZSB0b1xuXHQgKiBhbmQgYmVnaW4gcGxheWluZy5cblx0ICoqL1xuXHRwLmdvdG9BbmRQbGF5ID0gZnVuY3Rpb24oZnJhbWVPckFuaW1hdGlvbikge1xuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fc2tpcEFkdmFuY2UgPSB0cnVlO1xuXHRcdHRoaXMuX2dvdG8oZnJhbWVPckFuaW1hdGlvbik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgcGF1c2VkIHRvIHRydWUgYW5kIHNlZWtzIHRvIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uIG5hbWUsIG5hbWVkIGZyYW1lLCBvciBmcmFtZSBudW1iZXIuXG5cdCAqIEBtZXRob2QgZ290b0FuZFN0b3Bcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBmcmFtZU9yQW5pbWF0aW9uIFRoZSBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uIG5hbWUgdGhhdCB0aGUgcGxheWhlYWQgc2hvdWxkIG1vdmUgdG9cblx0ICogYW5kIHN0b3AuXG5cdCAqKi9cblx0cC5nb3RvQW5kU3RvcCA9IGZ1bmN0aW9uKGZyYW1lT3JBbmltYXRpb24pIHtcblx0XHR0aGlzLnBhdXNlZCA9IHRydWU7XG5cdFx0dGhpcy5fZ290byhmcmFtZU9yQW5pbWF0aW9uKTtcblx0fTtcblxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhlIHBsYXloZWFkLiBUaGlzIG9jY3VycyBhdXRvbWF0aWNhbGx5IGVhY2ggdGljayBieSBkZWZhdWx0LlxuXHQgKiBAcGFyYW0gW3RpbWVdIHtOdW1iZXJ9IFRoZSBhbW91bnQgb2YgdGltZSBpbiBtcyB0byBhZHZhbmNlIGJ5LiBPbmx5IGFwcGxpY2FibGUgaWYgZnJhbWVyYXRlIGlzIHNldCBvbiB0aGUgU3ByaXRlXG5cdCAqIG9yIGl0cyBTcHJpdGVTaGVldC5cblx0ICogQG1ldGhvZCBhZHZhbmNlXG5cdCovXG5cdHAuYWR2YW5jZSA9IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHR2YXIgZnBzID0gdGhpcy5mcmFtZXJhdGUgfHwgdGhpcy5zcHJpdGVTaGVldC5mcmFtZXJhdGU7XG5cdFx0dmFyIHQgPSAoZnBzICYmIHRpbWUgIT0gbnVsbCkgPyB0aW1lLygxMDAwL2ZwcykgOiAxO1xuXHRcdHRoaXMuX25vcm1hbGl6ZUZyYW1lKHQpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSB7eyNjcm9zc0xpbmsgXCJSZWN0YW5nbGVcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UgZGVmaW5pbmcgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBmcmFtZSByZWxhdGl2ZSB0b1xuXHQgKiB0aGUgb3JpZ2luLiBGb3IgZXhhbXBsZSwgYSA5MCB4IDcwIGZyYW1lIHdpdGggPGNvZGU+cmVnWD01MDwvY29kZT4gYW5kIDxjb2RlPnJlZ1k9NDA8L2NvZGU+IHdvdWxkIHJldHVybiBhXG5cdCAqIHJlY3RhbmdsZSB3aXRoIFt4PS01MCwgeT0tNDAsIHdpZHRoPTkwLCBoZWlnaHQ9NzBdLiBUaGlzIGlnbm9yZXMgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBkaXNwbGF5IG9iamVjdC5cblx0ICpcblx0ICogQWxzbyBzZWUgdGhlIFNwcml0ZVNoZWV0IHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0L2dldEZyYW1lQm91bmRzXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogQG1ldGhvZCBnZXRCb3VuZHNcblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBBIFJlY3RhbmdsZSBpbnN0YW5jZS4gUmV0dXJucyBudWxsIGlmIHRoZSBmcmFtZSBkb2VzIG5vdCBleGlzdCwgb3IgdGhlIGltYWdlIGlzIG5vdCBmdWxseVxuXHQgKiBsb2FkZWQuXG5cdCAqKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBUT0RPOiBzaG91bGQgdGhpcyBub3JtYWxpemVGcmFtZT9cblx0XHRyZXR1cm4gdGhpcy5EaXNwbGF5T2JqZWN0X2dldEJvdW5kcygpIHx8IHRoaXMuc3ByaXRlU2hlZXQuZ2V0RnJhbWVCb3VuZHModGhpcy5jdXJyZW50RnJhbWUsIHRoaXMuX3JlY3RhbmdsZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgU3ByaXRlIGluc3RhbmNlLiBOb3RlIHRoYXQgdGhlIHNhbWUgU3ByaXRlU2hlZXQgaXMgc2hhcmVkIGJldHdlZW4gY2xvbmVkXG5cdCAqIGluc3RhbmNlcy5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtTcHJpdGV9IGEgY2xvbmUgb2YgdGhlIFNwcml0ZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lUHJvcHMobmV3IFNwcml0ZSh0aGlzLnNwcml0ZVNoZWV0KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltTcHJpdGUgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcblx0fTtcblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfY2xvbmVQcm9wc1xuXHQgKiBAcGFyYW0ge1Nwcml0ZX0gb1xuXHQgKiBAcmV0dXJuIHtTcHJpdGV9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2Nsb25lUHJvcHMgPSBmdW5jdGlvbihvKSB7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X19jbG9uZVByb3BzKG8pO1xuXHRcdG8uY3VycmVudEZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG5cdFx0by5jdXJyZW50QW5pbWF0aW9uID0gdGhpcy5jdXJyZW50QW5pbWF0aW9uO1xuXHRcdG8ucGF1c2VkID0gdGhpcy5wYXVzZWQ7XG5cdFx0by5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZTtcblx0XHRvLmZyYW1lcmF0ZSA9IHRoaXMuZnJhbWVyYXRlO1xuXHRcdFxuXHRcdG8uX2FuaW1hdGlvbiA9IHRoaXMuX2FuaW1hdGlvbjtcblx0XHRvLl9jdXJyZW50RnJhbWUgPSB0aGlzLl9jdXJyZW50RnJhbWU7XG5cdFx0by5fc2tpcEFkdmFuY2UgPSB0aGlzLl9za2lwQWR2YW5jZTtcblx0XHRyZXR1cm4gbztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGUgPGNvZGU+Y3VycmVudEZyYW1lPC9jb2RlPiBpZiBwYXVzZWQgaXMgbm90IHRydWUuIFRoaXMgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogdGlja3MuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldnRPYmogQW4gZXZlbnQgb2JqZWN0IHRoYXQgd2lsbCBiZSBkaXNwYXRjaGVkIHRvIGFsbCB0aWNrIGxpc3RlbmVycy4gVGhpcyBvYmplY3QgaXMgcmV1c2VkIGJldHdlZW4gZGlzcGF0Y2hlcnMgdG8gcmVkdWNlIGNvbnN0cnVjdGlvbiAmIEdDIGNvc3RzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX3RpY2tcblx0ICoqL1xuXHRwLl90aWNrID0gZnVuY3Rpb24oZXZ0T2JqKSB7XG5cdFx0aWYgKCF0aGlzLnBhdXNlZCkge1xuXHRcdFx0aWYgKCF0aGlzLl9za2lwQWR2YW5jZSkgeyB0aGlzLmFkdmFuY2UoZXZ0T2JqJiZldnRPYmouZGVsdGEpOyB9XG5cdFx0XHR0aGlzLl9za2lwQWR2YW5jZSA9IGZhbHNlO1xuXHRcdH1cblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfX3RpY2soZXZ0T2JqKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBOb3JtYWxpemVzIHRoZSBjdXJyZW50IGZyYW1lLCBhZHZhbmNpbmcgYW5pbWF0aW9ucyBhbmQgZGlzcGF0Y2hpbmcgY2FsbGJhY2tzIGFzIGFwcHJvcHJpYXRlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX25vcm1hbGl6ZUZyYW1lXG5cdCAqKi9cblx0cC5fbm9ybWFsaXplRnJhbWUgPSBmdW5jdGlvbihmcmFtZURlbHRhKSB7XG5cdFx0ZnJhbWVEZWx0YSA9IGZyYW1lRGVsdGEgfHwgMDtcblx0XHR2YXIgYW5pbWF0aW9uID0gdGhpcy5fYW5pbWF0aW9uO1xuXHRcdHZhciBwYXVzZWQgPSB0aGlzLnBhdXNlZDtcblx0XHR2YXIgZnJhbWUgPSB0aGlzLl9jdXJyZW50RnJhbWU7XG5cdFx0dmFyIGw7XG5cdFx0XG5cdFx0aWYgKGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIHNwZWVkID0gYW5pbWF0aW9uLnNwZWVkIHx8IDE7XG5cdFx0XHR2YXIgYW5pbUZyYW1lID0gdGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWU7XG5cdFx0XHRsID0gYW5pbWF0aW9uLmZyYW1lcy5sZW5ndGg7XG5cdFx0XHRpZiAoYW5pbUZyYW1lICsgZnJhbWVEZWx0YSAqIHNwZWVkID49IGwpIHtcblx0XHRcdFx0dmFyIG5leHQgPSBhbmltYXRpb24ubmV4dDtcblx0XHRcdFx0aWYgKHRoaXMuX2Rpc3BhdGNoQW5pbWF0aW9uRW5kKGFuaW1hdGlvbiwgZnJhbWUsIHBhdXNlZCwgbmV4dCwgbCAtIDEpKSB7XG5cdFx0XHRcdFx0Ly8gc29tZXRoaW5nIGNoYW5nZWQgaW4gdGhlIGV2ZW50IHN0YWNrLCBzbyB3ZSBzaG91bGRuJ3QgbWFrZSBhbnkgbW9yZSBjaGFuZ2VzIGhlcmUuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG5leHQpIHtcblx0XHRcdFx0XHQvLyBzZXF1ZW5jZS4gQXV0b21hdGljYWxseSBjYWxscyBfbm9ybWFsaXplRnJhbWUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGZyYW1lcy5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fZ290byhuZXh0LCBmcmFtZURlbHRhIC0gKGwgLSBhbmltRnJhbWUpIC8gc3BlZWQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGVuZC5cblx0XHRcdFx0XHR0aGlzLnBhdXNlZCA9IHRydWU7XG5cdFx0XHRcdFx0YW5pbUZyYW1lID0gYW5pbWF0aW9uLmZyYW1lcy5sZW5ndGggLSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhbmltRnJhbWUgKz0gZnJhbWVEZWx0YSAqIHNwZWVkO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSBhbmltRnJhbWU7XG5cdFx0XHR0aGlzLl9jdXJyZW50RnJhbWUgPSBhbmltYXRpb24uZnJhbWVzW2FuaW1GcmFtZSB8IDBdXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZyYW1lID0gKHRoaXMuX2N1cnJlbnRGcmFtZSArPSBmcmFtZURlbHRhKTtcblx0XHRcdGwgPSB0aGlzLnNwcml0ZVNoZWV0LmdldE51bUZyYW1lcygpO1xuXHRcdFx0aWYgKGZyYW1lID49IGwgJiYgbCA+IDApIHtcblx0XHRcdFx0aWYgKCF0aGlzLl9kaXNwYXRjaEFuaW1hdGlvbkVuZChhbmltYXRpb24sIGZyYW1lLCBwYXVzZWQsIGwgLSAxKSkge1xuXHRcdFx0XHRcdC8vIGxvb3BlZC5cblx0XHRcdFx0XHRpZiAoKHRoaXMuX2N1cnJlbnRGcmFtZSAtPSBsKSA+PSBsKSB7IHJldHVybiB0aGlzLl9ub3JtYWxpemVGcmFtZSgpOyB9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZnJhbWUgPSB0aGlzLl9jdXJyZW50RnJhbWUgfCAwO1xuXHRcdGlmICh0aGlzLmN1cnJlbnRGcmFtZSAhPSBmcmFtZSkge1xuXHRcdFx0dGhpcy5jdXJyZW50RnJhbWUgPSBmcmFtZTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNoYW5nZVwiKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZXMgdGhlIFwiYW5pbWF0aW9uZW5kXCIgZXZlbnQuIFJldHVybnMgdHJ1ZSBpZiBhIGhhbmRsZXIgY2hhbmdlZCB0aGUgYW5pbWF0aW9uIChleC4gY2FsbGluZyB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvc3RvcFwifX17ey9jcm9zc0xpbmt9fSxcblx0ICoge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319LCBldGMuKVxuXHQgKiBAcHJvcGVydHkgX2Rpc3BhdGNoQW5pbWF0aW9uRW5kXG5cdCAqIEBwcml2YXRlXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRwLl9kaXNwYXRjaEFuaW1hdGlvbkVuZCA9IGZ1bmN0aW9uKGFuaW1hdGlvbiwgZnJhbWUsIHBhdXNlZCwgbmV4dCwgZW5kKSB7XG5cdFx0dmFyIG5hbWUgPSBhbmltYXRpb24gPyBhbmltYXRpb24ubmFtZSA6IG51bGw7XG5cdFx0aWYgKHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiKSkge1xuXHRcdFx0dmFyIGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImFuaW1hdGlvbmVuZFwiKTtcblx0XHRcdGV2dC5uYW1lID0gbmFtZTtcblx0XHRcdGV2dC5uZXh0ID0gbmV4dDtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuXHRcdH1cblx0XHQvLyBkaWQgdGhlIGFuaW1hdGlvbiBnZXQgY2hhbmdlZCBpbiB0aGUgZXZlbnQgc3RhY2s/OlxuXHRcdHZhciBjaGFuZ2VkID0gKHRoaXMuX2FuaW1hdGlvbiAhPSBhbmltYXRpb24gfHwgdGhpcy5fY3VycmVudEZyYW1lICE9IGZyYW1lKTtcblx0XHQvLyBpZiB0aGUgYW5pbWF0aW9uIGhhc24ndCBjaGFuZ2VkLCBidXQgdGhlIHNwcml0ZSB3YXMgcGF1c2VkLCB0aGVuIHdlIHdhbnQgdG8gc3RpY2sgdG8gdGhlIGxhc3QgZnJhbWU6XG5cdFx0aWYgKCFjaGFuZ2VkICYmICFwYXVzZWQgJiYgdGhpcy5wYXVzZWQpIHsgdGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSBlbmQ7IGNoYW5nZWQgPSB0cnVlOyB9XG5cdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1vdmVzIHRoZSBwbGF5aGVhZCB0byB0aGUgc3BlY2lmaWVkIGZyYW1lIG51bWJlciBvciBhbmltYXRpb24uXG5cdCAqIEBtZXRob2QgX2dvdG9cblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBmcmFtZU9yQW5pbWF0aW9uIFRoZSBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uIHRoYXQgdGhlIHBsYXloZWFkIHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtmcmFtZV0gVGhlIGZyYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gZ28gdG8uIERlZmF1bHRzIHRvIDAuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nb3RvID0gZnVuY3Rpb24oZnJhbWVPckFuaW1hdGlvbiwgZnJhbWUpIHtcblx0XHR0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IDA7XG5cdFx0aWYgKGlzTmFOKGZyYW1lT3JBbmltYXRpb24pKSB7XG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMuc3ByaXRlU2hlZXQuZ2V0QW5pbWF0aW9uKGZyYW1lT3JBbmltYXRpb24pO1xuXHRcdFx0aWYgKGRhdGEpIHtcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uID0gZGF0YTtcblx0XHRcdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uID0gZnJhbWVPckFuaW1hdGlvbjtcblx0XHRcdFx0dGhpcy5fbm9ybWFsaXplRnJhbWUoZnJhbWUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRBbmltYXRpb24gPSB0aGlzLl9hbmltYXRpb24gPSBudWxsO1xuXHRcdFx0dGhpcy5fY3VycmVudEZyYW1lID0gZnJhbWVPckFuaW1hdGlvbjtcblx0XHRcdHRoaXMuX25vcm1hbGl6ZUZyYW1lKCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0Y3JlYXRlanMuU3ByaXRlID0gY3JlYXRlanMucHJvbW90ZShTcHJpdGUsIFwiRGlzcGxheU9iamVjdFwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTaGFwZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEEgU2hhcGUgYWxsb3dzIHlvdSB0byBkaXNwbGF5IHZlY3RvciBhcnQgaW4gdGhlIGRpc3BsYXkgbGlzdC4gSXQgY29tcG9zaXRlcyBhIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGluc3RhbmNlIHdoaWNoIGV4cG9zZXMgYWxsIG9mIHRoZSB2ZWN0b3IgZHJhd2luZyBtZXRob2RzLiBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgY2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIFNoYXBlXG5cdCAqIGluc3RhbmNlcyB0byBkaXNwbGF5IHRoZSBzYW1lIHZlY3RvciBncmFwaGljcyB3aXRoIGRpZmZlcmVudCBwb3NpdGlvbnMgb3IgdHJhbnNmb3Jtcy5cblx0ICpcblx0ICogSWYgdGhlIHZlY3RvciBhcnQgd2lsbCBub3Rcblx0ICogY2hhbmdlIGJldHdlZW4gZHJhd3MsIHlvdSBtYXkgd2FudCB0byB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHRvIHJlZHVjZSB0aGVcblx0ICogcmVuZGVyaW5nIGNvc3QuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgY3JlYXRlanMuR3JhcGhpY3MoKS5iZWdpbkZpbGwoXCIjZmYwMDAwXCIpLmRyYXdSZWN0KDAsIDAsIDEwMCwgMTAwKTtcblx0ICogICAgICB2YXIgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoZ3JhcGhpY3MpO1xuXHQgKlxuXHQgKiAgICAgIC8vQWx0ZXJuYXRpdmVseSB1c2UgY2FuIGFsc28gdXNlIHRoZSBncmFwaGljcyBwcm9wZXJ0eSBvZiB0aGUgU2hhcGUgY2xhc3MgdG8gcmVuZGVyZXIgdGhlIHNhbWUgYXMgYWJvdmUuXG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG5cdCAqICAgICAgc2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3UmVjdCgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqIEBjbGFzcyBTaGFwZVxuXHQgKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0dyYXBoaWNzfSBncmFwaGljcyBPcHRpb25hbC4gVGhlIGdyYXBoaWNzIGluc3RhbmNlIHRvIGRpc3BsYXkuIElmIG51bGwsIGEgbmV3IEdyYXBoaWNzIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZC5cblx0ICoqL1xuXHRmdW5jdGlvbiBTaGFwZShncmFwaGljcykge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgZ3JhcGhpY3MgaW5zdGFuY2UgdG8gZGlzcGxheS5cblx0XHQgKiBAcHJvcGVydHkgZ3JhcGhpY3Ncblx0XHQgKiBAdHlwZSBHcmFwaGljc1xuXHRcdCAqKi9cblx0XHR0aGlzLmdyYXBoaWNzID0gZ3JhcGhpY3MgPyBncmFwaGljcyA6IG5ldyBjcmVhdGVqcy5HcmFwaGljcygpO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNoYXBlLCBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFNoYXBlIHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFNoYXBlIHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCAodGhpcy5ncmFwaGljcyAmJiAhdGhpcy5ncmFwaGljcy5pc0VtcHR5KCkpO1xuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwICYmIGhhc0NvbnRlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgU2hhcGUgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uIFJldHVybnMgdHJ1ZSBpZlxuXHQgKiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKlxuXHQgKiA8aT5OT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuPC9pPlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlQ2FjaGU9ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLiBGb3IgZXhhbXBsZSxcblx0ICogdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrIGludG8gaXRzZWxmKS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0aWYgKHRoaXMuRGlzcGxheU9iamVjdF9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dGhpcy5ncmFwaGljcy5kcmF3KGN0eCwgdGhpcyk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIFNoYXBlLiBTb21lIHByb3BlcnRpZXMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhpcyBpbnN0YW5jZSdzIGN1cnJlbnQgY29udGV4dCBhcmUgcmV2ZXJ0ZWQgdG9cblx0ICogdGhlaXIgZGVmYXVsdHMgKGZvciBleGFtcGxlIC5wYXJlbnQpLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVjdXJzaXZlIElmIHRydWUsIHRoaXMgU2hhcGUncyB7eyNjcm9zc0xpbmsgXCJHcmFwaGljc1wifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZSB3aWxsIGFsc28gYmVcblx0ICogY2xvbmVkLiBJZiBmYWxzZSwgdGhlIEdyYXBoaWNzIGluc3RhbmNlIHdpbGwgYmUgc2hhcmVkIHdpdGggdGhlIG5ldyBTaGFwZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24ocmVjdXJzaXZlKSB7XG5cdFx0dmFyIGcgPSAocmVjdXJzaXZlICYmIHRoaXMuZ3JhcGhpY3MpID8gdGhpcy5ncmFwaGljcy5jbG9uZSgpIDogdGhpcy5ncmFwaGljcztcblx0XHRyZXR1cm4gIHRoaXMuX2Nsb25lUHJvcHMobmV3IFNoYXBlKGcpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1NoYXBlIChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5TaGFwZSA9IGNyZWF0ZWpzLnByb21vdGUoU2hhcGUsIFwiRGlzcGxheU9iamVjdFwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUZXh0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogRGlzcGxheSBvbmUgb3IgbW9yZSBsaW5lcyBvZiBkeW5hbWljIHRleHQgKG5vdCB1c2VyIGVkaXRhYmxlKSBpbiB0aGUgZGlzcGxheSBsaXN0LiBMaW5lIHdyYXBwaW5nIHN1cHBvcnQgKHVzaW5nIHRoZVxuXHQgKiBsaW5lV2lkdGgpIGlzIHZlcnkgYmFzaWMsIHdyYXBwaW5nIG9uIHNwYWNlcyBhbmQgdGFicyBvbmx5LiBOb3RlIHRoYXQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gVGV4dCwgeW91IGNhbiBwb3NpdGlvbiBIVE1MXG5cdCAqIHRleHQgYWJvdmUgb3IgYmVsb3cgdGhlIGNhbnZhcyByZWxhdGl2ZSB0byBpdGVtcyBpbiB0aGUgZGlzcGxheSBsaXN0IHVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2xvY2FsVG9HbG9iYWxcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLCBvciB1c2luZyB7eyNjcm9zc0xpbmsgXCJET01FbGVtZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8Yj5QbGVhc2Ugbm90ZSB0aGF0IFRleHQgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIHRleHQsIGFuZCBjYW4gb25seSBkaXNwbGF5IG9uZSBmb250IHN0eWxlIGF0IGEgdGltZS48L2I+IFRvIHVzZVxuXHQgKiBtdWx0aXBsZSBmb250IHN0eWxlcywgeW91IHdpbGwgbmVlZCB0byBjcmVhdGUgbXVsdGlwbGUgdGV4dCBpbnN0YW5jZXMsIGFuZCBwb3NpdGlvbiB0aGVtIG1hbnVhbGx5LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIHRleHQgPSBuZXcgY3JlYXRlanMuVGV4dChcIkhlbGxvIFdvcmxkXCIsIFwiMjBweCBBcmlhbFwiLCBcIiNmZjc3MDBcIik7XG5cdCAqICAgICAgdGV4dC54ID0gMTAwO1xuXHQgKiAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCI7XG5cdCAqXG5cdCAqIENyZWF0ZUpTIFRleHQgc3VwcG9ydHMgd2ViIGZvbnRzICh0aGUgc2FtZSBydWxlcyBhcyBDYW52YXMpLiBUaGUgZm9udCBtdXN0IGJlIGxvYWRlZCBhbmQgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyXG5cdCAqIGJlZm9yZSBpdCBjYW4gYmUgZGlzcGxheWVkLlxuXHQgKlxuXHQgKiA8c3Ryb25nPk5vdGU6PC9zdHJvbmc+IFRleHQgY2FuIGJlIGV4cGVuc2l2ZSB0byBnZW5lcmF0ZSwgc28gY2FjaGUgaW5zdGFuY2VzIHdoZXJlIHBvc3NpYmxlLiBCZSBhd2FyZSB0aGF0IG5vdCBhbGxcblx0ICogYnJvd3NlcnMgd2lsbCByZW5kZXIgVGV4dCBleGFjdGx5IHRoZSBzYW1lLlxuXHQgKiBAY2xhc3MgVGV4dFxuXHQgKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3RleHRdIFRoZSB0ZXh0IHRvIGRpc3BsYXkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbZm9udF0gVGhlIGZvbnQgc3R5bGUgdG8gdXNlLiBBbnkgdmFsaWQgdmFsdWUgZm9yIHRoZSBDU1MgZm9udCBhdHRyaWJ1dGUgaXMgYWNjZXB0YWJsZSAoZXguIFwiYm9sZFxuXHQgKiAzNnB4IEFyaWFsXCIpLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2NvbG9yXSBUaGUgY29sb3IgdG8gZHJhdyB0aGUgdGV4dCBpbi4gQW55IHZhbGlkIHZhbHVlIGZvciB0aGUgQ1NTIGNvbG9yIGF0dHJpYnV0ZSBpcyBhY2NlcHRhYmxlIChleC5cblx0ICogXCIjRjAwXCIsIFwicmVkXCIsIG9yIFwiI0ZGMDAwMFwiKS5cblx0ICoqL1xuXHRmdW5jdGlvbiBUZXh0KHRleHQsIGZvbnQsIGNvbG9yKSB7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0ZXh0IHRvIGRpc3BsYXkuXG5cdFx0ICogQHByb3BlcnR5IHRleHRcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy50ZXh0ID0gdGV4dDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGZvbnQgc3R5bGUgdG8gdXNlLiBBbnkgdmFsaWQgdmFsdWUgZm9yIHRoZSBDU1MgZm9udCBhdHRyaWJ1dGUgaXMgYWNjZXB0YWJsZSAoZXguIFwiYm9sZCAzNnB4IEFyaWFsXCIpLlxuXHRcdCAqIEBwcm9wZXJ0eSBmb250XG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICoqL1xuXHRcdHRoaXMuZm9udCA9IGZvbnQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb2xvciB0byBkcmF3IHRoZSB0ZXh0IGluLiBBbnkgdmFsaWQgdmFsdWUgZm9yIHRoZSBDU1MgY29sb3IgYXR0cmlidXRlIGlzIGFjY2VwdGFibGUgKGV4LiBcIiNGMDBcIikuIERlZmF1bHQgaXMgXCIjMDAwXCIuXG5cdFx0ICogSXQgd2lsbCBhbHNvIGFjY2VwdCB2YWxpZCBjYW52YXMgZmlsbFN0eWxlIHZhbHVlcy5cblx0XHQgKiBAcHJvcGVydHkgY29sb3Jcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgaG9yaXpvbnRhbCB0ZXh0IGFsaWdubWVudC4gQW55IG9mIFwic3RhcnRcIiwgXCJlbmRcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgYW5kIFwiY2VudGVyXCIuIEZvciBkZXRhaWxlZFxuXHRcdCAqIGluZm9ybWF0aW9uIHZpZXcgdGhlXG5cdFx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI3RleHQtc3R5bGVzXCI+XG5cdFx0ICogd2hhdHdnIHNwZWM8L2E+LiBEZWZhdWx0IGlzIFwibGVmdFwiLlxuXHRcdCAqIEBwcm9wZXJ0eSB0ZXh0QWxpZ25cblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy50ZXh0QWxpZ24gPSBcImxlZnRcIjtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHZlcnRpY2FsIGFsaWdubWVudCBwb2ludCBvbiB0aGUgZm9udC4gQW55IG9mIFwidG9wXCIsIFwiaGFuZ2luZ1wiLCBcIm1pZGRsZVwiLCBcImFscGhhYmV0aWNcIiwgXCJpZGVvZ3JhcGhpY1wiLCBvclxuXHRcdCAqIFwiYm90dG9tXCIuIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiB2aWV3IHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjdGV4dC1zdHlsZXNcIj5cblx0XHQgKiB3aGF0d2cgc3BlYzwvYT4uIERlZmF1bHQgaXMgXCJ0b3BcIi5cblx0XHQgKiBAcHJvcGVydHkgdGV4dEJhc2VsaW5lXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0Ki9cblx0XHR0aGlzLnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIHdpZHRoIHRvIGRyYXcgdGhlIHRleHQuIElmIG1heFdpZHRoIGlzIHNwZWNpZmllZCAobm90IG51bGwpLCB0aGUgdGV4dCB3aWxsIGJlIGNvbmRlbnNlZCBvclxuXHRcdCAqIHNocnVuayB0byBtYWtlIGl0IGZpdCBpbiB0aGlzIHdpZHRoLiBGb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gdmlldyB0aGVcblx0XHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjdGV4dC1zdHlsZXNcIj5cblx0XHQgKiB3aGF0d2cgc3BlYzwvYT4uXG5cdFx0ICogQHByb3BlcnR5IG1heFdpZHRoXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0Ki9cblx0XHR0aGlzLm1heFdpZHRoID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgZ3JlYXRlciB0aGFuIDAsIHRoZSB0ZXh0IHdpbGwgYmUgZHJhd24gYXMgYSBzdHJva2UgKG91dGxpbmUpIG9mIHRoZSBzcGVjaWZpZWQgd2lkdGguXG5cdFx0ICogQHByb3BlcnR5IG91dGxpbmVcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5vdXRsaW5lID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoZSBsaW5lIGhlaWdodCAodmVydGljYWwgZGlzdGFuY2UgYmV0d2VlbiBiYXNlbGluZXMpIGZvciBtdWx0aS1saW5lIHRleHQuIElmIG51bGwgb3IgMCxcblx0XHQgKiB0aGUgdmFsdWUgb2YgZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0IGlzIHVzZWQuXG5cdFx0ICogQHByb3BlcnR5IGxpbmVIZWlnaHRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5saW5lSGVpZ2h0ID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoZSBtYXhpbXVtIHdpZHRoIGZvciBhIGxpbmUgb2YgdGV4dCBiZWZvcmUgaXQgaXMgd3JhcHBlZCB0byBtdWx0aXBsZSBsaW5lcy4gSWYgbnVsbCxcblx0XHQgKiB0aGUgdGV4dCB3aWxsIG5vdCBiZSB3cmFwcGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBsaW5lV2lkdGhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5saW5lV2lkdGggPSBudWxsO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFRleHQsIGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cdFxuLy8gc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3dvcmtpbmdDb250ZXh0XG5cdCAqIEB0eXBlIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdHZhciBjYW52YXMgPSAoY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikpO1xuXHRpZiAoY2FudmFzLmdldENvbnRleHQpIHsgVGV4dC5fd29ya2luZ0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpOyBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTsgfVxuXHRcblx0XG4vLyBjb25zdGFudHM6XG5cdC8qKlxuXHQgKiBMb29rdXAgdGFibGUgZm9yIHRoZSByYXRpbyB0byBvZmZzZXQgYm91bmRzIHggY2FsY3VsYXRpb25zIGJhc2VkIG9uIHRoZSB0ZXh0QWxpZ24gcHJvcGVydHkuXG5cdCAqIEBwcm9wZXJ0eSBIX09GRlNFVFNcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRleHQuSF9PRkZTRVRTID0ge3N0YXJ0OiAwLCBsZWZ0OiAwLCBjZW50ZXI6IC0wLjUsIGVuZDogLTEsIHJpZ2h0OiAtMX07XG5cdFxuXHQvKipcblx0ICogTG9va3VwIHRhYmxlIGZvciB0aGUgcmF0aW8gdG8gb2Zmc2V0IGJvdW5kcyB5IGNhbGN1bGF0aW9ucyBiYXNlZCBvbiB0aGUgdGV4dEJhc2VsaW5lIHByb3BlcnR5LlxuXHQgKiBAcHJvcGVydHkgSF9PRkZTRVRTXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUZXh0LlZfT0ZGU0VUUyA9IHt0b3A6IDAsIGhhbmdpbmc6IC0wLjAxLCBtaWRkbGU6IC0wLjQsIGFscGhhYmV0aWM6IC0wLjgsIGlkZW9ncmFwaGljOiAtMC44NSwgYm90dG9tOiAtMX07XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCAodGhpcy50ZXh0ICE9IG51bGwgJiYgdGhpcy50ZXh0ICE9PSBcIlwiKTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIFRleHQgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZUNhY2hlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLlxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXG5cdCAqIGludG8gaXRzZWxmKS5cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0aWYgKHRoaXMuRGlzcGxheU9iamVjdF9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHR2YXIgY29sID0gdGhpcy5jb2xvciB8fCBcIiMwMDBcIjtcblx0XHRpZiAodGhpcy5vdXRsaW5lKSB7IGN0eC5zdHJva2VTdHlsZSA9IGNvbDsgY3R4LmxpbmVXaWR0aCA9IHRoaXMub3V0bGluZSoxOyB9XG5cdFx0ZWxzZSB7IGN0eC5maWxsU3R5bGUgPSBjb2w7IH1cblx0XHRcblx0XHR0aGlzLl9kcmF3VGV4dCh0aGlzLl9wcmVwQ29udGV4dChjdHgpKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbWVhc3VyZWQsIHVudHJhbnNmb3JtZWQgd2lkdGggb2YgdGhlIHRleHQgd2l0aG91dCB3cmFwcGluZy4gVXNlIGdldEJvdW5kcyBmb3IgYSBtb3JlIHJvYnVzdCB2YWx1ZS5cblx0ICogQG1ldGhvZCBnZXRNZWFzdXJlZFdpZHRoXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1lYXN1cmVkLCB1bnRyYW5zZm9ybWVkIHdpZHRoIG9mIHRoZSB0ZXh0LlxuXHQgKiovXG5cdHAuZ2V0TWVhc3VyZWRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRNZWFzdXJlZFdpZHRoKHRoaXMudGV4dCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXBwcm94aW1hdGUgbGluZSBoZWlnaHQgb2YgdGhlIHRleHQsIGlnbm9yaW5nIHRoZSBsaW5lSGVpZ2h0IHByb3BlcnR5LiBUaGlzIGlzIGJhc2VkIG9uIHRoZSBtZWFzdXJlZFxuXHQgKiB3aWR0aCBvZiBhIFwiTVwiIGNoYXJhY3RlciBtdWx0aXBsaWVkIGJ5IDEuMiwgd2hpY2ggcHJvdmlkZXMgYW4gYXBwcm94aW1hdGUgbGluZSBoZWlnaHQgZm9yIG1vc3QgZm9udHMuXG5cdCAqIEBtZXRob2QgZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0XG5cdCAqIEByZXR1cm4ge051bWJlcn0gYW4gYXBwcm94aW1hdGUgbGluZSBoZWlnaHQgb2YgdGhlIHRleHQsIGlnbm9yaW5nIHRoZSBsaW5lSGVpZ2h0IHByb3BlcnR5LiBUaGlzIGlzXG5cdCAqIGJhc2VkIG9uIHRoZSBtZWFzdXJlZCB3aWR0aCBvZiBhIFwiTVwiIGNoYXJhY3RlciBtdWx0aXBsaWVkIGJ5IDEuMiwgd2hpY2ggYXBwcm94aW1hdGVzIGVtIGZvciBtb3N0IGZvbnRzLlxuXHQgKiovXG5cdHAuZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE1lYXN1cmVkV2lkdGgoXCJNXCIpKjEuMjtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYXBwcm94aW1hdGUgaGVpZ2h0IG9mIG11bHRpLWxpbmUgdGV4dCBieSBtdWx0aXBseWluZyB0aGUgbnVtYmVyIG9mIGxpbmVzIGFnYWluc3QgZWl0aGVyIHRoZVxuXHQgKiA8Y29kZT5saW5lSGVpZ2h0PC9jb2RlPiAoaWYgc3BlY2lmaWVkKSBvciB7eyNjcm9zc0xpbmsgXCJUZXh0L2dldE1lYXN1cmVkTGluZUhlaWdodFwifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGF0XG5cdCAqIHRoaXMgb3BlcmF0aW9uIHJlcXVpcmVzIHRoZSB0ZXh0IGZsb3dpbmcgbG9naWMgdG8gcnVuLCB3aGljaCBoYXMgYW4gYXNzb2NpYXRlZCBDUFUgY29zdC5cblx0ICogQG1ldGhvZCBnZXRNZWFzdXJlZEhlaWdodFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhcHByb3hpbWF0ZSBoZWlnaHQgb2YgdGhlIHVudHJhbnNmb3JtZWQgbXVsdGktbGluZSB0ZXh0LlxuXHQgKiovXG5cdHAuZ2V0TWVhc3VyZWRIZWlnaHQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhd1RleHQobnVsbCx7fSkuaGVpZ2h0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEb2NjZWQgaW4gc3VwZXJjbGFzcy5cblx0ICovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSB0aGlzLkRpc3BsYXlPYmplY3RfZ2V0Qm91bmRzKCk7XG5cdFx0aWYgKHJlY3QpIHsgcmV0dXJuIHJlY3Q7IH1cblx0XHRpZiAodGhpcy50ZXh0ID09IG51bGwgfHwgdGhpcy50ZXh0ID09PSBcIlwiKSB7IHJldHVybiBudWxsOyB9XG5cdFx0dmFyIG8gPSB0aGlzLl9kcmF3VGV4dChudWxsLCB7fSk7XG5cdFx0dmFyIHcgPSAodGhpcy5tYXhXaWR0aCAmJiB0aGlzLm1heFdpZHRoIDwgby53aWR0aCkgPyB0aGlzLm1heFdpZHRoIDogby53aWR0aDtcblx0XHR2YXIgeCA9IHcgKiBUZXh0LkhfT0ZGU0VUU1t0aGlzLnRleHRBbGlnbnx8XCJsZWZ0XCJdO1xuXHRcdHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0fHx0aGlzLmdldE1lYXN1cmVkTGluZUhlaWdodCgpO1xuXHRcdHZhciB5ID0gbGluZUhlaWdodCAqIFRleHQuVl9PRkZTRVRTW3RoaXMudGV4dEJhc2VsaW5lfHxcInRvcFwiXTtcblx0XHRyZXR1cm4gdGhpcy5fcmVjdGFuZ2xlLnNldFZhbHVlcyh4LCB5LCB3LCBvLmhlaWdodCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB3aWR0aCwgaGVpZ2h0LCBhbmQgbGluZXMgcHJvcGVydGllcy4gVGhlIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHRoZSB2aXN1YWwgd2lkdGggYW5kIGhlaWdodFxuXHQgKiBvZiB0aGUgZHJhd24gdGV4dC4gVGhlIGxpbmVzIHByb3BlcnR5IGNvbnRhaW5zIGFuIGFycmF5IG9mIHN0cmluZ3MsIG9uZSBmb3Jcblx0ICogZWFjaCBsaW5lIG9mIHRleHQgdGhhdCB3aWxsIGJlIGRyYXduLCBhY2NvdW50aW5nIGZvciBsaW5lIGJyZWFrcyBhbmQgd3JhcHBpbmcuIFRoZXNlIHN0cmluZ3MgaGF2ZSB0cmFpbGluZ1xuXHQgKiB3aGl0ZXNwYWNlIHJlbW92ZWQuXG5cdCAqIEBtZXRob2QgZ2V0TWV0cmljc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHdpZHRoLCBoZWlnaHQsIGFuZCBsaW5lcyBwcm9wZXJ0aWVzLlxuXHQgKiovXG5cdHAuZ2V0TWV0cmljcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvID0ge2xpbmVzOltdfTtcblx0XHRvLmxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQgfHwgdGhpcy5nZXRNZWFzdXJlZExpbmVIZWlnaHQoKTtcblx0XHRvLnZPZmZzZXQgPSBvLmxpbmVIZWlnaHQgKiBUZXh0LlZfT0ZGU0VUU1t0aGlzLnRleHRCYXNlbGluZXx8XCJ0b3BcIl07XG5cdFx0cmV0dXJuIHRoaXMuX2RyYXdUZXh0KG51bGwsIG8sIG8ubGluZXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFRleHQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7VGV4dH0gYSBjbG9uZSBvZiB0aGUgVGV4dCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lUHJvcHMobmV3IFRleHQodGhpcy50ZXh0LCB0aGlzLmZvbnQsIHRoaXMuY29sb3IpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1RleHQgKHRleHQ9XCIrICAodGhpcy50ZXh0Lmxlbmd0aCA+IDIwID8gdGhpcy50ZXh0LnN1YnN0cigwLCAxNykrXCIuLi5cIiA6IHRoaXMudGV4dCkgK1wiKV1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jbG9uZVByb3BzXG5cdCAqIEBwYXJhbSB7VGV4dH0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge1RleHR9IG9cblx0ICoqL1xuXHRwLl9jbG9uZVByb3BzID0gZnVuY3Rpb24obykge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fY2xvbmVQcm9wcyhvKTtcblx0XHRvLnRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWduO1xuXHRcdG8udGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0QmFzZWxpbmU7XG5cdFx0by5tYXhXaWR0aCA9IHRoaXMubWF4V2lkdGg7XG5cdFx0by5vdXRsaW5lID0gdGhpcy5vdXRsaW5lO1xuXHRcdG8ubGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodDtcblx0XHRvLmxpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRXb3JraW5nQ29udGV4dFxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3ByZXBDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0Y3R4LmZvbnQgPSB0aGlzLmZvbnR8fFwiMTBweCBzYW5zLXNlcmlmXCI7XG5cdFx0Y3R4LnRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWdufHxcImxlZnRcIjtcblx0XHRjdHgudGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0QmFzZWxpbmV8fFwidG9wXCI7XG5cdFx0cmV0dXJuIGN0eDtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgbXVsdGlsaW5lIHRleHQuXG5cdCAqIEBtZXRob2QgX2RyYXdUZXh0XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHBhcmFtIHtBcnJheX0gbGluZXNcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZHJhd1RleHQgPSBmdW5jdGlvbihjdHgsIG8sIGxpbmVzKSB7XG5cdFx0dmFyIHBhaW50ID0gISFjdHg7XG5cdFx0aWYgKCFwYWludCkge1xuXHRcdFx0Y3R4ID0gVGV4dC5fd29ya2luZ0NvbnRleHQ7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0dGhpcy5fcHJlcENvbnRleHQoY3R4KTtcblx0XHR9XG5cdFx0dmFyIGxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHR8fHRoaXMuZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0KCk7XG5cdFx0XG5cdFx0dmFyIG1heFcgPSAwLCBjb3VudCA9IDA7XG5cdFx0dmFyIGhhcmRMaW5lcyA9IFN0cmluZyh0aGlzLnRleHQpLnNwbGl0KC8oPzpcXHJcXG58XFxyfFxcbikvKTtcblx0XHRmb3IgKHZhciBpPTAsIGw9aGFyZExpbmVzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciBzdHIgPSBoYXJkTGluZXNbaV07XG5cdFx0XHR2YXIgdyA9IG51bGw7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmxpbmVXaWR0aCAhPSBudWxsICYmICh3ID0gY3R4Lm1lYXN1cmVUZXh0KHN0cikud2lkdGgpID4gdGhpcy5saW5lV2lkdGgpIHtcblx0XHRcdFx0Ly8gdGV4dCB3cmFwcGluZzpcblx0XHRcdFx0dmFyIHdvcmRzID0gc3RyLnNwbGl0KC8oXFxzKS8pO1xuXHRcdFx0XHRzdHIgPSB3b3Jkc1swXTtcblx0XHRcdFx0dyA9IGN0eC5tZWFzdXJlVGV4dChzdHIpLndpZHRoO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgaj0xLCBqbD13b3Jkcy5sZW5ndGg7IGo8amw7IGorPTIpIHtcblx0XHRcdFx0XHQvLyBMaW5lIG5lZWRzIHRvIHdyYXA6XG5cdFx0XHRcdFx0dmFyIHdvcmRXID0gY3R4Lm1lYXN1cmVUZXh0KHdvcmRzW2pdICsgd29yZHNbaisxXSkud2lkdGg7XG5cdFx0XHRcdFx0aWYgKHcgKyB3b3JkVyA+IHRoaXMubGluZVdpZHRoKSB7XG5cdFx0XHRcdFx0XHRpZiAocGFpbnQpIHsgdGhpcy5fZHJhd1RleHRMaW5lKGN0eCwgc3RyLCBjb3VudCpsaW5lSGVpZ2h0KTsgfVxuXHRcdFx0XHRcdFx0aWYgKGxpbmVzKSB7IGxpbmVzLnB1c2goc3RyKTsgfVxuXHRcdFx0XHRcdFx0aWYgKHcgPiBtYXhXKSB7IG1heFcgPSB3OyB9XG5cdFx0XHRcdFx0XHRzdHIgPSB3b3Jkc1tqKzFdO1xuXHRcdFx0XHRcdFx0dyA9IGN0eC5tZWFzdXJlVGV4dChzdHIpLndpZHRoO1xuXHRcdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RyICs9IHdvcmRzW2pdICsgd29yZHNbaisxXTtcblx0XHRcdFx0XHRcdHcgKz0gd29yZFc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChwYWludCkgeyB0aGlzLl9kcmF3VGV4dExpbmUoY3R4LCBzdHIsIGNvdW50KmxpbmVIZWlnaHQpOyB9XG5cdFx0XHRpZiAobGluZXMpIHsgbGluZXMucHVzaChzdHIpOyB9XG5cdFx0XHRpZiAobyAmJiB3ID09IG51bGwpIHsgdyA9IGN0eC5tZWFzdXJlVGV4dChzdHIpLndpZHRoOyB9XG5cdFx0XHRpZiAodyA+IG1heFcpIHsgbWF4VyA9IHc7IH1cblx0XHRcdGNvdW50Kys7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChvKSB7XG5cdFx0XHRvLndpZHRoID0gbWF4Vztcblx0XHRcdG8uaGVpZ2h0ID0gY291bnQqbGluZUhlaWdodDtcblx0XHR9XG5cdFx0aWYgKCFwYWludCkgeyBjdHgucmVzdG9yZSgpOyB9XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2RyYXdUZXh0TGluZVxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9kcmF3VGV4dExpbmUgPSBmdW5jdGlvbihjdHgsIHRleHQsIHkpIHtcblx0XHQvLyBDaHJvbWUgMTcgd2lsbCBmYWlsIHRvIGRyYXcgdGhlIHRleHQgaWYgdGhlIGxhc3QgcGFyYW0gaXMgaW5jbHVkZWQgYnV0IG51bGwsIHNvIHdlIGZlZWQgaXQgYSBsYXJnZSB2YWx1ZSBpbnN0ZWFkOlxuXHRcdGlmICh0aGlzLm91dGxpbmUpIHsgY3R4LnN0cm9rZVRleHQodGV4dCwgMCwgeSwgdGhpcy5tYXhXaWR0aHx8MHhGRkZGKTsgfVxuXHRcdGVsc2UgeyBjdHguZmlsbFRleHQodGV4dCwgMCwgeSwgdGhpcy5tYXhXaWR0aHx8MHhGRkZGKTsgfVxuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRNZWFzdXJlZFdpZHRoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nZXRNZWFzdXJlZFdpZHRoID0gZnVuY3Rpb24odGV4dCkge1xuXHRcdHZhciBjdHggPSBUZXh0Ll93b3JraW5nQ29udGV4dDtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdHZhciB3ID0gdGhpcy5fcHJlcENvbnRleHQoY3R4KS5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHJldHVybiB3O1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuVGV4dCA9IGNyZWF0ZWpzLnByb21vdGUoVGV4dCwgXCJEaXNwbGF5T2JqZWN0XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEJpdG1hcFRleHQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogRGlzcGxheXMgdGV4dCB1c2luZyBiaXRtYXAgZ2x5cGhzIGRlZmluZWQgaW4gYSBzcHJpdGUgc2hlZXQuIE11bHRpLWxpbmUgdGV4dCBpcyBzdXBwb3J0ZWRcblx0ICogdXNpbmcgbmV3IGxpbmUgY2hhcmFjdGVycywgYnV0IGF1dG9tYXRpYyB3cmFwcGluZyBpcyBub3Qgc3VwcG9ydGVkLiBTZWUgdGhlIFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJCaXRtYXBUZXh0L3Nwcml0ZVNoZWV0OnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHByb3BlcnR5IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGRlZmluaW5nIGdseXBocy5cblx0ICogXG5cdCAqIDxzdHJvbmc+SW1wb3J0YW50Ojwvc3Ryb25nPiBCaXRtYXBUZXh0IGV4dGVuZHMgQ29udGFpbmVyLCBidXQgaXMgbm90IGRlc2lnbmVkIHRvIGJlIHVzZWQgYXMgb25lLlxuXHQgKiBBcyBzdWNoLCBtZXRob2RzIGxpa2UgYWRkQ2hpbGQgYW5kIHJlbW92ZUNoaWxkIGFyZSBkaXNhYmxlZC5cblx0ICogQGNsYXNzIEJpdG1hcFRleHRcblx0ICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3RleHQ9XCJcIl0gVGhlIHRleHQgdG8gZGlzcGxheS5cblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gW3Nwcml0ZVNoZWV0PW51bGxdIFRoZSBzcHJpdGVzaGVldCB0aGF0IGRlZmluZXMgdGhlIGNoYXJhY3RlciBnbHlwaHMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIEJpdG1hcFRleHQodGV4dCwgc3ByaXRlU2hlZXQpIHtcblx0XHR0aGlzLkNvbnRhaW5lcl9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgdGV4dCB0byBkaXNwbGF5LlxuXHRcdCAqIEBwcm9wZXJ0eSB0ZXh0XG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICogQGRlZmF1bHQgXCJcIlxuXHRcdCAqKi9cblx0XHR0aGlzLnRleHQgPSB0ZXh0fHxcIlwiO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEEgU3ByaXRlU2hlZXQgaW5zdGFuY2UgdGhhdCBkZWZpbmVzIHRoZSBnbHlwaHMgZm9yIHRoaXMgYml0bWFwIHRleHQuIEVhY2ggZ2x5cGgvY2hhcmFjdGVyXG5cdFx0ICogc2hvdWxkIGhhdmUgYSBzaW5nbGUgZnJhbWUgYW5pbWF0aW9uIGRlZmluZWQgaW4gdGhlIHNwcml0ZSBzaGVldCBuYW1lZCB0aGUgc2FtZSBhc1xuXHRcdCAqIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVyLiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBhbmltYXRpb24gZGVmaW5pdGlvbjpcblx0XHQgKlxuXHRcdCAqIFx0XHRcIkFcIjoge2ZyYW1lczogWzBdfVxuXHRcdCAqXG5cdFx0ICogd291bGQgaW5kaWNhdGUgdGhhdCB0aGUgZnJhbWUgYXQgaW5kZXggMCBvZiB0aGUgc3ByaXRlc2hlZXQgc2hvdWxkIGJlIGRyYXduIGZvciB0aGUgXCJBXCIgY2hhcmFjdGVyLiBUaGUgc2hvcnQgZm9ybVxuXHRcdCAqIGlzIGFsc28gYWNjZXB0YWJsZTpcblx0XHQgKiBcblx0XHQgKiBcdFx0XCJBXCI6IDBcblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBpZiBhIGNoYXJhY3RlciBpbiB0aGUgdGV4dCBpcyBub3QgZm91bmQgaW4gdGhlIHNwcml0ZSBzaGVldCwgaXQgd2lsbCBhbHNvXG5cdFx0ICogdHJ5IHRvIHVzZSB0aGUgYWx0ZXJuYXRlIGNhc2UgKHVwcGVyIG9yIGxvd2VyKS5cblx0XHQgKlxuXHRcdCAqIFNlZSBTcHJpdGVTaGVldCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBkZWZpbmluZyBzcHJpdGUgc2hlZXQgZGF0YS5cblx0XHQgKiBAcHJvcGVydHkgc3ByaXRlU2hlZXRcblx0XHQgKiBAdHlwZSBTcHJpdGVTaGVldFxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5zcHJpdGVTaGVldCA9IHNwcml0ZVNoZWV0O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgaGVpZ2h0IG9mIGVhY2ggbGluZSBvZiB0ZXh0LiBJZiAwLCB0aGVuIGl0IHdpbGwgdXNlIGEgbGluZSBoZWlnaHQgY2FsY3VsYXRlZFxuXHRcdCAqIGJ5IGNoZWNraW5nIGZvciB0aGUgaGVpZ2h0IG9mIHRoZSBcIjFcIiwgXCJUXCIsIG9yIFwiTFwiIGNoYXJhY3RlciAoaW4gdGhhdCBvcmRlcikuIElmXG5cdFx0ICogdGhvc2UgY2hhcmFjdGVycyBhcmUgbm90IGRlZmluZWQsIGl0IHdpbGwgdXNlIHRoZSBoZWlnaHQgb2YgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZVxuXHRcdCAqIHNwcml0ZSBzaGVldC5cblx0XHQgKiBAcHJvcGVydHkgbGluZUhlaWdodFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5saW5lSGVpZ2h0ID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBzcGFjaW5nIChpbiBwaXhlbHMpIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIG91dHB1dC5cblx0XHQgKiBAcHJvcGVydHkgbGV0dGVyU3BhY2luZ1xuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5sZXR0ZXJTcGFjaW5nID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgYSBzcGFjZSBjaGFyYWN0ZXIgaXMgbm90IGRlZmluZWQgaW4gdGhlIHNwcml0ZSBzaGVldCwgdGhlbiBlbXB0eSBwaXhlbHMgZXF1YWwgdG9cblx0XHQgKiBzcGFjZVdpZHRoIHdpbGwgYmUgaW5zZXJ0ZWQgaW5zdGVhZC4gSWYgMCwgdGhlbiBpdCB3aWxsIHVzZSBhIHZhbHVlIGNhbGN1bGF0ZWRcblx0XHQgKiBieSBjaGVja2luZyBmb3IgdGhlIHdpZHRoIG9mIHRoZSBcIjFcIiwgXCJsXCIsIFwiRVwiLCBvciBcIkFcIiBjaGFyYWN0ZXIgKGluIHRoYXQgb3JkZXIpLiBJZlxuXHRcdCAqIHRob3NlIGNoYXJhY3RlcnMgYXJlIG5vdCBkZWZpbmVkLCBpdCB3aWxsIHVzZSB0aGUgd2lkdGggb2YgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZVxuXHRcdCAqIHNwcml0ZSBzaGVldC5cblx0XHQgKiBAcHJvcGVydHkgc3BhY2VXaWR0aFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5zcGFjZVdpZHRoID0gMDtcblx0XHRcblx0XHRcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHQgXHQvKipcblx0XHQgKiBAcHJvcGVydHkgX29sZFByb3BzXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9vbGRQcm9wcyA9IHt0ZXh0OjAsc3ByaXRlU2hlZXQ6MCxsaW5lSGVpZ2h0OjAsbGV0dGVyU3BhY2luZzowLHNwYWNlV2lkdGg6MH07XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQml0bWFwVGV4dCwgY3JlYXRlanMuQ29udGFpbmVyKTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQml0bWFwVGV4dCB1c2VzIFNwcml0ZSBpbnN0YW5jZXMgdG8gZHJhdyB0ZXh0LiBUbyByZWR1Y2UgdGhlIGNyZWF0aW9uIGFuZCBkZXN0cnVjdGlvbiBvZiBpbnN0YW5jZXMgKGFuZCB0aHVzIGdhcmJhZ2UgY29sbGVjdGlvbiksIGl0IG1haW50YWluc1xuXHQgKiBhbiBpbnRlcm5hbCBvYmplY3QgcG9vbCBvZiBzcHJpdGUgaW5zdGFuY2VzIHRvIHJldXNlLiBJbmNyZWFzaW5nIHRoaXMgdmFsdWUgY2FuIGNhdXNlIG1vcmUgc3ByaXRlcyB0byBiZVxuXHQgKiByZXRhaW5lZCwgc2xpZ2h0bHkgaW5jcmVhc2luZyBtZW1vcnkgdXNlLCBidXQgcmVkdWNpbmcgaW5zdGFudGlhdGlvbi5cblx0ICogQHByb3BlcnR5IG1heFBvb2xTaXplXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZWZhdWx0IDEwMFxuXHQgKiovXG5cdEJpdG1hcFRleHQubWF4UG9vbFNpemUgPSAxMDA7XG5cdFxuXHQvKipcblx0ICogU3ByaXRlIG9iamVjdCBwb29sLlxuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEBzdGF0aWNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdEJpdG1hcFRleHQuX3Nwcml0ZVBvb2wgPSBbXTtcblxuXHRcbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogRG9jY2VkIGluIHN1cGVyY2xhc3MuXG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm47IH1cblx0XHR0aGlzLl91cGRhdGVUZXh0KCk7XG5cdFx0dGhpcy5Db250YWluZXJfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBEb2NjZWQgaW4gc3VwZXJjbGFzcy5cblx0ICoqL1xuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRleHQoKTtcblx0XHRyZXR1cm4gdGhpcy5Db250YWluZXJfZ2V0Qm91bmRzKCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xuXHQgKiovXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhc0NvbnRlbnQgPSB0aGlzLmNhY2hlQ2FudmFzIHx8ICh0aGlzLnNwcml0ZVNoZWV0ICYmIHRoaXMuc3ByaXRlU2hlZXQuY29tcGxldGUgJiYgdGhpcy50ZXh0KTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9PSAwICYmIHRoaXMuc2NhbGVZICE9PSAwICYmIGhhc0NvbnRlbnQpO1xuXHR9O1xuXHRcblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZVByb3BzKG5ldyBCaXRtYXBUZXh0KHRoaXMudGV4dCwgdGhpcy5zcHJpdGVTaGVldCkpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIDxzdHJvbmc+RGlzYWJsZWQgaW4gQml0bWFwVGV4dC48L3N0cm9uZz5cblx0ICogQG1ldGhvZCBhZGRDaGlsZFxuXHQgKiovXG5cdC8qKlxuXHQgKiA8c3Ryb25nPkRpc2FibGVkIGluIEJpdG1hcFRleHQuPC9zdHJvbmc+XG5cdCAqIEBtZXRob2QgYWRkQ2hpbGRBdFxuXHQgKiovXG5cdC8qKlxuXHQgKiA8c3Ryb25nPkRpc2FibGVkIGluIEJpdG1hcFRleHQuPC9zdHJvbmc+XG5cdCAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRcblx0ICoqL1xuXHQvKipcblx0ICogPHN0cm9uZz5EaXNhYmxlZCBpbiBCaXRtYXBUZXh0Ljwvc3Ryb25nPlxuXHQgKiBAbWV0aG9kIHJlbW92ZUNoaWxkQXRcblx0ICoqL1xuXHQvKipcblx0ICogPHN0cm9uZz5EaXNhYmxlZCBpbiBCaXRtYXBUZXh0Ljwvc3Ryb25nPlxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbENoaWxkcmVuXG5cdCAqKi9cblx0cC5hZGRDaGlsZCA9IHAuYWRkQ2hpbGRBdCA9IHAucmVtb3ZlQ2hpbGQgPSBwLnJlbW92ZUNoaWxkQXQgPSBwLnJlbW92ZUFsbENoaWxkcmVuID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG4gXHQvKipcblx0ICogQG1ldGhvZCBfY2xvbmVQcm9wc1xuXHQgKiBAcGFyYW0ge0JpdG1hcFRleHR9IG9cblx0ICogQHJldHVybiB7Qml0bWFwVGV4dH0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fY2xvbmVQcm9wcyA9IGZ1bmN0aW9uKG8pIHtcblx0XHR0aGlzLkNvbnRhaW5lcl9fY2xvbmVQcm9wcyhvKTtcblx0XHRvLmxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQ7XG5cdFx0by5sZXR0ZXJTcGFjaW5nID0gdGhpcy5sZXR0ZXJTcGFjaW5nO1xuXHRcdG8uc3BhY2VXaWR0aCA9IHRoaXMuc3BhY2VXaWR0aDtcblx0XHRyZXR1cm4gbztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRGcmFtZUluZGV4XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjaGFyYWN0ZXJcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3ByaXRlU2hlZXRcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0RnJhbWVJbmRleCA9IGZ1bmN0aW9uKGNoYXJhY3Rlciwgc3ByaXRlU2hlZXQpIHtcblx0XHR2YXIgYywgbyA9IHNwcml0ZVNoZWV0LmdldEFuaW1hdGlvbihjaGFyYWN0ZXIpO1xuXHRcdGlmICghbykge1xuXHRcdFx0KGNoYXJhY3RlciAhPSAoYyA9IGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpKSkgfHwgKGNoYXJhY3RlciAhPSAoYyA9IGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpKSkgfHwgKGM9bnVsbCk7XG5cdFx0XHRpZiAoYykgeyBvID0gc3ByaXRlU2hlZXQuZ2V0QW5pbWF0aW9uKGMpOyB9XG5cdFx0fVxuXHRcdHJldHVybiBvICYmIG8uZnJhbWVzWzBdO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldEZyYW1lXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjaGFyYWN0ZXJcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3ByaXRlU2hlZXRcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0RnJhbWUgPSBmdW5jdGlvbihjaGFyYWN0ZXIsIHNwcml0ZVNoZWV0KSB7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fZ2V0RnJhbWVJbmRleChjaGFyYWN0ZXIsIHNwcml0ZVNoZWV0KTtcblx0XHRyZXR1cm4gaW5kZXggPT0gbnVsbCA/IGluZGV4IDogc3ByaXRlU2hlZXQuZ2V0RnJhbWUoaW5kZXgpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldExpbmVIZWlnaHRcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3Ncblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0TGluZUhlaWdodCA9IGZ1bmN0aW9uKHNzKSB7XG5cdFx0dmFyIGZyYW1lID0gdGhpcy5fZ2V0RnJhbWUoXCIxXCIsc3MpIHx8IHRoaXMuX2dldEZyYW1lKFwiVFwiLHNzKSB8fCB0aGlzLl9nZXRGcmFtZShcIkxcIixzcykgfHwgc3MuZ2V0RnJhbWUoMCk7XG5cdFx0cmV0dXJuIGZyYW1lID8gZnJhbWUucmVjdC5oZWlnaHQgOiAxO1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0U3BhY2VXaWR0aFxuXHQgKiBAcGFyYW0ge1Nwcml0ZVNoZWV0fSBzc1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nZXRTcGFjZVdpZHRoID0gZnVuY3Rpb24oc3MpIHtcblx0XHR2YXIgZnJhbWUgPSB0aGlzLl9nZXRGcmFtZShcIjFcIixzcykgfHwgdGhpcy5fZ2V0RnJhbWUoXCJsXCIsc3MpIHx8IHRoaXMuX2dldEZyYW1lKFwiZVwiLHNzKSB8fCB0aGlzLl9nZXRGcmFtZShcImFcIixzcykgfHwgc3MuZ2V0RnJhbWUoMCk7XG5cdFx0cmV0dXJuIGZyYW1lID8gZnJhbWUucmVjdC53aWR0aCA6IDE7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZHJhd1RleHRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3VwZGF0ZVRleHQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgeD0wLCB5PTAsIG89dGhpcy5fb2xkUHJvcHMsIGNoYW5nZT1mYWxzZSwgc3BhY2VXPXRoaXMuc3BhY2VXaWR0aCwgbGluZUg9dGhpcy5saW5lSGVpZ2h0LCBzcz10aGlzLnNwcml0ZVNoZWV0O1xuXHRcdHZhciBwb29sPUJpdG1hcFRleHQuX3Nwcml0ZVBvb2wsIGtpZHM9dGhpcy5jaGlsZHJlbiwgY2hpbGRJbmRleD0wLCBudW1LaWRzPWtpZHMubGVuZ3RoLCBzcHJpdGU7XG5cdFx0XG5cdFx0Zm9yICh2YXIgbiBpbiBvKSB7XG5cdFx0XHRpZiAob1tuXSAhPSB0aGlzW25dKSB7XG5cdFx0XHRcdG9bbl0gPSB0aGlzW25dO1xuXHRcdFx0XHRjaGFuZ2UgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIWNoYW5nZSkgeyByZXR1cm47IH1cblx0XHRcblx0XHR2YXIgaGFzU3BhY2UgPSAhIXRoaXMuX2dldEZyYW1lKFwiIFwiLCBzcyk7XG5cdFx0aWYgKCFoYXNTcGFjZSAmJiAhc3BhY2VXKSB7IHNwYWNlVyA9IHRoaXMuX2dldFNwYWNlV2lkdGgoc3MpOyB9XG5cdFx0aWYgKCFsaW5lSCkgeyBsaW5lSCA9IHRoaXMuX2dldExpbmVIZWlnaHQoc3MpOyB9XG5cdFx0XG5cdFx0Zm9yKHZhciBpPTAsIGw9dGhpcy50ZXh0Lmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciBjaGFyYWN0ZXIgPSB0aGlzLnRleHQuY2hhckF0KGkpO1xuXHRcdFx0aWYgKGNoYXJhY3RlciA9PSBcIiBcIiAmJiAhaGFzU3BhY2UpIHtcblx0XHRcdFx0eCArPSBzcGFjZVc7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChjaGFyYWN0ZXI9PVwiXFxuXCIgfHwgY2hhcmFjdGVyPT1cIlxcclwiKSB7XG5cdFx0XHRcdGlmIChjaGFyYWN0ZXI9PVwiXFxyXCIgJiYgdGhpcy50ZXh0LmNoYXJBdChpKzEpID09IFwiXFxuXCIpIHsgaSsrOyB9IC8vIGNybGZcblx0XHRcdFx0eCA9IDA7XG5cdFx0XHRcdHkgKz0gbGluZUg7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaW5kZXggPSB0aGlzLl9nZXRGcmFtZUluZGV4KGNoYXJhY3Rlciwgc3MpO1xuXHRcdFx0aWYgKGluZGV4ID09IG51bGwpIHsgY29udGludWU7IH1cblx0XHRcdFxuXHRcdFx0aWYgKGNoaWxkSW5kZXggPCBudW1LaWRzKSB7XG5cdFx0XHRcdHNwcml0ZSA9IGtpZHNbY2hpbGRJbmRleF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRraWRzLnB1c2goc3ByaXRlID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IGNyZWF0ZWpzLlNwcml0ZSgpKTtcblx0XHRcdFx0c3ByaXRlLnBhcmVudCA9IHRoaXM7XG5cdFx0XHRcdG51bUtpZHMrKztcblx0XHRcdH1cblx0XHRcdHNwcml0ZS5zcHJpdGVTaGVldCA9IHNzO1xuXHRcdFx0c3ByaXRlLmdvdG9BbmRTdG9wKGluZGV4KTtcblx0XHRcdHNwcml0ZS54ID0geDtcblx0XHRcdHNwcml0ZS55ID0geTtcblx0XHRcdGNoaWxkSW5kZXgrKztcblx0XHRcdFxuXHRcdFx0eCArPSBzcHJpdGUuZ2V0Qm91bmRzKCkud2lkdGggKyB0aGlzLmxldHRlclNwYWNpbmc7XG5cdFx0fVxuXHRcdHdoaWxlIChudW1LaWRzID4gY2hpbGRJbmRleCkge1xuXHRcdFx0IC8vIGZhc3RlciB0aGFuIHJlbW92ZUNoaWxkLlxuXHRcdFx0cG9vbC5wdXNoKHNwcml0ZSA9IGtpZHMucG9wKCkpO1xuXHRcdFx0c3ByaXRlLnBhcmVudCA9IG51bGw7XG5cdFx0XHRudW1LaWRzLS07XG5cdFx0fVxuXHRcdGlmIChwb29sLmxlbmd0aCA+IEJpdG1hcFRleHQubWF4UG9vbFNpemUpIHsgcG9vbC5sZW5ndGggPSBCaXRtYXBUZXh0Lm1heFBvb2xTaXplOyB9XG5cdH07XG5cblxuXHRjcmVhdGVqcy5CaXRtYXBUZXh0ID0gY3JlYXRlanMucHJvbW90ZShCaXRtYXBUZXh0LCBcIkNvbnRhaW5lclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNb3ZpZUNsaXAuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGUgTW92aWVDbGlwIGNsYXNzIGFzc29jaWF0ZXMgYSBUd2VlbkpTIFRpbWVsaW5lIHdpdGggYW4gRWFzZWxKUyB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0uIEl0IGFsbG93c1xuXHQgKiB5b3UgdG8gY3JlYXRlIG9iamVjdHMgd2hpY2ggZW5jYXBzdWxhdGUgdGltZWxpbmUgYW5pbWF0aW9ucywgc3RhdGUgY2hhbmdlcywgYW5kIHN5bmNoZWQgYWN0aW9ucy4gRHVlIHRvIHRoZVxuXHQgKiBjb21wbGV4aXRpZXMgaW5oZXJlbnQgaW4gY29ycmVjdGx5IHNldHRpbmcgdXAgYSBNb3ZpZUNsaXAsIGl0IGlzIGxhcmdlbHkgaW50ZW5kZWQgZm9yIHRvb2wgb3V0cHV0IGFuZCBpcyBub3QgaW5jbHVkZWRcblx0ICogaW4gdGhlIG1haW4gRWFzZWxKUyBsaWJyYXJ5LlxuXHQgKlxuXHQgKiBDdXJyZW50bHkgTW92aWVDbGlwIG9ubHkgd29ya3MgcHJvcGVybHkgaWYgaXQgaXMgdGljayBiYXNlZCAoYXMgb3Bwb3NlZCB0byB0aW1lIGJhc2VkKSB0aG91Z2ggc29tZSBjb25jZXNzaW9ucyBoYXZlXG5cdCAqIGJlZW4gbWFkZSB0byBzdXBwb3J0IHRpbWUtYmFzZWQgdGltZWxpbmVzIGluIHRoZSBmdXR1cmUuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGFuaW1hdGVzIHR3byBzaGFwZXMgYmFjayBhbmQgZm9ydGguIFRoZSBncmV5IHNoYXBlIHN0YXJ0cyBvbiB0aGUgbGVmdCwgYnV0IHdlIGp1bXAgdG8gYSBtaWQtcG9pbnQgaW5cblx0ICogdGhlIGFuaW1hdGlvbiB1c2luZyB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqICAgICAgdmFyIHN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKFwiY2FudmFzXCIpO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBzdGFnZSk7XG5cdCAqXG5cdCAqICAgICAgdmFyIG1jID0gbmV3IGNyZWF0ZWpzLk1vdmllQ2xpcChudWxsLCAwLCB0cnVlLCB7c3RhcnQ6MjB9KTtcblx0ICogICAgICBzdGFnZS5hZGRDaGlsZChtYyk7XG5cdCAqXG5cdCAqICAgICAgdmFyIGNoaWxkMSA9IG5ldyBjcmVhdGVqcy5TaGFwZShcblx0ICogICAgICAgICAgbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCkuYmVnaW5GaWxsKFwiIzk5OTk5OVwiKVxuXHQgKiAgICAgICAgICAgICAgLmRyYXdDaXJjbGUoMzAsMzAsMzApKTtcblx0ICogICAgICB2YXIgY2hpbGQyID0gbmV3IGNyZWF0ZWpzLlNoYXBlKFxuXHQgKiAgICAgICAgICBuZXcgY3JlYXRlanMuR3JhcGhpY3MoKS5iZWdpbkZpbGwoXCIjNWE5Y2ZiXCIpXG5cdCAqICAgICAgICAgICAgICAuZHJhd0NpcmNsZSgzMCwzMCwzMCkpO1xuXHQgKlxuXHQgKiAgICAgIG1jLnRpbWVsaW5lLmFkZFR3ZWVuKFxuXHQgKiAgICAgICAgICBjcmVhdGVqcy5Ud2Vlbi5nZXQoY2hpbGQxKVxuXHQgKiAgICAgICAgICAgICAgLnRvKHt4OjB9KS50byh7eDo2MH0sIDUwKS50byh7eDowfSwgNTApKTtcblx0ICogICAgICBtYy50aW1lbGluZS5hZGRUd2Vlbihcblx0ICogICAgICAgICAgY3JlYXRlanMuVHdlZW4uZ2V0KGNoaWxkMilcblx0ICogICAgICAgICAgICAgIC50byh7eDo2MH0pLnRvKHt4OjB9LCA1MCkudG8oe3g6NjB9LCA1MCkpO1xuXHQgKlxuXHQgKiAgICAgIG1jLmdvdG9BbmRQbGF5KFwic3RhcnRcIik7XG5cdCAqXG5cdCAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSA8Y29kZT50d2Vlbi50bygpPC9jb2RlPiB0byBhbmltYXRlIGFuZCBzZXQgcHJvcGVydGllcyAodXNlIG5vIGR1cmF0aW9uIHRvIGhhdmUgaXQgc2V0XG5cdCAqIGltbWVkaWF0ZWx5KSwgYW5kIHRoZSA8Y29kZT50d2Vlbi53YWl0KCk8L2NvZGU+IG1ldGhvZCB0byBjcmVhdGUgZGVsYXlzIGJldHdlZW4gYW5pbWF0aW9ucy4gTm90ZSB0aGF0IHVzaW5nIHRoZVxuXHQgKiA8Y29kZT50d2Vlbi5zZXQoKTwvY29kZT4gbWV0aG9kIHRvIGFmZmVjdCBwcm9wZXJ0aWVzIHdpbGwgbGlrZWx5IG5vdCBwcm92aWRlIHRoZSBkZXNpcmVkIHJlc3VsdC5cblx0ICpcblx0ICogQGNsYXNzIE1vdmllQ2xpcFxuXHQgKiBAbWFpbiBNb3ZpZUNsaXBcblx0ICogQGV4dGVuZHMgQ29udGFpbmVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW21vZGU9aW5kZXBlbmRlbnRdIEluaXRpYWwgdmFsdWUgZm9yIHRoZSBtb2RlIHByb3BlcnR5LiBPbmUgb2Yge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL0lOREVQRU5ERU5UOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvU0lOR0xFX0ZSQU1FOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LCBvciB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvU1lOQ0hFRDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogVGhlIGRlZmF1bHQgaXMge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL0lOREVQRU5ERU5UOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0UG9zaXRpb249MF0gSW5pdGlhbCB2YWx1ZSBmb3IgdGhlIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcC9zdGFydFBvc2l0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHByb3BlcnR5LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb29wPXRydWVdIEluaXRpYWwgdmFsdWUgZm9yIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvbG9vcDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eS4gVGhlIGRlZmF1bHQgaXMgYHRydWVgLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2xhYmVscz1udWxsXSBBIGhhc2ggb2YgbGFiZWxzIHRvIHBhc3MgdG8gdGhlIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcC90aW1lbGluZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBNb3ZpZUNsaXAuIExhYmVscyBvbmx5IG5lZWQgdG8gYmUgcGFzc2VkIGlmIHRoZXkgbmVlZCB0byBiZSB1c2VkLlxuXHQgKiovXG5cdGZ1bmN0aW9uIE1vdmllQ2xpcChtb2RlLCBzdGFydFBvc2l0aW9uLCBsb29wLCBsYWJlbHMpIHtcblx0XHR0aGlzLkNvbnRhaW5lcl9jb25zdHJ1Y3RvcigpO1xuXHRcdCFNb3ZpZUNsaXAuaW5pdGVkJiZNb3ZpZUNsaXAuaW5pdCgpOyAvLyBzdGF0aWMgaW5pdFxuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBDb250cm9scyBob3cgdGhpcyBNb3ZpZUNsaXAgYWR2YW5jZXMgaXRzIHRpbWUuIE11c3QgYmUgb25lIG9mIDAgKElOREVQRU5ERU5UKSwgMSAoU0lOR0xFX0ZSQU1FKSwgb3IgMiAoU1lOQ0hFRCkuXG5cdFx0ICogU2VlIGVhY2ggY29uc3RhbnQgZm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIGJlaGF2aW91ci5cblx0XHQgKiBAcHJvcGVydHkgbW9kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5tb2RlID0gbW9kZXx8TW92aWVDbGlwLklOREVQRU5ERU5UO1xuXHRcblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgd2hhdCB0aGUgZmlyc3QgZnJhbWUgdG8gcGxheSBpbiB0aGlzIG1vdmllY2xpcCwgb3IgdGhlIG9ubHkgZnJhbWUgdG8gZGlzcGxheSBpZiBtb2RlIGlzIFNJTkdMRV9GUkFNRS5cblx0XHQgKiBAcHJvcGVydHkgc3RhcnRQb3NpdGlvblxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uIHx8IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgTW92aWVDbGlwIHNob3VsZCBsb29wIHdoZW4gaXQgcmVhY2hlcyB0aGUgZW5kIG9mIGl0cyB0aW1lbGluZS5cblx0XHQgKiBAcHJvcGVydHkgbG9vcFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5sb29wID0gbG9vcDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgZnJhbWUgb2YgdGhlIG1vdmllY2xpcC5cblx0XHQgKiBAcHJvcGVydHkgY3VycmVudEZyYW1lXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMuY3VycmVudEZyYW1lID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIFR3ZWVuSlMgVGltZWxpbmUgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBNb3ZpZUNsaXAuIFRoaXMgaXMgY3JlYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIE1vdmllQ2xpcFxuXHRcdCAqIGluc3RhbmNlIGlzIGluaXRpYWxpemVkLiBBbmltYXRpb25zIGFyZSBjcmVhdGVkIGJ5IGFkZGluZyA8YSBocmVmPVwiaHR0cDovL3R3ZWVuanMuY29tXCI+VHdlZW5KUzwvYT4gVHdlZW5cblx0XHQgKiBpbnN0YW5jZXMgdG8gdGhlIHRpbWVsaW5lLlxuXHRcdCAqXG5cdFx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHRcdCAqXG5cdFx0ICogICAgICB2YXIgdHdlZW4gPSBjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0KS50byh7eDowfSkudG8oe3g6MTAwfSwgMzApO1xuXHRcdCAqICAgICAgdmFyIG1jID0gbmV3IGNyZWF0ZWpzLk1vdmllQ2xpcCgpO1xuXHRcdCAqICAgICAgbWMudGltZWxpbmUuYWRkVHdlZW4odHdlZW4pO1xuXHRcdCAqXG5cdFx0ICogRWxlbWVudHMgY2FuIGJlIGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIHRpbWVsaW5lIGJ5IHRvZ2dsaW5nIGFuIFwiX29mZlwiIHByb3BlcnR5XG5cdFx0ICogdXNpbmcgdGhlIDxjb2RlPnR3ZWVuSW5zdGFuY2UudG8oKTwvY29kZT4gbWV0aG9kLiBOb3RlIHRoYXQgdXNpbmcgPGNvZGU+VHdlZW4uc2V0PC9jb2RlPiBpcyBub3QgcmVjb21tZW5kZWQgdG9cblx0XHQgKiBjcmVhdGUgTW92aWVDbGlwIGFuaW1hdGlvbnMuIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSB3aWxsIHRvZ2dsZSB0aGUgdGFyZ2V0IG9mZiBvbiBmcmFtZSAwLCBhbmQgdGhlbiBiYWNrIG9uIGZvclxuXHRcdCAqIGZyYW1lIDEuIFlvdSBjYW4gdXNlIHRoZSBcInZpc2libGVcIiBwcm9wZXJ0eSB0byBhY2hpZXZlIHRoZSBzYW1lIGVmZmVjdC5cblx0XHQgKlxuXHRcdCAqICAgICAgdmFyIHR3ZWVuID0gY3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCkudG8oe19vZmY6ZmFsc2V9KVxuXHRcdCAqICAgICAgICAgIC53YWl0KDEpLnRvKHtfb2ZmOnRydWV9KVxuXHRcdCAqICAgICAgICAgIC53YWl0KDEpLnRvKHtfb2ZmOmZhbHNlfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgdGltZWxpbmVcblx0XHQgKiBAdHlwZSBUaW1lbGluZVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnRpbWVsaW5lID0gbmV3IGNyZWF0ZWpzLlRpbWVsaW5lKG51bGwsIGxhYmVscywge3BhdXNlZDp0cnVlLCBwb3NpdGlvbjpzdGFydFBvc2l0aW9uLCB1c2VUaWNrczp0cnVlfSk7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIHRoZSBNb3ZpZUNsaXAncyBwb3NpdGlvbiB3aWxsIG5vdCBhZHZhbmNlIHdoZW4gdGlja2VkLlxuXHRcdCAqIEBwcm9wZXJ0eSBwYXVzZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJZiB0cnVlLCBhY3Rpb25zIGluIHRoaXMgTW92aWVDbGlwJ3MgdHdlZW5zIHdpbGwgYmUgcnVuIHdoZW4gdGhlIHBsYXloZWFkIGFkdmFuY2VzLlxuXHRcdCAqIEBwcm9wZXJ0eSBhY3Rpb25zRW5hYmxlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5hY3Rpb25zRW5hYmxlZCA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIHRoZSBNb3ZpZUNsaXAgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHJlc2V0IHRvIGl0cyBmaXJzdCBmcmFtZSB3aGVuZXZlciB0aGUgdGltZWxpbmUgYWRkc1xuXHRcdCAqIGl0IGJhY2sgb250byB0aGUgZGlzcGxheSBsaXN0LiBUaGlzIG9ubHkgYXBwbGllcyB0byBNb3ZpZUNsaXAgaW5zdGFuY2VzIHdpdGggbW9kZT1JTkRFUEVOREVOVC5cblx0XHQgKiA8YnI+PGJyPlxuXHRcdCAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGFkIGEgY2hhcmFjdGVyIGFuaW1hdGlvbiB3aXRoIGEgXCJib2R5XCIgY2hpbGQgTW92aWVDbGlwIGluc3RhbmNlXG5cdFx0ICogd2l0aCBkaWZmZXJlbnQgY29zdHVtZXMgb24gZWFjaCBmcmFtZSwgeW91IGNvdWxkIHNldCBib2R5LmF1dG9SZXNldCA9IGZhbHNlLCBzbyB0aGF0XG5cdFx0ICogeW91IGNhbiBtYW51YWxseSBjaGFuZ2UgdGhlIGZyYW1lIGl0IGlzIG9uLCB3aXRob3V0IHdvcnJ5aW5nIHRoYXQgaXQgd2lsbCBiZSByZXNldFxuXHRcdCAqIGF1dG9tYXRpY2FsbHkuXG5cdFx0ICogQHByb3BlcnR5IGF1dG9SZXNldFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5hdXRvUmVzZXQgPSB0cnVlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIGJvdW5kcyBmb3IgZWFjaCBmcmFtZSBpbiB0aGUgTW92aWVDbGlwLiBUaGlzIGlzIG1haW5seSBpbnRlbmRlZCBmb3IgdG9vbCBvdXRwdXQuXG5cdFx0ICogQHByb3BlcnR5IGZyYW1lQm91bmRzXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5mcmFtZUJvdW5kcyA9IHRoaXMuZnJhbWVCb3VuZHN8fG51bGw7IC8vIFRPRE86IERlcHJlY2F0ZWQuIFRoaXMgaXMgZm9yIGJhY2t3YXJkcyBzdXBwb3J0IG9mIEZsYXNoQ0Ncblx0XHRcblx0XHQvKipcblx0XHQgKiBCeSBkZWZhdWx0IE1vdmllQ2xpcCBpbnN0YW5jZXMgYWR2YW5jZSBvbmUgZnJhbWUgcGVyIHRpY2suIFNwZWNpZnlpbmcgYSBmcmFtZXJhdGUgZm9yIHRoZSBNb3ZpZUNsaXBcblx0XHQgKiB3aWxsIGNhdXNlIGl0IHRvIGFkdmFuY2UgYmFzZWQgb24gZWxhcHNlZCB0aW1lIGJldHdlZW4gdGlja3MgYXMgYXBwcm9wcmlhdGUgdG8gbWFpbnRhaW4gdGhlIHRhcmdldFxuXHRcdCAqIGZyYW1lcmF0ZS5cblx0XHQgKlxuXHRcdCAqIEZvciBleGFtcGxlLCBpZiBhIE1vdmllQ2xpcCB3aXRoIGEgZnJhbWVyYXRlIG9mIDEwIGlzIHBsYWNlZCBvbiBhIFN0YWdlIGJlaW5nIHVwZGF0ZWQgYXQgNDBmcHMsIHRoZW4gdGhlIE1vdmllQ2xpcCB3aWxsXG5cdFx0ICogYWR2YW5jZSByb3VnaGx5IG9uZSBmcmFtZSBldmVyeSA0IHRpY2tzLiBUaGlzIHdpbGwgbm90IGJlIGV4YWN0LCBiZWNhdXNlIHRoZSB0aW1lIGJldHdlZW4gZWFjaCB0aWNrIHdpbGxcblx0XHQgKiB2YXJ5IHNsaWdodGx5IGJldHdlZW4gZnJhbWVzLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBmZWF0dXJlIGlzIGRlcGVuZGVudCBvbiB0aGUgdGljayBldmVudCBvYmplY3QgKG9yIGFuIG9iamVjdCB3aXRoIGFuIGFwcHJvcHJpYXRlIFwiZGVsdGFcIiBwcm9wZXJ0eSkgYmVpbmdcblx0XHQgKiBwYXNzZWQgaW50byB7eyNjcm9zc0xpbmsgXCJTdGFnZS91cGRhdGVcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IGZyYW1lcmF0ZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLmZyYW1lcmF0ZSA9IG51bGw7XG5cdFx0XG5cdFx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3N5bmNoT2Zmc2V0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fc3luY2hPZmZzZXQgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3ByZXZQb3Ncblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAtMVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcHJldlBvcyA9IC0xOyAvLyBUT0RPOiBldmFsdWF0ZSB1c2luZyBhIC5fcmVzZXQgQm9vbGVhbiBwcm9wIGluc3RlYWQgb2YgLTEuXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJldlBvc2l0aW9uXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcHJldlBvc2l0aW9uID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHRpbWUgcmVtYWluaW5nIGZyb20gdGhlIHByZXZpb3VzIHRpY2ssIG9ubHkgYXBwbGljYWJsZSB3aGVuIC5mcmFtZXJhdGUgaXMgc2V0LlxuXHRcdCAqIEBwcm9wZXJ0eSBfdFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fdCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIExpc3Qgb2YgZGlzcGxheSBvYmplY3RzIHRoYXQgYXJlIGFjdGl2ZWx5IGJlaW5nIG1hbmFnZWQgYnkgdGhlIE1vdmllQ2xpcC5cblx0XHQgKiBAcHJvcGVydHkgX21hbmFnZWRcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX21hbmFnZWQgPSB7fTtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChNb3ZpZUNsaXAsIGNyZWF0ZWpzLkNvbnRhaW5lcik7XG5cblxuLy8gY29uc3RhbnRzOlxuXHQvKipcblx0ICogVGhlIE1vdmllQ2xpcCB3aWxsIGFkdmFuY2UgaW5kZXBlbmRlbnRseSBvZiBpdHMgcGFyZW50LCBldmVuIGlmIGl0cyBwYXJlbnQgaXMgcGF1c2VkLlxuXHQgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IG1vZGUuXG5cdCAqIEBwcm9wZXJ0eSBJTkRFUEVOREVOVFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAZGVmYXVsdCBcImluZGVwZW5kZW50XCJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0TW92aWVDbGlwLklOREVQRU5ERU5UID0gXCJpbmRlcGVuZGVudFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgTW92aWVDbGlwIHdpbGwgb25seSBkaXNwbGF5IGEgc2luZ2xlIGZyYW1lIChhcyBkZXRlcm1pbmVkIGJ5IHRoZSBzdGFydFBvc2l0aW9uIHByb3BlcnR5KS5cblx0ICogQHByb3BlcnR5IFNJTkdMRV9GUkFNRVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAZGVmYXVsdCBcInNpbmdsZVwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdE1vdmllQ2xpcC5TSU5HTEVfRlJBTUUgPSBcInNpbmdsZVwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgTW92aWVDbGlwIHdpbGwgYmUgYWR2YW5jZWQgb25seSB3aGVuIGl0cyBwYXJlbnQgYWR2YW5jZXMgYW5kIHdpbGwgYmUgc3luY2hlZCB0byB0aGUgcG9zaXRpb24gb2Zcblx0ICogdGhlIHBhcmVudCBNb3ZpZUNsaXAuXG5cdCAqIEBwcm9wZXJ0eSBTWU5DSEVEXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBkZWZhdWx0IFwic3luY2hlZFwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdE1vdmllQ2xpcC5TWU5DSEVEID0gXCJzeW5jaGVkXCI7XG5cdFxuXHRcbi8vIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHRNb3ZpZUNsaXAuaW5pdGVkID0gZmFsc2U7XG5cdFxuXHRcbi8vIHN0YXRpYyBtZXRob2RzOlxuXHRNb3ZpZUNsaXAuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChNb3ZpZUNsaXAuaW5pdGVkKSB7IHJldHVybjsgfVxuXHRcdC8vIHBsdWdpbnMgaW50cm9kdWNlIHNvbWUgb3ZlcmhlYWQgdG8gVHdlZW4sIHNvIHdlIG9ubHkgaW5zdGFsbCB0aGlzIGlmIGFuIE1DIGlzIGluc3RhbnRpYXRlZC5cblx0XHRNb3ZpZUNsaXBQbHVnaW4uaW5zdGFsbCgpO1xuXHRcdE1vdmllQ2xpcC5pbml0ZWQgPSB0cnVlO1xuXHR9O1xuXHRcblx0XG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvbGFiZWxzOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0TGFiZWxzXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdHAuZ2V0TGFiZWxzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudGltZWxpbmUuZ2V0TGFiZWxzKCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvY3VycmVudExhYmVsOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0Q3VycmVudExhYmVsXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLmdldEN1cnJlbnRMYWJlbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRpbWVsaW5lKCk7XG5cdFx0cmV0dXJuIHRoaXMudGltZWxpbmUuZ2V0Q3VycmVudExhYmVsKCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvZHVyYXRpb246cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXREdXJhdGlvblxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmdldER1cmF0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudGltZWxpbmUuZHVyYXRpb247XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGxhYmVsIGFuZCBwb3NpdGlvbiAoYWthIGZyYW1lKSBwcm9wZXJ0aWVzLCBzb3J0ZWQgYnkgcG9zaXRpb24uXG5cdCAqIFNob3J0Y3V0IHRvIFR3ZWVuSlM6IFRpbWVsaW5lLmdldExhYmVscygpO1xuXHQgKiBAcHJvcGVydHkgbGFiZWxzXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBsYWJlbCBvbiBvciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGN1cnJlbnQgZnJhbWUuIFNlZSBUd2VlbkpTOiBUaW1lbGluZS5nZXRDdXJyZW50TGFiZWwoKVxuXHQgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQHByb3BlcnR5IGN1cnJlbnRMYWJlbFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGR1cmF0aW9uIG9mIHRoaXMgTW92aWVDbGlwIGluIHNlY29uZHMgb3IgdGlja3MuIElkZW50aWNhbCB0byB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvZHVyYXRpb246cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYW5kIHByb3ZpZGVkIGZvciBGbGFzaCBBUEkgY29tcGF0aWJpbGl0eS5cblx0ICogQHByb3BlcnR5IHRvdGFsRnJhbWVzXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZHVyYXRpb24gb2YgdGhpcyBNb3ZpZUNsaXAgaW4gc2Vjb25kcyBvciB0aWNrcy5cblx0ICogQHByb3BlcnR5IGR1cmF0aW9uXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXHRcdFx0bGFiZWxzOiB7IGdldDogcC5nZXRMYWJlbHMgfSxcblx0XHRcdGN1cnJlbnRMYWJlbDogeyBnZXQ6IHAuZ2V0Q3VycmVudExhYmVsIH0sXG5cdFx0XHR0b3RhbEZyYW1lczogeyBnZXQ6IHAuZ2V0RHVyYXRpb24gfSxcblx0XHRcdGR1cmF0aW9uOiB7IGdldDogcC5nZXREdXJhdGlvbiB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RvciBhbGlhcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMuXG5cdCAqIFN1YmNsYXNzZXMgc2hvdWxkIGJlIHVwZGF0ZWQgdG8gdXNlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRzXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIGBjcmVhdGVqcy5wcm9tb3RlKClgXG5cdCAqKi9cblx0cC5pbml0aWFsaXplID0gTW92aWVDbGlwOyAvLyBUT0RPOiBEZXByZWNhdGVkLiBUaGlzIGlzIGZvciBiYWNrd2FyZHMgc3VwcG9ydCBvZiBGbGFzaENDXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIGNoaWxkcmVuIGFyZSBwbGFjZWQgaW4gZHJhdywgc28gd2UgY2FuJ3QgZGV0ZXJtaW5lIGlmIHdlIGhhdmUgY29udGVudC5cblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlQ2FjaGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuXG5cdCAqIEZvciBleGFtcGxlLCB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2tcblx0ICogaW50byBpdHNlbGYpLlxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHQvLyBkcmF3IHRvIGNhY2hlIGZpcnN0OlxuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHRoaXMuX3VwZGF0ZVRpbWVsaW5lKCk7XG5cdFx0dGhpcy5Db250YWluZXJfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTZXRzIHBhdXNlZCB0byBmYWxzZS5cblx0ICogQG1ldGhvZCBwbGF5XG5cdCAqKi9cblx0cC5wbGF5ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTZXRzIHBhdXNlZCB0byB0cnVlLlxuXHQgKiBAbWV0aG9kIHN0b3Bcblx0ICoqL1xuXHRwLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnBhdXNlZCA9IHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhpcyBtb3ZpZSBjbGlwIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gb3IgbGFiZWwgYW5kIHNldHMgcGF1c2VkIHRvIGZhbHNlLlxuXHQgKiBAbWV0aG9kIGdvdG9BbmRQbGF5XG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gcG9zaXRpb25PckxhYmVsIFRoZSBhbmltYXRpb24gbmFtZSBvciBmcmFtZSBudW1iZXIgdG8gZ28gdG8uXG5cdCAqKi9cblx0cC5nb3RvQW5kUGxheSA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fZ290byhwb3NpdGlvbk9yTGFiZWwpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoaXMgbW92aWUgY2xpcCB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIG9yIGxhYmVsIGFuZCBzZXRzIHBhdXNlZCB0byB0cnVlLlxuXHQgKiBAbWV0aG9kIGdvdG9BbmRTdG9wXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gcG9zaXRpb25PckxhYmVsIFRoZSBhbmltYXRpb24gb3IgZnJhbWUgbmFtZSB0byBnbyB0by5cblx0ICoqL1xuXHRwLmdvdG9BbmRTdG9wID0gZnVuY3Rpb24ocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX2dvdG8ocG9zaXRpb25PckxhYmVsKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGUgcGxheWhlYWQuIFRoaXMgb2NjdXJzIGF1dG9tYXRpY2FsbHkgZWFjaCB0aWNrIGJ5IGRlZmF1bHQuXG5cdCAqIEBwYXJhbSBbdGltZV0ge051bWJlcn0gVGhlIGFtb3VudCBvZiB0aW1lIGluIG1zIHRvIGFkdmFuY2UgYnkuIE9ubHkgYXBwbGljYWJsZSBpZiBmcmFtZXJhdGUgaXMgc2V0LlxuXHQgKiBAbWV0aG9kIGFkdmFuY2Vcblx0Ki9cblx0cC5hZHZhbmNlID0gZnVuY3Rpb24odGltZSkge1xuXHRcdC8vIFRPRE86IHNob3VsZCB3ZSB3b3JyeSBhdCBhbGwgYWJvdXQgY2xpcHMgd2hvIGNoYW5nZSB0aGVpciBvd24gbW9kZXMgdmlhIGZyYW1lIHNjcmlwdHM/XG5cdFx0dmFyIGluZGVwZW5kZW50ID0gTW92aWVDbGlwLklOREVQRU5ERU5UO1xuXHRcdGlmICh0aGlzLm1vZGUgIT0gaW5kZXBlbmRlbnQpIHsgcmV0dXJuOyB9XG5cdFx0XG5cdFx0dmFyIG89dGhpcywgZnBzID0gby5mcmFtZXJhdGU7XG5cdFx0d2hpbGUgKChvID0gby5wYXJlbnQpICYmIGZwcyA9PSBudWxsKSB7XG5cdFx0XHRpZiAoby5tb2RlID09IGluZGVwZW5kZW50KSB7IGZwcyA9IG8uX2ZyYW1lcmF0ZTsgfVxuXHRcdH1cblx0XHR0aGlzLl9mcmFtZXJhdGUgPSBmcHM7XG5cdFx0XG5cdFx0dmFyIHQgPSAoZnBzICE9IG51bGwgJiYgZnBzICE9IC0xICYmIHRpbWUgIT0gbnVsbCkgPyB0aW1lLygxMDAwL2ZwcykgKyB0aGlzLl90IDogMTtcblx0XHR2YXIgZnJhbWVzID0gdHwwO1xuXHRcdHRoaXMuX3QgPSB0LWZyYW1lczsgLy8gbGVmdG92ZXIgdGltZVxuXHRcdFxuXHRcdHdoaWxlICghdGhpcy5wYXVzZWQgJiYgZnJhbWVzLS0pIHtcblx0XHRcdHRoaXMuX3ByZXZQb3NpdGlvbiA9ICh0aGlzLl9wcmV2UG9zIDwgMCkgPyAwIDogdGhpcy5fcHJldlBvc2l0aW9uKzE7XG5cdFx0XHR0aGlzLl91cGRhdGVUaW1lbGluZSgpO1xuXHRcdH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBNb3ZpZUNsaXAgaW5zdGFuY2VzIGNhbm5vdCBiZSBjbG9uZWQuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIHRoaXM/IE5lZWQgdG8gY2xvbmUgdGhlIFRpbWVsaW5lICYgcmV0YXJnZXQgdHdlZW5zIC0gcHJldHR5IGNvbXBsZXguXG5cdFx0dGhyb3coXCJNb3ZpZUNsaXAgY2Fubm90IGJlIGNsb25lZC5cIilcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbTW92aWVDbGlwIChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfdGlja1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZ0T2JqIEFuIGV2ZW50IG9iamVjdCB0aGF0IHdpbGwgYmUgZGlzcGF0Y2hlZCB0byBhbGwgdGljayBsaXN0ZW5lcnMuIFRoaXMgb2JqZWN0IGlzIHJldXNlZCBiZXR3ZWVuIGRpc3BhdGNoZXJzIHRvIHJlZHVjZSBjb25zdHJ1Y3Rpb24gJiBHQyBjb3N0cy5cblx0ICogZnVuY3Rpb24uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl90aWNrID0gZnVuY3Rpb24oZXZ0T2JqKSB7XG5cdFx0dGhpcy5hZHZhbmNlKGV2dE9iaiYmZXZ0T2JqLmRlbHRhKTtcblx0XHR0aGlzLkNvbnRhaW5lcl9fdGljayhldnRPYmopO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dvdG9cblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwb3NpdGlvbk9yTGFiZWwgVGhlIGFuaW1hdGlvbiBuYW1lIG9yIGZyYW1lIG51bWJlciB0byBnbyB0by5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dvdG8gPSBmdW5jdGlvbihwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR2YXIgcG9zID0gdGhpcy50aW1lbGluZS5yZXNvbHZlKHBvc2l0aW9uT3JMYWJlbCk7XG5cdFx0aWYgKHBvcyA9PSBudWxsKSB7IHJldHVybjsgfVxuXHRcdC8vIHByZXZlbnQgX3VwZGF0ZVRpbWVsaW5lIGZyb20gb3ZlcndyaXRpbmcgdGhlIG5ldyBwb3NpdGlvbiBiZWNhdXNlIG9mIGEgcmVzZXQ6XG5cdFx0aWYgKHRoaXMuX3ByZXZQb3MgPT0gLTEpIHsgdGhpcy5fcHJldlBvcyA9IE5hTjsgfVxuXHRcdHRoaXMuX3ByZXZQb3NpdGlvbiA9IHBvcztcblx0XHR0aGlzLl90ID0gMDtcblx0XHR0aGlzLl91cGRhdGVUaW1lbGluZSgpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX3Jlc2V0XG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0cC5fcmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wcmV2UG9zID0gLTE7XG5cdFx0dGhpcy5fdCA9IHRoaXMuY3VycmVudEZyYW1lID0gMDtcblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVRpbWVsaW5lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl91cGRhdGVUaW1lbGluZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0bCA9IHRoaXMudGltZWxpbmU7XG5cdFx0dmFyIHN5bmNoZWQgPSB0aGlzLm1vZGUgIT0gTW92aWVDbGlwLklOREVQRU5ERU5UO1xuXHRcdHRsLmxvb3AgPSAodGhpcy5sb29wPT1udWxsKSA/IHRydWUgOiB0aGlzLmxvb3A7XG5cdFx0XG5cdFx0dmFyIHBvcyA9IHN5bmNoZWQgPyB0aGlzLnN0YXJ0UG9zaXRpb24gKyAodGhpcy5tb2RlPT1Nb3ZpZUNsaXAuU0lOR0xFX0ZSQU1FPzA6dGhpcy5fc3luY2hPZmZzZXQpIDogKHRoaXMuX3ByZXZQb3MgPCAwID8gMCA6IHRoaXMuX3ByZXZQb3NpdGlvbik7XG5cdFx0dmFyIG1vZGUgPSBzeW5jaGVkIHx8ICF0aGlzLmFjdGlvbnNFbmFibGVkID8gY3JlYXRlanMuVHdlZW4uTk9ORSA6IG51bGw7XG5cdFx0XG5cdFx0Ly8gcHJlLWFzc2lnbiBjdXJyZW50RnJhbWUgc28gaXQgaXMgYXZhaWxhYmxlIHRvIGZyYW1lIHNjcmlwdHM6XG5cdFx0dGhpcy5jdXJyZW50RnJhbWUgPSB0bC5fY2FsY1Bvc2l0aW9uKHBvcyk7XG5cdFx0XG5cdFx0Ly8gdXBkYXRlIHRpbWVsaW5lIHBvc2l0aW9uLCBpZ25vcmluZyBhY3Rpb25zIGlmIHRoaXMgaXMgYSBncmFwaGljLlxuXHRcdHRsLnNldFBvc2l0aW9uKHBvcywgbW9kZSk7XG5cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSB0bC5fcHJldlBvc2l0aW9uO1xuXHRcdGlmICh0aGlzLl9wcmV2UG9zID09IHRsLl9wcmV2UG9zKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuY3VycmVudEZyYW1lID0gdGhpcy5fcHJldlBvcyA9IHRsLl9wcmV2UG9zO1xuXG5cdFx0Zm9yICh2YXIgbiBpbiB0aGlzLl9tYW5hZ2VkKSB7IHRoaXMuX21hbmFnZWRbbl0gPSAxOyB9XG5cblx0XHR2YXIgdHdlZW5zID0gdGwuX3R3ZWVucztcblx0XHRmb3IgKHZhciBpPTAsIGw9dHdlZW5zLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciB0d2VlbiA9IHR3ZWVuc1tpXTtcblx0XHRcdHZhciB0YXJnZXQgPSB0d2Vlbi5fdGFyZ2V0O1xuXHRcdFx0aWYgKHRhcmdldCA9PSB0aGlzIHx8IHR3ZWVuLnBhc3NpdmUpIHsgY29udGludWU7IH0gLy8gVE9ETzogdGhpcyBhc3N1bWVzIGFjdGlvbnMgdHdlZW4gaGFzIHRoaXMgYXMgdGhlIHRhcmdldC4gVmFsaWQ/XG5cdFx0XHR2YXIgb2Zmc2V0ID0gdHdlZW4uX3N0ZXBQb3NpdGlvbjtcblxuXHRcdFx0aWYgKHRhcmdldCBpbnN0YW5jZW9mIGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QpIHtcblx0XHRcdFx0Ly8gbW90aW9uIHR3ZWVuLlxuXHRcdFx0XHR0aGlzLl9hZGRNYW5hZ2VkQ2hpbGQodGFyZ2V0LCBvZmZzZXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gc3RhdGUgdHdlZW4uXG5cdFx0XHRcdHRoaXMuX3NldFN0YXRlKHRhcmdldC5zdGF0ZSwgb2Zmc2V0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIga2lkcyA9IHRoaXMuY2hpbGRyZW47XG5cdFx0Zm9yIChpPWtpZHMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0dmFyIGlkID0ga2lkc1tpXS5pZDtcblx0XHRcdGlmICh0aGlzLl9tYW5hZ2VkW2lkXSA9PSAxKSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlQ2hpbGRBdChpKTtcblx0XHRcdFx0ZGVsZXRlKHRoaXMuX21hbmFnZWRbaWRdKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3NldFN0YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHN0YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3NldFN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIG9mZnNldCkge1xuXHRcdGlmICghc3RhdGUpIHsgcmV0dXJuOyB9XG5cdFx0Zm9yICh2YXIgaT1zdGF0ZS5sZW5ndGgtMTtpPj0wO2ktLSkge1xuXHRcdFx0dmFyIG8gPSBzdGF0ZVtpXTtcblx0XHRcdHZhciB0YXJnZXQgPSBvLnQ7XG5cdFx0XHR2YXIgcHJvcHMgPSBvLnA7XG5cdFx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7IHRhcmdldFtuXSA9IHByb3BzW25dOyB9XG5cdFx0XHR0aGlzLl9hZGRNYW5hZ2VkQ2hpbGQodGFyZ2V0LCBvZmZzZXQpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQWRkcyBhIGNoaWxkIHRvIHRoZSB0aW1lbGluZSwgYW5kIHNldHMgaXQgdXAgYXMgYSBtYW5hZ2VkIGNoaWxkLlxuXHQgKiBAbWV0aG9kIF9hZGRNYW5hZ2VkQ2hpbGRcblx0ICogQHBhcmFtIHtNb3ZpZUNsaXB9IGNoaWxkIFRoZSBjaGlsZCBNb3ZpZUNsaXAgdG8gbWFuYWdlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcblx0ICogQHByaXZhdGVcblx0ICoqL1xuXHRwLl9hZGRNYW5hZ2VkQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCwgb2Zmc2V0KSB7XG5cdFx0aWYgKGNoaWxkLl9vZmYpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5hZGRDaGlsZEF0KGNoaWxkLDApO1xuXG5cdFx0aWYgKGNoaWxkIGluc3RhbmNlb2YgTW92aWVDbGlwKSB7XG5cdFx0XHRjaGlsZC5fc3luY2hPZmZzZXQgPSBvZmZzZXQ7XG5cdFx0XHQvLyBUT0RPOiB0aGlzIGRvZXMgbm90IHByZWNpc2VseSBtYXRjaCBGbGFzaC4gRmxhc2ggbG9zZXMgdHJhY2sgb2YgdGhlIGNsaXAgaWYgaXQgaXMgcmVuYW1lZCBvciByZW1vdmVkIGZyb20gdGhlIHRpbWVsaW5lLCB3aGljaCBjYXVzZXMgaXQgdG8gcmVzZXQuXG5cdFx0XHRpZiAoY2hpbGQubW9kZSA9PSBNb3ZpZUNsaXAuSU5ERVBFTkRFTlQgJiYgY2hpbGQuYXV0b1Jlc2V0ICYmICF0aGlzLl9tYW5hZ2VkW2NoaWxkLmlkXSkgeyBjaGlsZC5fcmVzZXQoKTsgfVxuXHRcdH1cblx0XHR0aGlzLl9tYW5hZ2VkW2NoaWxkLmlkXSA9IDI7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0Qm91bmRzXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVRyYW5zZm9ybVxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nZXRCb3VuZHMgPSBmdW5jdGlvbihtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLkRpc3BsYXlPYmplY3RfZ2V0Qm91bmRzKCk7XG5cdFx0aWYgKCFib3VuZHMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVRpbWVsaW5lKCk7XG5cdFx0XHRpZiAodGhpcy5mcmFtZUJvdW5kcykgeyBib3VuZHMgPSB0aGlzLl9yZWN0YW5nbGUuY29weSh0aGlzLmZyYW1lQm91bmRzW3RoaXMuY3VycmVudEZyYW1lXSk7IH1cblx0XHR9XG5cdFx0aWYgKGJvdW5kcykgeyByZXR1cm4gdGhpcy5fdHJhbnNmb3JtQm91bmRzKGJvdW5kcywgbWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pOyB9XG5cdFx0cmV0dXJuIHRoaXMuQ29udGFpbmVyX19nZXRCb3VuZHMobWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuTW92aWVDbGlwID0gY3JlYXRlanMucHJvbW90ZShNb3ZpZUNsaXAsIFwiQ29udGFpbmVyXCIpO1xuXG5cblxuLy8gTW92aWVDbGlwUGx1Z2luIGZvciBUd2VlbkpTOlxuXHQvKipcblx0ICogVGhpcyBwbHVnaW4gd29ya3Mgd2l0aCA8YSBocmVmPVwiaHR0cDovL3R3ZWVuanMuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+VHdlZW5KUzwvYT4gdG8gcHJldmVudCB0aGUgc3RhcnRQb3NpdGlvblxuXHQgKiBwcm9wZXJ0eSBmcm9tIHR3ZWVuaW5nLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAY2xhc3MgTW92aWVDbGlwUGx1Z2luXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIE1vdmllQ2xpcFBsdWdpbigpIHtcblx0XHR0aHJvdyhcIk1vdmllQ2xpcFBsdWdpbiBjYW5ub3QgYmUgaW5zdGFudGlhdGVkLlwiKVxuXHR9XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBwcmlvcml0eVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdE1vdmllQ2xpcFBsdWdpbi5wcmlvcml0eSA9IDEwMDsgLy8gdmVyeSBoaWdoIHByaW9yaXR5LCBzaG91bGQgcnVuIGZpcnN0XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgaW5zdGFsbFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdE1vdmllQ2xpcFBsdWdpbi5pbnN0YWxsID0gZnVuY3Rpb24oKSB7XG5cdFx0Y3JlYXRlanMuVHdlZW4uaW5zdGFsbFBsdWdpbihNb3ZpZUNsaXBQbHVnaW4sIFtcInN0YXJ0UG9zaXRpb25cIl0pO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgaW5pdFxuXHQgKiBAcGFyYW0ge1R3ZWVufSB0d2VlblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qm9vbGVhbn0gdmFsdWVcblx0ICogQHByaXZhdGVcblx0ICoqL1xuXHRNb3ZpZUNsaXBQbHVnaW4uaW5pdCA9IGZ1bmN0aW9uKHR3ZWVuLCBwcm9wLCB2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHN0ZXBcblx0ICogQHByaXZhdGVcblx0ICoqL1xuXHRNb3ZpZUNsaXBQbHVnaW4uc3RlcCA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHVudXNlZC5cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCB0d2VlblxuXHQgKiBAcGFyYW0ge1R3ZWVufSB0d2VlblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlciB8IEJvb2xlYW59IHZhbHVlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0VmFsdWVzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGVuZFZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcmF0aW9cblx0ICogQHBhcmFtIHtPYmplY3R9IHdhaXRcblx0ICogQHBhcmFtIHtPYmplY3R9IGVuZFxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKi9cblx0TW92aWVDbGlwUGx1Z2luLnR3ZWVuID0gZnVuY3Rpb24odHdlZW4sIHByb3AsIHZhbHVlLCBzdGFydFZhbHVlcywgZW5kVmFsdWVzLCByYXRpbywgd2FpdCwgZW5kKSB7XG5cdFx0aWYgKCEodHdlZW4udGFyZ2V0IGluc3RhbmNlb2YgTW92aWVDbGlwKSkgeyByZXR1cm4gdmFsdWU7IH1cblx0XHRyZXR1cm4gKHJhdGlvID09IDEgPyBlbmRWYWx1ZXNbcHJvcF0gOiBzdGFydFZhbHVlc1twcm9wXSk7XG5cdH07XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTcHJpdGVTaGVldFV0aWxzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRcblx0XG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFRoZSBTcHJpdGVTaGVldFV0aWxzIGNsYXNzIGlzIGEgY29sbGVjdGlvbiBvZiBzdGF0aWMgbWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319cy5cblx0ICogQSBzcHJpdGUgc2hlZXQgaXMgYSBzZXJpZXMgb2YgaW1hZ2VzICh1c3VhbGx5IGFuaW1hdGlvbiBmcmFtZXMpIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgaW1hZ2Ugb24gYSByZWd1bGFyIGdyaWQuIEZvclxuXHQgKiBleGFtcGxlLCBhbiBhbmltYXRpb24gY29uc2lzdGluZyBvZiA4IDEwMHgxMDAgaW1hZ2VzIGNvdWxkIGJlIGNvbWJpbmVkIGludG8gYSA0MDB4MjAwIHNwcml0ZSBzaGVldCAoNCBmcmFtZXMgYWNyb3NzXG5cdCAqIGJ5IDIgaGlnaCkuIFRoZSBTcHJpdGVTaGVldFV0aWxzIGNsYXNzIHVzZXMgYSBzdGF0aWMgaW50ZXJmYWNlIGFuZCBzaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZC5cblx0ICogQGNsYXNzIFNwcml0ZVNoZWV0VXRpbHNcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdGZ1bmN0aW9uIFNwcml0ZVNoZWV0VXRpbHMoKSB7XG5cdFx0dGhyb3cgXCJTcHJpdGVTaGVldFV0aWxzIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWRcIjtcblx0fVxuXG5cbi8vIHByaXZhdGUgc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3dvcmtpbmdDYW52YXNcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSBIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3dvcmtpbmdDb250ZXh0XG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXG5cdCAqIEBwcm90ZWN0ZWRcblx0Ki9cblx0dmFyIGNhbnZhcyA9IChjcmVhdGVqcy5jcmVhdGVDYW52YXM/Y3JlYXRlanMuY3JlYXRlQ2FudmFzKCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSk7XG5cdGlmIChjYW52YXMuZ2V0Q29udGV4dCkge1xuXHRcdFNwcml0ZVNoZWV0VXRpbHMuX3dvcmtpbmdDYW52YXMgPSBjYW52YXM7XG5cdFx0U3ByaXRlU2hlZXRVdGlscy5fd29ya2luZ0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxO1xuXHR9XG5cblxuLy8gcHVibGljIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogPGI+VGhpcyBpcyBhbiBleHBlcmltZW50YWwgbWV0aG9kLCBhbmQgbWF5IGJlIGJ1Z2d5LiBQbGVhc2UgcmVwb3J0IGlzc3Vlcy48L2I+PGJyLz48YnIvPlxuXHQgKiBFeHRlbmRzIHRoZSBleGlzdGluZyBzcHJpdGUgc2hlZXQgYnkgZmxpcHBpbmcgdGhlIG9yaWdpbmFsIGZyYW1lcyBob3Jpem9udGFsbHksIHZlcnRpY2FsbHksIG9yIGJvdGgsXG5cdCAqIGFuZCBhZGRpbmcgYXBwcm9wcmlhdGUgYW5pbWF0aW9uICYgZnJhbWUgZGF0YS4gVGhlIGZsaXBwZWQgYW5pbWF0aW9ucyB3aWxsIGhhdmUgYSBzdWZmaXggYWRkZWQgdG8gdGhlaXIgbmFtZXNcblx0ICogKF9oLCBfdiwgX2h2IGFzIGFwcHJvcHJpYXRlKS4gTWFrZSBzdXJlIHRoZSBzcHJpdGUgc2hlZXQgaW1hZ2VzIGFyZSBmdWxseSBsb2FkZWQgYmVmb3JlIHVzaW5nIHRoaXMgbWV0aG9kLlxuXHQgKiA8YnIvPjxici8+XG5cdCAqIEZvciBleGFtcGxlOjxici8+XG5cdCAqIFNwcml0ZVNoZWV0VXRpbHMuYWRkRmxpcHBlZEZyYW1lcyhteVNwcml0ZVNoZWV0LCB0cnVlLCB0cnVlKTtcblx0ICogVGhlIGFib3ZlIHdvdWxkIGFkZCBmcmFtZXMgdGhhdCBhcmUgZmxpcHBlZCBob3Jpem9udGFsbHkgQU5EIGZyYW1lcyB0aGF0IGFyZSBmbGlwcGVkIHZlcnRpY2FsbHkuXG5cdCAqIDxici8+PGJyLz5cblx0ICogTm90ZSB0aGF0IHlvdSBjYW4gYWxzbyBmbGlwIGFueSBkaXNwbGF5IG9iamVjdCBieSBzZXR0aW5nIGl0cyBzY2FsZVggb3Igc2NhbGVZIHRvIGEgbmVnYXRpdmUgdmFsdWUuIE9uIHNvbWVcblx0ICogYnJvd3NlcnMgKGVzcGVjaWFsbHkgdGhvc2Ugd2l0aG91dCBoYXJkd2FyZSBhY2NlbGVyYXRlZCBjYW52YXMpIHRoaXMgY2FuIHJlc3VsdCBpbiBzbGlnaHRseSBkZWdyYWRlZCBwZXJmb3JtYW5jZSxcblx0ICogd2hpY2ggaXMgd2h5IGFkZEZsaXBwZWRGcmFtZXMgaXMgYXZhaWxhYmxlLlxuXHQgKiBAbWV0aG9kIGFkZEZsaXBwZWRGcmFtZXNcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge1Nwcml0ZVNoZWV0fSBzcHJpdGVTaGVldFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGhvcml6b250YWwgSWYgdHJ1ZSwgaG9yaXpvbnRhbGx5IGZsaXBwZWQgZnJhbWVzIHdpbGwgYmUgYWRkZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmVydGljYWwgSWYgdHJ1ZSwgdmVydGljYWxseSBmbGlwcGVkIGZyYW1lcyB3aWxsIGJlIGFkZGVkLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJvdGggSWYgdHJ1ZSwgZnJhbWVzIHRoYXQgYXJlIGZsaXBwZWQgYm90aCBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkgd2lsbCBiZSBhZGRlZC5cblx0ICogQGRlcHJlY2F0ZWQgTW9kZXJuIGJyb3dzZXJzIHBlcmZvcm0gYmV0dGVyIHdoZW4gZmxpcHBpbmcgdmlhIGEgdHJhbnNmb3JtIChleC4gc2NhbGVYPS0xKSByZW5kZXJpbmcgdGhpcyBvYnNvbGV0ZS5cblx0ICoqL1xuXHRTcHJpdGVTaGVldFV0aWxzLmFkZEZsaXBwZWRGcmFtZXMgPSBmdW5jdGlvbihzcHJpdGVTaGVldCwgaG9yaXpvbnRhbCwgdmVydGljYWwsIGJvdGgpIHtcblx0XHRpZiAoIWhvcml6b250YWwgJiYgIXZlcnRpY2FsICYmICFib3RoKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGNvdW50ID0gMDtcblx0XHRpZiAoaG9yaXpvbnRhbCkgeyBTcHJpdGVTaGVldFV0aWxzLl9mbGlwKHNwcml0ZVNoZWV0LCsrY291bnQsdHJ1ZSxmYWxzZSk7IH1cblx0XHRpZiAodmVydGljYWwpIHsgU3ByaXRlU2hlZXRVdGlscy5fZmxpcChzcHJpdGVTaGVldCwrK2NvdW50LGZhbHNlLHRydWUpOyB9XG5cdFx0aWYgKGJvdGgpIHsgU3ByaXRlU2hlZXRVdGlscy5fZmxpcChzcHJpdGVTaGVldCwrK2NvdW50LHRydWUsdHJ1ZSk7IH1cblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHNpbmdsZSBmcmFtZSBvZiB0aGUgc3BlY2lmaWVkIHNwcml0ZSBzaGVldCBhcyBhIG5ldyBQTkcgaW1hZ2UuIEFuIGV4YW1wbGUgb2Ygd2hlbiB0aGlzIG1heSBiZSB1c2VmdWwgaXNcblx0ICogdG8gdXNlIGEgc3ByaXRlc2hlZXQgZnJhbWUgYXMgdGhlIHNvdXJjZSBmb3IgYSBiaXRtYXAgZmlsbC5cblx0ICpcblx0ICogPHN0cm9uZz5XQVJOSU5HOjwvc3Ryb25nPiBJbiBhbG1vc3QgYWxsIGNhc2VzIGl0IGlzIGJldHRlciB0byBkaXNwbGF5IGEgc2luZ2xlIGZyYW1lIHVzaW5nIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdpdGggYSB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0gY2FsbCB0aGFuIGl0IGlzIHRvIHNsaWNlIG91dCBhIGZyYW1lIHVzaW5nIHRoaXNcblx0ICogbWV0aG9kIGFuZCBkaXNwbGF5IGl0IHdpdGggYSBCaXRtYXAgaW5zdGFuY2UuIFlvdSBjYW4gYWxzbyBjcm9wIGFuIGltYWdlIHVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJCaXRtYXAvc291cmNlUmVjdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eSBvZiB7eyNjcm9zc0xpbmsgXCJCaXRtYXBcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIFRoZSBleHRyYWN0RnJhbWUgbWV0aG9kIG1heSBjYXVzZSBjcm9zcy1kb21haW4gd2FybmluZ3Mgc2luY2UgaXQgYWNjZXNzZXMgcGl4ZWxzIGRpcmVjdGx5IG9uIHRoZSBjYW52YXMuXG5cdCAqIEBtZXRob2QgZXh0cmFjdEZyYW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3ByaXRlU2hlZXQgVGhlIFNwcml0ZVNoZWV0IGluc3RhbmNlIHRvIGV4dHJhY3QgYSBmcmFtZSBmcm9tLlxuXHQgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGZyYW1lT3JBbmltYXRpb24gVGhlIGZyYW1lIG51bWJlciBvciBhbmltYXRpb24gbmFtZSB0byBleHRyYWN0LiBJZiBhbiBhbmltYXRpb25cblx0ICogbmFtZSBpcyBzcGVjaWZpZWQsIG9ubHkgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBhbmltYXRpb24gd2lsbCBiZSBleHRyYWN0ZWQuXG5cdCAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IGEgc2luZ2xlIGZyYW1lIG9mIHRoZSBzcGVjaWZpZWQgc3ByaXRlIHNoZWV0IGFzIGEgbmV3IFBORyBpbWFnZS5cblx0Ki9cblx0U3ByaXRlU2hlZXRVdGlscy5leHRyYWN0RnJhbWUgPSBmdW5jdGlvbihzcHJpdGVTaGVldCwgZnJhbWVPckFuaW1hdGlvbikge1xuXHRcdGlmIChpc05hTihmcmFtZU9yQW5pbWF0aW9uKSkge1xuXHRcdFx0ZnJhbWVPckFuaW1hdGlvbiA9IHNwcml0ZVNoZWV0LmdldEFuaW1hdGlvbihmcmFtZU9yQW5pbWF0aW9uKS5mcmFtZXNbMF07XG5cdFx0fVxuXHRcdHZhciBkYXRhID0gc3ByaXRlU2hlZXQuZ2V0RnJhbWUoZnJhbWVPckFuaW1hdGlvbik7XG5cdFx0aWYgKCFkYXRhKSB7IHJldHVybiBudWxsOyB9XG5cdFx0dmFyIHIgPSBkYXRhLnJlY3Q7XG5cdFx0dmFyIGNhbnZhcyA9IFNwcml0ZVNoZWV0VXRpbHMuX3dvcmtpbmdDYW52YXM7XG5cdFx0Y2FudmFzLndpZHRoID0gci53aWR0aDtcblx0XHRjYW52YXMuaGVpZ2h0ID0gci5oZWlnaHQ7XG5cdFx0U3ByaXRlU2hlZXRVdGlscy5fd29ya2luZ0NvbnRleHQuZHJhd0ltYWdlKGRhdGEuaW1hZ2UsIHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCwgMCwgMCwgci53aWR0aCwgci5oZWlnaHQpO1xuXHRcdHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuXHRcdGltZy5zcmMgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuXHRcdHJldHVybiBpbWc7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1lcmdlcyB0aGUgcmdiIGNoYW5uZWxzIG9mIG9uZSBpbWFnZSB3aXRoIHRoZSBhbHBoYSBjaGFubmVsIG9mIGFub3RoZXIuIFRoaXMgY2FuIGJlIHVzZWQgdG8gY29tYmluZSBhIGNvbXByZXNzZWRcblx0ICogSlBFRyBpbWFnZSBjb250YWluaW5nIGNvbG9yIGRhdGEgd2l0aCBhIFBORzMyIG1vbm9jaHJvbWF0aWMgaW1hZ2UgY29udGFpbmluZyBhbHBoYSBkYXRhLiBXaXRoIGNlcnRhaW4gdHlwZXMgb2Zcblx0ICogaW1hZ2VzICh0aG9zZSB3aXRoIGRldGFpbCB0aGF0IGxlbmQgaXRzZWxmIHRvIEpQRUcgY29tcHJlc3Npb24pIHRoaXMgY2FuIHByb3ZpZGUgc2lnbmlmaWNhbnQgZmlsZSBzaXplIHNhdmluZ3Ncblx0ICogdmVyc3VzIGEgc2luZ2xlIFJHQkEgUE5HMzIuIFRoaXMgbWV0aG9kIGlzIHZlcnkgZmFzdCAoZ2VuZXJhbGx5IG9uIHRoZSBvcmRlciBvZiAxLTIgbXMgdG8gcnVuKS5cblx0ICogQG1ldGhvZCBtZXJnZUFscGhhXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSByYmdJbWFnZSBUaGUgaW1hZ2UgKG9yIGNhbnZhcykgY29udGFpbmluZyB0aGUgUkdCIGNoYW5uZWxzIHRvIHVzZS5cblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBhbHBoYUltYWdlIFRoZSBpbWFnZSAob3IgY2FudmFzKSBjb250YWluaW5nIHRoZSBhbHBoYSBjaGFubmVsIHRvIHVzZS5cblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgY2FudmFzIHdpbGwgYmUgdXNlZCBhbmQgcmV0dXJuZWQuIElmIG5vdCwgYSBuZXcgY2FudmFzIHdpbGwgYmUgY3JlYXRlZC5cblx0ICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IEEgY2FudmFzIHdpdGggdGhlIGNvbWJpbmVkIGltYWdlIGRhdGEuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYSBzb3VyY2UgZm9yIEJpdG1hcCBvciBTcHJpdGVTaGVldC5cblx0ICogQGRlcHJlY2F0ZWQgVG9vbHMgc3VjaCBhcyBJbWFnZUFscGhhIGdlbmVyYWxseSBwcm92aWRlIGJldHRlciByZXN1bHRzLiBUaGlzIHdpbGwgYmUgbW92ZWQgdG8gc2FuZGJveCBpbiB0aGUgZnV0dXJlLlxuXHQqL1xuXHRTcHJpdGVTaGVldFV0aWxzLm1lcmdlQWxwaGEgPSBmdW5jdGlvbihyZ2JJbWFnZSwgYWxwaGFJbWFnZSwgY2FudmFzKSB7XG5cdFx0aWYgKCFjYW52YXMpIHsgY2FudmFzID0gY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7IH1cblx0XHRjYW52YXMud2lkdGggPSBNYXRoLm1heChhbHBoYUltYWdlLndpZHRoLCByZ2JJbWFnZS53aWR0aCk7XG5cdFx0Y2FudmFzLmhlaWdodCA9IE1hdGgubWF4KGFscGhhSW1hZ2UuaGVpZ2h0LCByZ2JJbWFnZS5oZWlnaHQpO1xuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0Y3R4LmRyYXdJbWFnZShyZ2JJbWFnZSwwLDApO1xuXHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWluXCI7XG5cdFx0Y3R4LmRyYXdJbWFnZShhbHBoYUltYWdlLDAsMCk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRyZXR1cm4gY2FudmFzO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgc3RhdGljIG1ldGhvZHM6XG5cdFNwcml0ZVNoZWV0VXRpbHMuX2ZsaXAgPSBmdW5jdGlvbihzcHJpdGVTaGVldCwgY291bnQsIGgsIHYpIHtcblx0XHR2YXIgaW1ncyA9IHNwcml0ZVNoZWV0Ll9pbWFnZXM7XG5cdFx0dmFyIGNhbnZhcyA9IFNwcml0ZVNoZWV0VXRpbHMuX3dvcmtpbmdDYW52YXM7XG5cdFx0dmFyIGN0eCA9IFNwcml0ZVNoZWV0VXRpbHMuX3dvcmtpbmdDb250ZXh0O1xuXHRcdHZhciBpbCA9IGltZ3MubGVuZ3RoL2NvdW50O1xuXHRcdGZvciAodmFyIGk9MDtpPGlsO2krKykge1xuXHRcdFx0dmFyIHNyYyA9IGltZ3NbaV07XG5cdFx0XHRzcmMuX190bXAgPSBpOyAvLyBhIGJpdCBoYWNreSwgYnV0IGZhc3RlciB0aGFuIGRvaW5nIGluZGV4T2YgYmVsb3cuXG5cdFx0XHRjdHguc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKTtcblx0XHRcdGN0eC5jbGVhclJlY3QoMCwwLGNhbnZhcy53aWR0aCsxLGNhbnZhcy5oZWlnaHQrMSk7XG5cdFx0XHRjYW52YXMud2lkdGggPSBzcmMud2lkdGg7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gc3JjLmhlaWdodDtcblx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0oaD8tMToxLCAwLCAwLCB2Py0xOjEsIGg/c3JjLndpZHRoOjAsIHY/c3JjLmhlaWdodDowKTtcblx0XHRcdGN0eC5kcmF3SW1hZ2Uoc3JjLDAsMCk7XG5cdFx0XHR2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcblx0XHRcdGltZy5zcmMgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuXHRcdFx0Ly8gd29yayBhcm91bmQgYSBzdHJhbmdlIGJ1ZyBpbiBTYWZhcmk6XG5cdFx0XHRpbWcud2lkdGggPSBzcmMud2lkdGg7XG5cdFx0XHRpbWcuaGVpZ2h0ID0gc3JjLmhlaWdodDtcblx0XHRcdGltZ3MucHVzaChpbWcpO1xuXHRcdH1cblxuXHRcdHZhciBmcmFtZXMgPSBzcHJpdGVTaGVldC5fZnJhbWVzO1xuXHRcdHZhciBmbCA9IGZyYW1lcy5sZW5ndGgvY291bnQ7XG5cdFx0Zm9yIChpPTA7aTxmbDtpKyspIHtcblx0XHRcdHNyYyA9IGZyYW1lc1tpXTtcblx0XHRcdHZhciByZWN0ID0gc3JjLnJlY3QuY2xvbmUoKTtcblx0XHRcdGltZyA9IGltZ3Nbc3JjLmltYWdlLl9fdG1wK2lsKmNvdW50XTtcblxuXHRcdFx0dmFyIGZyYW1lID0ge2ltYWdlOmltZyxyZWN0OnJlY3QscmVnWDpzcmMucmVnWCxyZWdZOnNyYy5yZWdZfTtcblx0XHRcdGlmIChoKSB7XG5cdFx0XHRcdHJlY3QueCA9IGltZy53aWR0aC1yZWN0LngtcmVjdC53aWR0aDsgLy8gdXBkYXRlIHJlY3Rcblx0XHRcdFx0ZnJhbWUucmVnWCA9IHJlY3Qud2lkdGgtc3JjLnJlZ1g7IC8vIHVwZGF0ZSByZWdpc3RyYXRpb24gcG9pbnRcblx0XHRcdH1cblx0XHRcdGlmICh2KSB7XG5cdFx0XHRcdHJlY3QueSA9IGltZy5oZWlnaHQtcmVjdC55LXJlY3QuaGVpZ2h0OyAgLy8gdXBkYXRlIHJlY3Rcblx0XHRcdFx0ZnJhbWUucmVnWSA9IHJlY3QuaGVpZ2h0LXNyYy5yZWdZOyAvLyB1cGRhdGUgcmVnaXN0cmF0aW9uIHBvaW50XG5cdFx0XHR9XG5cdFx0XHRmcmFtZXMucHVzaChmcmFtZSk7XG5cdFx0fVxuXG5cdFx0dmFyIHNmeCA9IFwiX1wiKyhoP1wiaFwiOlwiXCIpKyh2P1widlwiOlwiXCIpO1xuXHRcdHZhciBuYW1lcyA9IHNwcml0ZVNoZWV0Ll9hbmltYXRpb25zO1xuXHRcdHZhciBkYXRhID0gc3ByaXRlU2hlZXQuX2RhdGE7XG5cdFx0dmFyIGFsID0gbmFtZXMubGVuZ3RoL2NvdW50O1xuXHRcdGZvciAoaT0wO2k8YWw7aSsrKSB7XG5cdFx0XHR2YXIgbmFtZSA9IG5hbWVzW2ldO1xuXHRcdFx0c3JjID0gZGF0YVtuYW1lXTtcblx0XHRcdHZhciBhbmltID0ge25hbWU6bmFtZStzZngsc3BlZWQ6c3JjLnNwZWVkLG5leHQ6c3JjLm5leHQsZnJhbWVzOltdfTtcblx0XHRcdGlmIChzcmMubmV4dCkgeyBhbmltLm5leHQgKz0gc2Z4OyB9XG5cdFx0XHRmcmFtZXMgPSBzcmMuZnJhbWVzO1xuXHRcdFx0Zm9yICh2YXIgaj0wLGw9ZnJhbWVzLmxlbmd0aDtqPGw7aisrKSB7XG5cdFx0XHRcdGFuaW0uZnJhbWVzLnB1c2goZnJhbWVzW2pdK2ZsKmNvdW50KTtcblx0XHRcdH1cblx0XHRcdGRhdGFbYW5pbS5uYW1lXSA9IGFuaW07XG5cdFx0XHRuYW1lcy5wdXNoKGFuaW0ubmFtZSk7XG5cdFx0fVxuXHR9O1xuXG5cblx0Y3JlYXRlanMuU3ByaXRlU2hlZXRVdGlscyA9IFNwcml0ZVNoZWV0VXRpbHM7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3ByaXRlU2hlZXRCdWlsZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhlIFNwcml0ZVNoZWV0QnVpbGRlciBhbGxvd3MgeW91IHRvIGdlbmVyYXRlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcyBhdCBydW4gdGltZVxuXHQgKiBmcm9tIGFueSBkaXNwbGF5IG9iamVjdC4gVGhpcyBjYW4gYWxsb3cgeW91IHRvIG1haW50YWluIHlvdXIgYXNzZXRzIGFzIHZlY3RvciBncmFwaGljcyAoZm9yIGxvdyBmaWxlIHNpemUpLCBhbmRcblx0ICogcmVuZGVyIHRoZW0gYXQgcnVuIHRpbWUgYXMgU3ByaXRlU2hlZXRzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG5cdCAqXG5cdCAqIFNwcml0ZVNoZWV0cyBjYW4gYmUgYnVpbHQgZWl0aGVyIHN5bmNocm9ub3VzbHksIG9yIGFzeW5jaHJvbm91c2x5LCBzbyB0aGF0IGxhcmdlIFNwcml0ZVNoZWV0cyBjYW4gYmUgZ2VuZXJhdGVkXG5cdCAqIHdpdGhvdXQgbG9ja2luZyB0aGUgVUkuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgXCJpbWFnZXNcIiB1c2VkIGluIHRoZSBnZW5lcmF0ZWQgU3ByaXRlU2hlZXQgYXJlIGFjdHVhbGx5IGNhbnZhcyBlbGVtZW50cywgYW5kIHRoYXQgdGhleSB3aWxsIGJlXG5cdCAqIHNpemVkIHRvIHRoZSBuZWFyZXN0IHBvd2VyIG9mIDIgdXAgdG8gdGhlIHZhbHVlIG9mIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0QnVpbGRlci9tYXhXaWR0aDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldEJ1aWxkZXIvbWF4SGVpZ2h0OnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAY2xhc3MgU3ByaXRlU2hlZXRCdWlsZGVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZnJhbWVyYXRlPTBdIFRoZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gb2Zcblx0ICoge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzIHRoYXQgYXJlIGNyZWF0ZWQuXG5cdCAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBTcHJpdGVTaGVldEJ1aWxkZXIoZnJhbWVyYXRlKSB7XG5cdFx0dGhpcy5FdmVudERpc3BhdGNoZXJfY29uc3RydWN0b3IoKTtcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIG1heGltdW0gd2lkdGggZm9yIHRoZSBpbWFnZXMgKG5vdCBpbmRpdmlkdWFsIGZyYW1lcykgaW4gdGhlIGdlbmVyYXRlZCBTcHJpdGVTaGVldC4gSXQgaXMgcmVjb21tZW5kZWQgdG9cblx0XHQgKiB1c2UgYSBwb3dlciBvZiAyIGZvciB0aGlzIHZhbHVlIChleC4gMTAyNCwgMjA0OCwgNDA5NikuIElmIHRoZSBmcmFtZXMgY2Fubm90IGFsbCBmaXQgd2l0aGluIHRoZSBtYXhcblx0XHQgKiBkaW1lbnNpb25zLCB0aGVuIGFkZGl0aW9uYWwgaW1hZ2VzIHdpbGwgYmUgY3JlYXRlZCBhcyBuZWVkZWQuXG5cdFx0ICogQHByb3BlcnR5IG1heFdpZHRoXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMjA0OFxuXHRcdCovXG5cdFx0dGhpcy5tYXhXaWR0aCA9IDIwNDg7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIGhlaWdodCBmb3IgdGhlIGltYWdlcyAobm90IGluZGl2aWR1YWwgZnJhbWVzKSBpbiB0aGUgZ2VuZXJhdGVkIFNwcml0ZVNoZWV0LiBJdCBpcyByZWNvbW1lbmRlZCB0b1xuXHRcdCAqIHVzZSBhIHBvd2VyIG9mIDIgZm9yIHRoaXMgdmFsdWUgKGV4LiAxMDI0LCAyMDQ4LCA0MDk2KS4gSWYgdGhlIGZyYW1lcyBjYW5ub3QgYWxsIGZpdCB3aXRoaW4gdGhlIG1heFxuXHRcdCAqIGRpbWVuc2lvbnMsIHRoZW4gYWRkaXRpb25hbCBpbWFnZXMgd2lsbCBiZSBjcmVhdGVkIGFzIG5lZWRlZC5cblx0XHQgKiBAcHJvcGVydHkgbWF4SGVpZ2h0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMjA0OFxuXHRcdCAqKi9cblx0XHR0aGlzLm1heEhlaWdodCA9IDIwNDg7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBTcHJpdGVTaGVldCB0aGF0IHdhcyBnZW5lcmF0ZWQuIFRoaXMgd2lsbCBiZSBudWxsIGJlZm9yZSBhIGJ1aWxkIGlzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG5cdFx0ICogQHByb3BlcnR5IHNwcml0ZVNoZWV0XG5cdFx0ICogQHR5cGUgU3ByaXRlU2hlZXRcblx0XHQgKiovXG5cdFx0dGhpcy5zcHJpdGVTaGVldCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzY2FsZSB0byBhcHBseSB3aGVuIGRyYXdpbmcgYWxsIGZyYW1lcyB0byB0aGUgU3ByaXRlU2hlZXQuIFRoaXMgaXMgbXVsdGlwbGllZCBhZ2FpbnN0IGFueSBzY2FsZSBzcGVjaWZpZWRcblx0XHQgKiBpbiB0aGUgYWRkRnJhbWUgY2FsbC4gVGhpcyBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIGdlbmVyYXRlIGEgU3ByaXRlU2hlZXQgYXQgcnVuIHRpbWUgdGhhdCBpcyB0YWlsb3JlZFxuXHRcdCAqIHRvIHRoZSBhIHNwZWNpZmljIGRldmljZSByZXNvbHV0aW9uIChleC4gdGFibGV0IHZzIG1vYmlsZSkuXG5cdFx0ICogQHByb3BlcnR5IHNjYWxlXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqKi9cblx0XHR0aGlzLnNjYWxlID0gMTtcblx0XG5cdFx0LyoqXG5cdFx0KiBUaGUgcGFkZGluZyB0byB1c2UgYmV0d2VlbiBmcmFtZXMuIFRoaXMgaXMgaGVscGZ1bCB0byBwcmVzZXJ2ZSBhbnRpYWxpYXNpbmcgb24gZHJhd24gdmVjdG9yIGNvbnRlbnQuXG5cdFx0KiBAcHJvcGVydHkgcGFkZGluZ1xuXHRcdCogQHR5cGUgTnVtYmVyXG5cdFx0KiBAZGVmYXVsdCAxXG5cdFx0KiovXG5cdFx0dGhpcy5wYWRkaW5nID0gMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQSBudW1iZXIgZnJvbSAwLjAxIHRvIDAuOTkgdGhhdCBpbmRpY2F0ZXMgd2hhdCBwZXJjZW50YWdlIG9mIHRpbWUgdGhlIGJ1aWxkZXIgY2FuIHVzZS4gVGhpcyBjYW4gYmVcblx0XHQgKiB0aG91Z2h0IG9mIGFzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBwZXIgc2Vjb25kIHRoZSBidWlsZGVyIHdpbGwgdXNlLiBGb3IgZXhhbXBsZSwgd2l0aCBhIHRpbWVTbGljZSB2YWx1ZSBvZiAwLjMsXG5cdFx0ICogdGhlIGJ1aWxkZXIgd2lsbCBydW4gMjAgdGltZXMgcGVyIHNlY29uZCwgdXNpbmcgYXBwcm94aW1hdGVseSAxNW1zIHBlciBidWlsZCAoMzAlIG9mIGF2YWlsYWJsZSB0aW1lLCBvciAwLjNzIHBlciBzZWNvbmQpLlxuXHRcdCAqIERlZmF1bHRzIHRvIDAuMy5cblx0XHQgKiBAcHJvcGVydHkgdGltZVNsaWNlXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMC4zXG5cdFx0ICoqL1xuXHRcdHRoaXMudGltZVNsaWNlID0gMC4zO1xuXHRcblx0XHQvKipcblx0XHQgKiBBIHZhbHVlIGJldHdlZW4gMCBhbmQgMSB0aGF0IGluZGljYXRlcyB0aGUgcHJvZ3Jlc3Mgb2YgYSBidWlsZCwgb3IgLTEgaWYgYSBidWlsZCBoYXMgbm90XG5cdFx0ICogYmVlbiBpbml0aWF0ZWQuXG5cdFx0ICogQHByb3BlcnR5IHByb2dyZXNzXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLnByb2dyZXNzID0gLTE7XG5cblx0XHQvKipcblx0XHQgKiBBIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0L2ZyYW1lcmF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSB2YWx1ZSB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIG5ldyB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgdGhhdCBhcmVcblx0XHQgKiBjcmVhdGVkLiBJZiBubyBmcmFtZXJhdGUgaXMgc3BlY2lmaWVkIChvciBpdCBpcyAwKSwgdGhlbiBTcHJpdGVTaGVldHMgd2lsbCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIGZyYW1lcmF0ZS5cblx0XHQgKiBAcHJvcGVydHkgZnJhbWVyYXRlXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuZnJhbWVyYXRlID0gZnJhbWVyYXRlIHx8IDA7XG5cdFxuXHRcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZnJhbWVzXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ZyYW1lcyA9IFtdO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2FuaW1hdGlvbnNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiovXG5cdFx0dGhpcy5fYW5pbWF0aW9ucyA9IHt9O1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2RhdGFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiovXG5cdFx0dGhpcy5fZGF0YSA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbmV4dEZyYW1lSW5kZXhcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX25leHRGcmFtZUluZGV4ID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9pbmRleFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5faW5kZXggPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3RpbWVySURcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3RpbWVySUQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3NjYWxlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9zY2FsZSA9IDE7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU3ByaXRlU2hlZXRCdWlsZGVyLCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBjb25zdGFudHM6XG5cdFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfRElNRU5TSU9OUyA9IFwiZnJhbWUgZGltZW5zaW9ucyBleGNlZWQgbWF4IHNwcml0ZXNoZWV0IGRpbWVuc2lvbnNcIjtcblx0U3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9SVU5OSU5HID0gXCJhIGJ1aWxkIGlzIGFscmVhZHkgcnVubmluZ1wiO1xuXG4vLyBldmVudHM6XG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gYSBidWlsZCBjb21wbGV0ZXMuXG5cdCAqIEBldmVudCBjb21wbGV0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIGFuIGFzeW5jaHJvbm91cyBidWlsZCBoYXMgcHJvZ3Jlc3MuXG5cdCAqIEBldmVudCBwcm9ncmVzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcyBUaGUgY3VycmVudCBwcm9ncmVzcyB2YWx1ZSAoMC0xKS5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQWRkcyBhIGZyYW1lIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGF0IHRoZSBmcmFtZSB3aWxsIG5vdCBiZSBkcmF3biB1bnRpbCB5b3Vcblx0ICogY2FsbCB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldEJ1aWxkZXIvYnVpbGRcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLiBUaGUgb3B0aW9uYWwgc2V0dXAgcGFyYW1zIGFsbG93IHlvdSB0byBoYXZlXG5cdCAqIGEgZnVuY3Rpb24gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZHJhdyBvY2N1cnMuIEZvciBleGFtcGxlLCB0aGlzIGFsbG93cyB5b3UgdG8gYWRkIGEgc2luZ2xlIHNvdXJjZSBtdWx0aXBsZVxuXHQgKiB0aW1lcywgYnV0IG1hbmlwdWxhdGUgaXQgb3IgaXRzIGNoaWxkcmVuIHRvIGNoYW5nZSBpdCB0byBnZW5lcmF0ZSBkaWZmZXJlbnQgZnJhbWVzLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIHNvdXJjZSdzIHRyYW5zZm9ybWF0aW9ucyAoeCwgeSwgc2NhbGUsIHJvdGF0ZSwgYWxwaGEpIHdpbGwgYmUgaWdub3JlZCwgZXhjZXB0IGZvciByZWdYL1kuIFRvIGFwcGx5XG5cdCAqIHRyYW5zZm9ybXMgdG8gYSBzb3VyY2Ugb2JqZWN0IGFuZCBoYXZlIHRoZW0gY2FwdHVyZWQgaW4gdGhlIFNwcml0ZVNoZWV0LCBzaW1wbHkgcGxhY2UgaXQgaW50byBhIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQgcGFzcyBpbiB0aGUgQ29udGFpbmVyIGFzIHRoZSBzb3VyY2UuXG5cdCAqIEBtZXRob2QgYWRkRnJhbWVcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0XCJ9fXt7L2Nyb3NzTGlua319ICB0byBkcmF3IGFzIHRoZSBmcmFtZS5cblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IFtzb3VyY2VSZWN0XSBBIHt7I2Nyb3NzTGluayBcIlJlY3RhbmdsZVwifX17ey9jcm9zc0xpbmt9fSBkZWZpbmluZyB0aGUgcG9ydGlvbiBvZiB0aGVcblx0ICogc291cmNlIHRvIGRyYXcgdG8gdGhlIGZyYW1lLiBJZiBub3Qgc3BlY2lmaWVkLCBpdCB3aWxsIGxvb2sgZm9yIGEgYGdldEJvdW5kc2AgbWV0aG9kLCBib3VuZHMgcHJvcGVydHksIG9yXG5cdCAqIGBub21pbmFsQm91bmRzYCBwcm9wZXJ0eSBvbiB0aGUgc291cmNlIHRvIHVzZS4gSWYgb25lIGlzIG5vdCBmb3VuZCwgdGhlIGZyYW1lIHdpbGwgYmUgc2tpcHBlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZT0xXSBPcHRpb25hbC4gVGhlIHNjYWxlIHRvIGRyYXcgdGhpcyBmcmFtZSBhdC4gRGVmYXVsdCBpcyAxLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2V0dXBGdW5jdGlvbl0gQSBmdW5jdGlvbiB0byBjYWxsIGltbWVkaWF0ZWx5IGJlZm9yZSBkcmF3aW5nIHRoaXMgZnJhbWUuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdHdvIHBhcmFtZXRlcnM6IHRoZSBzb3VyY2UsIGFuZCBzZXR1cERhdGEuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbc2V0dXBEYXRhXSBBcmJpdHJhcnkgc2V0dXAgZGF0YSB0byBwYXNzIHRvIHNldHVwRnVuY3Rpb24gYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBmcmFtZSB0aGF0IHdhcyBqdXN0IGFkZGVkLCBvciBudWxsIGlmIGEgc291cmNlUmVjdCBjb3VsZCBub3QgYmUgZGV0ZXJtaW5lZC5cblx0ICoqL1xuXHRwLmFkZEZyYW1lID0gZnVuY3Rpb24oc291cmNlLCBzb3VyY2VSZWN0LCBzY2FsZSwgc2V0dXBGdW5jdGlvbiwgc2V0dXBEYXRhKSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9SVU5OSU5HOyB9XG5cdFx0dmFyIHJlY3QgPSBzb3VyY2VSZWN0fHxzb3VyY2UuYm91bmRzfHxzb3VyY2Uubm9taW5hbEJvdW5kcztcblx0XHRpZiAoIXJlY3QmJnNvdXJjZS5nZXRCb3VuZHMpIHsgcmVjdCA9IHNvdXJjZS5nZXRCb3VuZHMoKTsgfVxuXHRcdGlmICghcmVjdCkgeyByZXR1cm4gbnVsbDsgfVxuXHRcdHNjYWxlID0gc2NhbGV8fDE7XG5cdFx0cmV0dXJuIHRoaXMuX2ZyYW1lcy5wdXNoKHtzb3VyY2U6c291cmNlLCBzb3VyY2VSZWN0OnJlY3QsIHNjYWxlOnNjYWxlLCBmdW5jdDpzZXR1cEZ1bmN0aW9uLCBkYXRhOnNldHVwRGF0YSwgaW5kZXg6dGhpcy5fZnJhbWVzLmxlbmd0aCwgaGVpZ2h0OnJlY3QuaGVpZ2h0KnNjYWxlfSktMTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkcyBhbiBhbmltYXRpb24gdGhhdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBjcmVhdGVkIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGFkZEFuaW1hdGlvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBmb3IgdGhlIGFuaW1hdGlvbi5cblx0ICogQHBhcmFtIHtBcnJheX0gZnJhbWVzIEFuIGFycmF5IG9mIGZyYW1lIGluZGV4ZXMgdGhhdCBjb21wcmlzZSB0aGUgYW5pbWF0aW9uLiBFeC4gWzMsNiw1XSB3b3VsZCBkZXNjcmliZSBhbiBhbmltYXRpb25cblx0ICogdGhhdCBwbGF5ZWQgZnJhbWUgaW5kZXhlcyAzLCA2LCBhbmQgNSBpbiB0aGF0IG9yZGVyLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW25leHRdIFNwZWNpZmllcyB0aGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIGNvbnRpbnVlIHRvIGFmdGVyIHRoaXMgYW5pbWF0aW9uIGVuZHMuIFlvdSBjYW5cblx0ICogYWxzbyBwYXNzIGZhbHNlIHRvIGhhdmUgdGhlIGFuaW1hdGlvbiBzdG9wIHdoZW4gaXQgZW5kcy4gQnkgZGVmYXVsdCBpdCB3aWxsIGxvb3AgdG8gdGhlIHN0YXJ0IG9mIHRoZSBzYW1lIGFuaW1hdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gU3BlY2lmaWVzIGEgZnJhbWUgYWR2YW5jZSBzcGVlZCBmb3IgdGhpcyBhbmltYXRpb24uIEZvciBleGFtcGxlLCBhIHZhbHVlIG9mIDAuNSB3b3VsZFxuXHQgKiBjYXVzZSB0aGUgYW5pbWF0aW9uIHRvIGFkdmFuY2UgZXZlcnkgc2Vjb25kIHRpY2suIE5vdGUgdGhhdCBlYXJsaWVyIHZlcnNpb25zIHVzZWQgYGZyZXF1ZW5jeWAgaW5zdGVhZCwgd2hpY2ggaGFkXG5cdCAqIHRoZSBvcHBvc2l0ZSBlZmZlY3QuXG5cdCAqKi9cblx0cC5hZGRBbmltYXRpb24gPSBmdW5jdGlvbihuYW1lLCBmcmFtZXMsIG5leHQsIHNwZWVkKSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9SVU5OSU5HOyB9XG5cdFx0dGhpcy5fYW5pbWF0aW9uc1tuYW1lXSA9IHtmcmFtZXM6ZnJhbWVzLCBuZXh0Om5leHQsIHNwZWVkOnNwZWVkfTtcblx0fTtcblxuXHQvKipcblx0ICogVGhpcyB3aWxsIHRha2UgYSB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXBcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UsIGFuZCBhZGQgaXRzIGZyYW1lcyBhbmQgbGFiZWxzIHRvIHRoaXNcblx0ICogYnVpbGRlci4gTGFiZWxzIHdpbGwgYmUgYWRkZWQgYXMgYW4gYW5pbWF0aW9uIHJ1bm5pbmcgZnJvbSB0aGUgbGFiZWwgaW5kZXggdG8gdGhlIG5leHQgbGFiZWwuIEZvciBleGFtcGxlLCBpZlxuXHQgKiB0aGVyZSBpcyBhIGxhYmVsIG5hbWVkIFwiZm9vXCIgYXQgZnJhbWUgMCBhbmQgYSBsYWJlbCBuYW1lZCBcImJhclwiIGF0IGZyYW1lIDEwLCBpbiBhIE1vdmllQ2xpcCB3aXRoIDE1IGZyYW1lcywgaXRcblx0ICogd2lsbCBhZGQgYW4gYW5pbWF0aW9uIG5hbWVkIFwiZm9vXCIgdGhhdCBydW5zIGZyb20gZnJhbWUgaW5kZXggMCB0byA5LCBhbmQgYW4gYW5pbWF0aW9uIG5hbWVkIFwiYmFyXCIgdGhhdCBydW5zIGZyb21cblx0ICogZnJhbWUgaW5kZXggMTAgdG8gMTQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgaXRlcmF0ZSB0aHJvdWdoIHRoZSBmdWxsIE1vdmllQ2xpcCB3aXRoIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcC9hY3Rpb25zRW5hYmxlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBzZXQgdG8gYGZhbHNlYCwgZW5kaW5nIG9uIHRoZSBsYXN0IGZyYW1lLlxuXHQgKiBAbWV0aG9kIGFkZE1vdmllQ2xpcFxuXHQgKiBAcGFyYW0ge01vdmllQ2xpcH0gc291cmNlIFRoZSBzb3VyY2UgTW92aWVDbGlwIGluc3RhbmNlIHRvIGFkZCB0byB0aGUgU3ByaXRlU2hlZXQuXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBbc291cmNlUmVjdF0gQSB7eyNjcm9zc0xpbmsgXCJSZWN0YW5nbGVcIn19e3svY3Jvc3NMaW5rfX0gZGVmaW5pbmcgdGhlIHBvcnRpb24gb2YgdGhlIHNvdXJjZSB0b1xuXHQgKiBkcmF3IHRvIHRoZSBmcmFtZS4gSWYgbm90IHNwZWNpZmllZCwgaXQgd2lsbCBsb29rIGZvciBhIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvZ2V0Qm91bmRzXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCwgYGZyYW1lQm91bmRzYCBBcnJheSwgYGJvdW5kc2AgcHJvcGVydHksIG9yIGBub21pbmFsQm91bmRzYCBwcm9wZXJ0eSBvbiB0aGUgc291cmNlIHRvIHVzZS4gSWYgb25lIGlzIG5vdFxuXHQgKiBmb3VuZCwgdGhlIE1vdmllQ2xpcCB3aWxsIGJlIHNraXBwZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGU9MV0gVGhlIHNjYWxlIHRvIGRyYXcgdGhlIG1vdmllIGNsaXAgYXQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZXR1cEZ1bmN0aW9uXSBBIGZ1bmN0aW9uIHRvIGNhbGwgaW1tZWRpYXRlbHkgYmVmb3JlIGRyYXdpbmcgZWFjaCBmcmFtZS4gSXQgd2lsbCBiZSBjYWxsZWRcblx0ICogd2l0aCB0aHJlZSBwYXJhbWV0ZXJzOiB0aGUgc291cmNlLCBzZXR1cERhdGEsIGFuZCB0aGUgZnJhbWUgaW5kZXguXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbc2V0dXBEYXRhXSBBcmJpdHJhcnkgc2V0dXAgZGF0YSB0byBwYXNzIHRvIHNldHVwRnVuY3Rpb24gYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtsYWJlbEZ1bmN0aW9uXSBUaGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBNb3ZpZUNsaXAgbGFiZWwgdGhhdCBpcyBhZGRlZCB3aXRoIGZvdXJcblx0ICogcGFyYW1ldGVyczogdGhlIGxhYmVsIG5hbWUsIHRoZSBzb3VyY2UgTW92aWVDbGlwIGluc3RhbmNlLCB0aGUgc3RhcnRpbmcgZnJhbWUgaW5kZXggKGluIHRoZSBtb3ZpZWNsaXAgdGltZWxpbmUpXG5cdCAqIGFuZCB0aGUgZW5kIGluZGV4LiBJdCBtdXN0IHJldHVybiBhIG5ldyBuYW1lIGZvciB0aGUgbGFiZWwvYW5pbWF0aW9uLCBvciBgZmFsc2VgIHRvIGV4Y2x1ZGUgdGhlIGxhYmVsLlxuXHQgKiovXG5cdHAuYWRkTW92aWVDbGlwID0gZnVuY3Rpb24oc291cmNlLCBzb3VyY2VSZWN0LCBzY2FsZSwgc2V0dXBGdW5jdGlvbiwgc2V0dXBEYXRhLCBsYWJlbEZ1bmN0aW9uKSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9SVU5OSU5HOyB9XG5cdFx0dmFyIHJlY3RzID0gc291cmNlLmZyYW1lQm91bmRzO1xuXHRcdHZhciByZWN0ID0gc291cmNlUmVjdHx8c291cmNlLmJvdW5kc3x8c291cmNlLm5vbWluYWxCb3VuZHM7XG5cdFx0aWYgKCFyZWN0JiZzb3VyY2UuZ2V0Qm91bmRzKSB7IHJlY3QgPSBzb3VyY2UuZ2V0Qm91bmRzKCk7IH1cblx0XHRpZiAoIXJlY3QgJiYgIXJlY3RzKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGksIGwsIGJhc2VGcmFtZUluZGV4ID0gdGhpcy5fZnJhbWVzLmxlbmd0aDtcblx0XHR2YXIgZHVyYXRpb24gPSBzb3VyY2UudGltZWxpbmUuZHVyYXRpb247XG5cdFx0Zm9yIChpPTA7IGk8ZHVyYXRpb247IGkrKykge1xuXHRcdFx0dmFyIHIgPSAocmVjdHMmJnJlY3RzW2ldKSA/IHJlY3RzW2ldIDogcmVjdDtcblx0XHRcdHRoaXMuYWRkRnJhbWUoc291cmNlLCByLCBzY2FsZSwgdGhpcy5fc2V0dXBNb3ZpZUNsaXBGcmFtZSwge2k6aSwgZjpzZXR1cEZ1bmN0aW9uLCBkOnNldHVwRGF0YX0pO1xuXHRcdH1cblx0XHR2YXIgbGFiZWxzID0gc291cmNlLnRpbWVsaW5lLl9sYWJlbHM7XG5cdFx0dmFyIGxibHMgPSBbXTtcblx0XHRmb3IgKHZhciBuIGluIGxhYmVscykge1xuXHRcdFx0bGJscy5wdXNoKHtpbmRleDpsYWJlbHNbbl0sIGxhYmVsOm59KTtcblx0XHR9XG5cdFx0aWYgKGxibHMubGVuZ3RoKSB7XG5cdFx0XHRsYmxzLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEuaW5kZXgtYi5pbmRleDsgfSk7XG5cdFx0XHRmb3IgKGk9MCxsPWxibHMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0XHR2YXIgbGFiZWwgPSBsYmxzW2ldLmxhYmVsO1xuXHRcdFx0XHR2YXIgc3RhcnQgPSBiYXNlRnJhbWVJbmRleCtsYmxzW2ldLmluZGV4O1xuXHRcdFx0XHR2YXIgZW5kID0gYmFzZUZyYW1lSW5kZXgrKChpID09IGwtMSkgPyBkdXJhdGlvbiA6IGxibHNbaSsxXS5pbmRleCk7XG5cdFx0XHRcdHZhciBmcmFtZXMgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaj1zdGFydDsgajxlbmQ7IGorKykgeyBmcmFtZXMucHVzaChqKTsgfVxuXHRcdFx0XHRpZiAobGFiZWxGdW5jdGlvbikge1xuXHRcdFx0XHRcdGxhYmVsID0gbGFiZWxGdW5jdGlvbihsYWJlbCwgc291cmNlLCBzdGFydCwgZW5kKTtcblx0XHRcdFx0XHRpZiAoIWxhYmVsKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hZGRBbmltYXRpb24obGFiZWwsIGZyYW1lcywgdHJ1ZSk7IC8vIGZvciBub3csIHRoaXMgbG9vcHMgYWxsIGFuaW1hdGlvbnMuXG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBCdWlsZHMgYSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBmcmFtZXMuXG5cdCAqIEBtZXRob2QgYnVpbGRcblx0ICogQHJldHVybiB7U3ByaXRlU2hlZXR9IFRoZSBjcmVhdGVkIFNwcml0ZVNoZWV0IGluc3RhbmNlLCBvciBudWxsIGlmIGEgYnVpbGQgaXMgYWxyZWFkeSBydW5uaW5nIG9yIGFuIGVycm9yXG5cdCAqIG9jY3VycmVkLlxuXHQgKiovXG5cdHAuYnVpbGQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fZGF0YSkgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX1JVTk5JTkc7IH1cblx0XHR0aGlzLl9zdGFydEJ1aWxkKCk7XG5cdFx0d2hpbGUgKHRoaXMuX2RyYXdOZXh0KCkpIHt9XG5cdFx0dGhpcy5fZW5kQnVpbGQoKTtcblx0XHRyZXR1cm4gdGhpcy5zcHJpdGVTaGVldDtcblx0fTtcblxuXHQvKipcblx0ICogQXN5bmNocm9ub3VzbHkgYnVpbGRzIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZnJhbWVzLiBJdCB3aWxsXG5cdCAqIHJ1biAyMCB0aW1lcyBwZXIgc2Vjb25kLCB1c2luZyBhbiBhbW91bnQgb2YgdGltZSBkZWZpbmVkIGJ5IGB0aW1lU2xpY2VgLiBXaGVuIGl0IGlzIGNvbXBsZXRlIGl0IHdpbGwgY2FsbCB0aGVcblx0ICogc3BlY2lmaWVkIGNhbGxiYWNrLlxuXHQgKiBAbWV0aG9kIGJ1aWxkQXN5bmNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lU2xpY2VdIFNldHMgdGhlIHRpbWVTbGljZSBwcm9wZXJ0eSBvbiB0aGlzIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuYnVpbGRBc3luYyA9IGZ1bmN0aW9uKHRpbWVTbGljZSkge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORzsgfVxuXHRcdHRoaXMudGltZVNsaWNlID0gdGltZVNsaWNlO1xuXHRcdHRoaXMuX3N0YXJ0QnVpbGQoKTtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHRoaXMuX3RpbWVySUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBfdGhpcy5fcnVuKCk7IH0sIDUwLU1hdGgubWF4KDAuMDEsIE1hdGgubWluKDAuOTksIHRoaXMudGltZVNsaWNlfHwwLjMpKSo1MCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3BzIHRoZSBjdXJyZW50IGFzeW5jaHJvbm91cyBidWlsZC5cblx0ICogQG1ldGhvZCBzdG9wQXN5bmNcblx0ICoqL1xuXHRwLnN0b3BBc3luYyA9IGZ1bmN0aW9uKCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcklEKTtcblx0XHR0aGlzLl9kYXRhID0gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogU3ByaXRlU2hlZXRCdWlsZGVyIGluc3RhbmNlcyBjYW5ub3QgYmUgY2xvbmVkLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRocm93KFwiU3ByaXRlU2hlZXRCdWlsZGVyIGNhbm5vdCBiZSBjbG9uZWQuXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbU3ByaXRlU2hlZXRCdWlsZGVyXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX3N0YXJ0QnVpbGRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3N0YXJ0QnVpbGQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFkID0gdGhpcy5wYWRkaW5nfHwwO1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSAwO1xuXHRcdHRoaXMuc3ByaXRlU2hlZXQgPSBudWxsO1xuXHRcdHRoaXMuX2luZGV4ID0gMDtcblx0XHR0aGlzLl9zY2FsZSA9IHRoaXMuc2NhbGU7XG5cdFx0dmFyIGRhdGFGcmFtZXMgPSBbXTtcblx0XHR0aGlzLl9kYXRhID0ge1xuXHRcdFx0aW1hZ2VzOiBbXSxcblx0XHRcdGZyYW1lczogZGF0YUZyYW1lcyxcblx0XHRcdGZyYW1lcmF0ZTogdGhpcy5mcmFtZXJhdGUsXG5cdFx0XHRhbmltYXRpb25zOiB0aGlzLl9hbmltYXRpb25zIC8vIFRPRE86IHNob3VsZCB3ZSBcImNsb25lXCIgX2FuaW1hdGlvbnMgaW4gY2FzZSBzb21lb25lIGFkZHMgbW9yZSBhbmltYXRpb25zIGFmdGVyIGEgYnVpbGQ/XG5cdFx0fTtcblxuXHRcdHZhciBmcmFtZXMgPSB0aGlzLl9mcmFtZXMuc2xpY2UoKTtcblx0XHRmcmFtZXMuc29ydChmdW5jdGlvbihhLGIpIHsgcmV0dXJuIChhLmhlaWdodDw9Yi5oZWlnaHQpID8gLTEgOiAxOyB9KTtcblxuXHRcdGlmIChmcmFtZXNbZnJhbWVzLmxlbmd0aC0xXS5oZWlnaHQrcGFkKjIgPiB0aGlzLm1heEhlaWdodCkgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX0RJTUVOU0lPTlM7IH1cblx0XHR2YXIgeT0wLCB4PTA7XG5cdFx0dmFyIGltZyA9IDA7XG5cdFx0d2hpbGUgKGZyYW1lcy5sZW5ndGgpIHtcblx0XHRcdHZhciBvID0gdGhpcy5fZmlsbFJvdyhmcmFtZXMsIHksIGltZywgZGF0YUZyYW1lcywgcGFkKTtcblx0XHRcdGlmIChvLncgPiB4KSB7IHggPSBvLnc7IH1cblx0XHRcdHkgKz0gby5oO1xuXHRcdFx0aWYgKCFvLmggfHwgIWZyYW1lcy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGNhbnZhcyA9IGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHRcdFx0XHRjYW52YXMud2lkdGggPSB0aGlzLl9nZXRTaXplKHgsdGhpcy5tYXhXaWR0aCk7XG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSB0aGlzLl9nZXRTaXplKHksdGhpcy5tYXhIZWlnaHQpO1xuXHRcdFx0XHR0aGlzLl9kYXRhLmltYWdlc1tpbWddID0gY2FudmFzO1xuXHRcdFx0XHRpZiAoIW8uaCkge1xuXHRcdFx0XHRcdHg9eT0wO1xuXHRcdFx0XHRcdGltZysrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX3NldHVwTW92aWVDbGlwRnJhbWVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB3aWR0aCAmIGhlaWdodCBvZiB0aGUgcm93LlxuXHQgKiovXG5cdHAuX3NldHVwTW92aWVDbGlwRnJhbWUgPSBmdW5jdGlvbihzb3VyY2UsIGRhdGEpIHtcblx0XHR2YXIgYWUgPSBzb3VyY2UuYWN0aW9uc0VuYWJsZWQ7XG5cdFx0c291cmNlLmFjdGlvbnNFbmFibGVkID0gZmFsc2U7XG5cdFx0c291cmNlLmdvdG9BbmRTdG9wKGRhdGEuaSk7XG5cdFx0c291cmNlLmFjdGlvbnNFbmFibGVkID0gYWU7XG5cdFx0ZGF0YS5mJiZkYXRhLmYoc291cmNlLCBkYXRhLmQsIGRhdGEuaSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFNpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB3aWR0aCAmIGhlaWdodCBvZiB0aGUgcm93LlxuXHQgKiovXG5cdHAuX2dldFNpemUgPSBmdW5jdGlvbihzaXplLG1heCkge1xuXHRcdHZhciBwb3cgPSA0O1xuXHRcdHdoaWxlIChNYXRoLnBvdygyLCsrcG93KSA8IHNpemUpe31cblx0XHRyZXR1cm4gTWF0aC5taW4obWF4LE1hdGgucG93KDIscG93KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2ZpbGxSb3dcblx0ICogQHBhcmFtIHtBcnJheX0gZnJhbWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1nXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhRnJhbWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWRcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB3aWR0aCAmIGhlaWdodCBvZiB0aGUgcm93LlxuXHQgKiovXG5cdHAuX2ZpbGxSb3cgPSBmdW5jdGlvbihmcmFtZXMsIHksIGltZywgZGF0YUZyYW1lcywgcGFkKSB7XG5cdFx0dmFyIHcgPSB0aGlzLm1heFdpZHRoO1xuXHRcdHZhciBtYXhIID0gdGhpcy5tYXhIZWlnaHQ7XG5cdFx0eSArPSBwYWQ7XG5cdFx0dmFyIGggPSBtYXhILXk7XG5cdFx0dmFyIHggPSBwYWQ7XG5cdFx0dmFyIGhlaWdodCA9IDA7XG5cdFx0Zm9yICh2YXIgaT1mcmFtZXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0dmFyIGZyYW1lID0gZnJhbWVzW2ldO1xuXHRcdFx0dmFyIHNjID0gdGhpcy5fc2NhbGUqZnJhbWUuc2NhbGU7XG5cdFx0XHR2YXIgcmVjdCA9IGZyYW1lLnNvdXJjZVJlY3Q7XG5cdFx0XHR2YXIgc291cmNlID0gZnJhbWUuc291cmNlO1xuXHRcdFx0dmFyIHJ4ID0gTWF0aC5mbG9vcihzYypyZWN0LngtcGFkKTtcblx0XHRcdHZhciByeSA9IE1hdGguZmxvb3Ioc2MqcmVjdC55LXBhZCk7XG5cdFx0XHR2YXIgcmggPSBNYXRoLmNlaWwoc2MqcmVjdC5oZWlnaHQrcGFkKjIpO1xuXHRcdFx0dmFyIHJ3ID0gTWF0aC5jZWlsKHNjKnJlY3Qud2lkdGgrcGFkKjIpO1xuXHRcdFx0aWYgKHJ3ID4gdykgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX0RJTUVOU0lPTlM7IH1cblx0XHRcdGlmIChyaCA+IGggfHwgeCtydyA+IHcpIHsgY29udGludWU7IH1cblx0XHRcdGZyYW1lLmltZyA9IGltZztcblx0XHRcdGZyYW1lLnJlY3QgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKHgseSxydyxyaCk7XG5cdFx0XHRoZWlnaHQgPSBoZWlnaHQgfHwgcmg7XG5cdFx0XHRmcmFtZXMuc3BsaWNlKGksMSk7XG5cdFx0XHRkYXRhRnJhbWVzW2ZyYW1lLmluZGV4XSA9IFt4LHkscncscmgsaW1nLE1hdGgucm91bmQoLXJ4K3NjKnNvdXJjZS5yZWdYLXBhZCksTWF0aC5yb3VuZCgtcnkrc2Mqc291cmNlLnJlZ1ktcGFkKV07XG5cdFx0XHR4ICs9IHJ3O1xuXHRcdH1cblx0XHRyZXR1cm4ge3c6eCwgaDpoZWlnaHR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9lbmRCdWlsZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZW5kQnVpbGQgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnNwcml0ZVNoZWV0ID0gbmV3IGNyZWF0ZWpzLlNwcml0ZVNoZWV0KHRoaXMuX2RhdGEpO1xuXHRcdHRoaXMuX2RhdGEgPSBudWxsO1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSAxO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9ydW5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3J1biA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0cyA9IE1hdGgubWF4KDAuMDEsIE1hdGgubWluKDAuOTksIHRoaXMudGltZVNsaWNlfHwwLjMpKSo1MDtcblx0XHR2YXIgdCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkrdHM7XG5cdFx0dmFyIGNvbXBsZXRlID0gZmFsc2U7XG5cdFx0d2hpbGUgKHQgPiAobmV3IERhdGUoKSkuZ2V0VGltZSgpKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2RyYXdOZXh0KCkpIHsgY29tcGxldGUgPSB0cnVlOyBicmVhazsgfVxuXHRcdH1cblx0XHRpZiAoY29tcGxldGUpIHtcblx0XHRcdHRoaXMuX2VuZEJ1aWxkKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHR0aGlzLl90aW1lcklEID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgX3RoaXMuX3J1bigpOyB9LCA1MC10cyk7XG5cdFx0fVxuXHRcdHZhciBwID0gdGhpcy5wcm9ncmVzcyA9IHRoaXMuX2luZGV4L3RoaXMuX2ZyYW1lcy5sZW5ndGg7XG5cdFx0aWYgKHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIpKSB7XG5cdFx0XHR2YXIgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwicHJvZ3Jlc3NcIik7XG5cdFx0XHRldnQucHJvZ3Jlc3MgPSBwO1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9kcmF3TmV4dFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4gQm9vbGVhbiBSZXR1cm5zIGZhbHNlIGlmIHRoaXMgaXMgdGhlIGxhc3QgZHJhdy5cblx0ICoqL1xuXHRwLl9kcmF3TmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmcmFtZSA9IHRoaXMuX2ZyYW1lc1t0aGlzLl9pbmRleF07XG5cdFx0dmFyIHNjID0gZnJhbWUuc2NhbGUqdGhpcy5fc2NhbGU7XG5cdFx0dmFyIHJlY3QgPSBmcmFtZS5yZWN0O1xuXHRcdHZhciBzb3VyY2VSZWN0ID0gZnJhbWUuc291cmNlUmVjdDtcblx0XHR2YXIgY2FudmFzID0gdGhpcy5fZGF0YS5pbWFnZXNbZnJhbWUuaW1nXTtcblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRmcmFtZS5mdW5jdCYmZnJhbWUuZnVuY3QoZnJhbWUuc291cmNlLCBmcmFtZS5kYXRhKTtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgucmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHRcdGN0eC5jbGlwKCk7XG5cdFx0Y3R4LnRyYW5zbGF0ZShNYXRoLmNlaWwocmVjdC54LXNvdXJjZVJlY3QueCpzYyksIE1hdGguY2VpbChyZWN0Lnktc291cmNlUmVjdC55KnNjKSk7XG5cdFx0Y3R4LnNjYWxlKHNjLHNjKTtcblx0XHRmcmFtZS5zb3VyY2UuZHJhdyhjdHgpOyAvLyBkaXNwbGF5IG9iamVjdCB3aWxsIGRyYXcgaXRzZWxmLlxuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0cmV0dXJuICgrK3RoaXMuX2luZGV4KSA8IHRoaXMuX2ZyYW1lcy5sZW5ndGg7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5TcHJpdGVTaGVldEJ1aWxkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFNwcml0ZVNoZWV0QnVpbGRlciwgXCJFdmVudERpc3BhdGNoZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRE9NRWxlbWVudC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIDxiPlRoaXMgY2xhc3MgaXMgc3RpbGwgZXhwZXJpbWVudGFsLCBhbmQgbW9yZSBhZHZhbmNlZCB1c2UgaXMgbGlrZWx5IHRvIGJlIGJ1Z2d5LiBQbGVhc2UgcmVwb3J0IGJ1Z3MuPC9iPlxuXHQgKlxuXHQgKiBBIERPTUVsZW1lbnQgYWxsb3dzIHlvdSB0byBhc3NvY2lhdGUgYSBIVE1MRWxlbWVudCB3aXRoIHRoZSBkaXNwbGF5IGxpc3QuIEl0IHdpbGwgYmUgdHJhbnNmb3JtZWRcblx0ICogd2l0aGluIHRoZSBET00gYXMgdGhvdWdoIGl0IGlzIGNoaWxkIG9mIHRoZSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0gaXQgaXMgYWRkZWQgdG8uIEhvd2V2ZXIsIGl0IGlzXG5cdCAqIG5vdCByZW5kZXJlZCB0byBjYW52YXMsIGFuZCBhcyBzdWNoIHdpbGwgcmV0YWluIHdoYXRldmVyIHotaW5kZXggaXQgaGFzIHJlbGF0aXZlIHRvIHRoZSBjYW52YXMgKGllLiBpdCB3aWxsIGJlXG5cdCAqIGRyYXduIGluIGZyb250IG9mIG9yIGJlaGluZCB0aGUgY2FudmFzKS5cblx0ICpcblx0ICogVGhlIHBvc2l0aW9uIG9mIGEgRE9NRWxlbWVudCBpcyByZWxhdGl2ZSB0byB0aGVpciBwYXJlbnQgbm9kZSBpbiB0aGUgRE9NLiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0XG5cdCAqIHRoZSBET00gT2JqZWN0IGJlIGFkZGVkIHRvIGEgZGl2IHRoYXQgYWxzbyBjb250YWlucyB0aGUgY2FudmFzIHNvIHRoYXQgdGhleSBzaGFyZSB0aGUgc2FtZSBwb3NpdGlvblxuXHQgKiBvbiB0aGUgcGFnZS5cblx0ICpcblx0ICogRE9NRWxlbWVudCBpcyB1c2VmdWwgZm9yIHBvc2l0aW9uaW5nIEhUTUwgZWxlbWVudHMgb3ZlciB0b3Agb2YgY2FudmFzIGNvbnRlbnQsIGFuZCBmb3IgZWxlbWVudHNcblx0ICogdGhhdCB5b3Ugd2FudCB0byBkaXNwbGF5IG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGUgY2FudmFzLiBGb3IgZXhhbXBsZSwgYSB0b29sdGlwIHdpdGggcmljaCBIVE1MXG5cdCAqIGNvbnRlbnQuXG5cdCAqXG5cdCAqIDxoND5Nb3VzZSBJbnRlcmFjdGlvbjwvaDQ+XG5cdCAqXG5cdCAqIERPTUVsZW1lbnQgaW5zdGFuY2VzIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cywgYW5kIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBFYXNlbEpTIG1vdXNlXG5cdCAqIGV2ZW50cyBvciBzdXBwb3J0IG1ldGhvZHMgbGlrZSBoaXRUZXN0LiBUbyBnZXQgbW91c2UgZXZlbnRzIGZyb20gYSBET01FbGVtZW50LCB5b3UgbXVzdCBpbnN0ZWFkIGFkZCBoYW5kbGVycyB0b1xuXHQgKiB0aGUgaHRtbEVsZW1lbnQgKG5vdGUsIHRoaXMgZG9lcyBub3Qgc3VwcG9ydCBFdmVudERpc3BhdGNoZXIpXG5cdCAqXG5cdCAqICAgICAgdmFyIGRvbUVsZW1lbnQgPSBuZXcgY3JlYXRlanMuRE9NRWxlbWVudChodG1sRWxlbWVudCk7XG5cdCAqICAgICAgZG9tRWxlbWVudC5odG1sRWxlbWVudC5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2xpY2tlZFwiKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBjbGFzcyBET01FbGVtZW50XG5cdCAqIEBleHRlbmRzIERpc3BsYXlPYmplY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGh0bWxFbGVtZW50IEEgcmVmZXJlbmNlIG9yIGlkIGZvciB0aGUgRE9NIGVsZW1lbnQgdG8gbWFuYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gRE9NRWxlbWVudChodG1sRWxlbWVudCkge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdGlmICh0eXBlb2YoaHRtbEVsZW1lbnQpPT1cInN0cmluZ1wiKSB7IGh0bWxFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaHRtbEVsZW1lbnQpOyB9XG5cdFx0dGhpcy5tb3VzZUVuYWJsZWQgPSBmYWxzZTtcblx0XHRcblx0XHR2YXIgc3R5bGUgPSBodG1sRWxlbWVudC5zdHlsZTtcblx0XHRzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS5XZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS5tc1RyYW5zZm9ybU9yaWdpbiA9IHN0eWxlLk1velRyYW5zZm9ybU9yaWdpbiA9IHN0eWxlLk9UcmFuc2Zvcm1PcmlnaW4gPSBcIjAlIDAlXCI7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBET00gb2JqZWN0IHRvIG1hbmFnZS5cblx0XHQgKiBAcHJvcGVydHkgaHRtbEVsZW1lbnRcblx0XHQgKiBAdHlwZSBIVE1MRWxlbWVudFxuXHRcdCAqL1xuXHRcdHRoaXMuaHRtbEVsZW1lbnQgPSBodG1sRWxlbWVudDtcblx0XG5cdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9vbGRNdHhcblx0XHQgKiBAdHlwZSBNYXRyaXgyRFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9vbGRQcm9wcyA9IG51bGw7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoRE9NRWxlbWVudCwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmh0bWxFbGVtZW50ICE9IG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlQ2FjaGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuXG5cdCAqIEZvciBleGFtcGxlLCB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2tcblx0ICogaW50byBpdHNlbGYpLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdC8vIHRoaXMgcmVsaWVzIG9uIHRoZSBfdGljayBtZXRob2QgYmVjYXVzZSBkcmF3IGlzbid0IGNhbGxlZCBpZiB0aGUgcGFyZW50IGlzIG5vdCB2aXNpYmxlLlxuXHRcdC8vIHRoZSBhY3R1YWwgdXBkYXRlIGhhcHBlbnMgaW4gX2hhbmRsZURyYXdFbmRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCBjYWNoZVxuXHQgKi9cblx0cC5jYWNoZSA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgdW5jYWNoZVxuXHQgKi9cblx0cC51bmNhY2hlID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCB1cGRhdGVDYWNoZVxuXHQgKi9cblx0cC51cGRhdGVDYWNoZSA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgaGl0VGVzdFxuXHQgKi9cblx0cC5oaXRUZXN0ID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCBsb2NhbFRvR2xvYmFsXG5cdCAqL1xuXHRwLmxvY2FsVG9HbG9iYWwgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgKiBAbWV0aG9kIGdsb2JhbFRvTG9jYWxcblx0ICovXG5cdHAuZ2xvYmFsVG9Mb2NhbCA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgbG9jYWxUb0xvY2FsXG5cdCAqL1xuXHRwLmxvY2FsVG9Mb2NhbCA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIERPTUVsZW1lbnQgY2Fubm90IGJlIGNsb25lZC4gVGhyb3dzIGFuIGVycm9yLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJET01FbGVtZW50IGNhbm5vdCBiZSBjbG9uZWQuXCIpXG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0RPTUVsZW1lbnQgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcblx0fTtcblxuXHQvKipcbiAgICAgKiBJbnRlcmFjdGlvbiBldmVudHMgc2hvdWxkIGJlIGFkZGVkIHRvIGBodG1sRWxlbWVudGAsIGFuZCBub3QgdGhlIERPTUVsZW1lbnQgaW5zdGFuY2UsIHNpbmNlIERPTUVsZW1lbnQgaW5zdGFuY2VzXG5cdCAqIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cyBhbmQgZG8gbm90IHBhcnRpY2lwYXRlIGluIEVhc2VsSlMgbW91c2UgZXZlbnRzLlxuXHQgKiBAZXZlbnQgY2xpY2tcblx0ICovXG5cbiAgICAgLyoqXG4gICAgICogSW50ZXJhY3Rpb24gZXZlbnRzIHNob3VsZCBiZSBhZGRlZCB0byBgaHRtbEVsZW1lbnRgLCBhbmQgbm90IHRoZSBET01FbGVtZW50IGluc3RhbmNlLCBzaW5jZSBET01FbGVtZW50IGluc3RhbmNlc1xuIFx0ICogYXJlIG5vdCBmdWxsIEVhc2VsSlMgZGlzcGxheSBvYmplY3RzIGFuZCBkbyBub3QgcGFydGljaXBhdGUgaW4gRWFzZWxKUyBtb3VzZSBldmVudHMuXG5cdCAqIEBldmVudCBkYmxDbGlja1xuXHQgKi9cblxuICAgICAvKipcbiAgICAgICogSW50ZXJhY3Rpb24gZXZlbnRzIHNob3VsZCBiZSBhZGRlZCB0byBgaHRtbEVsZW1lbnRgLCBhbmQgbm90IHRoZSBET01FbGVtZW50IGluc3RhbmNlLCBzaW5jZSBET01FbGVtZW50IGluc3RhbmNlc1xuIFx0ICAqIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cyBhbmQgZG8gbm90IHBhcnRpY2lwYXRlIGluIEVhc2VsSlMgbW91c2UgZXZlbnRzLlxuXHQgICogQGV2ZW50IG1vdXNlZG93blxuXHQgICovXG5cbiAgICAgLyoqXG4gICAgICAqIFRoZSBIVE1MRWxlbWVudCBjYW4gbGlzdGVuIGZvciB0aGUgbW91c2VvdmVyIGV2ZW50LCBub3QgdGhlIERPTUVsZW1lbnQgaW5zdGFuY2UuXG4gICAgICAqIFNpbmNlIERPTUVsZW1lbnQgaW5zdGFuY2VzIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cyBhbmQgZG8gbm90IHBhcnRpY2lwYXRlIGluIEVhc2VsSlMgbW91c2UgZXZlbnRzLlxuICAgICAgKiBAZXZlbnQgbW91c2VvdmVyXG5cdCAgKi9cblxuICAgICAvKipcbiAgICAgICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICAqIEBldmVudCB0aWNrXG5cdCAgKi9cblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF90aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldnRPYmogQW4gZXZlbnQgb2JqZWN0IHRoYXQgd2lsbCBiZSBkaXNwYXRjaGVkIHRvIGFsbCB0aWNrIGxpc3RlbmVycy4gVGhpcyBvYmplY3QgaXMgcmV1c2VkIGJldHdlZW4gZGlzcGF0Y2hlcnMgdG8gcmVkdWNlIGNvbnN0cnVjdGlvbiAmIEdDIGNvc3RzLlxuXHQgKiBmdW5jdGlvbi5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fdGljayA9IGZ1bmN0aW9uKGV2dE9iaikge1xuXHRcdHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcblx0XHRzdGFnZSYmc3RhZ2Uub24oXCJkcmF3ZW5kXCIsIHRoaXMuX2hhbmRsZURyYXdFbmQsIHRoaXMsIHRydWUpO1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fdGljayhldnRPYmopO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZURyYXdFbmRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZ0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2hhbmRsZURyYXdFbmQgPSBmdW5jdGlvbihldnQpIHtcblx0XHR2YXIgbyA9IHRoaXMuaHRtbEVsZW1lbnQ7XG5cdFx0aWYgKCFvKSB7IHJldHVybjsgfVxuXHRcdHZhciBzdHlsZSA9IG8uc3R5bGU7XG5cdFx0XG5cdFx0dmFyIHByb3BzID0gdGhpcy5nZXRDb25jYXRlbmF0ZWREaXNwbGF5UHJvcHModGhpcy5fcHJvcHMpLCBtdHggPSBwcm9wcy5tYXRyaXg7XG5cdFx0XG5cdFx0dmFyIHZpc2liaWxpdHkgPSBwcm9wcy52aXNpYmxlID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiO1xuXHRcdGlmICh2aXNpYmlsaXR5ICE9IHN0eWxlLnZpc2liaWxpdHkpIHsgc3R5bGUudmlzaWJpbGl0eSA9IHZpc2liaWxpdHk7IH1cblx0XHRpZiAoIXByb3BzLnZpc2libGUpIHsgcmV0dXJuOyB9XG5cdFx0XG5cdFx0dmFyIG9sZFByb3BzID0gdGhpcy5fb2xkUHJvcHMsIG9sZE10eCA9IG9sZFByb3BzJiZvbGRQcm9wcy5tYXRyaXg7XG5cdFx0dmFyIG4gPSAxMDAwMDsgLy8gcHJlY2lzaW9uXG5cdFx0XG5cdFx0aWYgKCFvbGRNdHggfHwgIW9sZE10eC5lcXVhbHMobXR4KSkge1xuXHRcdFx0dmFyIHN0ciA9IFwibWF0cml4KFwiICsgKG10eC5hKm58MCkvbiArXCIsXCIrIChtdHguYipufDApL24gK1wiLFwiKyAobXR4LmMqbnwwKS9uICtcIixcIisgKG10eC5kKm58MCkvbiArXCIsXCIrIChtdHgudHgrMC41fDApO1xuXHRcdFx0c3R5bGUudHJhbnNmb3JtID0gc3R5bGUuV2Via2l0VHJhbnNmb3JtID0gc3R5bGUuT1RyYW5zZm9ybSA9IHN0eWxlLm1zVHJhbnNmb3JtID0gc3RyICtcIixcIisgKG10eC50eSswLjV8MCkgK1wiKVwiO1xuXHRcdFx0c3R5bGUuTW96VHJhbnNmb3JtID0gc3RyICtcInB4LFwiKyAobXR4LnR5KzAuNXwwKSArXCJweClcIjtcblx0XHRcdGlmICghb2xkUHJvcHMpIHsgb2xkUHJvcHMgPSB0aGlzLl9vbGRQcm9wcyA9IG5ldyBjcmVhdGVqcy5EaXNwbGF5UHJvcHModHJ1ZSwgTmFOKTsgfVxuXHRcdFx0b2xkUHJvcHMubWF0cml4LmNvcHkobXR4KTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKG9sZFByb3BzLmFscGhhICE9IHByb3BzLmFscGhhKSB7XG5cdFx0XHRzdHlsZS5vcGFjaXR5ID0gXCJcIisocHJvcHMuYWxwaGEqbnwwKS9uO1xuXHRcdFx0b2xkUHJvcHMuYWxwaGEgPSBwcm9wcy5hbHBoYTtcblx0XHR9XG5cdH07XG5cblxuXHRjcmVhdGVqcy5ET01FbGVtZW50ID0gY3JlYXRlanMucHJvbW90ZShET01FbGVtZW50LCBcIkRpc3BsYXlPYmplY3RcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRmlsdGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQmFzZSBjbGFzcyB0aGF0IGFsbCBmaWx0ZXJzIHNob3VsZCBpbmhlcml0IGZyb20uIEZpbHRlcnMgbmVlZCB0byBiZSBhcHBsaWVkIHRvIG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gY2FjaGVkIHVzaW5nXG5cdCAqIHRoZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2NhY2hlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC4gSWYgYW4gb2JqZWN0IGNoYW5nZXMsIHBsZWFzZSBjYWNoZSBpdCBhZ2Fpbiwgb3IgdXNlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvdXBkYXRlQ2FjaGVcIn19e3svY3Jvc3NMaW5rfX0uIE5vdGUgdGhhdCB0aGUgZmlsdGVycyBtdXN0IGJlIGFwcGxpZWQgYmVmb3JlIGNhY2hpbmcuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBteUluc3RhbmNlLmZpbHRlcnMgPSBbXG5cdCAqICAgICAgICAgIG5ldyBjcmVhdGVqcy5Db2xvckZpbHRlcigwLCAwLCAwLCAxLCAyNTUsIDAsIDApLFxuXHQgKiAgICAgICAgICBuZXcgY3JlYXRlanMuQmx1ckZpbHRlcig1LCA1LCAxMClcblx0ICogICAgICBdO1xuXHQgKiAgICAgIG15SW5zdGFuY2UuY2FjaGUoMCwwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBlYWNoIGZpbHRlciBjYW4gaW1wbGVtZW50IGEge3sjY3Jvc3NMaW5rIFwiRmlsdGVyL2dldEJvdW5kc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QsIHdoaWNoIHJldHVybnMgdGhlXG5cdCAqIG1hcmdpbnMgdGhhdCBuZWVkIHRvIGJlIGFwcGxpZWQgaW4gb3JkZXIgdG8gZnVsbHkgZGlzcGxheSB0aGUgZmlsdGVyLiBGb3IgZXhhbXBsZSwgdGhlIHt7I2Nyb3NzTGluayBcIkJsdXJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2lsbCBjYXVzZSBhbiBvYmplY3QgdG8gZmVhdGhlciBvdXR3YXJkcywgcmVzdWx0aW5nIGluIGEgbWFyZ2luIGFyb3VuZCB0aGUgc2hhcGUuXG5cdCAqXG5cdCAqIDxoND5FYXNlbEpTIEZpbHRlcnM8L2g0PlxuXHQgKiBFYXNlbEpTIGNvbWVzIHdpdGggYSBudW1iZXIgb2YgcHJlLWJ1aWx0IGZpbHRlcnM6XG5cdCAqIDx1bD48bGk+e3sjY3Jvc3NMaW5rIFwiQWxwaGFNYXBGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0gOiBNYXAgYSBncmV5c2NhbGUgaW1hZ2UgdG8gdGhlIGFscGhhIGNoYW5uZWwgb2YgYSBkaXNwbGF5IG9iamVjdDwvbGk+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFscGhhTWFza0ZpbHRlclwifX17ey9jcm9zc0xpbmt9fTogTWFwIGFuIGltYWdlJ3MgYWxwaGEgY2hhbm5lbCB0byB0aGUgYWxwaGEgY2hhbm5lbCBvZiBhIGRpc3BsYXkgb2JqZWN0PC9saT5cblx0ICogICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQmx1ckZpbHRlclwifX17ey9jcm9zc0xpbmt9fTogQXBwbHkgdmVydGljYWwgYW5kIGhvcml6b250YWwgYmx1ciB0byBhIGRpc3BsYXkgb2JqZWN0PC9saT5cblx0ICogICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQ29sb3JGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX06IENvbG9yIHRyYW5zZm9ybSBhIGRpc3BsYXkgb2JqZWN0PC9saT5cblx0ICogICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQ29sb3JNYXRyaXhGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX06IFRyYW5zZm9ybSBhbiBpbWFnZSB1c2luZyBhIHt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4XCJ9fXt7L2Nyb3NzTGlua319PC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogQGNsYXNzIEZpbHRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBGaWx0ZXIoKSB7fVxuXHR2YXIgcCA9IEZpbHRlci5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUHJvdmlkZXMgcGFkZGluZyB2YWx1ZXMgZm9yIHRoaXMgZmlsdGVyLiBUaGF0IGlzLCBob3cgbXVjaCB0aGUgZmlsdGVyIHdpbGwgZXh0ZW5kIHRoZSB2aXN1YWwgYm91bmRzIG9mIGFuIG9iamVjdCBpdCBpcyBhcHBsaWVkIHRvLlxuXHQgKiBAbWV0aG9kIGdldEJvdW5kc1xuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gW3JlY3RdIElmIHNwZWNpZmllZCwgdGhlIHByb3ZpZGVkIFJlY3RhbmdsZSBpbnN0YW5jZSB3aWxsIGJlIGV4cGFuZGVkIGJ5IHRoZSBwYWRkaW5nIGFtb3VudHMgYW5kIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IElmIGEgYHJlY3RgIHBhcmFtIHdhcyBwcm92aWRlZCwgaXQgaXMgcmV0dXJuZWQuIElmIG5vdCwgZWl0aGVyIGEgbmV3IHJlY3RhbmdsZSB3aXRoIHRoZSBwYWRkaW5nIHZhbHVlcywgb3IgbnVsbCBpZiBubyBwYWRkaW5nIGlzIHJlcXVpcmVkIGZvciB0aGlzIGZpbHRlci5cblx0ICoqL1xuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHRyZXR1cm4gcmVjdDtcblx0fTtcblxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgZmlsdGVyIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cblx0ICogQG1ldGhvZCBhcHBseUZpbHRlclxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSAyRCBjb250ZXh0IHRvIHVzZSBhcyB0aGUgc291cmNlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFt0YXJnZXRDdHhdIFRoZSAyRCBjb250ZXh0IHRvIGRyYXcgdGhlIHJlc3VsdCB0by4gRGVmYXVsdHMgdG8gdGhlIGNvbnRleHQgcGFzc2VkIHRvIGN0eC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0YXJnZXRYXSBUaGUgeCBwb3NpdGlvbiB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBwYXNzZWQgdG8geC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0YXJnZXRZXSBUaGUgeSBwb3NpdGlvbiB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBwYXNzZWQgdG8geS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGZpbHRlciB3YXMgYXBwbGllZCBzdWNjZXNzZnVsbHkuXG5cdCAqKi9cblx0cC5hcHBseUZpbHRlciA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgdGFyZ2V0Q3R4LCB0YXJnZXRYLCB0YXJnZXRZKSB7XG5cdFx0Ly8gdGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgYmVjYXVzZSBtb3N0IGZpbHRlcnMgYWNjZXNzIHBpeGVsIGRhdGEuIEl0IGlzIG92ZXJyaWRkZW4gd2hlbiBub3QgbmVlZGVkLlxuXHRcdHRhcmdldEN0eCA9IHRhcmdldEN0eCB8fCBjdHg7XG5cdFx0aWYgKHRhcmdldFggPT0gbnVsbCkgeyB0YXJnZXRYID0geDsgfVxuXHRcdGlmICh0YXJnZXRZID09IG51bGwpIHsgdGFyZ2V0WSA9IHk7IH1cblx0XHR0cnkge1xuXHRcdFx0dmFyIGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAodGhpcy5fYXBwbHlGaWx0ZXIoaW1hZ2VEYXRhKSkge1xuXHRcdFx0dGFyZ2V0Q3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIHRhcmdldFgsIHRhcmdldFkpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0ZpbHRlcl1cIjtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgRmlsdGVyIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0ZpbHRlcn0gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBGaWx0ZXIgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKCk7XG5cdH07XG5cdFxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfYXBwbHlGaWx0ZXJcblx0ICogQHBhcmFtIHtJbWFnZURhdGF9IGltYWdlRGF0YSBUYXJnZXQgSW1hZ2VEYXRhIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiovXG5cdHAuX2FwcGx5RmlsdGVyID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7IHJldHVybiB0cnVlOyB9O1xuXG5cblx0Y3JlYXRlanMuRmlsdGVyID0gRmlsdGVyO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEJsdXJGaWx0ZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgYm94IGJsdXIgdG8gRGlzcGxheU9iamVjdHMuIE5vdGUgdGhhdCB0aGlzIGZpbHRlciBpcyBmYWlybHkgQ1BVIGludGVuc2l2ZSwgcGFydGljdWxhcmx5IGlmIHRoZSBxdWFsaXR5IGlzXG5cdCAqIHNldCBoaWdoZXIgdGhhbiAxLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBjcmVhdGVzIGEgcmVkIGNpcmNsZSwgYW5kIHRoZW4gYXBwbGllcyBhIDUgcGl4ZWwgYmx1ciB0byBpdC4gSXQgdXNlcyB0aGUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyL2dldEJvdW5kc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QgdG8gYWNjb3VudCBmb3IgdGhlIHNwcmVhZCB0aGF0IHRoZSBibHVyIGNhdXNlcy5cblx0ICpcblx0ICogICAgICB2YXIgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKS5zZXQoe3g6MTAwLHk6MTAwfSk7XG5cdCAqICAgICAgc2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3Q2lyY2xlKDAsMCw1MCk7XG5cdCAqXG5cdCAqICAgICAgdmFyIGJsdXJGaWx0ZXIgPSBuZXcgY3JlYXRlanMuQmx1ckZpbHRlcig1LCA1LCAxKTtcblx0ICogICAgICBzaGFwZS5maWx0ZXJzID0gW2JsdXJGaWx0ZXJdO1xuXHQgKiAgICAgIHZhciBib3VuZHMgPSBibHVyRmlsdGVyLmdldEJvdW5kcygpO1xuXHQgKlxuXHQgKiAgICAgIHNoYXBlLmNhY2hlKC01MCtib3VuZHMueCwgLTUwK2JvdW5kcy55LCAxMDArYm91bmRzLndpZHRoLCAxMDArYm91bmRzLmhlaWdodCk7XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGFuIG1vcmUgaW5mb3JtYXRpb24gb24gYXBwbHlpbmcgZmlsdGVycy5cblx0ICogQGNsYXNzIEJsdXJGaWx0ZXJcblx0ICogQGV4dGVuZHMgRmlsdGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2JsdXJYPTBdIFRoZSBob3Jpem9udGFsIGJsdXIgcmFkaXVzIGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtibHVyWT0wXSBUaGUgdmVydGljYWwgYmx1ciByYWRpdXMgaW4gcGl4ZWxzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3F1YWxpdHk9MV0gVGhlIG51bWJlciBvZiBibHVyIGl0ZXJhdGlvbnMuXG5cdCAqKi9cblx0ZnVuY3Rpb24gQmx1ckZpbHRlciggYmx1clgsIGJsdXJZLCBxdWFsaXR5KSB7XG5cdFx0aWYgKCBpc05hTihibHVyWCkgfHwgYmx1clggPCAwICkgYmx1clggPSAwO1xuXHRcdGlmICggaXNOYU4oYmx1clkpIHx8IGJsdXJZIDwgMCApIGJsdXJZID0gMDtcblx0XHRpZiAoIGlzTmFOKHF1YWxpdHkpIHx8IHF1YWxpdHkgPCAxICApIHF1YWxpdHkgPSAxO1xuXG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBIb3Jpem9udGFsIGJsdXIgcmFkaXVzIGluIHBpeGVsc1xuXHRcdCAqIEBwcm9wZXJ0eSBibHVyWFxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ibHVyWCA9IGJsdXJYIHwgMDtcblxuXHRcdC8qKlxuXHRcdCAqIFZlcnRpY2FsIGJsdXIgcmFkaXVzIGluIHBpeGVsc1xuXHRcdCAqIEBwcm9wZXJ0eSBibHVyWVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ibHVyWSA9IGJsdXJZIHwgMDtcblxuXHRcdC8qKlxuXHRcdCAqIE51bWJlciBvZiBibHVyIGl0ZXJhdGlvbnMuIEZvciBleGFtcGxlLCBhIHZhbHVlIG9mIDEgd2lsbCBwcm9kdWNlIGEgcm91Z2ggYmx1ci4gQSB2YWx1ZSBvZiAyIHdpbGwgcHJvZHVjZSBhXG5cdFx0ICogc21vb3RoZXIgYmx1ciwgYnV0IHRha2UgdHdpY2UgYXMgbG9uZyB0byBydW4uXG5cdFx0ICogQHByb3BlcnR5IHF1YWxpdHlcblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMucXVhbGl0eSA9IHF1YWxpdHkgfCAwO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEJsdXJGaWx0ZXIsIGNyZWF0ZWpzLkZpbHRlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gY29uc3RhbnRzOlxuXHQvKipcblx0ICogQXJyYXkgb2YgbXVsdGlwbHkgdmFsdWVzIGZvciBibHVyIGNhbGN1bGF0aW9ucy5cblx0ICogQHByb3BlcnR5IE1VTF9UQUJMRVxuXHQgKiBAdHlwZSBBcnJheVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRCbHVyRmlsdGVyLk1VTF9UQUJMRSA9IFsxLCAxNzEsIDIwNSwgMjkzLCA1NywgMzczLCA3OSwgMTM3LCAyNDEsIDI3LCAzOTEsIDM1NywgNDEsIDE5LCAyODMsIDI2NSwgNDk3LCA0NjksIDQ0MywgNDIxLCAyNSwgMTkxLCAzNjUsIDM0OSwgMzM1LCAxNjEsIDE1NSwgMTQ5LCA5LCAyNzgsIDI2OSwgMjYxLCA1MDUsIDI0NSwgNDc1LCAyMzEsIDQ0OSwgNDM3LCAyMTMsIDQxNSwgNDA1LCAzOTUsIDE5MywgMzc3LCAzNjksIDM2MSwgMzUzLCAzNDUsIDE2OSwgMzMxLCAzMjUsIDMxOSwgMzEzLCAzMDcsIDMwMSwgMzcsIDE0NSwgMjg1LCAyODEsIDY5LCAyNzEsIDI2NywgMjYzLCAyNTksIDUwOSwgNTAxLCA0OTMsIDI0MywgNDc5LCAxMTgsIDQ2NSwgNDU5LCAxMTMsIDQ0NiwgNTUsIDQzNSwgNDI5LCA0MjMsIDIwOSwgNDEzLCA1MSwgNDAzLCAxOTksIDM5MywgOTcsIDMsIDM3OSwgMzc1LCAzNzEsIDM2NywgMzYzLCAzNTksIDM1NSwgMzUxLCAzNDcsIDQzLCA4NSwgMzM3LCAzMzMsIDE2NSwgMzI3LCAzMjMsIDUsIDMxNywgMTU3LCAzMTEsIDc3LCAzMDUsIDMwMywgNzUsIDI5NywgMjk0LCA3MywgMjg5LCAyODcsIDcxLCAxNDEsIDI3OSwgMjc3LCAyNzUsIDY4LCAxMzUsIDY3LCAxMzMsIDMzLCAyNjIsIDI2MCwgMTI5LCA1MTEsIDUwNywgNTAzLCA0OTksIDQ5NSwgNDkxLCA2MSwgMTIxLCA0ODEsIDQ3NywgMjM3LCAyMzUsIDQ2NywgMjMyLCAxMTUsIDQ1NywgMjI3LCA0NTEsIDcsIDQ0NSwgMjIxLCA0MzksIDIxOCwgNDMzLCAyMTUsIDQyNywgNDI1LCAyMTEsIDQxOSwgNDE3LCAyMDcsIDQxMSwgNDA5LCAyMDMsIDIwMiwgNDAxLCAzOTksIDM5NiwgMTk3LCA0OSwgMzg5LCAzODcsIDM4NSwgMzgzLCA5NSwgMTg5LCA0NywgMTg3LCA5MywgMTg1LCAyMywgMTgzLCA5MSwgMTgxLCA0NSwgMTc5LCA4OSwgMTc3LCAxMSwgMTc1LCA4NywgMTczLCAzNDUsIDM0MywgMzQxLCAzMzksIDMzNywgMjEsIDE2NywgODMsIDMzMSwgMzI5LCAzMjcsIDE2MywgODEsIDMyMywgMzIxLCAzMTksIDE1OSwgNzksIDMxNSwgMzEzLCAzOSwgMTU1LCAzMDksIDMwNywgMTUzLCAzMDUsIDMwMywgMTUxLCA3NSwgMjk5LCAxNDksIDM3LCAyOTUsIDE0NywgNzMsIDI5MSwgMTQ1LCAyODksIDI4NywgMTQzLCAyODUsIDcxLCAxNDEsIDI4MSwgMzUsIDI3OSwgMTM5LCA2OSwgMjc1LCAxMzcsIDI3MywgMTcsIDI3MSwgMTM1LCAyNjksIDI2NywgMTMzLCAyNjUsIDMzLCAyNjMsIDEzMSwgMjYxLCAxMzAsIDI1OSwgMTI5LCAyNTcsIDFdO1xuXG5cdC8qKlxuXHQgKiBBcnJheSBvZiBzaGlmdCB2YWx1ZXMgZm9yIGJsdXIgY2FsY3VsYXRpb25zLlxuXHQgKiBAcHJvcGVydHkgU0hHX1RBQkxFXG5cdCAqIEB0eXBlIEFycmF5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdEJsdXJGaWx0ZXIuU0hHX1RBQkxFID0gWzAsIDksIDEwLCAxMSwgOSwgMTIsIDEwLCAxMSwgMTIsIDksIDEzLCAxMywgMTAsIDksIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDEwLCAxMywgMTQsIDE0LCAxNCwgMTMsIDEzLCAxMywgOSwgMTQsIDE0LCAxNCwgMTUsIDE0LCAxNSwgMTQsIDE1LCAxNSwgMTQsIDE1LCAxNSwgMTUsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxMiwgMTQsIDE1LCAxNSwgMTMsIDE1LCAxNSwgMTUsIDE1LCAxNiwgMTYsIDE2LCAxNSwgMTYsIDE0LCAxNiwgMTYsIDE0LCAxNiwgMTMsIDE2LCAxNiwgMTYsIDE1LCAxNiwgMTMsIDE2LCAxNSwgMTYsIDE0LCA5LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxMywgMTQsIDE2LCAxNiwgMTUsIDE2LCAxNiwgMTAsIDE2LCAxNSwgMTYsIDE0LCAxNiwgMTYsIDE0LCAxNiwgMTYsIDE0LCAxNiwgMTYsIDE0LCAxNSwgMTYsIDE2LCAxNiwgMTQsIDE1LCAxNCwgMTUsIDEzLCAxNiwgMTYsIDE1LCAxNywgMTcsIDE3LCAxNywgMTcsIDE3LCAxNCwgMTUsIDE3LCAxNywgMTYsIDE2LCAxNywgMTYsIDE1LCAxNywgMTYsIDE3LCAxMSwgMTcsIDE2LCAxNywgMTYsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE2LCAxNCwgMTcsIDE3LCAxNywgMTcsIDE1LCAxNiwgMTQsIDE2LCAxNSwgMTYsIDEzLCAxNiwgMTUsIDE2LCAxNCwgMTYsIDE1LCAxNiwgMTIsIDE2LCAxNSwgMTYsIDE3LCAxNywgMTcsIDE3LCAxNywgMTMsIDE2LCAxNSwgMTcsIDE3LCAxNywgMTYsIDE1LCAxNywgMTcsIDE3LCAxNiwgMTUsIDE3LCAxNywgMTQsIDE2LCAxNywgMTcsIDE2LCAxNywgMTcsIDE2LCAxNSwgMTcsIDE2LCAxNCwgMTcsIDE2LCAxNSwgMTcsIDE2LCAxNywgMTcsIDE2LCAxNywgMTUsIDE2LCAxNywgMTQsIDE3LCAxNiwgMTUsIDE3LCAxNiwgMTcsIDEzLCAxNywgMTYsIDE3LCAxNywgMTYsIDE3LCAxNCwgMTcsIDE2LCAxNywgMTYsIDE3LCAxNiwgMTcsIDldO1xuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbiAocmVjdCkge1xuXHRcdHZhciB4ID0gdGhpcy5ibHVyWHwwLCB5ID0gdGhpcy5ibHVyWXwgMDtcblx0XHRpZiAoeCA8PSAwICYmIHkgPD0gMCkgeyByZXR1cm4gcmVjdDsgfVxuXHRcdHZhciBxID0gTWF0aC5wb3codGhpcy5xdWFsaXR5LCAwLjIpO1xuXHRcdHJldHVybiAocmVjdCB8fCBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKCkpLnBhZCh4KnErMSx5KnErMSx4KnErMSx5KnErMSk7XG5cdH07XG5cblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgQmx1ckZpbHRlcih0aGlzLmJsdXJYLCB0aGlzLmJsdXJZLCB0aGlzLnF1YWxpdHkpO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbQmx1ckZpbHRlcl1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5fYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG5cblx0XHR2YXIgcmFkaXVzWCA9IHRoaXMuYmx1clggPj4gMTtcblx0XHRpZiAoaXNOYU4ocmFkaXVzWCkgfHwgcmFkaXVzWCA8IDApIHJldHVybiBmYWxzZTtcblx0XHR2YXIgcmFkaXVzWSA9IHRoaXMuYmx1clkgPj4gMTtcblx0XHRpZiAoaXNOYU4ocmFkaXVzWSkgfHwgcmFkaXVzWSA8IDApIHJldHVybiBmYWxzZTtcblx0XHRpZiAocmFkaXVzWCA9PSAwICYmIHJhZGl1c1kgPT0gMCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0dmFyIGl0ZXJhdGlvbnMgPSB0aGlzLnF1YWxpdHk7XG5cdFx0aWYgKGlzTmFOKGl0ZXJhdGlvbnMpIHx8IGl0ZXJhdGlvbnMgPCAxKSBpdGVyYXRpb25zID0gMTtcblx0XHRpdGVyYXRpb25zIHw9IDA7XG5cdFx0aWYgKGl0ZXJhdGlvbnMgPiAzKSBpdGVyYXRpb25zID0gMztcblx0XHRpZiAoaXRlcmF0aW9ucyA8IDEpIGl0ZXJhdGlvbnMgPSAxO1xuXG5cdFx0dmFyIHB4ID0gaW1hZ2VEYXRhLmRhdGE7XG5cdFx0dmFyIHg9MCwgeT0wLCBpPTAsIHA9MCwgeXA9MCwgeWk9MCwgeXc9MCwgcj0wLCBnPTAsIGI9MCwgYT0wLCBwcj0wLCBwZz0wLCBwYj0wLCBwYT0wO1xuXG5cdFx0dmFyIGRpdnggPSAocmFkaXVzWCArIHJhZGl1c1ggKyAxKSB8IDA7XG5cdFx0dmFyIGRpdnkgPSAocmFkaXVzWSArIHJhZGl1c1kgKyAxKSB8IDA7XG5cdFx0dmFyIHcgPSBpbWFnZURhdGEud2lkdGggfCAwO1xuXHRcdHZhciBoID0gaW1hZ2VEYXRhLmhlaWdodCB8IDA7XG5cblx0XHR2YXIgdzEgPSAodyAtIDEpIHwgMDtcblx0XHR2YXIgaDEgPSAoaCAtIDEpIHwgMDtcblx0XHR2YXIgcnhwMSA9IChyYWRpdXNYICsgMSkgfCAwO1xuXHRcdHZhciByeXAxID0gKHJhZGl1c1kgKyAxKSB8IDA7XG5cblx0XHR2YXIgc3N4ID0ge3I6MCxiOjAsZzowLGE6MH07XG5cdFx0dmFyIHN4ID0gc3N4O1xuXHRcdGZvciAoIGkgPSAxOyBpIDwgZGl2eDsgaSsrIClcblx0XHR7XG5cdFx0XHRzeCA9IHN4Lm4gPSB7cjowLGI6MCxnOjAsYTowfTtcblx0XHR9XG5cdFx0c3gubiA9IHNzeDtcblxuXHRcdHZhciBzc3kgPSB7cjowLGI6MCxnOjAsYTowfTtcblx0XHR2YXIgc3kgPSBzc3k7XG5cdFx0Zm9yICggaSA9IDE7IGkgPCBkaXZ5OyBpKysgKVxuXHRcdHtcblx0XHRcdHN5ID0gc3kubiA9IHtyOjAsYjowLGc6MCxhOjB9O1xuXHRcdH1cblx0XHRzeS5uID0gc3N5O1xuXG5cdFx0dmFyIHNpID0gbnVsbDtcblxuXG5cdFx0dmFyIG10eCA9IEJsdXJGaWx0ZXIuTVVMX1RBQkxFW3JhZGl1c1hdIHwgMDtcblx0XHR2YXIgc3R4ID0gQmx1ckZpbHRlci5TSEdfVEFCTEVbcmFkaXVzWF0gfCAwO1xuXHRcdHZhciBtdHkgPSBCbHVyRmlsdGVyLk1VTF9UQUJMRVtyYWRpdXNZXSB8IDA7XG5cdFx0dmFyIHN0eSA9IEJsdXJGaWx0ZXIuU0hHX1RBQkxFW3JhZGl1c1ldIHwgMDtcblxuXHRcdHdoaWxlIChpdGVyYXRpb25zLS0gPiAwKSB7XG5cblx0XHRcdHl3ID0geWkgPSAwO1xuXHRcdFx0dmFyIG1zID0gbXR4O1xuXHRcdFx0dmFyIHNzID0gc3R4O1xuXHRcdFx0Zm9yICh5ID0gaDsgLS15ID4gLTE7KSB7XG5cdFx0XHRcdHIgPSByeHAxICogKHByID0gcHhbKHlpKSB8IDBdKTtcblx0XHRcdFx0ZyA9IHJ4cDEgKiAocGcgPSBweFsoeWkgKyAxKSB8IDBdKTtcblx0XHRcdFx0YiA9IHJ4cDEgKiAocGIgPSBweFsoeWkgKyAyKSB8IDBdKTtcblx0XHRcdFx0YSA9IHJ4cDEgKiAocGEgPSBweFsoeWkgKyAzKSB8IDBdKTtcblxuXHRcdFx0XHRzeCA9IHNzeDtcblxuXHRcdFx0XHRmb3IoIGkgPSByeHAxOyAtLWkgPiAtMTsgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3guciA9IHByO1xuXHRcdFx0XHRcdHN4LmcgPSBwZztcblx0XHRcdFx0XHRzeC5iID0gcGI7XG5cdFx0XHRcdFx0c3guYSA9IHBhO1xuXHRcdFx0XHRcdHN4ID0gc3gubjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciggaSA9IDE7IGkgPCByeHAxOyBpKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cCA9ICh5aSArICgodzEgPCBpID8gdzEgOiBpKSA8PCAyKSkgfCAwO1xuXHRcdFx0XHRcdHIgKz0gKCBzeC5yID0gcHhbcF0pO1xuXHRcdFx0XHRcdGcgKz0gKCBzeC5nID0gcHhbcCsxXSk7XG5cdFx0XHRcdFx0YiArPSAoIHN4LmIgPSBweFtwKzJdKTtcblx0XHRcdFx0XHRhICs9ICggc3guYSA9IHB4W3ArM10pO1xuXG5cdFx0XHRcdFx0c3ggPSBzeC5uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2kgPSBzc3g7XG5cdFx0XHRcdGZvciAoIHggPSAwOyB4IDwgdzsgeCsrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHB4W3lpKytdID0gKHIgKiBtcykgPj4+IHNzO1xuXHRcdFx0XHRcdHB4W3lpKytdID0gKGcgKiBtcykgPj4+IHNzO1xuXHRcdFx0XHRcdHB4W3lpKytdID0gKGIgKiBtcykgPj4+IHNzO1xuXHRcdFx0XHRcdHB4W3lpKytdID0gKGEgKiBtcykgPj4+IHNzO1xuXG5cdFx0XHRcdFx0cCA9ICgoeXcgKyAoKHAgPSB4ICsgcmFkaXVzWCArIDEpIDwgdzEgPyBwIDogdzEpKSA8PCAyKTtcblxuXHRcdFx0XHRcdHIgLT0gc2kuciAtICggc2kuciA9IHB4W3BdKTtcblx0XHRcdFx0XHRnIC09IHNpLmcgLSAoIHNpLmcgPSBweFtwKzFdKTtcblx0XHRcdFx0XHRiIC09IHNpLmIgLSAoIHNpLmIgPSBweFtwKzJdKTtcblx0XHRcdFx0XHRhIC09IHNpLmEgLSAoIHNpLmEgPSBweFtwKzNdKTtcblxuXHRcdFx0XHRcdHNpID0gc2kubjtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdHl3ICs9IHc7XG5cdFx0XHR9XG5cblx0XHRcdG1zID0gbXR5O1xuXHRcdFx0c3MgPSBzdHk7XG5cdFx0XHRmb3IgKHggPSAwOyB4IDwgdzsgeCsrKSB7XG5cdFx0XHRcdHlpID0gKHggPDwgMikgfCAwO1xuXG5cdFx0XHRcdHIgPSAocnlwMSAqIChwciA9IHB4W3lpXSkpIHwgMDtcblx0XHRcdFx0ZyA9IChyeXAxICogKHBnID0gcHhbKHlpICsgMSkgfCAwXSkpIHwgMDtcblx0XHRcdFx0YiA9IChyeXAxICogKHBiID0gcHhbKHlpICsgMikgfCAwXSkpIHwgMDtcblx0XHRcdFx0YSA9IChyeXAxICogKHBhID0gcHhbKHlpICsgMykgfCAwXSkpIHwgMDtcblxuXHRcdFx0XHRzeSA9IHNzeTtcblx0XHRcdFx0Zm9yKCBpID0gMDsgaSA8IHJ5cDE7IGkrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzeS5yID0gcHI7XG5cdFx0XHRcdFx0c3kuZyA9IHBnO1xuXHRcdFx0XHRcdHN5LmIgPSBwYjtcblx0XHRcdFx0XHRzeS5hID0gcGE7XG5cdFx0XHRcdFx0c3kgPSBzeS5uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0eXAgPSB3O1xuXG5cdFx0XHRcdGZvciggaSA9IDE7IGkgPD0gcmFkaXVzWTsgaSsrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHlpID0gKCB5cCArIHggKSA8PCAyO1xuXG5cdFx0XHRcdFx0ciArPSAoIHN5LnIgPSBweFt5aV0pO1xuXHRcdFx0XHRcdGcgKz0gKCBzeS5nID0gcHhbeWkrMV0pO1xuXHRcdFx0XHRcdGIgKz0gKCBzeS5iID0gcHhbeWkrMl0pO1xuXHRcdFx0XHRcdGEgKz0gKCBzeS5hID0gcHhbeWkrM10pO1xuXG5cdFx0XHRcdFx0c3kgPSBzeS5uO1xuXG5cdFx0XHRcdFx0aWYoIGkgPCBoMSApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0eXAgKz0gdztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR5aSA9IHg7XG5cdFx0XHRcdHNpID0gc3N5O1xuXHRcdFx0XHRpZiAoIGl0ZXJhdGlvbnMgPiAwIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoIHkgPSAwOyB5IDwgaDsgeSsrIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRwID0geWkgPDwgMjtcblx0XHRcdFx0XHRcdHB4W3ArM10gPSBwYSA9KGEgKiBtcykgPj4+IHNzO1xuXHRcdFx0XHRcdFx0aWYgKCBwYSA+IDAgKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRweFtwXSAgID0gKChyICogbXMpID4+PiBzcyApO1xuXHRcdFx0XHRcdFx0XHRweFtwKzFdID0gKChnICogbXMpID4+PiBzcyApO1xuXHRcdFx0XHRcdFx0XHRweFtwKzJdID0gKChiICogbXMpID4+PiBzcyApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHhbcF0gPSBweFtwKzFdID0gcHhbcCsyXSA9IDBcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cCA9ICggeCArICgoICggcCA9IHkgKyByeXAxKSA8IGgxID8gcCA6IGgxICkgKiB3ICkpIDw8IDI7XG5cblx0XHRcdFx0XHRcdHIgLT0gc2kuciAtICggc2kuciA9IHB4W3BdKTtcblx0XHRcdFx0XHRcdGcgLT0gc2kuZyAtICggc2kuZyA9IHB4W3ArMV0pO1xuXHRcdFx0XHRcdFx0YiAtPSBzaS5iIC0gKCBzaS5iID0gcHhbcCsyXSk7XG5cdFx0XHRcdFx0XHRhIC09IHNpLmEgLSAoIHNpLmEgPSBweFtwKzNdKTtcblxuXHRcdFx0XHRcdFx0c2kgPSBzaS5uO1xuXG5cdFx0XHRcdFx0XHR5aSArPSB3O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKCB5ID0gMDsgeSA8IGg7IHkrKyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cCA9IHlpIDw8IDI7XG5cdFx0XHRcdFx0XHRweFtwKzNdID0gcGEgPShhICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRcdGlmICggcGEgPiAwIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cGEgPSAyNTUgLyBwYTtcblx0XHRcdFx0XHRcdFx0cHhbcF0gICA9ICgociAqIG1zKSA+Pj4gc3MgKSAqIHBhO1xuXHRcdFx0XHRcdFx0XHRweFtwKzFdID0gKChnICogbXMpID4+PiBzcyApICogcGE7XG5cdFx0XHRcdFx0XHRcdHB4W3ArMl0gPSAoKGIgKiBtcykgPj4+IHNzICkgKiBwYTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHB4W3BdID0gcHhbcCsxXSA9IHB4W3ArMl0gPSAwXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHAgPSAoIHggKyAoKCAoIHAgPSB5ICsgcnlwMSkgPCBoMSA/IHAgOiBoMSApICogdyApKSA8PCAyO1xuXG5cdFx0XHRcdFx0XHRyIC09IHNpLnIgLSAoIHNpLnIgPSBweFtwXSk7XG5cdFx0XHRcdFx0XHRnIC09IHNpLmcgLSAoIHNpLmcgPSBweFtwKzFdKTtcblx0XHRcdFx0XHRcdGIgLT0gc2kuYiAtICggc2kuYiA9IHB4W3ArMl0pO1xuXHRcdFx0XHRcdFx0YSAtPSBzaS5hIC0gKCBzaS5hID0gcHhbcCszXSk7XG5cblx0XHRcdFx0XHRcdHNpID0gc2kubjtcblxuXHRcdFx0XHRcdFx0eWkgKz0gdztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHRjcmVhdGVqcy5CbHVyRmlsdGVyID0gY3JlYXRlanMucHJvbW90ZShCbHVyRmlsdGVyLCBcIkZpbHRlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBBbHBoYU1hcEZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXHRcbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQXBwbGllcyBhIGdyZXlzY2FsZSBhbHBoYSBtYXAgaW1hZ2UgKG9yIGNhbnZhcykgdG8gdGhlIHRhcmdldCwgc3VjaCB0aGF0IHRoZSBhbHBoYSBjaGFubmVsIG9mIHRoZSByZXN1bHQgd2lsbFxuXHQgKiBiZSBjb3BpZWQgZnJvbSB0aGUgcmVkIGNoYW5uZWwgb2YgdGhlIG1hcCwgYW5kIHRoZSBSR0IgY2hhbm5lbHMgd2lsbCBiZSBjb3BpZWQgZnJvbSB0aGUgdGFyZ2V0LlxuXHQgKlxuXHQgKiBHZW5lcmFsbHksIGl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZSB7eyNjcm9zc0xpbmsgXCJBbHBoYU1hc2tGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0sIGJlY2F1c2UgaXQgaGFzIG11Y2hcblx0ICogYmV0dGVyIHBlcmZvcm1hbmNlLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBkcmF3cyBhIHJlZC0+Ymx1ZSBib3gsIGNhY2hlcyBpdCwgYW5kIHRoZW4gdXNlcyB0aGUgY2FjaGUgY2FudmFzIGFzIGFuIGFscGhhIG1hcCBvbiBhIDEwMHgxMDAgaW1hZ2UuXG5cdCAqXG5cdCAqICAgICAgIHZhciBib3ggPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcblx0ICogICAgICAgYm94LmdyYXBoaWNzLmJlZ2luTGluZWFyR3JhZGllbnRGaWxsKFtcIiNmZjAwMDBcIiwgXCIjMDAwMGZmXCJdLCBbMCwgMV0sIDAsIDAsIDAsIDEwMClcblx0ICogICAgICAgYm94LmdyYXBoaWNzLmRyYXdSZWN0KDAsIDAsIDEwMCwgMTAwKTtcblx0ICogICAgICAgYm94LmNhY2hlKDAsIDAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogICAgICAgdmFyIGJtcCA9IG5ldyBjcmVhdGVqcy5CaXRtYXAoXCJwYXRoL3RvL2ltYWdlLmpwZ1wiKTtcblx0ICogICAgICAgYm1wLmZpbHRlcnMgPSBbXG5cdCAqICAgICAgICAgICBuZXcgY3JlYXRlanMuQWxwaGFNYXBGaWx0ZXIoYm94LmNhY2hlQ2FudmFzKVxuXHQgKiAgICAgICBdO1xuXHQgKiAgICAgICBibXAuY2FjaGUoMCwgMCwgMTAwLCAxMDApO1xuXHQgKiAgICAgICBzdGFnZS5hZGRDaGlsZChibXApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGFwcGx5aW5nIGZpbHRlcnMuXG5cdCAqIEBjbGFzcyBBbHBoYU1hcEZpbHRlclxuXHQgKiBAZXh0ZW5kcyBGaWx0ZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gYWxwaGFNYXAgVGhlIGdyZXlzY2FsZSBpbWFnZSAob3IgY2FudmFzKSB0byB1c2UgYXMgdGhlIGFscGhhIHZhbHVlIGZvciB0aGVcblx0ICogcmVzdWx0LiBUaGlzIHNob3VsZCBiZSBleGFjdGx5IHRoZSBzYW1lIGRpbWVuc2lvbnMgYXMgdGhlIHRhcmdldC5cblx0ICoqL1xuXHRmdW5jdGlvbiBBbHBoYU1hcEZpbHRlcihhbHBoYU1hcCkge1xuXHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBncmV5c2NhbGUgaW1hZ2UgKG9yIGNhbnZhcykgdG8gdXNlIGFzIHRoZSBhbHBoYSB2YWx1ZSBmb3IgdGhlIHJlc3VsdC4gVGhpcyBzaG91bGQgYmUgZXhhY3RseSB0aGUgc2FtZVxuXHRcdCAqIGRpbWVuc2lvbnMgYXMgdGhlIHRhcmdldC5cblx0XHQgKiBAcHJvcGVydHkgYWxwaGFNYXBcblx0XHQgKiBAdHlwZSBIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50XG5cdFx0ICoqL1xuXHRcdHRoaXMuYWxwaGFNYXAgPSBhbHBoYU1hcDtcblx0XHRcblx0XHRcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfYWxwaGFNYXBcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgSFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudFxuXHRcdCAqKi9cblx0XHR0aGlzLl9hbHBoYU1hcCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9tYXBEYXRhXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIFVpbnQ4Q2xhbXBlZEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX21hcERhdGEgPSBudWxsO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEFscGhhTWFwRmlsdGVyLCBjcmVhdGVqcy5GaWx0ZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBvID0gbmV3IEFscGhhTWFwRmlsdGVyKHRoaXMuYWxwaGFNYXApO1xuXHRcdG8uX2FscGhhTWFwID0gdGhpcy5fYWxwaGFNYXA7XG5cdFx0by5fbWFwRGF0YSA9IHRoaXMuX21hcERhdGE7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbQWxwaGFNYXBGaWx0ZXJdXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLl9hcHBseUZpbHRlciA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcblx0XHRpZiAoIXRoaXMuYWxwaGFNYXApIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoIXRoaXMuX3ByZXBBbHBoYU1hcCgpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFxuXHRcdC8vIFRPRE86IHVwZGF0ZSB0byBzdXBwb3J0IHNjZW5hcmlvcyB3aGVyZSB0aGUgdGFyZ2V0IGhhcyBkaWZmZXJlbnQgZGltZW5zaW9ucy5cblx0XHR2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXBEYXRhO1xuXHRcdGZvcih2YXIgaT0wLCBsPWRhdGEubGVuZ3RoOyBpPGw7IGkgKz0gNCkgeyBkYXRhW2kgKyAzXSA9IG1hcFtpXSB8fCAwOyB9XG5cdFx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3ByZXBBbHBoYU1hcFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fcHJlcEFscGhhTWFwID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5hbHBoYU1hcCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodGhpcy5hbHBoYU1hcCA9PSB0aGlzLl9hbHBoYU1hcCAmJiB0aGlzLl9tYXBEYXRhKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHR0aGlzLl9tYXBEYXRhID0gbnVsbDtcblx0XHR2YXIgbWFwID0gdGhpcy5fYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwO1xuXHRcdHZhciBjYW52YXMgPSBtYXA7XG5cdFx0dmFyIGN0eDtcblx0XHRpZiAobWFwIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcblx0XHRcdGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcyA9IGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcyA/IGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblx0XHRcdGNhbnZhcy53aWR0aCA9IG1hcC53aWR0aDtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBtYXAuaGVpZ2h0O1xuXHRcdFx0Y3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRcdGN0eC5kcmF3SW1hZ2UobWFwLCAwLCAwKTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIGltZ0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIG1hcC53aWR0aCwgbWFwLmhlaWdodCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly9pZiAoIXRoaXMuc3VwcHJlc3NDcm9zc0RvbWFpbkVycm9ycykgdGhyb3cgbmV3IEVycm9yKFwidW5hYmxlIHRvIGFjY2VzcyBsb2NhbCBpbWFnZSBkYXRhOiBcIiArIGUpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHR0aGlzLl9tYXBEYXRhID0gaW1nRGF0YS5kYXRhO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQWxwaGFNYXBGaWx0ZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEFscGhhTWFwRmlsdGVyLCBcIkZpbHRlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBBbHBoYU1hc2tGaWx0ZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgYWxwaGEgZnJvbSB0aGUgbWFzayBpbWFnZSAob3IgY2FudmFzKSB0byB0aGUgdGFyZ2V0LCBzdWNoIHRoYXQgdGhlIGFscGhhIGNoYW5uZWwgb2YgdGhlIHJlc3VsdCB3aWxsXG5cdCAqIGJlIGRlcml2ZWQgZnJvbSB0aGUgbWFzaywgYW5kIHRoZSBSR0IgY2hhbm5lbHMgd2lsbCBiZSBjb3BpZWQgZnJvbSB0aGUgdGFyZ2V0LiBUaGlzIGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgdG9cblx0ICogYXBwbHkgYW4gYWxwaGEgbWFzayB0byBhIGRpc3BsYXkgb2JqZWN0LiBUaGlzIGNhbiBhbHNvIGJlIHVzZWQgdG8gY29tYmluZSBhIEpQRyBjb21wcmVzc2VkIFJHQiBpbWFnZSB3aXRoIGEgUE5HMzJcblx0ICogYWxwaGEgbWFzaywgd2hpY2ggY2FuIHJlc3VsdCBpbiBhIG11Y2ggc21hbGxlciBmaWxlIHNpemUgdGhhbiBhIHNpbmdsZSBQTkczMiBjb250YWluaW5nIEFSR0IuXG5cdCAqXG5cdCAqIDxiPklNUE9SVEFOVCBOT1RFOiBUaGlzIGZpbHRlciBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCB0aGUgdGFyZ2V0Q3R4LCBvciB0YXJnZXRYL1kgcGFyYW1ldGVycyBjb3JyZWN0bHkuPC9iPlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBkcmF3cyBhIGdyYWRpZW50IGJveCwgdGhlbiBjYWNoZXMgaXQgYW5kIHVzZXMgdGhlIFwiY2FjaGVDYW52YXNcIiBhcyB0aGUgYWxwaGEgbWFzayBvbiBhIDEwMHgxMDAgaW1hZ2UuXG5cdCAqXG5cdCAqICAgICAgdmFyIGJveCA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuXHQgKiAgICAgIGJveC5ncmFwaGljcy5iZWdpbkxpbmVhckdyYWRpZW50RmlsbChbXCIjMDAwMDAwXCIsIFwicmdiYSgwLCAwLCAwLCAwKVwiXSwgWzAsIDFdLCAwLCAwLCAxMDAsIDEwMClcblx0ICogICAgICBib3guZ3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgMTAwLCAxMDApO1xuXHQgKiAgICAgIGJveC5jYWNoZSgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqICAgICAgdmFyIGJtcCA9IG5ldyBjcmVhdGVqcy5CaXRtYXAoXCJwYXRoL3RvL2ltYWdlLmpwZ1wiKTtcblx0ICogICAgICBibXAuZmlsdGVycyA9IFtcblx0ICogICAgICAgICAgbmV3IGNyZWF0ZWpzLkFscGhhTWFza0ZpbHRlcihib3guY2FjaGVDYW52YXMpXG5cdCAqICAgICAgXTtcblx0ICogICAgICBibXAuY2FjaGUoMCwgMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGFwcGx5aW5nIGZpbHRlcnMuXG5cdCAqIEBjbGFzcyBBbHBoYU1hc2tGaWx0ZXJcblx0ICogQGV4dGVuZHMgRmlsdGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IG1hc2tcblx0ICoqL1xuXHRmdW5jdGlvbiBBbHBoYU1hc2tGaWx0ZXIobWFzaykge1xuXHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbWFnZSAob3IgY2FudmFzKSB0byB1c2UgYXMgdGhlIG1hc2suXG5cdFx0ICogQHByb3BlcnR5IG1hc2tcblx0XHQgKiBAdHlwZSBIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50XG5cdFx0ICoqL1xuXHRcdHRoaXMubWFzayA9IG1hc2s7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWxwaGFNYXNrRmlsdGVyLCBjcmVhdGVqcy5GaWx0ZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXHRcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoZSBmaWx0ZXIgdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LlxuXHQgKlxuXHQgKiA8c3Ryb25nPklNUE9SVEFOVCBOT1RFOiBUaGlzIGZpbHRlciBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCB0aGUgdGFyZ2V0Q3R4LCBvciB0YXJnZXRYL1kgcGFyYW1ldGVyc1xuXHQgKiBjb3JyZWN0bHkuPC9zdHJvbmc+XG5cdCAqIEBtZXRob2QgYXBwbHlGaWx0ZXJcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgMkQgY29udGV4dCB0byB1c2UgYXMgdGhlIHNvdXJjZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBbdGFyZ2V0Q3R4XSBOT1QgU1VQUE9SVEVEIElOIFRISVMgRklMVEVSLiBUaGUgMkQgY29udGV4dCB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSBjb250ZXh0IHBhc3NlZCB0byBjdHguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGFyZ2V0WF0gTk9UIFNVUFBPUlRFRCBJTiBUSElTIEZJTFRFUi4gVGhlIHggcG9zaXRpb24gdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgcGFzc2VkIHRvIHguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGFyZ2V0WV0gTk9UIFNVUFBPUlRFRCBJTiBUSElTIEZJTFRFUi4gVGhlIHkgcG9zaXRpb24gdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgcGFzc2VkIHRvIHkuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBmaWx0ZXIgd2FzIGFwcGxpZWQgc3VjY2Vzc2Z1bGx5LlxuXHQgKiovXG5cdHAuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0YXJnZXRDdHgsIHRhcmdldFgsIHRhcmdldFkpIHtcblx0XHRpZiAoIXRoaXMubWFzaykgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHRhcmdldEN0eCA9IHRhcmdldEN0eCB8fCBjdHg7XG5cdFx0aWYgKHRhcmdldFggPT0gbnVsbCkgeyB0YXJnZXRYID0geDsgfVxuXHRcdGlmICh0YXJnZXRZID09IG51bGwpIHsgdGFyZ2V0WSA9IHk7IH1cblxuXHRcdHRhcmdldEN0eC5zYXZlKCk7XG5cdFx0aWYgKGN0eCAhPSB0YXJnZXRDdHgpIHtcblx0XHRcdC8vIFRPRE86IHN1cHBvcnQgdGFyZ2V0Q3R4IGFuZCB0YXJnZXRYL1lcblx0XHRcdC8vIGNsZWFyUmVjdCwgdGhlbiBkcmF3IHRoZSBjdHggaW4/XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0Q3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24taW5cIjtcblx0XHR0YXJnZXRDdHguZHJhd0ltYWdlKHRoaXMubWFzaywgdGFyZ2V0WCwgdGFyZ2V0WSk7XG5cdFx0dGFyZ2V0Q3R4LnJlc3RvcmUoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBuZXcgQWxwaGFNYXNrRmlsdGVyKHRoaXMubWFzayk7XG5cdH07XG5cblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbQWxwaGFNYXNrRmlsdGVyXVwiO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQWxwaGFNYXNrRmlsdGVyID0gY3JlYXRlanMucHJvbW90ZShBbHBoYU1hc2tGaWx0ZXIsIFwiRmlsdGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIENvbG9yRmlsdGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQXBwbGllcyBhIGNvbG9yIHRyYW5zZm9ybSB0byBEaXNwbGF5T2JqZWN0cy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgZHJhd3MgYSByZWQgY2lyY2xlLCBhbmQgdGhlbiB0cmFuc2Zvcm1zIGl0IHRvIEJsdWUuIFRoaXMgaXMgYWNjb21wbGlzaGVkIGJ5IG11bHRpcGx5aW5nIGFsbCB0aGUgY2hhbm5lbHNcblx0ICogdG8gMCAoZXhjZXB0IGFscGhhLCB3aGljaCBpcyBzZXQgdG8gMSksIGFuZCB0aGVuIGFkZGluZyAyNTUgdG8gdGhlIGJsdWUgY2hhbm5lbC5cblx0ICpcblx0ICogICAgICB2YXIgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKS5zZXQoe3g6MTAwLHk6MTAwfSk7XG5cdCAqICAgICAgc2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3Q2lyY2xlKDAsMCw1MCk7XG5cdCAqXG5cdCAqICAgICAgc2hhcGUuZmlsdGVycyA9IFtcblx0ICogICAgICAgICAgbmV3IGNyZWF0ZWpzLkNvbG9yRmlsdGVyKDAsMCwwLDEsIDAsMCwyNTUsMClcblx0ICogICAgICBdO1xuXHQgKiAgICAgIHNoYXBlLmNhY2hlKC01MCwgLTUwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGFuIG1vcmUgaW5mb3JtYXRpb24gb24gYXBwbHlpbmcgZmlsdGVycy5cblx0ICogQGNsYXNzIENvbG9yRmlsdGVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcmVkTXVsdGlwbGllcj0xXSBUaGUgYW1vdW50IHRvIG11bHRpcGx5IGFnYWluc3QgdGhlIHJlZCBjaGFubmVsLiBUaGlzIGlzIGEgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2dyZWVuTXVsdGlwbGllcj0xXSBUaGUgYW1vdW50IHRvIG11bHRpcGx5IGFnYWluc3QgdGhlIGdyZWVuIGNoYW5uZWwuIFRoaXMgaXMgYSByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYmx1ZU11bHRpcGxpZXI9MV0gVGhlIGFtb3VudCB0byBtdWx0aXBseSBhZ2FpbnN0IHRoZSBibHVlIGNoYW5uZWwuIFRoaXMgaXMgYSByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWxwaGFNdWx0aXBsaWVyPTFdIFRoZSBhbW91bnQgdG8gbXVsdGlwbHkgYWdhaW5zdCB0aGUgYWxwaGEgY2hhbm5lbC4gVGhpcyBpcyBhIHJhbmdlIGJldHdlZW4gMCBhbmQgMS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyZWRPZmZzZXQ9MF0gVGhlIGFtb3VudCB0byBhZGQgdG8gdGhlIHJlZCBjaGFubmVsIGFmdGVyIGl0IGhhcyBiZWVuIG11bHRpcGxpZWQuIFRoaXMgaXMgYSByYW5nZVxuXHQgKiBiZXR3ZWVuIC0yNTUgYW5kIDI1NS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtncmVlbk9mZnNldD0wXSBUaGUgYW1vdW50IHRvIGFkZCB0byB0aGUgZ3JlZW4gY2hhbm5lbCBhZnRlciBpdCBoYXMgYmVlbiBtdWx0aXBsaWVkLiBUaGlzIGlzIGEgcmFuZ2Vcblx0ICAqIGJldHdlZW4gLTI1NSBhbmQgMjU1LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2JsdWVPZmZzZXQ9MF0gVGhlIGFtb3VudCB0byBhZGQgdG8gdGhlIGJsdWUgY2hhbm5lbCBhZnRlciBpdCBoYXMgYmVlbiBtdWx0aXBsaWVkLiBUaGlzIGlzIGEgcmFuZ2Vcblx0ICAqIGJldHdlZW4gLTI1NSBhbmQgMjU1LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FscGhhT2Zmc2V0PTBdIFRoZSBhbW91bnQgdG8gYWRkIHRvIHRoZSBhbHBoYSBjaGFubmVsIGFmdGVyIGl0IGhhcyBiZWVuIG11bHRpcGxpZWQuIFRoaXMgaXMgYSByYW5nZVxuXHQgICogYmV0d2VlbiAtMjU1IGFuZCAyNTUuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAZXh0ZW5kcyBGaWx0ZXJcblx0ICoqL1xuXHRmdW5jdGlvbiBDb2xvckZpbHRlcihyZWRNdWx0aXBsaWVyLCBncmVlbk11bHRpcGxpZXIsIGJsdWVNdWx0aXBsaWVyLCBhbHBoYU11bHRpcGxpZXIsIHJlZE9mZnNldCwgZ3JlZW5PZmZzZXQsIGJsdWVPZmZzZXQsIGFscGhhT2Zmc2V0KSB7XG5cdFx0XG5cdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBSZWQgY2hhbm5lbCBtdWx0aXBsaWVyLlxuXHRcdCAqIEBwcm9wZXJ0eSByZWRNdWx0aXBsaWVyXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMucmVkTXVsdGlwbGllciA9IHJlZE11bHRpcGxpZXIgIT0gbnVsbCA/IHJlZE11bHRpcGxpZXIgOiAxO1xuXHRcblx0XHQvKipcblx0XHQgKiBHcmVlbiBjaGFubmVsIG11bHRpcGxpZXIuXG5cdFx0ICogQHByb3BlcnR5IGdyZWVuTXVsdGlwbGllclxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmdyZWVuTXVsdGlwbGllciA9IGdyZWVuTXVsdGlwbGllciAhPSBudWxsID8gZ3JlZW5NdWx0aXBsaWVyIDogMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQmx1ZSBjaGFubmVsIG11bHRpcGxpZXIuXG5cdFx0ICogQHByb3BlcnR5IGJsdWVNdWx0aXBsaWVyXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYmx1ZU11bHRpcGxpZXIgPSBibHVlTXVsdGlwbGllciAhPSBudWxsID8gYmx1ZU11bHRpcGxpZXIgOiAxO1xuXHRcblx0XHQvKipcblx0XHQgKiBBbHBoYSBjaGFubmVsIG11bHRpcGxpZXIuXG5cdFx0ICogQHByb3BlcnR5IGFscGhhTXVsdGlwbGllclxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmFscGhhTXVsdGlwbGllciA9IGFscGhhTXVsdGlwbGllciAhPSBudWxsID8gYWxwaGFNdWx0aXBsaWVyIDogMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogUmVkIGNoYW5uZWwgb2Zmc2V0IChhZGRlZCB0byB2YWx1ZSkuXG5cdFx0ICogQHByb3BlcnR5IHJlZE9mZnNldFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLnJlZE9mZnNldCA9IHJlZE9mZnNldCB8fCAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBHcmVlbiBjaGFubmVsIG9mZnNldCAoYWRkZWQgdG8gdmFsdWUpLlxuXHRcdCAqIEBwcm9wZXJ0eSBncmVlbk9mZnNldFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmdyZWVuT2Zmc2V0ID0gZ3JlZW5PZmZzZXQgfHwgMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQmx1ZSBjaGFubmVsIG9mZnNldCAoYWRkZWQgdG8gdmFsdWUpLlxuXHRcdCAqIEBwcm9wZXJ0eSBibHVlT2Zmc2V0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYmx1ZU9mZnNldCA9IGJsdWVPZmZzZXQgfHwgMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxwaGEgY2hhbm5lbCBvZmZzZXQgKGFkZGVkIHRvIHZhbHVlKS5cblx0XHQgKiBAcHJvcGVydHkgYWxwaGFPZmZzZXRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5hbHBoYU9mZnNldCA9IGFscGhhT2Zmc2V0IHx8IDA7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQ29sb3JGaWx0ZXIsIGNyZWF0ZWpzLkZpbHRlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbQ29sb3JGaWx0ZXJdXCI7XG5cdH07XG5cblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgQ29sb3JGaWx0ZXIodGhpcy5yZWRNdWx0aXBsaWVyLCB0aGlzLmdyZWVuTXVsdGlwbGllciwgdGhpcy5ibHVlTXVsdGlwbGllciwgdGhpcy5hbHBoYU11bHRpcGxpZXIsIHRoaXMucmVkT2Zmc2V0LCB0aGlzLmdyZWVuT2Zmc2V0LCB0aGlzLmJsdWVPZmZzZXQsIHRoaXMuYWxwaGFPZmZzZXQpO1xuXHR9O1xuXHRcblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLl9hcHBseUZpbHRlciA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuXHRcdHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cdFx0dmFyIGwgPSBkYXRhLmxlbmd0aDtcblx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSs9NCkge1xuXHRcdFx0ZGF0YVtpXSA9IGRhdGFbaV0qdGhpcy5yZWRNdWx0aXBsaWVyK3RoaXMucmVkT2Zmc2V0O1xuXHRcdFx0ZGF0YVtpKzFdID0gZGF0YVtpKzFdKnRoaXMuZ3JlZW5NdWx0aXBsaWVyK3RoaXMuZ3JlZW5PZmZzZXQ7XG5cdFx0XHRkYXRhW2krMl0gPSBkYXRhW2krMl0qdGhpcy5ibHVlTXVsdGlwbGllcit0aGlzLmJsdWVPZmZzZXQ7XG5cdFx0XHRkYXRhW2krM10gPSBkYXRhW2krM10qdGhpcy5hbHBoYU11bHRpcGxpZXIrdGhpcy5hbHBoYU9mZnNldDtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5Db2xvckZpbHRlciA9IGNyZWF0ZWpzLnByb21vdGUoQ29sb3JGaWx0ZXIsIFwiRmlsdGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIENvbG9yTWF0cml4LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogUHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyBmb3IgYXNzZW1ibGluZyBhIG1hdHJpeCBmb3IgdXNlIHdpdGggdGhlIHt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4RmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBNb3N0IG1ldGhvZHMgcmV0dXJuIHRoZSBpbnN0YW5jZSB0byBmYWNpbGl0YXRlIGNoYWluZWQgY2FsbHMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBteUNvbG9yTWF0cml4LmFkanVzdEh1ZSgyMCkuYWRqdXN0QnJpZ2h0bmVzcyg1MCk7XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGFuIGV4YW1wbGUgb2YgaG93IHRvIGFwcGx5IGZpbHRlcnMsIG9yIHt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4RmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBhbiBleGFtcGxlIG9mIGhvdyB0byB1c2UgQ29sb3JNYXRyaXggdG8gY2hhbmdlIGEgRGlzcGxheU9iamVjdCdzIGNvbG9yLlxuXHQgKiBAY2xhc3MgQ29sb3JNYXRyaXhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJyaWdodG5lc3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvbnRyYXN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBodWVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gQ29sb3JNYXRyaXgoYnJpZ2h0bmVzcywgY29udHJhc3QsIHNhdHVyYXRpb24sIGh1ZSkge1xuXHRcdHRoaXMuc2V0Q29sb3IoYnJpZ2h0bmVzcywgY29udHJhc3QsIHNhdHVyYXRpb24sIGh1ZSk7XG5cdH1cblx0dmFyIHAgPSBDb2xvck1hdHJpeC5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIEFycmF5IG9mIGRlbHRhIHZhbHVlcyBmb3IgY29udHJhc3QgY2FsY3VsYXRpb25zLlxuXHQgKiBAcHJvcGVydHkgREVMVEFfSU5ERVhcblx0ICogQHR5cGUgQXJyYXlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0Q29sb3JNYXRyaXguREVMVEFfSU5ERVggPSBbXG5cdFx0MCwgICAgMC4wMSwgMC4wMiwgMC4wNCwgMC4wNSwgMC4wNiwgMC4wNywgMC4wOCwgMC4xLCAgMC4xMSxcblx0XHQwLjEyLCAwLjE0LCAwLjE1LCAwLjE2LCAwLjE3LCAwLjE4LCAwLjIwLCAwLjIxLCAwLjIyLCAwLjI0LFxuXHRcdDAuMjUsIDAuMjcsIDAuMjgsIDAuMzAsIDAuMzIsIDAuMzQsIDAuMzYsIDAuMzgsIDAuNDAsIDAuNDIsXG5cdFx0MC40NCwgMC40NiwgMC40OCwgMC41LCAgMC41MywgMC41NiwgMC41OSwgMC42MiwgMC42NSwgMC42OCxcblx0XHQwLjcxLCAwLjc0LCAwLjc3LCAwLjgwLCAwLjgzLCAwLjg2LCAwLjg5LCAwLjkyLCAwLjk1LCAwLjk4LFxuXHRcdDEuMCwgIDEuMDYsIDEuMTIsIDEuMTgsIDEuMjQsIDEuMzAsIDEuMzYsIDEuNDIsIDEuNDgsIDEuNTQsXG5cdFx0MS42MCwgMS42NiwgMS43MiwgMS43OCwgMS44NCwgMS45MCwgMS45NiwgMi4wLCAgMi4xMiwgMi4yNSxcblx0XHQyLjM3LCAyLjUwLCAyLjYyLCAyLjc1LCAyLjg3LCAzLjAsICAzLjIsICAzLjQsICAzLjYsICAzLjgsXG5cdFx0NC4wLCAgNC4zLCAgNC43LCAgNC45LCAgNS4wLCAgNS41LCAgNi4wLCAgNi41LCAgNi44LCAgNy4wLFxuXHRcdDcuMywgIDcuNSwgIDcuOCwgIDguMCwgIDguNCwgIDguNywgIDkuMCwgIDkuNCwgIDkuNiwgIDkuOCxcblx0XHQxMC4wXG5cdF07XG5cblx0LyoqXG5cdCAqIElkZW50aXR5IG1hdHJpeCB2YWx1ZXMuXG5cdCAqIEBwcm9wZXJ0eSBJREVOVElUWV9NQVRSSVhcblx0ICogQHR5cGUgQXJyYXlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0Q29sb3JNYXRyaXguSURFTlRJVFlfTUFUUklYID0gW1xuXHRcdDEsMCwwLDAsMCxcblx0XHQwLDEsMCwwLDAsXG5cdFx0MCwwLDEsMCwwLFxuXHRcdDAsMCwwLDEsMCxcblx0XHQwLDAsMCwwLDFcblx0XTtcblxuXHQvKipcblx0ICogVGhlIGNvbnN0YW50IGxlbmd0aCBvZiBhIGNvbG9yIG1hdHJpeC5cblx0ICogQHByb3BlcnR5IExFTkdUSFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0Q29sb3JNYXRyaXguTEVOR1RIID0gQ29sb3JNYXRyaXguSURFTlRJVFlfTUFUUklYLmxlbmd0aDtcblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJlc2V0cyB0aGUgaW5zdGFuY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlcy5cblx0ICogQG1ldGhvZCBzZXRDb2xvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gYnJpZ2h0bmVzc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gY29udHJhc3Rcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNhdHVyYXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGh1ZVxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0cC5zZXRDb2xvciA9IGZ1bmN0aW9uKGJyaWdodG5lc3MsY29udHJhc3Qsc2F0dXJhdGlvbixodWUpIHtcblx0XHRyZXR1cm4gdGhpcy5yZXNldCgpLmFkanVzdENvbG9yKGJyaWdodG5lc3MsY29udHJhc3Qsc2F0dXJhdGlvbixodWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIG1hdHJpeCB0byBpZGVudGl0eSB2YWx1ZXMuXG5cdCAqIEBtZXRob2QgcmVzZXRcblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHAucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jb3B5KENvbG9yTWF0cml4LklERU5USVRZX01BVFJJWCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IG1ldGhvZCB0byBhZGp1c3QgYnJpZ2h0bmVzcywgY29udHJhc3QsIHNhdHVyYXRpb24gYW5kIGh1ZS5cblx0ICogRXF1aXZhbGVudCB0byBjYWxsaW5nIGFkanVzdEh1ZShodWUpLCBhZGp1c3RDb250cmFzdChjb250cmFzdCksXG5cdCAqIGFkanVzdEJyaWdodG5lc3MoYnJpZ2h0bmVzcyksIGFkanVzdFNhdHVyYXRpb24oc2F0dXJhdGlvbiksIGluIHRoYXQgb3JkZXIuXG5cdCAqIEBtZXRob2QgYWRqdXN0Q29sb3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJyaWdodG5lc3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvbnRyYXN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBodWVcblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFkanVzdENvbG9yID0gZnVuY3Rpb24oYnJpZ2h0bmVzcyxjb250cmFzdCxzYXR1cmF0aW9uLGh1ZSkge1xuXHRcdHRoaXMuYWRqdXN0SHVlKGh1ZSk7XG5cdFx0dGhpcy5hZGp1c3RDb250cmFzdChjb250cmFzdCk7XG5cdFx0dGhpcy5hZGp1c3RCcmlnaHRuZXNzKGJyaWdodG5lc3MpO1xuXHRcdHJldHVybiB0aGlzLmFkanVzdFNhdHVyYXRpb24oc2F0dXJhdGlvbik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkanVzdHMgdGhlIGJyaWdodG5lc3Mgb2YgcGl4ZWwgY29sb3IgYnkgYWRkaW5nIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gdGhlIHJlZCwgZ3JlZW4gYW5kIGJsdWUgY2hhbm5lbHMuXG5cdCAqIFBvc2l0aXZlIHZhbHVlcyB3aWxsIG1ha2UgdGhlIGltYWdlIGJyaWdodGVyLCBuZWdhdGl2ZSB2YWx1ZXMgd2lsbCBtYWtlIGl0IGRhcmtlci5cblx0ICogQG1ldGhvZCBhZGp1c3RCcmlnaHRuZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBBIHZhbHVlIGJldHdlZW4gLTI1NSAmIDI1NSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIFJHQiBjaGFubmVscy5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFkanVzdEJyaWdodG5lc3MgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSAwIHx8IGlzTmFOKHZhbHVlKSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHZhbHVlID0gdGhpcy5fY2xlYW5WYWx1ZSh2YWx1ZSwyNTUpO1xuXHRcdHRoaXMuX211bHRpcGx5TWF0cml4KFtcblx0XHRcdDEsMCwwLDAsdmFsdWUsXG5cdFx0XHQwLDEsMCwwLHZhbHVlLFxuXHRcdFx0MCwwLDEsMCx2YWx1ZSxcblx0XHRcdDAsMCwwLDEsMCxcblx0XHRcdDAsMCwwLDAsMVxuXHRcdF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGp1c3RzIHRoZSBjb250cmFzdCBvZiBwaXhlbCBjb2xvci5cblx0ICogUG9zaXRpdmUgdmFsdWVzIHdpbGwgaW5jcmVhc2UgY29udHJhc3QsIG5lZ2F0aXZlIHZhbHVlcyB3aWxsIGRlY3JlYXNlIGNvbnRyYXN0LlxuXHQgKiBAbWV0aG9kIGFkanVzdENvbnRyYXN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBBIHZhbHVlIGJldHdlZW4gLTEwMCAmIDEwMC5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFkanVzdENvbnRyYXN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gMCB8fCBpc05hTih2YWx1ZSkpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR2YWx1ZSA9IHRoaXMuX2NsZWFuVmFsdWUodmFsdWUsMTAwKTtcblx0XHR2YXIgeDtcblx0XHRpZiAodmFsdWU8MCkge1xuXHRcdFx0eCA9IDEyNyt2YWx1ZS8xMDAqMTI3O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gdmFsdWUlMTtcblx0XHRcdGlmICh4ID09IDApIHtcblx0XHRcdFx0eCA9IENvbG9yTWF0cml4LkRFTFRBX0lOREVYW3ZhbHVlXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHggPSBDb2xvck1hdHJpeC5ERUxUQV9JTkRFWFsodmFsdWU8PDApXSooMS14KStDb2xvck1hdHJpeC5ERUxUQV9JTkRFWFsodmFsdWU8PDApKzFdKng7IC8vIHVzZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBmb3IgbW9yZSBncmFudWxhcml0eS5cblx0XHRcdH1cblx0XHRcdHggPSB4KjEyNysxMjc7XG5cdFx0fVxuXHRcdHRoaXMuX211bHRpcGx5TWF0cml4KFtcblx0XHRcdHgvMTI3LDAsMCwwLDAuNSooMTI3LXgpLFxuXHRcdFx0MCx4LzEyNywwLDAsMC41KigxMjcteCksXG5cdFx0XHQwLDAseC8xMjcsMCwwLjUqKDEyNy14KSxcblx0XHRcdDAsMCwwLDEsMCxcblx0XHRcdDAsMCwwLDAsMVxuXHRcdF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGp1c3RzIHRoZSBjb2xvciBzYXR1cmF0aW9uIG9mIHRoZSBwaXhlbC5cblx0ICogUG9zaXRpdmUgdmFsdWVzIHdpbGwgaW5jcmVhc2Ugc2F0dXJhdGlvbiwgbmVnYXRpdmUgdmFsdWVzIHdpbGwgZGVjcmVhc2Ugc2F0dXJhdGlvbiAodHJlbmQgdG93YXJkcyBncmV5c2NhbGUpLlxuXHQgKiBAbWV0aG9kIGFkanVzdFNhdHVyYXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIEEgdmFsdWUgYmV0d2VlbiAtMTAwICYgMTAwLlxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYWRqdXN0U2F0dXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IDAgfHwgaXNOYU4odmFsdWUpKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dmFsdWUgPSB0aGlzLl9jbGVhblZhbHVlKHZhbHVlLDEwMCk7XG5cdFx0dmFyIHggPSAxKygodmFsdWUgPiAwKSA/IDMqdmFsdWUvMTAwIDogdmFsdWUvMTAwKTtcblx0XHR2YXIgbHVtUiA9IDAuMzA4Njtcblx0XHR2YXIgbHVtRyA9IDAuNjA5NDtcblx0XHR2YXIgbHVtQiA9IDAuMDgyMDtcblx0XHR0aGlzLl9tdWx0aXBseU1hdHJpeChbXG5cdFx0XHRsdW1SKigxLXgpK3gsbHVtRyooMS14KSxsdW1CKigxLXgpLDAsMCxcblx0XHRcdGx1bVIqKDEteCksbHVtRyooMS14KSt4LGx1bUIqKDEteCksMCwwLFxuXHRcdFx0bHVtUiooMS14KSxsdW1HKigxLXgpLGx1bUIqKDEteCkreCwwLDAsXG5cdFx0XHQwLDAsMCwxLDAsXG5cdFx0XHQwLDAsMCwwLDFcblx0XHRdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBBZGp1c3RzIHRoZSBodWUgb2YgdGhlIHBpeGVsIGNvbG9yLlxuXHQgKiBAbWV0aG9kIGFkanVzdEh1ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgQSB2YWx1ZSBiZXR3ZWVuIC0xODAgJiAxODAuXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hZGp1c3RIdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSAwIHx8IGlzTmFOKHZhbHVlKSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHZhbHVlID0gdGhpcy5fY2xlYW5WYWx1ZSh2YWx1ZSwxODApLzE4MCpNYXRoLlBJO1xuXHRcdHZhciBjb3NWYWwgPSBNYXRoLmNvcyh2YWx1ZSk7XG5cdFx0dmFyIHNpblZhbCA9IE1hdGguc2luKHZhbHVlKTtcblx0XHR2YXIgbHVtUiA9IDAuMjEzO1xuXHRcdHZhciBsdW1HID0gMC43MTU7XG5cdFx0dmFyIGx1bUIgPSAwLjA3Mjtcblx0XHR0aGlzLl9tdWx0aXBseU1hdHJpeChbXG5cdFx0XHRsdW1SK2Nvc1ZhbCooMS1sdW1SKStzaW5WYWwqKC1sdW1SKSxsdW1HK2Nvc1ZhbCooLWx1bUcpK3NpblZhbCooLWx1bUcpLGx1bUIrY29zVmFsKigtbHVtQikrc2luVmFsKigxLWx1bUIpLDAsMCxcblx0XHRcdGx1bVIrY29zVmFsKigtbHVtUikrc2luVmFsKigwLjE0MyksbHVtRytjb3NWYWwqKDEtbHVtRykrc2luVmFsKigwLjE0MCksbHVtQitjb3NWYWwqKC1sdW1CKStzaW5WYWwqKC0wLjI4MyksMCwwLFxuXHRcdFx0bHVtUitjb3NWYWwqKC1sdW1SKStzaW5WYWwqKC0oMS1sdW1SKSksbHVtRytjb3NWYWwqKC1sdW1HKStzaW5WYWwqKGx1bUcpLGx1bUIrY29zVmFsKigxLWx1bUIpK3NpblZhbCoobHVtQiksMCwwLFxuXHRcdFx0MCwwLDAsMSwwLFxuXHRcdFx0MCwwLDAsMCwxXG5cdFx0XSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmNhdGVuYXRlcyAobXVsdGlwbGllcykgdGhlIHNwZWNpZmllZCBtYXRyaXggd2l0aCB0aGlzIG9uZS5cblx0ICogQG1ldGhvZCBjb25jYXRcblx0ICogQHBhcmFtIHtBcnJheX0gbWF0cml4IEFuIGFycmF5IG9yIENvbG9yTWF0cml4IGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuY29uY2F0ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0bWF0cml4ID0gdGhpcy5fZml4TWF0cml4KG1hdHJpeCk7XG5cdFx0aWYgKG1hdHJpeC5sZW5ndGggIT0gQ29sb3JNYXRyaXguTEVOR1RIKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbXVsdGlwbHlNYXRyaXgobWF0cml4KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgQ29sb3JNYXRyaXguXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IEEgY2xvbmUgb2YgdGhpcyBDb2xvck1hdHJpeC5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIChuZXcgQ29sb3JNYXRyaXgoKSkuY29weSh0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJuIGEgbGVuZ3RoIDI1ICg1eDUpIGFycmF5IGluc3RhbmNlIGNvbnRhaW5pbmcgdGhpcyBtYXRyaXgncyB2YWx1ZXMuXG5cdCAqIEBtZXRob2QgdG9BcnJheVxuXHQgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgaG9sZGluZyB0aGlzIG1hdHJpeCdzIHZhbHVlcy5cblx0ICoqL1xuXHRwLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJyID0gW107XG5cdFx0Zm9yICh2YXIgaT0gMCwgbD1Db2xvck1hdHJpeC5MRU5HVEg7IGk8bDsgaSsrKSB7XG5cdFx0XHRhcnJbaV0gPSB0aGlzW2ldO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb3B5IHRoZSBzcGVjaWZpZWQgbWF0cml4J3MgdmFsdWVzIHRvIHRoaXMgbWF0cml4LlxuXHQgKiBAbWV0aG9kIGNvcHlcblx0ICogQHBhcmFtIHtBcnJheX0gbWF0cml4IEFuIGFycmF5IG9yIENvbG9yTWF0cml4IGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuY29weSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHZhciBsID0gQ29sb3JNYXRyaXguTEVOR1RIO1xuXHRcdGZvciAodmFyIGk9MDtpPGw7aSsrKSB7XG5cdFx0XHR0aGlzW2ldID0gbWF0cml4W2ldO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbQ29sb3JNYXRyaXhdXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfbXVsdGlwbHlNYXRyaXhcblx0ICogQHBhcmFtIHtBcnJheX0gbWF0cml4XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9tdWx0aXBseU1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHZhciBpLCBqLCBrLCBjb2wgPSBbXTtcblxuXHRcdGZvciAoaT0wO2k8NTtpKyspIHtcblx0XHRcdGZvciAoaj0wO2o8NTtqKyspIHtcblx0XHRcdFx0Y29sW2pdID0gdGhpc1tqK2kqNV07XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGo9MDtqPDU7aisrKSB7XG5cdFx0XHRcdHZhciB2YWw9MDtcblx0XHRcdFx0Zm9yIChrPTA7azw1O2srKykge1xuXHRcdFx0XHRcdHZhbCArPSBtYXRyaXhbaitrKjVdKmNvbFtrXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzW2oraSo1XSA9IHZhbDtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIE1ha2Ugc3VyZSB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHJhbmdlLCBodWUgaGFzIGEgbGltaXQgb2YgMTgwLCBicmlnaHRuZXNzIGlzIDI1NSwgb3RoZXJzIGFyZSAxMDAuXG5cdCAqIEBtZXRob2QgX2NsZWFuVmFsdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSByYXcgbnVtYmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdCBUaGUgbWF4aW11bSB0aGF0IHRoZSBudW1iZXIgY2FuIGJlLiBUaGUgbWluaW11bSBpcyB0aGUgbGltaXQgKiAtMS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2NsZWFuVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgbGltaXQpIHtcblx0XHRyZXR1cm4gTWF0aC5taW4obGltaXQsTWF0aC5tYXgoLWxpbWl0LHZhbHVlKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1ha2VzIHN1cmUgbWF0cml4ZXMgYXJlIDV4NSAoMjUgbG9uZykuXG5cdCAqIEBtZXRob2QgX2ZpeE1hdHJpeFxuXHQgKiBAcGFyYW0ge0FycmF5fSBtYXRyaXhcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2ZpeE1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdGlmIChtYXRyaXggaW5zdGFuY2VvZiBDb2xvck1hdHJpeCkgeyBtYXRyaXggPSBtYXRyaXgudG9BcnJheSgpOyB9XG5cdFx0aWYgKG1hdHJpeC5sZW5ndGggPCBDb2xvck1hdHJpeC5MRU5HVEgpIHtcblx0XHRcdG1hdHJpeCA9IG1hdHJpeC5zbGljZSgwLG1hdHJpeC5sZW5ndGgpLmNvbmNhdChDb2xvck1hdHJpeC5JREVOVElUWV9NQVRSSVguc2xpY2UobWF0cml4Lmxlbmd0aCxDb2xvck1hdHJpeC5MRU5HVEgpKTtcblx0XHR9IGVsc2UgaWYgKG1hdHJpeC5sZW5ndGggPiBDb2xvck1hdHJpeC5MRU5HVEgpIHtcblx0XHRcdG1hdHJpeCA9IG1hdHJpeC5zbGljZSgwLENvbG9yTWF0cml4LkxFTkdUSCk7XG5cdFx0fVxuXHRcdHJldHVybiBtYXRyaXg7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5Db2xvck1hdHJpeCA9IENvbG9yTWF0cml4O1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIENvbG9yTWF0cml4RmlsdGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQWxsb3dzIHlvdSB0byBjYXJyeSBvdXQgY29tcGxleCBjb2xvciBvcGVyYXRpb25zIHN1Y2ggYXMgbW9kaWZ5aW5nIHNhdHVyYXRpb24sIGJyaWdodG5lc3MsIG9yIGludmVydGluZy4gU2VlIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBjaGFuZ2luZyBjb2xvcnMuIEZvciBhbiBlYXNpZXIgY29sb3IgdHJhbnNmb3JtLFxuXHQgKiBjb25zaWRlciB0aGUge3sjY3Jvc3NMaW5rIFwiQ29sb3JGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYSByZWQgY2lyY2xlLCBpbnZlcnRzIGl0cyBodWUsIGFuZCB0aGVuIHNhdHVyYXRlcyBpdCB0byBicmlnaHRlbiBpdCB1cC5cblx0ICpcblx0ICogICAgICB2YXIgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKS5zZXQoe3g6MTAwLHk6MTAwfSk7XG5cdCAqICAgICAgc2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3Q2lyY2xlKDAsMCw1MCk7XG5cdCAqXG5cdCAqICAgICAgdmFyIG1hdHJpeCA9IG5ldyBjcmVhdGVqcy5Db2xvck1hdHJpeCgpLmFkanVzdEh1ZSgxODApLmFkanVzdFNhdHVyYXRpb24oMTAwKTtcblx0ICogICAgICBzaGFwZS5maWx0ZXJzID0gW1xuXHQgKiAgICAgICAgICBuZXcgY3JlYXRlanMuQ29sb3JNYXRyaXhGaWx0ZXIobWF0cml4KVxuXHQgKiAgICAgIF07XG5cdCAqXG5cdCAqICAgICAgc2hhcGUuY2FjaGUoLTUwLCAtNTAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fSBmb3IgYW4gbW9yZSBpbmZvcm1hdGlvbiBvbiBhcHBseWluZyBmaWx0ZXJzLlxuXHQgKiBAY2xhc3MgQ29sb3JNYXRyaXhGaWx0ZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBleHRlbmRzIEZpbHRlclxuXHQgKiBAcGFyYW0ge0FycmF5IHwgQ29sb3JNYXRyaXh9IG1hdHJpeCBBIDR4NSBtYXRyaXggZGVzY3JpYmluZyB0aGUgY29sb3Igb3BlcmF0aW9uIHRvIHBlcmZvcm0uIFNlZSBhbHNvIHRoZSB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBjbGFzcy5cblx0ICoqL1xuXHRmdW5jdGlvbiBDb2xvck1hdHJpeEZpbHRlcihtYXRyaXgpIHtcblx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEEgNHg1IG1hdHJpeCBkZXNjcmliaW5nIHRoZSBjb2xvciBvcGVyYXRpb24gdG8gcGVyZm9ybS4gU2VlIGFsc28gdGhlIHt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4XCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogQHByb3BlcnR5IG1hdHJpeFxuXHRcdCAqIEB0eXBlIEFycmF5IHwgQ29sb3JNYXRyaXhcblx0XHQgKiovXG5cdFx0dGhpcy5tYXRyaXggPSBtYXRyaXg7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQ29sb3JNYXRyaXhGaWx0ZXIsIGNyZWF0ZWpzLkZpbHRlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cdFxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltDb2xvck1hdHJpeEZpbHRlcl1cIjtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvck1hdHJpeEZpbHRlcih0aGlzLm1hdHJpeCk7XG5cdH07XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5fYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbihpbWFnZURhdGEpIHsgXG5cdFx0dmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHR2YXIgbCA9IGRhdGEubGVuZ3RoO1xuXHRcdHZhciByLGcsYixhO1xuXHRcdHZhciBtdHggPSB0aGlzLm1hdHJpeDtcblx0XHR2YXIgbTAgPSAgbXR4WzBdLCAgbTEgPSAgbXR4WzFdLCAgbTIgPSAgbXR4WzJdLCAgbTMgPSAgbXR4WzNdLCAgbTQgPSAgbXR4WzRdO1xuXHRcdHZhciBtNSA9ICBtdHhbNV0sICBtNiA9ICBtdHhbNl0sICBtNyA9ICBtdHhbN10sICBtOCA9ICBtdHhbOF0sICBtOSA9ICBtdHhbOV07XG5cdFx0dmFyIG0xMCA9IG10eFsxMF0sIG0xMSA9IG10eFsxMV0sIG0xMiA9IG10eFsxMl0sIG0xMyA9IG10eFsxM10sIG0xNCA9IG10eFsxNF07XG5cdFx0dmFyIG0xNSA9IG10eFsxNV0sIG0xNiA9IG10eFsxNl0sIG0xNyA9IG10eFsxN10sIG0xOCA9IG10eFsxOF0sIG0xOSA9IG10eFsxOV07XG5cblx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSs9NCkge1xuXHRcdFx0ciA9IGRhdGFbaV07XG5cdFx0XHRnID0gZGF0YVtpKzFdO1xuXHRcdFx0YiA9IGRhdGFbaSsyXTtcblx0XHRcdGEgPSBkYXRhW2krM107XG5cdFx0XHRkYXRhW2ldID0gciptMCtnKm0xK2IqbTIrYSptMyttNDsgLy8gcmVkXG5cdFx0XHRkYXRhW2krMV0gPSByKm01K2cqbTYrYiptNythKm04K205OyAvLyBncmVlblxuXHRcdFx0ZGF0YVtpKzJdID0gciptMTArZyptMTErYiptMTIrYSptMTMrbTE0OyAvLyBibHVlXG5cdFx0XHRkYXRhW2krM10gPSByKm0xNStnKm0xNitiKm0xNythKm0xOCttMTk7IC8vIGFscGhhXG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQ29sb3JNYXRyaXhGaWx0ZXIgPSBjcmVhdGVqcy5wcm9tb3RlKENvbG9yTWF0cml4RmlsdGVyLCBcIkZpbHRlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUb3VjaC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG4gKiBHbG9iYWwgdXRpbGl0eSBmb3Igd29ya2luZyB3aXRoIG11bHRpLXRvdWNoIGVuYWJsZWQgZGV2aWNlcyBpbiBFYXNlbEpTLiBDdXJyZW50bHkgc3VwcG9ydHMgVzNDIFRvdWNoIEFQSSAoaU9TIGFuZFxuICogbW9kZXJuIEFuZHJvaWQgYnJvd3NlcikgYW5kIHRoZSBQb2ludGVyIEFQSSAoSUUpLCBpbmNsdWRpbmcgbXMtcHJlZml4ZWQgZXZlbnRzIGluIElFMTAsIGFuZCB1bnByZWZpeGVkIGluIElFMTEuXG4gKlxuICogRW5zdXJlIHRoYXQgeW91IHt7I2Nyb3NzTGluayBcIlRvdWNoL2Rpc2FibGVcIn19e3svY3Jvc3NMaW5rfX0gdG91Y2ggd2hlbiBjbGVhbmluZyB1cCB5b3VyIGFwcGxpY2F0aW9uLiBZb3UgZG8gbm90IGhhdmVcbiAqIHRvIGNoZWNrIGlmIHRvdWNoIGlzIHN1cHBvcnRlZCB0byBlbmFibGUgaXQsIGFzIGl0IHdpbGwgZmFpbCBncmFjZWZ1bGx5IGlmIGl0IGlzIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogPGg0PkV4YW1wbGU8L2g0PlxuICpcbiAqICAgICAgdmFyIHN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKFwiY2FudmFzSWRcIik7XG4gKiAgICAgIGNyZWF0ZWpzLlRvdWNoLmVuYWJsZShzdGFnZSk7XG4gKlxuICogPHN0cm9uZz5Ob3RlOjwvc3Ryb25nPiBJdCBpcyBpbXBvcnRhbnQgdG8gZGlzYWJsZSBUb3VjaCBvbiBhIHN0YWdlIHRoYXQgeW91IGFyZSBubyBsb25nZXIgdXNpbmc6XG4gKlxuICogICAgICBjcmVhdGVqcy5Ub3VjaC5kaXNhYmxlKHN0YWdlKTtcbiAqXG4gKiBAY2xhc3MgVG91Y2hcbiAqIEBzdGF0aWNcbiAqKi9cblx0ZnVuY3Rpb24gVG91Y2goKSB7XG5cdFx0dGhyb3cgXCJUb3VjaCBjYW5ub3QgYmUgaW5zdGFudGlhdGVkXCI7XG5cdH1cblxuXG4vLyBwdWJsaWMgc3RhdGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0b3VjaCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci5cblx0ICogQG1ldGhvZCBpc1N1cHBvcnRlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0b3VjaCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci5cblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuXHQhISgoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSAvLyBpT1MgJiBBbmRyb2lkXG5cdFx0XHR8fCAod2luZG93Lm5hdmlnYXRvclsnbXNQb2ludGVyRW5hYmxlZCddICYmIHdpbmRvdy5uYXZpZ2F0b3JbJ21zTWF4VG91Y2hQb2ludHMnXSA+IDApIC8vIElFMTBcblx0XHRcdHx8ICh3aW5kb3cubmF2aWdhdG9yWydwb2ludGVyRW5hYmxlZCddICYmIHdpbmRvdy5uYXZpZ2F0b3JbJ21heFRvdWNoUG9pbnRzJ10gPiAwKSk7IC8vIElFMTErXG5cdH07XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgdG91Y2ggaW50ZXJhY3Rpb24gZm9yIHRoZSBzcGVjaWZpZWQgRWFzZWxKUyB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fS4gQ3VycmVudGx5IHN1cHBvcnRzIGlPU1xuXHQgKiAoYW5kIGNvbXBhdGlibGUgYnJvd3NlcnMsIHN1Y2ggYXMgbW9kZXJuIEFuZHJvaWQgYnJvd3NlcnMpLCBhbmQgSUUxMC8xMS4gU3VwcG9ydHMgYm90aCBzaW5nbGUgdG91Y2ggYW5kXG5cdCAqIG11bHRpLXRvdWNoIG1vZGVzLiBFeHRlbmRzIHRoZSBFYXNlbEpTIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gbW9kZWwsIGJ1dCB3aXRob3V0IHN1cHBvcnQgZm9yXG5cdCAqIGRvdWJsZSBjbGljayBvciBvdmVyL291dCBldmVudHMuIFNlZSB0aGUgTW91c2VFdmVudCB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50L3BvaW50ZXJJZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCBlbmFibGVcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2UgVGhlIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319IHRvIGVuYWJsZSB0b3VjaCBvbi5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbc2luZ2xlVG91Y2g9ZmFsc2VdIElmIGB0cnVlYCwgb25seSBhIHNpbmdsZSB0b3VjaCB3aWxsIGJlIGFjdGl2ZSBhdCBhIHRpbWUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbG93RGVmYXVsdD1mYWxzZV0gSWYgYHRydWVgLCB0aGVuIGRlZmF1bHQgZ2VzdHVyZSBhY3Rpb25zIChleC4gc2Nyb2xsaW5nLCB6b29taW5nKSB3aWxsIGJlXG5cdCAqIGFsbG93ZWQgd2hlbiB0aGUgdXNlciBpcyBpbnRlcmFjdGluZyB3aXRoIHRoZSB0YXJnZXQgY2FudmFzLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0b3VjaCB3YXMgc3VjY2Vzc2Z1bGx5IGVuYWJsZWQgb24gdGhlIHRhcmdldCBzdGFnZS5cblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLmVuYWJsZSA9IGZ1bmN0aW9uKHN0YWdlLCBzaW5nbGVUb3VjaCwgYWxsb3dEZWZhdWx0KSB7XG5cdFx0aWYgKCFzdGFnZSB8fCAhc3RhZ2UuY2FudmFzIHx8ICFUb3VjaC5pc1N1cHBvcnRlZCgpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmIChzdGFnZS5fX3RvdWNoKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHQvLyBpbmplY3QgcmVxdWlyZWQgcHJvcGVydGllcyBvbiBzdGFnZTpcblx0XHRzdGFnZS5fX3RvdWNoID0ge3BvaW50ZXJzOnt9LCBtdWx0aXRvdWNoOiFzaW5nbGVUb3VjaCwgcHJldmVudERlZmF1bHQ6IWFsbG93RGVmYXVsdCwgY291bnQ6MH07XG5cblx0XHQvLyBub3RlIHRoYXQgaW4gdGhlIGZ1dHVyZSB3ZSBtYXkgbmVlZCB0byBkaXNhYmxlIHRoZSBzdGFuZGFyZCBtb3VzZSBldmVudCBtb2RlbCBiZWZvcmUgYWRkaW5nXG5cdFx0Ly8gdGhlc2UgdG8gcHJldmVudCBkdXBsaWNhdGUgY2FsbHMuIEl0IGRvZXNuJ3Qgc2VlbSB0byBiZSBhbiBpc3N1ZSB3aXRoIGlPUyBkZXZpY2VzIHRob3VnaC5cblx0XHRpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7IFRvdWNoLl9JT1NfZW5hYmxlKHN0YWdlKTsgfVxuXHRcdGVsc2UgaWYgKHdpbmRvdy5uYXZpZ2F0b3JbJ21zUG9pbnRlckVuYWJsZWQnXSB8fCB3aW5kb3cubmF2aWdhdG9yW1wicG9pbnRlckVuYWJsZWRcIl0pIHsgVG91Y2guX0lFX2VuYWJsZShzdGFnZSk7IH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIHRoYXQgd2VyZSBzZXQgdXAgd2hlbiBjYWxsaW5nIGBUb3VjaC5lbmFibGUoKWAgb24gYSBzdGFnZS5cblx0ICogQG1ldGhvZCBkaXNhYmxlXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlIFRoZSB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fSB0byBkaXNhYmxlIHRvdWNoIG9uLlxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guZGlzYWJsZSA9IGZ1bmN0aW9uKHN0YWdlKSB7XG5cdFx0aWYgKCFzdGFnZSkgeyByZXR1cm47IH1cblx0XHRpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7IFRvdWNoLl9JT1NfZGlzYWJsZShzdGFnZSk7IH1cblx0XHRlbHNlIGlmICh3aW5kb3cubmF2aWdhdG9yWydtc1BvaW50ZXJFbmFibGVkJ10gfHwgd2luZG93Lm5hdmlnYXRvcltcInBvaW50ZXJFbmFibGVkXCJdKSB7IFRvdWNoLl9JRV9kaXNhYmxlKHN0YWdlKTsgfVxuXHRcdFxuXHRcdGRlbGV0ZSBzdGFnZS5fX3RvdWNoO1xuXHR9O1xuXG5cbi8vIFByaXZhdGUgc3RhdGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9JT1NfZW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLl9JT1NfZW5hYmxlID0gZnVuY3Rpb24oc3RhZ2UpIHtcblx0XHR2YXIgY2FudmFzID0gc3RhZ2UuY2FudmFzO1xuXHRcdHZhciBmID0gc3RhZ2UuX190b3VjaC5mID0gZnVuY3Rpb24oZSkgeyBUb3VjaC5fSU9TX2hhbmRsZUV2ZW50KHN0YWdlLGUpOyB9O1xuXHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBmLCBmYWxzZSk7XG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgZiwgZmFsc2UpO1xuXHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgZiwgZmFsc2UpO1xuXHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9JT1NfZGlzYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5fSU9TX2Rpc2FibGUgPSBmdW5jdGlvbihzdGFnZSkge1xuXHRcdHZhciBjYW52YXMgPSBzdGFnZS5jYW52YXM7XG5cdFx0aWYgKCFjYW52YXMpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIGYgPSBzdGFnZS5fX3RvdWNoLmY7XG5cdFx0Y2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0Y2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBmLCBmYWxzZSk7XG5cdFx0Y2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBmLCBmYWxzZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX0lPU19oYW5kbGVFdmVudFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLl9JT1NfaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihzdGFnZSwgZSkge1xuXHRcdGlmICghc3RhZ2UpIHsgcmV0dXJuOyB9XG5cdFx0aWYgKHN0YWdlLl9fdG91Y2gucHJldmVudERlZmF1bHQpIHsgZS5wcmV2ZW50RGVmYXVsdCYmZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG5cdFx0dmFyIHRvdWNoZXMgPSBlLmNoYW5nZWRUb3VjaGVzO1xuXHRcdHZhciB0eXBlID0gZS50eXBlO1xuXHRcdGZvciAodmFyIGk9IDAsbD10b3VjaGVzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG5cdFx0XHR2YXIgaWQgPSB0b3VjaC5pZGVudGlmaWVyO1xuXHRcdFx0aWYgKHRvdWNoLnRhcmdldCAhPSBzdGFnZS5jYW52YXMpIHsgY29udGludWU7IH1cblxuXHRcdFx0aWYgKHR5cGUgPT0gXCJ0b3VjaHN0YXJ0XCIpIHtcblx0XHRcdFx0dGhpcy5faGFuZGxlU3RhcnQoc3RhZ2UsIGlkLCBlLCB0b3VjaC5wYWdlWCwgdG91Y2gucGFnZVkpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09IFwidG91Y2htb3ZlXCIpIHtcblx0XHRcdFx0dGhpcy5faGFuZGxlTW92ZShzdGFnZSwgaWQsIGUsIHRvdWNoLnBhZ2VYLCB0b3VjaC5wYWdlWSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gXCJ0b3VjaGVuZFwiIHx8IHR5cGUgPT0gXCJ0b3VjaGNhbmNlbFwiKSB7XG5cdFx0XHRcdHRoaXMuX2hhbmRsZUVuZChzdGFnZSwgaWQsIGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfSUVfZW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLl9JRV9lbmFibGUgPSBmdW5jdGlvbihzdGFnZSkge1xuXHRcdHZhciBjYW52YXMgPSBzdGFnZS5jYW52YXM7XG5cdFx0dmFyIGYgPSBzdGFnZS5fX3RvdWNoLmYgPSBmdW5jdGlvbihlKSB7IFRvdWNoLl9JRV9oYW5kbGVFdmVudChzdGFnZSxlKTsgfTtcblxuXHRcdGlmICh3aW5kb3cubmF2aWdhdG9yW1wicG9pbnRlckVuYWJsZWRcIl0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJEb3duXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyTW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlclVwXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyQ2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0XHRcdGlmIChzdGFnZS5fX3RvdWNoLnByZXZlbnREZWZhdWx0KSB7IGNhbnZhcy5zdHlsZS5tc1RvdWNoQWN0aW9uID0gXCJub25lXCI7IH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBmLCBmYWxzZSk7XG5cdFx0XHRpZiAoc3RhZ2UuX190b3VjaC5wcmV2ZW50RGVmYXVsdCkgeyBjYW52YXMuc3R5bGUudG91Y2hBY3Rpb24gPSBcIm5vbmVcIjsgfVxuXG5cdFx0fVxuXHRcdHN0YWdlLl9fdG91Y2guYWN0aXZlSURzID0ge307XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX0lFX2Rpc2FibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lFX2Rpc2FibGUgPSBmdW5jdGlvbihzdGFnZSkge1xuXHRcdHZhciBmID0gc3RhZ2UuX190b3VjaC5mO1xuXG5cdFx0aWYgKHdpbmRvdy5uYXZpZ2F0b3JbXCJwb2ludGVyRW5hYmxlZFwiXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlck1vdmVcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJVcFwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlckNhbmNlbFwiLCBmLCBmYWxzZSk7XG5cdFx0XHRpZiAoc3RhZ2UuY2FudmFzKSB7XG5cdFx0XHRcdHN0YWdlLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyRG93blwiLCBmLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0XHRcdGlmIChzdGFnZS5jYW52YXMpIHtcblx0XHRcdFx0c3RhZ2UuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBmLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9JRV9oYW5kbGVFdmVudFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgZXZlbnQgdG8gaGFuZGxlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5fSUVfaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihzdGFnZSwgZSkge1xuXHRcdGlmICghc3RhZ2UpIHsgcmV0dXJuOyB9XG5cdFx0aWYgKHN0YWdlLl9fdG91Y2gucHJldmVudERlZmF1bHQpIHsgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCk7IH1cblx0XHR2YXIgdHlwZSA9IGUudHlwZTtcblx0XHR2YXIgaWQgPSBlLnBvaW50ZXJJZDtcblx0XHR2YXIgaWRzID0gc3RhZ2UuX190b3VjaC5hY3RpdmVJRHM7XG5cblx0XHRpZiAodHlwZSA9PSBcIk1TUG9pbnRlckRvd25cIiB8fCB0eXBlID09IFwicG9pbnRlcmRvd25cIikge1xuXHRcdFx0aWYgKGUuc3JjRWxlbWVudCAhPSBzdGFnZS5jYW52YXMpIHsgcmV0dXJuOyB9XG5cdFx0XHRpZHNbaWRdID0gdHJ1ZTtcblx0XHRcdHRoaXMuX2hhbmRsZVN0YXJ0KHN0YWdlLCBpZCwgZSwgZS5wYWdlWCwgZS5wYWdlWSk7XG5cdFx0fSBlbHNlIGlmIChpZHNbaWRdKSB7IC8vIGl0J3MgYW4gaWQgd2UncmUgd2F0Y2hpbmdcblx0XHRcdGlmICh0eXBlID09IFwiTVNQb2ludGVyTW92ZVwiIHx8IHR5cGUgPT0gXCJwb2ludGVybW92ZVwiKSB7XG5cdFx0XHRcdHRoaXMuX2hhbmRsZU1vdmUoc3RhZ2UsIGlkLCBlLCBlLnBhZ2VYLCBlLnBhZ2VZKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PSBcIk1TUG9pbnRlclVwXCIgfHwgdHlwZSA9PSBcIk1TUG9pbnRlckNhbmNlbFwiXG5cdFx0XHRcdFx0fHwgdHlwZSA9PSBcInBvaW50ZXJ1cFwiIHx8IHR5cGUgPT0gXCJwb2ludGVyY2FuY2VsXCIpIHtcblx0XHRcdFx0ZGVsZXRlKGlkc1tpZF0pO1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVFbmQoc3RhZ2UsIGlkLCBlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVN0YXJ0XG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRvdWNoLl9oYW5kbGVTdGFydCA9IGZ1bmN0aW9uKHN0YWdlLCBpZCwgZSwgeCwgeSkge1xuXHRcdHZhciBwcm9wcyA9IHN0YWdlLl9fdG91Y2g7XG5cdFx0aWYgKCFwcm9wcy5tdWx0aXRvdWNoICYmIHByb3BzLmNvdW50KSB7IHJldHVybjsgfVxuXHRcdHZhciBpZHMgPSBwcm9wcy5wb2ludGVycztcblx0XHRpZiAoaWRzW2lkXSkgeyByZXR1cm47IH1cblx0XHRpZHNbaWRdID0gdHJ1ZTtcblx0XHRwcm9wcy5jb3VudCsrO1xuXHRcdHN0YWdlLl9oYW5kbGVQb2ludGVyRG93bihpZCwgZSwgeCwgeSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1vdmVcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VG91Y2guX2hhbmRsZU1vdmUgPSBmdW5jdGlvbihzdGFnZSwgaWQsIGUsIHgsIHkpIHtcblx0XHRpZiAoIXN0YWdlLl9fdG91Y2gucG9pbnRlcnNbaWRdKSB7IHJldHVybjsgfVxuXHRcdHN0YWdlLl9oYW5kbGVQb2ludGVyTW92ZShpZCwgZSwgeCwgeSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVuZFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUb3VjaC5faGFuZGxlRW5kID0gZnVuY3Rpb24oc3RhZ2UsIGlkLCBlKSB7XG5cdFx0Ly8gVE9ETzogY2FuY2VsIHNob3VsZCBiZSBoYW5kbGVkIGRpZmZlcmVudGx5IGZvciBwcm9wZXIgVUkgKGV4LiBhbiB1cCB3b3VsZCB0cmlnZ2VyIGEgY2xpY2ssIGEgY2FuY2VsIHdvdWxkIG1vcmUgY2xvc2VseSByZXNlbWJsZSBhbiBvdXQpLlxuXHRcdHZhciBwcm9wcyA9IHN0YWdlLl9fdG91Y2g7XG5cdFx0dmFyIGlkcyA9IHByb3BzLnBvaW50ZXJzO1xuXHRcdGlmICghaWRzW2lkXSkgeyByZXR1cm47IH1cblx0XHRwcm9wcy5jb3VudC0tO1xuXHRcdHN0YWdlLl9oYW5kbGVQb2ludGVyVXAoaWQsIGUsIHRydWUpO1xuXHRcdGRlbGV0ZShpZHNbaWRdKTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlRvdWNoID0gVG91Y2g7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gdmVyc2lvbi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogU3RhdGljIGNsYXNzIGhvbGRpbmcgbGlicmFyeSBzcGVjaWZpYyBpbmZvcm1hdGlvbiBzdWNoIGFzIHRoZSB2ZXJzaW9uIGFuZCBidWlsZERhdGUgb2Zcblx0ICogdGhlIGxpYnJhcnkuXG5cdCAqIEBjbGFzcyBFYXNlbEpTXG5cdCAqKi9cblx0dmFyIHMgPSBjcmVhdGVqcy5FYXNlbEpTID0gY3JlYXRlanMuRWFzZWxKUyB8fCB7fTtcblxuXHQvKipcblx0ICogVGhlIHZlcnNpb24gc3RyaW5nIGZvciB0aGlzIHJlbGVhc2UuXG5cdCAqIEBwcm9wZXJ0eSB2ZXJzaW9uXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy52ZXJzaW9uID0gLyo9dmVyc2lvbiovXCIwLjguMlwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cblx0LyoqXG5cdCAqIFRoZSBidWlsZCBkYXRlIGZvciB0aGlzIHJlbGVhc2UgaW4gVVRDIGZvcm1hdC5cblx0ICogQHByb3BlcnR5IGJ1aWxkRGF0ZVxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdHMuYnVpbGREYXRlID0gLyo9ZGF0ZSovXCJUaHUsIDI2IE5vdiAyMDE1IDIwOjQ0OjM0IEdNVFwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cbn0pKCk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyB2ZXJzaW9uLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogU3RhdGljIGNsYXNzIGhvbGRpbmcgbGlicmFyeSBzcGVjaWZpYyBpbmZvcm1hdGlvbiBzdWNoIGFzIHRoZSB2ZXJzaW9uIGFuZCBidWlsZERhdGUgb2YgdGhlIGxpYnJhcnkuXG5cdCAqIEBjbGFzcyBQcmVsb2FkSlNcblx0ICoqL1xuXHR2YXIgcyA9IGNyZWF0ZWpzLlByZWxvYWRKUyA9IGNyZWF0ZWpzLlByZWxvYWRKUyB8fCB7fTtcblxuXHQvKipcblx0ICogVGhlIHZlcnNpb24gc3RyaW5nIGZvciB0aGlzIHJlbGVhc2UuXG5cdCAqIEBwcm9wZXJ0eSB2ZXJzaW9uXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLnZlcnNpb24gPSAvKj12ZXJzaW9uKi9cIjAuNi4yXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxuXHQvKipcblx0ICogVGhlIGJ1aWxkIGRhdGUgZm9yIHRoaXMgcmVsZWFzZSBpbiBVVEMgZm9ybWF0LlxuXHQgKiBAcHJvcGVydHkgYnVpbGREYXRlXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLmJ1aWxkRGF0ZSA9IC8qPWRhdGUqL1wiVGh1LCAyNiBOb3YgMjAxNSAyMDo0NDozMSBHTVRcIjsgLy8gaW5qZWN0ZWQgYnkgYnVpbGQgcHJvY2Vzc1xuXG59KSgpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gcHJveHkuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8qKlxuICogVmFyaW91cyB1dGlsaXRpZXMgdGhhdCB0aGUgQ3JlYXRlSlMgU3VpdGUgdXNlcy4gVXRpbGl0aWVzIGFyZSBjcmVhdGVkIGFzIHNlcGFyYXRlIGZpbGVzLCBhbmQgd2lsbCBiZSBhdmFpbGFibGUgb24gdGhlXG4gKiBjcmVhdGVqcyBuYW1lc3BhY2UgZGlyZWN0bHkuXG4gKlxuICogPGg0PkV4YW1wbGU8L2g0PlxuICpcbiAqICAgICAgbXlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBjcmVhdGVqcy5wcm94eShteU1ldGhvZCwgc2NvcGUpKTtcbiAqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKiBAbWFpbiBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBIGZ1bmN0aW9uIHByb3h5IGZvciBtZXRob2RzLiBCeSBkZWZhdWx0LCBKYXZhU2NyaXB0IG1ldGhvZHMgZG8gbm90IG1haW50YWluIHNjb3BlLCBzbyBwYXNzaW5nIGEgbWV0aG9kIGFzIGFcblx0ICogY2FsbGJhY2sgd2lsbCByZXN1bHQgaW4gdGhlIG1ldGhvZCBnZXR0aW5nIGNhbGxlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIGNhbGxlci4gVXNpbmcgYSBwcm94eSBlbnN1cmVzIHRoYXQgdGhlXG5cdCAqIG1ldGhvZCBnZXRzIGNhbGxlZCBpbiB0aGUgY29ycmVjdCBzY29wZS5cblx0ICpcblx0ICogQWRkaXRpb25hbCBhcmd1bWVudHMgY2FuIGJlIHBhc3NlZCB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZnVuY3Rpb24gd2hlbiBpdCBpcyBjYWxsZWQuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBteU9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwiZXZlbnRcIiwgY3JlYXRlanMucHJveHkobXlIYW5kbGVyLCB0aGlzLCBhcmcxLCBhcmcyKSk7XG5cdCAqXG5cdCAqICAgICAgZnVuY3Rpb24gbXlIYW5kbGVyKGFyZzEsIGFyZzIpIHtcblx0ICogICAgICAgICAgIC8vIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBteU9iamVjdC5teUNhbGxiYWNrIGlzIGV4ZWN1dGVkLlxuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQG1ldGhvZCBwcm94eVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgVGhlIGZ1bmN0aW9uIHRvIGNhbGxcblx0ICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFRoZSBzY29wZSB0byBjYWxsIHRoZSBtZXRob2QgbmFtZSBvblxuXHQgKiBAcGFyYW0ge21peGVkfSBbYXJnXSAqIEFyZ3VtZW50cyB0aGF0IGFyZSBhcHBlbmRlZCB0byB0aGUgY2FsbGJhY2sgZm9yIGFkZGl0aW9uYWwgcGFyYW1zLlxuXHQgKiBAcHVibGljXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdGNyZWF0ZWpzLnByb3h5ID0gZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUpIHtcblx0XHR2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gbWV0aG9kLmFwcGx5KHNjb3BlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLmNvbmNhdChhQXJncykpO1xuXHRcdH07XG5cdH1cblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEVycm9yRXZlbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJhbCBlcnJvciB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSwgdGhhdCBkZXNjcmliZXMgYW4gZXJyb3IgdGhhdCBvY2N1cnJlZCwgYXMgd2VsbCBhcyBhbnkgZGV0YWlscy5cblx0ICogQGNsYXNzIEVycm9yRXZlbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0aXRsZV0gVGhlIGVycm9yIHRpdGxlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gVGhlIGVycm9yIGRlc2NyaXB0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gQWRkaXRpb25hbCBlcnJvciBkYXRhXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gRXJyb3JFdmVudCh0aXRsZSwgbWVzc2FnZSwgZGF0YSkge1xuXHRcdHRoaXMuRXZlbnRfY29uc3RydWN0b3IoXCJlcnJvclwiKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzaG9ydCBlcnJvciB0aXRsZSwgd2hpY2ggaW5kaWNhdGVzIHRoZSB0eXBlIG9mIGVycm9yIHRoYXQgb2NjdXJyZWQuXG5cdFx0ICogQHByb3BlcnR5IHRpdGxlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0dGhpcy50aXRsZSA9IHRpdGxlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHZlcmJvc2UgZXJyb3IgbWVzc2FnZSwgY29udGFpbmluZyBkZXRhaWxzIGFib3V0IHRoZSBlcnJvci5cblx0XHQgKiBAcHJvcGVydHkgbWVzc2FnZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cblx0XHQvKipcblx0XHQgKiBBZGRpdGlvbmFsIGRhdGEgYXR0YWNoZWQgdG8gYW4gZXJyb3IuXG5cdFx0ICogQHByb3BlcnR5IGRhdGFcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdH1cblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChFcnJvckV2ZW50LCBjcmVhdGVqcy5FdmVudCk7XG5cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgY3JlYXRlanMuRXJyb3JFdmVudCh0aGlzLnRpdGxlLCB0aGlzLm1lc3NhZ2UsIHRoaXMuZGF0YSk7XG5cdH07XG5cblx0Y3JlYXRlanMuRXJyb3JFdmVudCA9IGNyZWF0ZWpzLnByb21vdGUoRXJyb3JFdmVudCwgXCJFdmVudFwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFByb2dyZXNzRXZlbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoc2NvcGUpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgQ3JlYXRlSlMge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBkaXNwYXRjaGVkIHdoZW4gcHJvZ3Jlc3MgY2hhbmdlcy5cblx0ICogQGNsYXNzIFByb2dyZXNzRXZlbnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxvYWRlZCBUaGUgYW1vdW50IHRoYXQgaGFzIGJlZW4gbG9hZGVkLiBUaGlzIGNhbiBiZSBhbnkgbnVtYmVyIHJlbGF0aXZlIHRvIHRoZSB0b3RhbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0b3RhbD0xXSBUaGUgdG90YWwgYW1vdW50IHRoYXQgd2lsbCBsb2FkLiBUaGlzIHdpbGwgZGVmYXVsdCB0byAxLCBzbyBpZiB0aGUgYGxvYWRlZGAgdmFsdWUgaXNcblx0ICogYSBwZXJjZW50YWdlIChiZXR3ZWVuIDAgYW5kIDEpLCBpdCBjYW4gYmUgb21pdHRlZC5cblx0ICogQHRvZG8gQ29uc2lkZXIgaGF2aW5nIHRoaXMgZXZlbnQgYmUgYSBcImZpbGVwcm9ncmVzc1wiIGV2ZW50IGFzIHdlbGxcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBQcm9ncmVzc0V2ZW50KGxvYWRlZCwgdG90YWwpIHtcblx0XHR0aGlzLkV2ZW50X2NvbnN0cnVjdG9yKFwicHJvZ3Jlc3NcIik7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYW1vdW50IHRoYXQgaGFzIGJlZW4gbG9hZGVkIChvdXQgb2YgYSB0b3RhbCBhbW91bnQpXG5cdFx0ICogQHByb3BlcnR5IGxvYWRlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5sb2FkZWQgPSBsb2FkZWQ7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdG90YWwgXCJzaXplXCIgb2YgdGhlIGxvYWQuXG5cdFx0ICogQHByb3BlcnR5IHRvdGFsXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy50b3RhbCA9ICh0b3RhbCA9PSBudWxsKSA/IDEgOiB0b3RhbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBwZXJjZW50YWdlIChvdXQgb2YgMSkgdGhhdCB0aGUgbG9hZCBoYXMgYmVlbiBjb21wbGV0ZWQuIFRoaXMgaXMgY2FsY3VsYXRlZCB1c2luZyBgbG9hZGVkL3RvdGFsYC5cblx0XHQgKiBAcHJvcGVydHkgcHJvZ3Jlc3Ncblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLnByb2dyZXNzID0gKHRvdGFsID09IDApID8gMCA6IHRoaXMubG9hZGVkIC8gdGhpcy50b3RhbDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChQcm9ncmVzc0V2ZW50LCBjcmVhdGVqcy5FdmVudCk7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgUHJvZ3Jlc3NFdmVudCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtQcm9ncmVzc0V2ZW50fSBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50KHRoaXMubG9hZGVkLCB0aGlzLnRvdGFsKTtcblx0fTtcblxuXHRjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50ID0gY3JlYXRlanMucHJvbW90ZShQcm9ncmVzc0V2ZW50LCBcIkV2ZW50XCIpO1xuXG59KHdpbmRvdykpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8ganNvbjMuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIERvbVV0aWxzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuXHQgKiBBIGZldyB1dGlsaXRpZXMgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIGRvbS5cblx0ICogQGNsYXNzIERvbVV0aWxzXG5cdCAqL1xuXHR2YXIgcyA9IHt9O1xuXG5cdHMuYXBwZW5kVG9IZWFkID0gZnVuY3Rpb24gKGVsKSB7XG5cdFx0cy5nZXRIZWFkKCkuYXBwZW5kQ2hpbGQoZWwpXG5cdH1cblxuXHRzLmdldEhlYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuXHR9XG5cblx0cy5nZXRCb2R5ID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTtcblx0fVxuXG5cdGNyZWF0ZWpzLkRvbVV0aWxzID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIERhdGFVdGlscy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblxuXHQvKipcblx0ICogQSBmZXcgZGF0YSB1dGlsaXRpZXMgZm9yIGZvcm1hdHRpbmcgZGlmZmVyZW50IGRhdGEgdHlwZXMuXG5cdCAqIEBjbGFzcyBEYXRhVXRpbHNcblx0ICovXG5cdHZhciBzID0ge307XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIFBhcnNlIFhNTCB1c2luZyB0aGUgRE9NLiBUaGlzIGlzIHJlcXVpcmVkIHdoZW4gcHJlbG9hZGluZyBYTUwgb3IgU1ZHLlxuXHQgKiBAbWV0aG9kIHBhcnNlWE1MXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSByYXcgdGV4dCBvciBYTUwgdGhhdCBpcyBsb2FkZWQgYnkgWEhSLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbWltZSB0eXBlIG9mIHRoZSBYTUwuIFVzZSBcInRleHQveG1sXCIgZm9yIFhNTCwgYW5kICBcImltYWdlL3N2Zyt4bWxcIiBmb3IgU1ZHIHBhcnNpbmcuXG5cdCAqIEByZXR1cm4ge1hNTH0gQW4gWE1MIGRvY3VtZW50XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMucGFyc2VYTUwgPSBmdW5jdGlvbiAodGV4dCwgdHlwZSkge1xuXHRcdHZhciB4bWwgPSBudWxsO1xuXHRcdC8vIENvY29vbkpTIGRvZXMgbm90IHN1cHBvcnQgWE1MIHBhcnNpbmcgd2l0aCBlaXRoZXIgbWV0aG9kLlxuXG5cdFx0Ly8gTW9zdCBicm93c2VycyB3aWxsIHVzZSBET01QYXJzZXJcblx0XHQvLyBJRSBmYWlscyBvbiBjZXJ0YWluIFNWRyBmaWxlcywgc28gd2UgaGF2ZSBhIGZhbGxiYWNrIGJlbG93LlxuXHRcdHRyeSB7XG5cdFx0XHRpZiAod2luZG93LkRPTVBhcnNlcikge1xuXHRcdFx0XHR2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdFx0XHR4bWwgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRleHQsIHR5cGUpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayBmb3IgSUUgc3VwcG9ydC5cblx0XHRpZiAoIXhtbCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0eG1sID0gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpO1xuXHRcdFx0XHR4bWwuYXN5bmMgPSBmYWxzZTtcblx0XHRcdFx0eG1sLmxvYWRYTUwodGV4dCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHhtbCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHhtbDtcblx0fTtcblxuXHQvKipcblx0ICogUGFyc2UgYSBzdHJpbmcgaW50byBhbiBPYmplY3QuXG5cdCAqIEBtZXRob2QgcGFyc2VKU09OXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgbG9hZGVkIEpTT04gc3RyaW5nXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IEEgSmF2YVNjcmlwdCBvYmplY3QuXG5cdCAqL1xuXHRzLnBhcnNlSlNPTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIFRPRE87IEhhbmRsZSB0aGlzIHdpdGggYSBjdXN0b20gZXJyb3I/XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0fTtcblxuXHRjcmVhdGVqcy5EYXRhVXRpbHMgPSBzO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTG9hZEl0ZW0uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBbGwgbG9hZGVycyBhY2NlcHQgYW4gaXRlbSBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhpcyBjbGFzcy4gSWYgYSByYXcgb2JqZWN0IGlzIHBhc3NlZCBpbnN0ZWFkLFxuXHQgKiBpdCB3aWxsIG5vdCBiZSBhZmZlY3RlZCwgYnV0IGl0IG11c3QgY29udGFpbiBhdCBsZWFzdCBhIHt7I2Nyb3NzTGluayBcInNyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eS4gQVxuXHQgKiBzdHJpbmcgcGF0aCBvciBIVE1MIHRhZyBpcyBhbHNvIGFjY2VwdGFibGUsIGJ1dCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGEgTG9hZEl0ZW0gdXNpbmcgdGhlXG5cdCAqIHt7I2Nyb3NzTGluayBcImNyZWF0ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgYnkge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogQGNsYXNzIExvYWRJdGVtXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdGZ1bmN0aW9uIExvYWRJdGVtKCkge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBzb3VyY2Ugb2YgdGhlIGZpbGUgdGhhdCBpcyBiZWluZyBsb2FkZWQuIFRoaXMgcHJvcGVydHkgaXMgPGI+cmVxdWlyZWQ8L2I+LiBUaGUgc291cmNlIGNhbiBlaXRoZXIgYmUgYVxuXHRcdCAqIHN0cmluZyAocmVjb21tZW5kZWQpLCBvciBhbiBIVE1MIHRhZy5cblx0XHQgKiBUaGlzIGNhbiBhbHNvIGJlIGFuIG9iamVjdCwgYnV0IGluIHRoYXQgY2FzZSBpdCBoYXMgdG8gaW5jbHVkZSBhIHR5cGUgYW5kIGJlIGhhbmRsZWQgYnkgYSBwbHVnaW4uXG5cdFx0ICogQHByb3BlcnR5IHNyY1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuc3JjID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIGZpbGUgdGhhdCBpcyBiZWluZyBsb2FkZWQuIFRoZSB0eXBlIG9mIHRoZSBmaWxlIGlzIHVzdWFsbHkgaW5mZXJyZWQgYnkgdGhlIGV4dGVuc2lvbiwgYnV0IGNhbiBhbHNvXG5cdFx0ICogYmUgc2V0IG1hbnVhbGx5LiBUaGlzIGlzIGhlbHBmdWwgaW4gY2FzZXMgd2hlcmUgYSBmaWxlIGRvZXMgbm90IGhhdmUgYW4gZXh0ZW5zaW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSB0eXBlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy50eXBlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIGlkZW50aWZpZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSBsb2FkZWQgb2JqZWN0LiBJZiBub25lIGlzIHByb3ZpZGVkLCB0aGlzIHdpbGwgYmVcblx0XHQgKiBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGUge3sjY3Jvc3NMaW5rIFwic3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBpZFxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuaWQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiBhIG1hbmlmZXN0IHdpbGwgbWFpbnRhaW4gdGhlIG9yZGVyIG9mIHRoaXMgaXRlbSwgaW4gcmVsYXRpb24gdG8gb3RoZXIgaXRlbXMgaW4gdGhlIG1hbmlmZXN0XG5cdFx0ICogdGhhdCBoYXZlIGFsc28gc2V0IHRoZSBgbWFpbnRhaW5PcmRlcmAgcHJvcGVydHkgdG8gYHRydWVgLiBUaGlzIG9ubHkgYXBwbGllcyB3aGVuIHRoZSBtYXggY29ubmVjdGlvbnMgaGFzXG5cdFx0ICogYmVlbiBzZXQgYWJvdmUgMSAodXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319KS4gRXZlcnl0aGluZyB3aXRoIHRoaXNcblx0XHQgKiBwcm9wZXJ0eSBzZXQgdG8gYGZhbHNlYCB3aWxsIGZpbmlzaCBhcyBpdCBpcyBsb2FkZWQuIE9yZGVyZWQgaXRlbXMgYXJlIGNvbWJpbmVkIHdpdGggc2NyaXB0IHRhZ3MgbG9hZGluZyBpblxuXHRcdCAqIG9yZGVyIHdoZW4ge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL21haW50YWluU2NyaXB0T3JkZXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgc2V0IHRvIGB0cnVlYC5cblx0XHQgKiBAcHJvcGVydHkgbWFpbnRhaW5PcmRlclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5tYWludGFpbk9yZGVyID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBBIGNhbGxiYWNrIHVzZWQgYnkgSlNPTlAgcmVxdWVzdHMgdGhhdCBkZWZpbmVzIHdoYXQgZ2xvYmFsIG1ldGhvZCB0byBjYWxsIHdoZW4gdGhlIEpTT05QIGNvbnRlbnQgaXMgbG9hZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBjYWxsYmFja1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJiaXRyYXJ5IGRhdGEgb2JqZWN0LCB3aGljaCBpcyBpbmNsdWRlZCB3aXRoIHRoZSBsb2FkZWQgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBkYXRhXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5kYXRhID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZXF1ZXN0IG1ldGhvZCB1c2VkIGZvciBIVFRQIGNhbGxzLiBCb3RoIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0dFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBvclxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1BPU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcmVxdWVzdCB0eXBlcyBhcmUgc3VwcG9ydGVkLCBhbmQgYXJlIGRlZmluZWQgYXNcblx0XHQgKiBjb25zdGFudHMgb24ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IG1ldGhvZFxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgZ2V0XG5cdFx0ICovXG5cdFx0dGhpcy5tZXRob2QgPSBjcmVhdGVqcy5Mb2FkSXRlbS5HRVQ7XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBuYW1lL3ZhbHVlIHBhaXJzIHRvIHNlbmQgdG8gdGhlIHNlcnZlci5cblx0XHQgKiBAcHJvcGVydHkgdmFsdWVzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy52YWx1ZXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgaGVhZGVycyB0byBhdHRhY2ggdG8gYW4gWEhSIHJlcXVlc3QuIFByZWxvYWRKUyB3aWxsIGF1dG9tYXRpY2FsbHkgYXR0YWNoIHNvbWUgZGVmYXVsdFxuXHRcdCAqIGhlYWRlcnMgd2hlbiByZXF1aXJlZCwgaW5jbHVkaW5nIFwiT3JpZ2luXCIsIFwiQ29udGVudC1UeXBlXCIsIGFuZCBcIlgtUmVxdWVzdGVkLVdpdGhcIi4gWW91IG1heSBvdmVycmlkZSB0aGVcblx0XHQgKiBkZWZhdWx0IGhlYWRlcnMgYnkgaW5jbHVkaW5nIHRoZW0gaW4geW91ciBoZWFkZXJzIG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgaGVhZGVyc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuaGVhZGVycyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBFbmFibGUgY3JlZGVudGlhbHMgZm9yIFhIUiByZXF1ZXN0cy5cblx0XHQgKiBAcHJvcGVydHkgd2l0aENyZWRlbnRpYWxzXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBtaW1lIHR5cGUgb2YgWEhSLWJhc2VkIHJlcXVlc3RzLiBUaGlzIGlzIGF1dG9tYXRpY2FsbHkgc2V0IHRvIFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiIGZvciB0ZXh0XG5cdFx0ICogYmFzZWQgZmlsZXMgKGpzb24sIHhtbCwgdGV4dCwgY3NzLCBqcykuXG5cdFx0ICogQHByb3BlcnR5IG1pbWVUeXBlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5taW1lVHlwZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBTZXRzIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgZm9yIENPUlMtZW5hYmxlZCBpbWFnZXMgbG9hZGluZyBjcm9zcy1kb21haW4uXG5cdFx0ICogQHByb3BlcnR5IGNyb3NzT3JpZ2luXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgQW5vbnltb3VzXG5cdFx0ICovXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGEgcmVxdWVzdCB0aW1lcyBvdXQuIFRoaXMgb25seSBhcHBsaWVzIHRvIHRhZy1iYXNlZCBhbmQgYW5kIFhIUlxuXHRcdCAqIChsZXZlbCBvbmUpIGxvYWRpbmcsIGFzIFhIUiAobGV2ZWwgMikgcHJvdmlkZXMgaXRzIG93biB0aW1lb3V0IGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBsb2FkVGltZW91dFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgODAwMCAoOCBzZWNvbmRzKVxuXHRcdCAqL1xuXHRcdHRoaXMubG9hZFRpbWVvdXQgPSBzLkxPQURfVElNRU9VVF9ERUZBVUxUO1xuXHR9O1xuXG5cdHZhciBwID0gTG9hZEl0ZW0ucHJvdG90eXBlID0ge307XG5cdHZhciBzID0gTG9hZEl0ZW07XG5cblx0LyoqXG5cdCAqIERlZmF1bHQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGEgcmVxdWVzdCB0aW1lcyBvdXQuIFRoaXMgb25seSBhcHBsaWVzIHRvIHRhZy1iYXNlZCBhbmQgYW5kIFhIUlxuXHQgKiAobGV2ZWwgb25lKSBsb2FkaW5nLCBhcyBYSFIgKGxldmVsIDIpIHByb3ZpZGVzIGl0cyBvd24gdGltZW91dCBldmVudC5cblx0ICogQHByb3BlcnR5IExPQURfVElNRU9VVF9ERUZBVUxUXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuTE9BRF9USU1FT1VUX0RFRkFVTFQgPSA4MDAwO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBMb2FkSXRlbS5cblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPlN0cmluZy1iYXNlZCBpdGVtcyBhcmUgY29udmVydGVkIHRvIGEgTG9hZEl0ZW0gd2l0aCBhIHBvcHVsYXRlZCB7eyNjcm9zc0xpbmsgXCJzcmM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uPC9saT5cblx0ICogICAgIDxsaT5Mb2FkSXRlbSBpbnN0YW5jZXMgYXJlIHJldHVybmVkIGFzLWlzPC9saT5cblx0ICogICAgIDxsaT5PYmplY3RzIGFyZSByZXR1cm5lZCB3aXRoIGFueSBuZWVkZWQgcHJvcGVydGllcyBhZGRlZDwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIEBtZXRob2QgY3JlYXRlXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18U3RyaW5nfE9iamVjdH0gdmFsdWUgVGhlIGxvYWQgaXRlbSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7TG9hZEl0ZW18T2JqZWN0fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIGl0ZW0gPSBuZXcgTG9hZEl0ZW0oKTtcblx0XHRcdGl0ZW0uc3JjID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2Ygcykge1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgdmFsdWUuc3JjKSB7XG5cdFx0XHRpZiAodmFsdWUubG9hZFRpbWVvdXQgPT0gbnVsbCkge1xuXHRcdFx0XHR2YWx1ZS5sb2FkVGltZW91dCA9IHMuTE9BRF9USU1FT1VUX0RFRkFVTFQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlR5cGUgbm90IHJlY29nbml6ZWQuXCIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUHJvdmlkZXMgYSBjaGFpbmFibGUgc2hvcnRjdXQgbWV0aG9kIGZvciBzZXR0aW5nIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIGxvYWRJdGVtID0gbmV3IGNyZWF0ZWpzLkxvYWRJdGVtKCkuc2V0KHtzcmM6XCJpbWFnZS5wbmdcIiwgbWFpbnRhaW5PcmRlcjp0cnVlfSk7XG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjb3B5IHRvIHRoZSBMb2FkSXRlbSBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7TG9hZEl0ZW19IFJldHVybnMgdGhlIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0Ki9cblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHsgdGhpc1tuXSA9IHByb3BzW25dOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0Y3JlYXRlanMuTG9hZEl0ZW0gPSBzO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gUmVxdWVzdFV0aWxzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuXHQgKiBVdGlsaXRpZXMgdGhhdCBhc3Npc3Qgd2l0aCBwYXJzaW5nIGxvYWQgaXRlbXMsIGFuZCBkZXRlcm1pbmluZyBmaWxlIHR5cGVzLCBldGMuXG5cdCAqIEBjbGFzcyBSZXF1ZXN0VXRpbHNcblx0ICovXG5cdHZhciBzID0ge307XG5cblx0LyoqXG5cdCAqIFRoZSBSZWd1bGFyIEV4cHJlc3Npb24gdXNlZCB0byB0ZXN0IGZpbGUgVVJMUyBmb3IgYW4gYWJzb2x1dGUgcGF0aC5cblx0ICogQHByb3BlcnR5IEFCU09MVVRFX1BBVEhcblx0ICogQHR5cGUge1JlZ0V4cH1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5BQlNPTFVURV9QQVRUID0gL14oPzpcXHcrOik/XFwvezJ9L2k7XG5cblx0LyoqXG5cdCAqIFRoZSBSZWd1bGFyIEV4cHJlc3Npb24gdXNlZCB0byB0ZXN0IGZpbGUgVVJMUyBmb3IgYSByZWxhdGl2ZSBwYXRoLlxuXHQgKiBAcHJvcGVydHkgUkVMQVRJVkVfUEFUSFxuXHQgKiBAdHlwZSB7UmVnRXhwfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlJFTEFUSVZFX1BBVFQgPSAoL15bLi9dKj9cXC8vaSk7XG5cblx0LyoqXG5cdCAqIFRoZSBSZWd1bGFyIEV4cHJlc3Npb24gdXNlZCB0byB0ZXN0IGZpbGUgVVJMUyBmb3IgYW4gZXh0ZW5zaW9uLiBOb3RlIHRoYXQgVVJJcyBtdXN0IGFscmVhZHkgaGF2ZSB0aGUgcXVlcnkgc3RyaW5nXG5cdCAqIHJlbW92ZWQuXG5cdCAqIEBwcm9wZXJ0eSBFWFRFTlNJT05fUEFUVFxuXHQgKiBAdHlwZSB7UmVnRXhwfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLkVYVEVOU0lPTl9QQVRUID0gL1xcLz9bXi9dK1xcLihcXHd7MSw1fSkkL2k7XG5cblx0LyoqXG5cdCAqIFBhcnNlIGEgZmlsZSBwYXRoIHRvIGRldGVybWluZSB0aGUgaW5mb3JtYXRpb24gd2UgbmVlZCB0byB3b3JrIHdpdGggaXQuIEN1cnJlbnRseSwgUHJlbG9hZEpTIG5lZWRzIHRvIGtub3c6XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5JZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gQWJzb2x1dGUgcGF0aHMgc3RhcnQgd2l0aCBhIHByb3RvY29sIChzdWNoIGFzIGBodHRwOi8vYCwgYGZpbGU6Ly9gLCBvclxuXHQgKiAgICAgYC8vbmV0d29ya1BhdGhgKTwvbGk+XG5cdCAqICAgICA8bGk+SWYgdGhlIHBhdGggaXMgcmVsYXRpdmUuIFJlbGF0aXZlIHBhdGhzIHN0YXJ0IHdpdGggYC4uL2Agb3IgYC9wYXRoYCAob3Igc2ltaWxhcik8L2xpPlxuXHQgKiAgICAgPGxpPlRoZSBmaWxlIGV4dGVuc2lvbi4gVGhpcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBmaWxlbmFtZSB3aXRoIGFuIGV4dGVuc2lvbi4gUXVlcnkgc3RyaW5ncyBhcmUgZHJvcHBlZCwgYW5kXG5cdCAqICAgICB0aGUgZmlsZSBwYXRoIGlzIGV4cGVjdGVkIHRvIGZvbGxvdyB0aGUgZm9ybWF0IGBuYW1lLmV4dGAuPC9saT5cblx0ICogPC91bD5cblx0ICogQG1ldGhvZCBwYXJzZVVSSVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBPYmplY3Qgd2l0aCBhbiBgYWJzb2x1dGVgIGFuZCBgcmVsYXRpdmVgIEJvb2xlYW4gdmFsdWVzLCBhcyB3ZWxsIGFzIGFuIG9wdGlvbmFsICdleHRlbnNpb25gXG5cdCAqIHByb3BlcnR5LCB3aGljaCBpcyB0aGUgbG93ZXJjYXNlIGV4dGVuc2lvbi5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5wYXJzZVVSSSA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0dmFyIGluZm8gPSB7YWJzb2x1dGU6IGZhbHNlLCByZWxhdGl2ZTogZmFsc2V9O1xuXHRcdGlmIChwYXRoID09IG51bGwpIHsgcmV0dXJuIGluZm87IH1cblxuXHRcdC8vIERyb3AgdGhlIHF1ZXJ5IHN0cmluZ1xuXHRcdHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKTtcblx0XHRpZiAocXVlcnlJbmRleCA+IC0xKSB7XG5cdFx0XHRwYXRoID0gcGF0aC5zdWJzdHIoMCwgcXVlcnlJbmRleCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJzb2x1dGVcblx0XHR2YXIgbWF0Y2g7XG5cdFx0aWYgKHMuQUJTT0xVVEVfUEFUVC50ZXN0KHBhdGgpKSB7XG5cdFx0XHRpbmZvLmFic29sdXRlID0gdHJ1ZTtcblxuXHRcdFx0Ly8gUmVsYXRpdmVcblx0XHR9IGVsc2UgaWYgKHMuUkVMQVRJVkVfUEFUVC50ZXN0KHBhdGgpKSB7XG5cdFx0XHRpbmZvLnJlbGF0aXZlID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBFeHRlbnNpb25cblx0XHRpZiAobWF0Y2ggPSBwYXRoLm1hdGNoKHMuRVhURU5TSU9OX1BBVFQpKSB7XG5cdFx0XHRpbmZvLmV4dGVuc2lvbiA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBpbmZvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb3JtYXRzIGFuIG9iamVjdCBpbnRvIGEgcXVlcnkgc3RyaW5nIGZvciBlaXRoZXIgYSBQT1NUIG9yIEdFVCByZXF1ZXN0LlxuXHQgKiBAbWV0aG9kIGZvcm1hdFF1ZXJ5U3RyaW5nXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIHRvIGNvbnZlcnQgdG8gYSBxdWVyeSBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtxdWVyeV0gRXhpc3RpbmcgbmFtZS92YWx1ZSBwYWlycyB0byBhcHBlbmQgb24gdG8gdGhpcyBxdWVyeS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5mb3JtYXRRdWVyeVN0cmluZyA9IGZ1bmN0aW9uIChkYXRhLCBxdWVyeSkge1xuXHRcdGlmIChkYXRhID09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBkYXRhLicpO1xuXHRcdH1cblx0XHR2YXIgcGFyYW1zID0gW107XG5cdFx0Zm9yICh2YXIgbiBpbiBkYXRhKSB7XG5cdFx0XHRwYXJhbXMucHVzaChuICsgJz0nICsgZXNjYXBlKGRhdGFbbl0pKTtcblx0XHR9XG5cdFx0aWYgKHF1ZXJ5KSB7XG5cdFx0XHRwYXJhbXMgPSBwYXJhbXMuY29uY2F0KHF1ZXJ5KTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcmFtcy5qb2luKCcmJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgdXRpbGl0eSBtZXRob2QgdGhhdCBidWlsZHMgYSBmaWxlIHBhdGggdXNpbmcgYSBzb3VyY2UgYW5kIGEgZGF0YSBvYmplY3QsIGFuZCBmb3JtYXRzIGl0IGludG8gYSBuZXcgcGF0aC5cblx0ICogQG1ldGhvZCBidWlsZFBhdGhcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIHBhdGggdG8gYWRkIHZhbHVlcyB0by5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSBPYmplY3QgdXNlZCB0byBhcHBlbmQgdmFsdWVzIHRvIHRoaXMgcmVxdWVzdCBhcyBhIHF1ZXJ5IHN0cmluZy4gRXhpc3RpbmcgcGFyYW1ldGVycyBvbiB0aGVcblx0ICogcGF0aCB3aWxsIGJlIHByZXNlcnZlZC5cblx0ICogQHJldHVybnMge3N0cmluZ30gQSBmb3JtYXR0ZWQgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIHBhdGggYW5kIHRoZSBzdXBwbGllZCBwYXJhbWV0ZXJzLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChzcmMsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gc3JjO1xuXHRcdH1cblxuXHRcdHZhciBxdWVyeSA9IFtdO1xuXHRcdHZhciBpZHggPSBzcmMuaW5kZXhPZignPycpO1xuXG5cdFx0aWYgKGlkeCAhPSAtMSkge1xuXHRcdFx0dmFyIHEgPSBzcmMuc2xpY2UoaWR4ICsgMSk7XG5cdFx0XHRxdWVyeSA9IHF1ZXJ5LmNvbmNhdChxLnNwbGl0KCcmJykpO1xuXHRcdH1cblxuXHRcdGlmIChpZHggIT0gLTEpIHtcblx0XHRcdHJldHVybiBzcmMuc2xpY2UoMCwgaWR4KSArICc/JyArIHRoaXMuZm9ybWF0UXVlcnlTdHJpbmcoZGF0YSwgcXVlcnkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gc3JjICsgJz8nICsgdGhpcy5mb3JtYXRRdWVyeVN0cmluZyhkYXRhLCBxdWVyeSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGlzQ3Jvc3NEb21haW5cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gQSBsb2FkIGl0ZW0gd2l0aCBhIGBzcmNgIHByb3BlcnR5LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgbG9hZCBpdGVtIGlzIGxvYWRpbmcgZnJvbSBhIGRpZmZlcmVudCBkb21haW4gdGhhbiB0aGUgY3VycmVudCBsb2NhdGlvbi5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc0Nyb3NzRG9tYWluID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHR2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG5cdFx0dGFyZ2V0LmhyZWYgPSBpdGVtLnNyYztcblxuXHRcdHZhciBob3N0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG5cdFx0aG9zdC5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuXHRcdHZhciBjcm9zc2RvbWFpbiA9ICh0YXJnZXQuaG9zdG5hbWUgIT0gXCJcIikgJiZcblx0XHRcdFx0XHRcdCAgKHRhcmdldC5wb3J0ICE9IGhvc3QucG9ydCB8fFxuXHRcdFx0XHRcdFx0ICAgdGFyZ2V0LnByb3RvY29sICE9IGhvc3QucHJvdG9jb2wgfHxcblx0XHRcdFx0XHRcdCAgIHRhcmdldC5ob3N0bmFtZSAhPSBob3N0Lmhvc3RuYW1lKTtcblx0XHRyZXR1cm4gY3Jvc3Nkb21haW47XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgaXNMb2NhbFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBBIGxvYWQgaXRlbSB3aXRoIGEgYHNyY2AgcHJvcGVydHlcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGxvYWQgaXRlbSBpcyBsb2FkaW5nIGZyb20gdGhlIFwiZmlsZTpcIiBwcm90b2NvbC4gQXNzdW1lIHRoYXQgdGhlIGhvc3QgbXVzdCBiZSBsb2NhbCBhc1xuXHQgKiB3ZWxsLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzTG9jYWwgPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHZhciB0YXJnZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0XHR0YXJnZXQuaHJlZiA9IGl0ZW0uc3JjO1xuXHRcdHJldHVybiB0YXJnZXQuaG9zdG5hbWUgPT0gXCJcIiAmJiB0YXJnZXQucHJvdG9jb2wgPT0gXCJmaWxlOlwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyB0eXBlIHNob3VsZCBiZSBsb2FkZWQgYXMgYSBiaW5hcnkgZmlsZS4gQ3VycmVudGx5LCBvbmx5IGltYWdlcyBhbmQgaXRlbXMgbWFya2VkXG5cdCAqIHNwZWNpZmljYWxseSBhcyBcImJpbmFyeVwiIGFyZSBsb2FkZWQgYXMgYmluYXJ5LiBOb3RlIHRoYXQgYXVkaW8gaXMgPGI+bm90PC9iPiBhIGJpbmFyeSB0eXBlLCBhcyB3ZSBjYW4gbm90IHBsYXlcblx0ICogYmFjayB1c2luZyBhbiBhdWRpbyB0YWcgaWYgaXQgaXMgbG9hZGVkIGFzIGJpbmFyeS4gUGx1Z2lucyBjYW4gY2hhbmdlIHRoZSBpdGVtIHR5cGUgdG8gYmluYXJ5IHRvIGVuc3VyZSB0aGV5IGdldFxuXHQgKiBhIGJpbmFyeSByZXN1bHQgdG8gd29yayB3aXRoLiBCaW5hcnkgZmlsZXMgYXJlIGxvYWRlZCB1c2luZyBYSFIyLiBUeXBlcyBhcmUgZGVmaW5lZCBhcyBzdGF0aWMgY29uc3RhbnRzIG9uXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGlzQmluYXJ5XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBpdGVtIHR5cGUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBzcGVjaWZpZWQgdHlwZSBpcyBiaW5hcnkuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNCaW5hcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5JTUFHRTpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQklOQVJZOlxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGl0ZW0gaXMgYSB2YWxpZCBIVE1MSW1hZ2VFbGVtZW50XG5cdCAqIEBtZXRob2QgaXNJbWFnZVRhZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc0ltYWdlVGFnID0gZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudDtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgaXRlbSBpcyBhIHZhbGlkIEhUTUxBdWRpb0VsZW1lbnRcblx0ICogQG1ldGhvZCBpc0F1ZGlvVGFnXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzQXVkaW9UYWcgPSBmdW5jdGlvbihpdGVtKSB7XG5cdFx0aWYgKHdpbmRvdy5IVE1MQXVkaW9FbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gaXRlbSBpbnN0YW5jZW9mIEhUTUxBdWRpb0VsZW1lbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGl0ZW0gaXMgYSB2YWxpZCBIVE1MVmlkZW9FbGVtZW50XG5cdCAqIEBtZXRob2QgaXNWaWRlb1RhZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc1ZpZGVvVGFnID0gZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmICh3aW5kb3cuSFRNTFZpZGVvRWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyB0eXBlIGlzIGEgdGV4dC1iYXNlZCBhc3NldCwgYW5kIHNob3VsZCBiZSBsb2FkZWQgYXMgVVRGLTguXG5cdCAqIEBtZXRob2QgaXNUZXh0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBpdGVtIHR5cGUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBzcGVjaWZpZWQgdHlwZSBpcyB0ZXh0LlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzVGV4dCA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQ6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT046XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLk1BTklGRVNUOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5YTUw6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkNTUzpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1ZHOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KQVZBU0NSSVBUOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TUFJJVEVTSEVFVDpcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgdGhlIG9iamVjdCB1c2luZyBjb21tb24gZXh0ZW5zaW9ucy4gTm90ZSB0aGF0IHRoZSB0eXBlIGNhbiBiZSBwYXNzZWQgaW4gd2l0aCB0aGUgbG9hZCBpdGVtXG5cdCAqIGlmIGl0IGlzIGFuIHVudXN1YWwgZXh0ZW5zaW9uLlxuXHQgKiBAbWV0aG9kIGdldFR5cGVCeUV4dGVuc2lvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXh0ZW5zaW9uIFRoZSBmaWxlIGV4dGVuc2lvbiB0byB1c2UgdG8gZGV0ZXJtaW5lIHRoZSBsb2FkIHR5cGUuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGRldGVybWluZWQgbG9hZCB0eXBlIChmb3IgZXhhbXBsZSwgPGNvZGU+QWJzdHJhY3RMb2FkZXIuSU1BR0U8L2NvZGU+KS4gV2lsbCByZXR1cm4gYG51bGxgIGlmXG5cdCAqIHRoZSB0eXBlIGNhbiBub3QgYmUgZGV0ZXJtaW5lZCBieSB0aGUgZXh0ZW5zaW9uLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmdldFR5cGVCeUV4dGVuc2lvbiA9IGZ1bmN0aW9uIChleHRlbnNpb24pIHtcblx0XHRpZiAoZXh0ZW5zaW9uID09IG51bGwpIHtcblx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5URVhUO1xuXHRcdH1cblxuXHRcdHN3aXRjaCAoZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdGNhc2UgXCJqcGVnXCI6XG5cdFx0XHRjYXNlIFwianBnXCI6XG5cdFx0XHRjYXNlIFwiZ2lmXCI6XG5cdFx0XHRjYXNlIFwicG5nXCI6XG5cdFx0XHRjYXNlIFwid2VicFwiOlxuXHRcdFx0Y2FzZSBcImJtcFwiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSU1BR0U7XG5cdFx0XHRjYXNlIFwib2dnXCI6XG5cdFx0XHRjYXNlIFwibXAzXCI6XG5cdFx0XHRjYXNlIFwid2VibVwiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU09VTkQ7XG5cdFx0XHRjYXNlIFwibXA0XCI6XG5cdFx0XHRjYXNlIFwid2VibVwiOlxuXHRcdFx0Y2FzZSBcInRzXCI6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5WSURFTztcblx0XHRcdGNhc2UgXCJqc29uXCI6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OO1xuXHRcdFx0Y2FzZSBcInhtbFwiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuWE1MO1xuXHRcdFx0Y2FzZSBcImNzc1wiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQ1NTO1xuXHRcdFx0Y2FzZSBcImpzXCI6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KQVZBU0NSSVBUO1xuXHRcdFx0Y2FzZSAnc3ZnJzpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNWRztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5URVhUO1xuXHRcdH1cblx0fTtcblxuXHRjcmVhdGVqcy5SZXF1ZXN0VXRpbHMgPSBzO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWJzdHJhY3RMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogVGhlIGJhc2UgbG9hZGVyLCB3aGljaCBkZWZpbmVzIGFsbCB0aGUgZ2VuZXJpYyBtZXRob2RzLCBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzLiBBbGwgbG9hZGVycyBleHRlbmQgdGhpcyBjbGFzcyxcblx0ICogaW5jbHVkaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBjbGFzcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfG9iamVjdHxzdHJpbmd9IGxvYWRJdGVtIFRoZSBpdGVtIHRvIGJlIGxvYWRlZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcHJlZmVyWEhSXSBEZXRlcm1pbmVzIGlmIHRoZSBMb2FkSXRlbSBzaG91bGQgPGVtPnRyeTwvZW0+IGFuZCBsb2FkIHVzaW5nIFhIUiwgb3IgdGFrZSBhXG5cdCAqIHRhZy1iYXNlZCBhcHByb2FjaCwgd2hpY2ggY2FuIGJlIGJldHRlciBpbiBjcm9zcy1kb21haW4gc2l0dWF0aW9ucy4gTm90IGFsbCBsb2FkZXJzIGNhbiBsb2FkIHVzaW5nIG9uZSBvciB0aGVcblx0ICogb3RoZXIsIHNvIHRoaXMgaXMgYSBzdWdnZXN0ZWQgZGlyZWN0aXZlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIFRoZSB0eXBlIG9mIGxvYWRlci4gTG9hZGVyIHR5cGVzIGFyZSBkZWZpbmVkIGFzIGNvbnN0YW50cyBvbiB0aGUgQWJzdHJhY3RMb2FkZXIgY2xhc3MsXG5cdCAqIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiSU1BR0U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkNTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSwgZXRjLlxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcblx0ICovXG5cdGZ1bmN0aW9uIEFic3RyYWN0TG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIsIHR5cGUpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBJZiB0aGUgbG9hZGVyIGhhcyBjb21wbGV0ZWQgbG9hZGluZy4gVGhpcyBwcm92aWRlcyBhIHF1aWNrIGNoZWNrLCBidXQgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIGRpZmZlcmVudCBhcHByb2FjaGVzXG5cdFx0ICogdXNlZCBmb3IgbG9hZGluZyBkbyBub3QgcGlsZSB1cCByZXN1bHRpbmcgaW4gbW9yZSB0aGFuIG9uZSBgY29tcGxldGVgIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBsb2FkZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMubG9hZGVkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmUgaWYgdGhlIGxvYWRlciB3YXMgY2FuY2VsZWQuIENhbmNlbGVkIGxvYWRzIHdpbGwgbm90IGZpcmUgY29tcGxldGUgZXZlbnRzLiBOb3RlIHRoYXQgdGhpcyBwcm9wZXJ0eVxuXHRcdCAqIGlzIHJlYWRvbmx5LCBzbyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gcXVldWVzIHNob3VsZCBiZSBjbG9zZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2Nsb3NlXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogaW5zdGVhZC5cblx0XHQgKiBAcHJvcGVydHkgY2FuY2VsZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMuY2FuY2VsZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IGxvYWQgcHJvZ3Jlc3MgKHBlcmNlbnRhZ2UpIGZvciB0aGlzIGl0ZW0uIFRoaXMgd2lsbCBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG5cdFx0ICpcblx0XHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdFx0ICpcblx0XHQgKiAgICAgdmFyIHF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSgpO1xuXHRcdCAqICAgICBxdWV1ZS5sb2FkRmlsZShcImxhcmdlSW1hZ2UucG5nXCIpO1xuXHRcdCAqICAgICBxdWV1ZS5vbihcInByb2dyZXNzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgICAgY29uc29sZS5sb2coXCJQcm9ncmVzczpcIiwgcXVldWUucHJvZ3Jlc3MsIGV2ZW50LnByb2dyZXNzKTtcblx0XHQgKiAgICAgfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgcHJvZ3Jlc3Ncblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLnByb2dyZXNzID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIGl0ZW0gdGhpcyBsb2FkZXIgd2lsbCBsb2FkLiBTZWUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGEgZnVsbCBsaXN0IG9mXG5cdFx0ICogc3VwcG9ydGVkIHR5cGVzLlxuXHRcdCAqIEBwcm9wZXJ0eSB0eXBlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBmb3JtYXR0ZXIgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyB0aGUgbG9hZGVkIHJhdyByZXN1bHQgaW50byB0aGUgZmluYWwgcmVzdWx0LiBGb3IgZXhhbXBsZSwgdGhlIEpTT05Mb2FkZXJcblx0XHQgKiBjb252ZXJ0cyBhIHN0cmluZyBvZiB0ZXh0IGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC4gTm90IGFsbCBsb2FkZXJzIGhhdmUgYSByZXN1bHRGb3JtYXR0ZXIsIGFuZCB0aGlzIHByb3BlcnR5XG5cdFx0ICogY2FuIGJlIG92ZXJyaWRkZW4gdG8gcHJvdmlkZSBjdXN0b20gZm9ybWF0dGluZy5cblx0XHQgKlxuXHRcdCAqIE9wdGlvbmFsbHksIGEgcmVzdWx0Rm9ybWF0dGVyIGNhbiByZXR1cm4gYSBjYWxsYmFjayBmdW5jdGlvbiBpbiBjYXNlcyB3aGVyZSB0aGUgZm9ybWF0dGluZyBuZWVkcyB0byBiZVxuXHRcdCAqIGFzeW5jaHJvbm91cywgc3VjaCBhcyBjcmVhdGluZyBhIG5ldyBpbWFnZS4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHBhc3NlZCAyIHBhcmFtZXRlcnMsIHdoaWNoIGFyZSBjYWxsYmFja3Ncblx0XHQgKiB0byBoYW5kbGUgc3VjY2VzcyBhbmQgZXJyb3IgY29uZGl0aW9ucyBpbiB0aGUgcmVzdWx0Rm9ybWF0dGVyLiBOb3RlIHRoYXQgdGhlIHJlc3VsdEZvcm1hdHRlciBtZXRob2QgaXNcblx0XHQgKiBjYWxsZWQgaW4gdGhlIGN1cnJlbnQgc2NvcGUsIGFzIHdlbGwgYXMgdGhlIHN1Y2Nlc3MgYW5kIGVycm9yIGNhbGxiYWNrcy5cblx0XHQgKlxuXHRcdCAqIDxoND5FeGFtcGxlIGFzeW5jaHJvbm91cyByZXN1bHRGb3JtYXR0ZXI8L2g0PlxuXHRcdCAqXG5cdFx0ICogXHRmdW5jdGlvbiBfZm9ybWF0UmVzdWx0KGxvYWRlcikge1xuXHRcdCAqIFx0XHRyZXR1cm4gZnVuY3Rpb24oc3VjY2VzcywgZXJyb3IpIHtcblx0XHQgKiBcdFx0XHRpZiAoZXJyb3JDb25kaXRpb24pIHsgZXJyb3IoZXJyb3JEZXRhaWxFdmVudCk7IH1cblx0XHQgKiBcdFx0XHRzdWNjZXNzKHJlc3VsdCk7XG5cdFx0ICogXHRcdH1cblx0XHQgKiBcdH1cblx0XHQgKiBAcHJvcGVydHkgcmVzdWx0Rm9ybWF0dGVyXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IG51bGw7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSB0aGlzIGxvYWRlciByZXByZXNlbnRzLiBOb3RlIHRoYXQgdGhpcyBpcyBudWxsIGluIGEge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319LFxuXHRcdCAqIGJ1dCB3aWxsIGJlIGF2YWlsYWJsZSBvbiBsb2FkZXJzIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiWE1MTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJJbWFnZUxvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX2l0ZW1cblx0XHQgKiBAdHlwZSB7TG9hZEl0ZW18T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0aWYgKGxvYWRJdGVtKSB7XG5cdFx0XHR0aGlzLl9pdGVtID0gY3JlYXRlanMuTG9hZEl0ZW0uY3JlYXRlKGxvYWRJdGVtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faXRlbSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgbG9hZGVyIHdpbGwgdHJ5IGFuZCBsb2FkIGNvbnRlbnQgdXNpbmcgWEhSICh0cnVlKSBvciBIVE1MIHRhZ3MgKGZhbHNlKS5cblx0XHQgKiBAcHJvcGVydHkgX3ByZWZlclhIUlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcHJlZmVyWEhSID0gcHJlZmVyWEhSO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxvYWRlZCByZXN1bHQgYWZ0ZXIgaXQgaXMgZm9ybWF0dGVkIGJ5IGFuIG9wdGlvbmFsIHt7I2Nyb3NzTGluayBcInJlc3VsdEZvcm1hdHRlclwifX17ey9jcm9zc0xpbmt9fS4gRm9yXG5cdFx0ICogaXRlbXMgdGhhdCBhcmUgbm90IGZvcm1hdHRlZCwgdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSB7eyNjcm9zc0xpbmsgXCJfcmF3UmVzdWx0OnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIFRoZSByZXN1bHQgaXMgYWNjZXNzZWQgdXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcImdldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdFx0ICogQHByb3BlcnR5IF9yZXN1bHRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fFN0cmluZ31cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Jlc3VsdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbG9hZGVkIHJlc3VsdCBiZWZvcmUgaXQgaXMgZm9ybWF0dGVkLiBUaGUgcmF3UmVzdWx0IGlzIGFjY2Vzc2VkIHVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJnZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBtZXRob2QsIGFuZCBwYXNzaW5nIGB0cnVlYC5cblx0XHQgKiBAcHJvcGVydHkgX3Jhd1Jlc3VsdFxuXHRcdCAqIEB0eXBlIHtPYmplY3R8U3RyaW5nfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcmF3UmVzdWx0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgbGlzdCBvZiBpdGVtcyB0aGF0IGxvYWRlcnMgbG9hZCBiZWhpbmQgdGhlIHNjZW5lcy4gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBtYWluIGl0ZW0gdGhlIGxvYWRlciBpc1xuXHRcdCAqIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nLiBFeGFtcGxlcyBvZiBsb2FkZXJzIHRoYXQgaGF2ZSBzdWItaXRlbXMgaW5jbHVkZSB0aGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYW5kXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkSXRlbXNcblx0XHQgKiBAdHlwZSB7bnVsbH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZGVkSXRlbXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGF0dHJpYnV0ZSB0aGUgaXRlbXMgbG9hZGVkIHVzaW5nIHRhZ3MgdXNlIGZvciB0aGUgc291cmNlLlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIEhUTUwgdGFnIChvciBzaW1pbGFyKSB0aGF0IGEgbG9hZGVyIG1heSB1c2UgdG8gbG9hZCBIVE1MIGNvbnRlbnQsIHN1Y2ggYXMgaW1hZ2VzLCBzY3JpcHRzLCBldGMuXG5cdFx0ICogQHByb3BlcnR5IF90YWdcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFnID0gbnVsbDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChBYnN0cmFjdExvYWRlciwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblx0dmFyIHMgPSBBYnN0cmFjdExvYWRlcjtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIGEgUE9TVCByZXF1ZXN0LCB1c2UgZm9yIGEgbWV0aG9kIHZhbHVlIHdoZW4gbG9hZGluZyBkYXRhLlxuXHQgKiBAcHJvcGVydHkgUE9TVFxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBwb3N0XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuUE9TVCA9IFwiUE9TVFwiO1xuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIGEgR0VUIHJlcXVlc3QsIHVzZSBmb3IgYSBtZXRob2QgdmFsdWUgd2hlbiBsb2FkaW5nIGRhdGEuXG5cdCAqIEBwcm9wZXJ0eSBHRVRcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICogQGRlZmF1bHQgZ2V0XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuR0VUID0gXCJHRVRcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgZ2VuZXJpYyBiaW5hcnkgdHlwZXMuIE5vdGUgdGhhdCBpbWFnZXMgYXJlIGxvYWRlZCBhcyBiaW5hcnkgZmlsZXMgd2hlbiB1c2luZyBYSFIuXG5cdCAqIEBwcm9wZXJ0eSBCSU5BUllcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgYmluYXJ5XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLkJJTkFSWSA9IFwiYmluYXJ5XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGNzcyBmaWxlcy4gQ1NTIGZpbGVzIGFyZSBsb2FkZWQgdXNpbmcgYSAmbHQ7bGluayZndDsgd2hlbiBsb2FkZWQgd2l0aCBYSFIsIG9yIGFcblx0ICogJmx0O3N0eWxlJmd0OyB0YWcgd2hlbiBsb2FkZWQgd2l0aCB0YWdzLlxuXHQgKiBAcHJvcGVydHkgQ1NTXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGNzc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5DU1MgPSBcImNzc1wiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBpbWFnZSBmaWxlcywgdXN1YWxseSBwbmcsIGdpZiwgb3IganBnL2pwZWcuIEltYWdlcyBhcmUgbG9hZGVkIGludG8gYW4gJmx0O2ltYWdlJmd0OyB0YWcuXG5cdCAqIEBwcm9wZXJ0eSBJTUFHRVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBpbWFnZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5JTUFHRSA9IFwiaW1hZ2VcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgamF2YXNjcmlwdCBmaWxlcywgdXN1YWxseSB3aXRoIHRoZSBcImpzXCIgZmlsZSBleHRlbnNpb24uIEphdmFTY3JpcHQgZmlsZXMgYXJlIGxvYWRlZCBpbnRvIGFcblx0ICogJmx0O3NjcmlwdCZndDsgdGFnLlxuXHQgKlxuXHQgKiBTaW5jZSB2ZXJzaW9uIDAuNC4xKywgZHVlIHRvIGhvdyB0YWctbG9hZGVkIHNjcmlwdHMgd29yaywgYWxsIEphdmFTY3JpcHQgZmlsZXMgYXJlIGF1dG9tYXRpY2FsbHkgaW5qZWN0ZWQgaW50b1xuXHQgKiB0aGUgYm9keSBvZiB0aGUgZG9jdW1lbnQgdG8gbWFpbnRhaW4gcGFyaXR5IGJldHdlZW4gWEhSIGFuZCB0YWctbG9hZGVkIHNjcmlwdHMuIEluIHZlcnNpb24gMC40LjAgYW5kIGVhcmxpZXIsXG5cdCAqIG9ubHkgdGFnLWxvYWRlZCBzY3JpcHRzIGFyZSBpbmplY3RlZC5cblx0ICogQHByb3BlcnR5IEpBVkFTQ1JJUFRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgamF2YXNjcmlwdFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5KQVZBU0NSSVBUID0gXCJqYXZhc2NyaXB0XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGpzb24gZmlsZXMsIHVzdWFsbHkgd2l0aCB0aGUgXCJqc29uXCIgZmlsZSBleHRlbnNpb24uIEpTT04gZGF0YSBpcyBsb2FkZWQgYW5kIHBhcnNlZCBpbnRvIGFcblx0ICogSmF2YVNjcmlwdCBvYmplY3QuIE5vdGUgdGhhdCBpZiBhIGBjYWxsYmFja2AgaXMgcHJlc2VudCBvbiB0aGUgbG9hZCBpdGVtLCB0aGUgZmlsZSB3aWxsIGJlIGxvYWRlZCB3aXRoIEpTT05QLFxuXHQgKiBubyBtYXR0ZXIgd2hhdCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3ByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpcyBzZXQgdG8sIGFuZCB0aGUgSlNPTlxuXHQgKiBtdXN0IGNvbnRhaW4gYSBtYXRjaGluZyB3cmFwcGVyIGZ1bmN0aW9uLlxuXHQgKiBAcHJvcGVydHkgSlNPTlxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqc29uXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLkpTT04gPSBcImpzb25cIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IganNvbnAgZmlsZXMsIHVzdWFsbHkgd2l0aCB0aGUgXCJqc29uXCIgZmlsZSBleHRlbnNpb24uIEpTT04gZGF0YSBpcyBsb2FkZWQgYW5kIHBhcnNlZCBpbnRvIGFcblx0ICogSmF2YVNjcmlwdCBvYmplY3QuIFlvdSBhcmUgcmVxdWlyZWQgdG8gcGFzcyBhIGNhbGxiYWNrIHBhcmFtZXRlciB0aGF0IG1hdGNoZXMgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgaW4gdGhlIEpTT04uXG5cdCAqIE5vdGUgdGhhdCBKU09OUCB3aWxsIGFsd2F5cyBiZSB1c2VkIGlmIHRoZXJlIGlzIGEgY2FsbGJhY2sgcHJlc2VudCwgbm8gbWF0dGVyIHdoYXQgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9wcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogcHJvcGVydHkgaXMgc2V0IHRvLlxuXHQgKiBAcHJvcGVydHkgSlNPTlBcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQganNvbnBcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuSlNPTlAgPSBcImpzb25wXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGpzb24tYmFzZWQgbWFuaWZlc3QgZmlsZXMsIHVzdWFsbHkgd2l0aCB0aGUgXCJqc29uXCIgZmlsZSBleHRlbnNpb24uIFRoZSBKU09OIGRhdGEgaXMgbG9hZGVkXG5cdCAqIGFuZCBwYXJzZWQgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0LiBQcmVsb2FkSlMgd2lsbCB0aGVuIGxvb2sgZm9yIGEgXCJtYW5pZmVzdFwiIHByb3BlcnR5IGluIHRoZSBKU09OLCB3aGljaCBpcyBhblxuXHQgKiBBcnJheSBvZiBmaWxlcyB0byBsb2FkLCBmb2xsb3dpbmcgdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC4gSWYgYSBcImNhbGxiYWNrXCIgaXMgc3BlY2lmaWVkIG9uIHRoZSBtYW5pZmVzdCBvYmplY3QsIHRoZW4gaXQgd2lsbCBiZSBsb2FkZWQgdXNpbmcgSlNPTlAgaW5zdGVhZCxcblx0ICogcmVnYXJkbGVzcyBvZiB3aGF0IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGlzIHNldCB0by5cblx0ICogQHByb3BlcnR5IE1BTklGRVNUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IG1hbmlmZXN0XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLk1BTklGRVNUID0gXCJtYW5pZmVzdFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBzb3VuZCBmaWxlcywgdXN1YWxseSBtcDMsIG9nZywgb3Igd2F2LiBXaGVuIGxvYWRpbmcgdmlhIHRhZ3MsIGF1ZGlvIGlzIGxvYWRlZCBpbnRvIGFuXG5cdCAqICZsdDthdWRpbyZndDsgdGFnLlxuXHQgKiBAcHJvcGVydHkgU09VTkRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgc291bmRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuU09VTkQgPSBcInNvdW5kXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIHZpZGVvIGZpbGVzLCB1c3VhbGx5IG1wNCwgdHMsIG9yIG9nZy4gV2hlbiBsb2FkaW5nIHZpYSB0YWdzLCB2aWRlbyBpcyBsb2FkZWQgaW50byBhblxuXHQgKiAmbHQ7dmlkZW8mZ3Q7IHRhZy5cblx0ICogQHByb3BlcnR5IFZJREVPXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHZpZGVvXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlZJREVPID0gXCJ2aWRlb1wiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBTcHJpdGVTaGVldCBmaWxlcy4gU3ByaXRlU2hlZXQgZmlsZXMgYXJlIEpTT04gZmlsZXMgdGhhdCBjb250YWluIHN0cmluZyBpbWFnZSBwYXRocy5cblx0ICogQHByb3BlcnR5IFNQUklURVNIRUVUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHNwcml0ZXNoZWV0XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlNQUklURVNIRUVUID0gXCJzcHJpdGVzaGVldFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBTVkcgZmlsZXMuXG5cdCAqIEBwcm9wZXJ0eSBTVkdcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgc3ZnXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlNWRyA9IFwic3ZnXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIHRleHQgZmlsZXMsIHdoaWNoIGlzIGFsc28gdGhlIGRlZmF1bHQgZmlsZSB0eXBlIGlmIHRoZSB0eXBlIGNhbiBub3QgYmUgZGV0ZXJtaW5lZC4gVGV4dCBpc1xuXHQgKiBsb2FkZWQgYXMgcmF3IHRleHQuXG5cdCAqIEBwcm9wZXJ0eSBURVhUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHRleHRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuVEVYVCA9IFwidGV4dFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciB4bWwgZmlsZXMuIFhNTCBpcyBsb2FkZWQgaW50byBhbiBYTUwgZG9jdW1lbnQuXG5cdCAqIEBwcm9wZXJ0eSBYTUxcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgeG1sXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlhNTCA9IFwieG1sXCI7XG5cbi8vIEV2ZW50c1xuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIlByb2dyZXNzRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIHRoZSBvdmVyYWxsIHByb2dyZXNzIGNoYW5nZXMuIFByaW9yIHRvXG5cdCAqIHZlcnNpb24gMC42LjAsIHRoaXMgd2FzIGp1c3QgYSByZWd1bGFyIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAZXZlbnQgcHJvZ3Jlc3Ncblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIGEgbG9hZCBzdGFydHMuXG5cdCAqIEBldmVudCBsb2Fkc3RhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAc2luY2UgMC4zLjFcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlIGVudGlyZSBxdWV1ZSBoYXMgYmVlbiBsb2FkZWQuXG5cdCAqIEBldmVudCBjb21wbGV0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkVycm9yRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIHRoZSBsb2FkZXIgZW5jb3VudGVycyBhbiBlcnJvci4gSWYgdGhlIGVycm9yIHdhc1xuXHQgKiBlbmNvdW50ZXJlZCBieSBhIGZpbGUsIHRoZSBldmVudCB3aWxsIGNvbnRhaW4gdGhlIGl0ZW0gdGhhdCBjYXVzZWQgdGhlIGVycm9yLiBQcmlvciB0byB2ZXJzaW9uIDAuNi4wLCB0aGlzIHdhc1xuXHQgKiBqdXN0IGEgcmVndWxhciB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGV2ZW50IGVycm9yXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgbG9hZGVyIGVuY291bnRlcnMgYW4gaW50ZXJuYWwgZmlsZSBsb2FkIGVycm9yLlxuXHQgKiBUaGlzIGVuYWJsZXMgbG9hZGVycyB0byBtYWludGFpbiBpbnRlcm5hbCBxdWV1ZXMsIGFuZCBzdXJmYWNlIGZpbGUgbG9hZCBlcnJvcnMuXG5cdCAqIEBldmVudCBmaWxlZXJyb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVuIHR5cGUgKFwiZmlsZWVycm9yXCIpXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18b2JqZWN0fSBUaGUgaXRlbSB0aGF0IGVuY291bnRlcmVkIHRoZSBlcnJvclxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgaW50ZXJuYWxseSBsb2FkcyBhIGZpbGUuIFRoaXMgZW5hYmxlc1xuXHQgKiBsb2FkZXJzIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gdG8gbWFpbnRhaW4gaW50ZXJuYWwge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319c1xuXHQgKiBhbmQgbm90aWZ5IHdoZW4gdGhleSBoYXZlIGxvYWRlZCBhIGZpbGUuIFRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZGlzcGF0Y2hlcyBhXG5cdCAqIHNsaWdodGx5IGRpZmZlcmVudCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQuXG5cdCAqIEBldmVudCBmaWxlbG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUgKFwiZmlsZWxvYWRcIilcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIGZpbGUgaXRlbSB3aGljaCB3YXMgc3BlY2lmaWVkIGluIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fSBjYWxsLiBJZiBvbmx5IGEgc3RyaW5nIHBhdGggb3IgdGFnIHdhcyBzcGVjaWZpZWQsIHRoZVxuXHQgKiBvYmplY3Qgd2lsbCBjb250YWluIHRoYXQgdmFsdWUgYXMgYSBgc3JjYCBwcm9wZXJ0eS5cblx0ICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCBUaGUgSFRNTCB0YWcgb3IgcGFyc2VkIHJlc3VsdCBvZiB0aGUgbG9hZGVkIGl0ZW0uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByYXdSZXN1bHQgVGhlIHVucHJvY2Vzc2VkIHJlc3VsdCwgdXN1YWxseSB0aGUgcmF3IHRleHQgb3IgYmluYXJ5IGRhdGEgYmVmb3JlIGl0IGlzIGNvbnZlcnRlZFxuXHQgKiB0byBhIHVzYWJsZSBvYmplY3QuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgYWZ0ZXIgdGhlIGludGVybmFsIHJlcXVlc3QgaXMgY3JlYXRlZCwgYnV0IGJlZm9yZSBhIGxvYWQuXG5cdCAqIFRoaXMgYWxsb3dzIHVwZGF0ZXMgdG8gdGhlIGxvYWRlciBmb3Igc3BlY2lmaWMgbG9hZGluZyBuZWVkcywgc3VjaCBhcyBiaW5hcnkgb3IgWEhSIGltYWdlIGxvYWRpbmcuXG5cdCAqIEBldmVudCBpbml0aWFsaXplXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZSAoXCJpbml0aWFsaXplXCIpXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgbG9hZGVyIHRoYXQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG5cdCAqL1xuXG5cblx0LyoqXG5cdCAqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgbWFuaWZlc3QgaXRlbSB0aGF0IGlzIGxvYWRlZCBieSB0aGlzIGxvYWRlci4gSW4gc29tZSBjYXNlcyB0aGlzIHdpbGwgYmUgdGhlIHZhbHVlIHRoYXQgd2FzXG5cdCAqIHBhc3NlZCBpbnRvIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fS4gSG93ZXZlciBpZiBvbmx5IGEgU3RyaW5nIHBhdGggd2FzIHBhc3NlZCBpbiwgdGhlbiBpdCB3aWxsXG5cdCAqIGJlIGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgZ2V0SXRlbVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtYW5pZmVzdCBpdGVtIHRoYXQgdGhpcyBsb2FkZXIgaXMgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5nZXRJdGVtID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9pdGVtO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIGNvbnRlbnQgdGhhdCB3YXMgbG9hZGVkIGJ5IHRoZSBsb2FkZXIgKG9ubHkgYXZhaWxhYmxlIGFmdGVyIHRoZSB7eyNjcm9zc0xpbmsgXCJjb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBpcyBkaXNwYXRjaGVkLlxuXHQgKiBAbWV0aG9kIGdldFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyYXc9ZmFsc2VdIERldGVybWluZXMgaWYgdGhlIHJldHVybmVkIHJlc3VsdCB3aWxsIGJlIHRoZSBmb3JtYXR0ZWQgY29udGVudCwgb3IgdGhlIHJhdyBsb2FkZWRcblx0ICogZGF0YSAoaWYgaXQgZXhpc3RzKS5cblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKHJhdykge1xuXHRcdHJldHVybiByYXcgPyB0aGlzLl9yYXdSZXN1bHQgOiB0aGlzLl9yZXN1bHQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgYHRhZ2AgdGhpcyBvYmplY3QgY3JlYXRlcyBvciB1c2VzIGZvciBsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIGdldFRhZ1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB0YWcgaW5zdGFuY2Vcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldFRhZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGFnO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGB0YWdgIHRoaXMgaXRlbSB1c2VzIGZvciBsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIHNldFRhZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFnIFRoZSB0YWcgaW5zdGFuY2Vcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLnNldFRhZyA9IGZ1bmN0aW9uKHRhZykge1xuXHQgIHRoaXMuX3RhZyA9IHRhZztcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW4gbG9hZGluZyB0aGUgaXRlbS4gVGhpcyBtZXRob2QgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBhIGxvYWRlciBieSBpdHNlbGYuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdCAqICAgICAgcXVldWUub24oXCJjb21wbGV0ZVwiLCBoYW5kbGVDb21wbGV0ZSk7XG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KGZpbGVBcnJheSwgZmFsc2UpOyAvLyBOb3RlIHRoZSAybmQgYXJndW1lbnQgdGhhdCB0ZWxscyB0aGUgcXVldWUgbm90IHRvIHN0YXJ0IGxvYWRpbmcgeWV0XG5cdCAqICAgICAgcXVldWUubG9hZCgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICovXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jcmVhdGVSZXF1ZXN0KCk7XG5cblx0XHR0aGlzLl9yZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgdGhpcywgdGhpcyk7XG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcInByb2dyZXNzXCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJsb2FkU3RhcnRcIiwgdGhpcywgdGhpcyk7XG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcImFib3J0XCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJ0aW1lb3V0XCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJlcnJvclwiLCB0aGlzLCB0aGlzKTtcblxuXHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJpbml0aWFsaXplXCIpO1xuXHRcdGV2dC5sb2FkZXIgPSB0aGlzLl9yZXF1ZXN0O1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuXG5cdFx0dGhpcy5fcmVxdWVzdC5sb2FkKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsb3NlIHRoZSB0aGUgaXRlbS4gVGhpcyB3aWxsIHN0b3AgYW55IG9wZW4gcmVxdWVzdHMgKGFsdGhvdWdoIGRvd25sb2FkcyB1c2luZyBIVE1MIHRhZ3MgbWF5IHN0aWxsIGNvbnRpbnVlIGluXG5cdCAqIHRoZSBiYWNrZ3JvdW5kKSwgYnV0IGV2ZW50cyB3aWxsIG5vdCBsb25nZXIgYmUgZGlzcGF0Y2hlZC5cblx0ICogQG1ldGhvZCBjYW5jZWxcblx0ICovXG5cdHAuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY2FuY2VsZWQgPSB0cnVlO1xuXHRcdHRoaXMuZGVzdHJveSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0aGUgbG9hZGVyLlxuXHQgKiBAbWV0aG9kIGRlc3Ryb3lcblx0ICovXG5cdHAuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0KSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmRlc3Ryb3koKTtcblx0XHR9XG5cblx0XHR0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcblxuXHRcdHRoaXMuX2l0ZW0gPSBudWxsO1xuXHRcdHRoaXMuX3Jhd1Jlc3VsdCA9IG51bGw7XG5cdFx0dGhpcy5fcmVzdWx0ID0gbnVsbDtcblxuXHRcdHRoaXMuX2xvYWRJdGVtcyA9IG51bGw7XG5cblx0XHR0aGlzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBhbnkgaXRlbXMgbG9hZGVkIGludGVybmFsbHkgYnkgdGhlIGxvYWRlci4gVGhlIGVuYWJsZXMgbG9hZGVycyBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHRvIGV4cG9zZSBpdGVtcyBpdCBsb2FkcyBpbnRlcm5hbGx5LlxuXHQgKiBAbWV0aG9kIGdldExvYWRlZEl0ZW1zXG5cdCAqIEByZXR1cm4ge0FycmF5fSBBIGxpc3Qgb2YgdGhlIGl0ZW1zIGxvYWRlZCBieSB0aGUgbG9hZGVyLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZ2V0TG9hZGVkSXRlbXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRlZEl0ZW1zO1xuXHR9O1xuXG5cblx0Ly8gUHJpdmF0ZSBtZXRob2RzXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gaW50ZXJuYWwgcmVxdWVzdCB1c2VkIGZvciBsb2FkaW5nLiBCeSBkZWZhdWx0LCBhbiB7eyNjcm9zc0xpbmsgXCJYSFJSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRhZ1JlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0gaXMgY3JlYXRlZCwgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiB7eyNjcm9zc0xpbmsgXCJwcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIE90aGVyIGxvYWRlcnMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gdXNlIGRpZmZlcmVudCByZXF1ZXN0IHR5cGVzLCBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB3aGljaCB1c2VzIHt7I2Nyb3NzTGluayBcIkpTT05Mb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiSlNPTlBMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gdW5kZXIgdGhlIGhvb2QuXG5cdCAqIEBtZXRob2QgX2NyZWF0ZVJlcXVlc3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fcHJlZmVyWEhSKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLlRhZ1JlcXVlc3QodGhpcy5faXRlbSwgdGhpcy5fdGFnIHx8IHRoaXMuX2NyZWF0ZVRhZygpLCB0aGlzLl90YWdTcmNBdHRyaWJ1dGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLlhIUlJlcXVlc3QodGhpcy5faXRlbSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgdGhlIEhUTUwgdGFnIHVzZWQgZm9yIGxvYWRpbmcuIFRoaXMgbWV0aG9kIGRvZXMgbm90aGluZyBieSBkZWZhdWx0LCBhbmQgbmVlZHMgdG8gYmUgaW1wbGVtZW50ZWRcblx0ICogYnkgbG9hZGVycyB0aGF0IHJlcXVpcmUgdGFnIGxvYWRpbmcuXG5cdCAqIEBtZXRob2QgX2NyZWF0ZVRhZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSB0YWcgc291cmNlXG5cdCAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgdGFnIHRoYXQgd2FzIGNyZWF0ZWRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fY3JlYXRlVGFnID0gZnVuY3Rpb24oc3JjKSB7IHJldHVybiBudWxsOyB9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIGxvYWRzdGFydCB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvbG9hZHN0YXJ0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGZvciBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuXHQgKiBAbWV0aG9kIF9zZW5kTG9hZFN0YXJ0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRMb2FkU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSkgeyByZXR1cm47IH1cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJsb2Fkc3RhcnRcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEge3sjY3Jvc3NMaW5rIFwiUHJvZ3Jlc3NFdmVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBfc2VuZFByb2dyZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyIHwgT2JqZWN0fSB2YWx1ZSBUaGUgcHJvZ3Jlc3Mgb2YgdGhlIGxvYWRlZCBpdGVtLCBvciBhbiBvYmplY3QgY29udGFpbmluZyA8Y29kZT5sb2FkZWQ8L2NvZGU+XG5cdCAqIGFuZCA8Y29kZT50b3RhbDwvY29kZT4gcHJvcGVydGllcy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZFByb2dyZXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSkgeyByZXR1cm47IH1cblx0XHR2YXIgZXZlbnQgPSBudWxsO1xuXHRcdGlmICh0eXBlb2YodmFsdWUpID09IFwibnVtYmVyXCIpIHtcblx0XHRcdHRoaXMucHJvZ3Jlc3MgPSB2YWx1ZTtcblx0XHRcdGV2ZW50ID0gbmV3IGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQodGhpcy5wcm9ncmVzcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50ID0gdmFsdWU7XG5cdFx0XHR0aGlzLnByb2dyZXNzID0gdmFsdWUubG9hZGVkIC8gdmFsdWUudG90YWw7XG5cdFx0XHRldmVudC5wcm9ncmVzcyA9IHRoaXMucHJvZ3Jlc3M7XG5cdFx0XHRpZiAoaXNOYU4odGhpcy5wcm9ncmVzcykgfHwgdGhpcy5wcm9ncmVzcyA9PSBJbmZpbml0eSkgeyB0aGlzLnByb2dyZXNzID0gMDsgfVxuXHRcdH1cblx0XHR0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiKSAmJiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIGNvbXBsZXRlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudFxuXHQgKiBAbWV0aG9kIF9zZW5kQ29tcGxldGVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLmxvYWRlZCA9IHRydWU7XG5cblx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0XHRldmVudC5yYXdSZXN1bHQgPSB0aGlzLl9yYXdSZXN1bHQ7XG5cblx0XHRpZiAodGhpcy5fcmVzdWx0ICE9IG51bGwpIHtcblx0XHRcdGV2ZW50LnJlc3VsdCA9IHRoaXMuX3Jlc3VsdDtcblx0XHR9XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhbiBlcnJvciB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZXJyb3I6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgZm9yIGRldGFpbHMgb24gdGhlIGV2ZW50IHBheWxvYWQuXG5cdCAqIEBtZXRob2QgX3NlbmRFcnJvclxuXHQgKiBAcGFyYW0ge0Vycm9yRXZlbnR9IGV2ZW50IFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBzcGVjaWZpYyBlcnJvciBwcm9wZXJ0aWVzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAodGhpcy5faXNDYW5jZWxlZCgpIHx8ICF0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJlcnJvclwiKSkgeyByZXR1cm47IH1cblx0XHRpZiAoZXZlbnQgPT0gbnVsbCkge1xuXHRcdFx0ZXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfRVJST1JfRU1QVFlcIik7IC8vIFRPRE86IFBvcHVsYXRlIGVycm9yXG5cdFx0fVxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSBpZiB0aGUgbG9hZCBoYXMgYmVlbiBjYW5jZWxlZC4gVGhpcyBpcyBpbXBvcnRhbnQgdG8gZW5zdXJlIHRoYXQgbWV0aG9kIGNhbGxzIG9yIGFzeW5jaHJvbm91cyBldmVudHNcblx0ICogZG8gbm90IGNhdXNlIGlzc3VlcyBhZnRlciB0aGUgcXVldWUgaGFzIGJlZW4gY2xlYW5lZCB1cC5cblx0ICogQG1ldGhvZCBfaXNDYW5jZWxlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgbG9hZGVyIGhhcyBiZWVuIGNhbmNlbGVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9pc0NhbmNlbGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh3aW5kb3cuY3JlYXRlanMgPT0gbnVsbCB8fCB0aGlzLmNhbmNlbGVkKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIGN1c3RvbSByZXN1bHQgZm9ybWF0dGVyIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQganVzdCBiZWZvcmUgYSByZXF1ZXN0IGRpc3BhdGNoZXMgaXRzIGNvbXBsZXRlIGV2ZW50LiBNb3N0XG5cdCAqIGxvYWRlciB0eXBlcyBhbHJlYWR5IGhhdmUgYW4gaW50ZXJuYWwgZm9ybWF0dGVyLCBidXQgdGhpcyBjYW4gYmUgdXNlci1vdmVycmlkZGVuIGZvciBjdXN0b20gZm9ybWF0dGluZy4gVGhlXG5cdCAqIGZvcm1hdHRlZCByZXN1bHQgd2lsbCBiZSBhdmFpbGFibGUgb24gTG9hZGVycyB1c2luZyB7eyNjcm9zc0xpbmsgXCJnZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCBwYXNzaW5nIGB0cnVlYC5cblx0ICogQHByb3BlcnR5IHJlc3VsdEZvcm1hdHRlclxuXHQgKiBAdHlwZSBGdW5jdGlvblxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBmb3JtYXR0ZWQgcmVzdWx0XG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5yZXN1bHRGb3JtYXR0ZXIgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBIYW5kbGUgZXZlbnRzIGZyb20gaW50ZXJuYWwgcmVxdWVzdHMuIEJ5IGRlZmF1bHQsIGxvYWRlcnMgd2lsbCBoYW5kbGUsIGFuZCByZWRpc3BhdGNoIHRoZSBuZWNlc3NhcnkgZXZlbnRzLCBidXRcblx0ICogdGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gZm9yIGN1c3RvbSBiZWhhdmlvdXJzLlxuXHQgKiBAbWV0aG9kIGhhbmRsZUV2ZW50XG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0aGF0IHRoZSBpbnRlcm5hbCByZXF1ZXN0IGRpc3BhdGNoZXMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0c3dpdGNoIChldmVudC50eXBlKSB7XG5cdFx0XHRjYXNlIFwiY29tcGxldGVcIjpcblx0XHRcdFx0dGhpcy5fcmF3UmVzdWx0ID0gZXZlbnQudGFyZ2V0Ll9yZXNwb25zZTtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0Rm9ybWF0dGVyICYmIHRoaXMucmVzdWx0Rm9ybWF0dGVyKHRoaXMpO1xuXHRcdFx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0XHRyZXN1bHQuY2FsbCh0aGlzLFxuXHRcdFx0XHRcdFx0XHRjcmVhdGVqcy5wcm94eSh0aGlzLl9yZXN1bHRGb3JtYXRTdWNjZXNzLCB0aGlzKSxcblx0XHRcdFx0XHRcdFx0Y3JlYXRlanMucHJveHkodGhpcy5fcmVzdWx0Rm9ybWF0RmFpbGVkLCB0aGlzKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVzdWx0ID0gIHJlc3VsdCB8fCB0aGlzLl9yYXdSZXN1bHQ7XG5cdFx0XHRcdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwicHJvZ3Jlc3NcIjpcblx0XHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKGV2ZW50KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiZXJyb3JcIjpcblx0XHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwibG9hZHN0YXJ0XCI6XG5cdFx0XHRcdHRoaXMuX3NlbmRMb2FkU3RhcnQoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiYWJvcnRcIjpcblx0XHRcdGNhc2UgXCJ0aW1lb3V0XCI6XG5cdFx0XHRcdGlmICghdGhpcy5faXNDYW5jZWxlZCgpKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9cIiArIGV2ZW50LnR5cGUudG9VcHBlckNhc2UoKSArIFwiX0VSUk9SXCIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBcInN1Y2Nlc3NcIiBjYWxsYmFjayBwYXNzZWQgdG8ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvcmVzdWx0Rm9ybWF0dGVyXCJ9fXt7L2Nyb3NzTGlua319IGFzeW5jaHJvbm91c1xuXHQgKiBmdW5jdGlvbnMuXG5cdCAqIEBtZXRob2QgX3Jlc3VsdEZvcm1hdFN1Y2Nlc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCBUaGUgZm9ybWF0dGVkIHJlc3VsdFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fcmVzdWx0Rm9ybWF0U3VjY2VzcyA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHR0aGlzLl9yZXN1bHQgPSByZXN1bHQ7XG5cdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBcImVycm9yXCIgY2FsbGJhY2sgcGFzc2VkIHRvIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL3Jlc3VsdEZvcm1hdHRlclwifX17ey9jcm9zc0xpbmt9fSBhc3luY2hyb25vdXNcblx0ICogZnVuY3Rpb25zLlxuXHQgKiBAbWV0aG9kIF9yZXN1bHRGb3JtYXRTdWNjZXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvciBUaGUgZXJyb3IgZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3Jlc3VsdEZvcm1hdEZhaWxlZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgYnVpbGRQYXRoXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJSZXF1ZXN0VXRpbHNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHt7I2Nyb3NzTGluayBcIlJlcXVlc3RVdGlscy9idWlsZFBhdGhcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaW5zdGVhZC5cblx0ICovXG5cdHAuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHNyYywgZGF0YSkge1xuXHRcdHJldHVybiBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuYnVpbGRQYXRoKHNyYywgZGF0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltQcmVsb2FkSlMgQWJzdHJhY3RMb2FkZXJdXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuQWJzdHJhY3RMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEFic3RyYWN0TG9hZGVyLCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFic3RyYWN0TWVkaWFMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBUaGUgQWJzdHJhY3RNZWRpYUxvYWRlciBpcyBhIGJhc2UgY2xhc3MgdGhhdCBoYW5kbGVzIHNvbWUgb2YgdGhlIHNoYXJlZCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIG9mIGxvYWRlcnMgdGhhdFxuXHQgKiBoYW5kbGUgSFRNTCBtZWRpYSBlbGVtZW50cywgc3VjaCBhcyBWaWRlbyBhbmQgQXVkaW8uXG5cdCAqIEBjbGFzcyBBYnN0cmFjdE1lZGlhTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBtZWRpYSB0byBsb2FkLiBVc3VhbGx5IFwidmlkZW9cIiBvciBcImF1ZGlvXCIuXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gQWJzdHJhY3RNZWRpYUxvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSLCB0eXBlKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCB0eXBlKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IFwic3JjXCI7XG5cbiAgICAgICAgdGhpcy5vbihcImluaXRpYWxpemVcIiwgdGhpcy5fdXBkYXRlWEhSLCB0aGlzKTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChBYnN0cmFjdE1lZGlhTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cblx0Ly8gc3RhdGljIHByb3BlcnRpZXNcblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRhZ1JlcXVlc3Qgd2lsbCBoYW5kbGUgbW9zdCBvZiB0aGlzLCBidXQgU291bmQgLyBWaWRlbyBuZWVkIGEgZmV3IGN1c3RvbSBwcm9wZXJ0aWVzLCBzbyBqdXN0IGhhbmRsZSB0aGVtIGhlcmUuXG5cdFx0aWYgKCF0aGlzLl90YWcpIHtcblx0XHRcdHRoaXMuX3RhZyA9IHRoaXMuX2NyZWF0ZVRhZyh0aGlzLl9pdGVtLnNyYyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdGFnLnByZWxvYWQgPSBcImF1dG9cIjtcblx0XHR0aGlzLl90YWcubG9hZCgpO1xuXG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9sb2FkKCk7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgdGFnIGZvciBsb2FkaW5nIGlmIGl0IGRvZXNuJ3QgZXhpc3QgeWV0LlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVUYWdcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NyZWF0ZVRhZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG5cblx0cC5fY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fcHJlZmVyWEhSKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLk1lZGlhVGFnUmVxdWVzdCh0aGlzLl9pdGVtLCB0aGlzLl90YWcgfHwgdGhpcy5fY3JlYXRlVGFnKCksIHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuWEhSUmVxdWVzdCh0aGlzLl9pdGVtKTtcblx0XHR9XG5cdH07XG5cbiAgICAvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIEJlZm9yZSB0aGUgaXRlbSBsb2Fkcywgc2V0IGl0cyBtaW1lVHlwZSBhbmQgcmVzcG9uc2VUeXBlLlxuICAgICAqIEBwcm9wZXJ0eSBfdXBkYXRlWEhSXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX3VwZGF0ZVhIUiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBPbmx5IGV4aXN0cyBmb3IgWEhSXG4gICAgICAgIGlmIChldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYmxvYlwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBtZWRpYSBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7SFRNTFZpZGVvRWxlbWVudHxIVE1MQXVkaW9FbGVtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHRoaXMuX3RhZy5yZW1vdmVFdmVudExpc3RlbmVyICYmIHRoaXMuX3RhZy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fbG9hZGVkSGFuZGxlcik7XG5cdFx0dGhpcy5fdGFnLm9uc3RhbGxlZCA9IG51bGw7XG5cdFx0aWYgKHRoaXMuX3ByZWZlclhIUikge1xuICAgICAgICAgICAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBsb2FkZXIuZ2V0UmVzdWx0KHRydWUpO1xuXG5cdFx0XHRsb2FkZXIuZ2V0VGFnKCkuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChyZXN1bHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9hZGVyLmdldFRhZygpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkFic3RyYWN0TWVkaWFMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEFic3RyYWN0TWVkaWFMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBBYnN0cmFjdFJlcXVlc3QuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBIGJhc2UgY2xhc3MgZm9yIGFjdHVhbCBkYXRhIHJlcXVlc3RzLCBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIlhIUlJlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIlRhZ1JlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGFuZCB7eyNjcm9zc0xpbmsgXCJNZWRpYVJlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0uIFByZWxvYWRKUyBsb2FkZXJzIHdpbGwgdHlwaWNhbGx5IHVzZSBhIGRhdGEgbG9hZGVyIHVuZGVyIHRoZVxuXHQgKiBob29kIHRvIGdldCBkYXRhLlxuXHQgKiBAY2xhc3MgQWJzdHJhY3RSZXF1ZXN0XG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW19IGl0ZW1cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHR2YXIgQWJzdHJhY3RSZXF1ZXN0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHR0aGlzLl9pdGVtID0gaXRlbTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChBYnN0cmFjdFJlcXVlc3QsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIEJlZ2luIGEgbG9hZC5cblx0ICogQG1ldGhvZCBsb2FkXG5cdCAqL1xuXHRwLmxvYWQgPSAgZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogQ2xlYW4gdXAgYSByZXF1ZXN0LlxuXHQgKiBAbWV0aG9kIGRlc3Ryb3lcblx0ICovXG5cdHAuZGVzdHJveSA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIENhbmNlbCBhbiBpbi1wcm9ncmVzcyByZXF1ZXN0LlxuXHQgKiBAbWV0aG9kIGNhbmNlbFxuXHQgKi9cblx0cC5jYW5jZWwgPSBmdW5jdGlvbigpIHt9O1xuXG5cdGNyZWF0ZWpzLkFic3RyYWN0UmVxdWVzdCA9IGNyZWF0ZWpzLnByb21vdGUoQWJzdHJhY3RSZXF1ZXN0LCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFRhZ1JlcXVlc3QuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBbiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFJlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBsb2FkcyBIVE1MIHRhZ3MsIHN1Y2ggYXMgaW1hZ2VzIGFuZCBzY3JpcHRzLlxuXHQgKiBAY2xhc3MgVGFnUmVxdWVzdFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWdcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyY0F0dHJpYnV0ZSBUaGUgdGFnIGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyB0aGUgc291cmNlLCBzdWNoIGFzIFwic3JjXCIsIFwiaHJlZlwiLCBldGMuXG5cdCAqL1xuXHRmdW5jdGlvbiBUYWdSZXF1ZXN0KGxvYWRJdGVtLCB0YWcsIHNyY0F0dHJpYnV0ZSkge1xuXHRcdHRoaXMuQWJzdHJhY3RSZXF1ZXN0X2NvbnN0cnVjdG9yKGxvYWRJdGVtKTtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogVGhlIEhUTUwgdGFnIGluc3RhbmNlIHRoYXQgaXMgdXNlZCB0byBsb2FkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfdGFnXG5cdFx0ICogQHR5cGUge0hUTUxFbGVtZW50fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl90YWcgPSB0YWc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGFnIGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyB0aGUgc291cmNlLCBzdWNoIGFzIFwic3JjXCIsIFwiaHJlZlwiLCBldGMuXG5cdFx0ICogQHByb3BlcnR5IF90YWdTcmNBdHRyaWJ1dGVcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBzcmNBdHRyaWJ1dGU7XG5cblx0XHQvKipcblx0XHQgKiBBIG1ldGhvZCBjbG9zdXJlIHVzZWQgZm9yIGhhbmRsaW5nIHRoZSB0YWcgbG9hZCBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRlZEhhbmRsZXJcblx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGFnQ29tcGxldGUsIHRoaXMpO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgZWxlbWVudCB3YXMgYWRkZWQgdG8gdGhlIERPTSBhdXRvbWF0aWNhbGx5IGJ5IFByZWxvYWRKUywgc28gaXQgY2FuIGJlIGNsZWFuZWQgdXAgYWZ0ZXIuXG5cdFx0ICogQHByb3BlcnR5IF9hZGRlZFRvRE9NXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9hZGRlZFRvRE9NID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmVzIHdoYXQgdGhlIHRhZ3MgaW5pdGlhbCBzdHlsZS52aXNpYmlsaXR5IHdhcywgc28gd2UgY2FuIHNldCBpdCBjb3JyZWN0bHkgYWZ0ZXIgYSBsb2FkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bGx9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zdGFydFRhZ1Zpc2liaWxpdHkgPSBudWxsO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFRhZ1JlcXVlc3QsIGNyZWF0ZWpzLkFic3RyYWN0UmVxdWVzdCk7XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3RhZy5vbmxvYWQgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUYWdDb21wbGV0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fdGFnLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2UsIHRoaXMpO1xuXHRcdHRoaXMuX3RhZy5vbmVycm9yID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlRXJyb3IsIHRoaXMpO1xuXG5cdFx0dmFyIGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImluaXRpYWxpemVcIik7XG5cdFx0ZXZ0LmxvYWRlciA9IHRoaXMuX3RhZztcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuXG5cdFx0dGhpcy5faGlkZVRhZygpO1xuXG5cdFx0dGhpcy5fbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRpbWVvdXQsIHRoaXMpLCB0aGlzLl9pdGVtLmxvYWRUaW1lb3V0KTtcblxuXHRcdHRoaXMuX3RhZ1t0aGlzLl90YWdTcmNBdHRyaWJ1dGVdID0gdGhpcy5faXRlbS5zcmM7XG5cblx0XHQvLyB3ZGc6OiBBcHBlbmQgdGhlIHRhZyBBRlRFUiBzZXR0aW5nIHRoZSBzcmMsIG9yIFNWRyBsb2FkaW5nIG9uIGlPUyB3aWxsIGZhaWwuXG5cdFx0aWYgKHRoaXMuX3RhZy5wYXJlbnROb2RlID09IG51bGwpIHtcblx0XHRcdHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3RhZyk7XG5cdFx0XHR0aGlzLl9hZGRlZFRvRE9NID0gdHJ1ZTtcblx0XHR9XG5cdH07XG5cblx0cC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fY2xlYW4oKTtcblx0XHR0aGlzLl90YWcgPSBudWxsO1xuXG5cdFx0dGhpcy5BYnN0cmFjdFJlcXVlc3RfZGVzdHJveSgpO1xuXHR9O1xuXG5cdC8vIHByaXZhdGUgbWV0aG9kc1xuXHQvKipcblx0ICogSGFuZGxlIHRoZSByZWFkeVN0YXRlQ2hhbmdlIGV2ZW50IGZyb20gYSB0YWcuIFdlIG5lZWQgdGhpcyBpbiBwbGFjZSBvZiB0aGUgYG9ubG9hZGAgY2FsbGJhY2sgKG1haW5seSBTQ1JJUFRcblx0ICogYW5kIExJTksgdGFncyksIGJ1dCBvdGhlciBjYXNlcyBtYXkgZXhpc3QuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2Vcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblx0XHQvLyBUaGlzIGlzIHN0cmljdGx5IGZvciB0YWdzIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgb25sb2FkLlxuXHRcdHZhciB0YWcgPSB0aGlzLl90YWc7XG5cblx0XHQvLyBDb21wbGV0ZSBpcyBmb3Igb2xkIElFIHN1cHBvcnQuXG5cdFx0aWYgKHRhZy5yZWFkeVN0YXRlID09IFwibG9hZGVkXCIgfHwgdGFnLnJlYWR5U3RhdGUgPT0gXCJjb21wbGV0ZVwiKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVUYWdDb21wbGV0ZSgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlIGFueSBlcnJvciBldmVudHMgZnJvbSB0aGUgdGFnLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVFcnJvclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiZXJyb3JcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZSB0aGUgdGFnJ3Mgb25sb2FkIGNhbGxiYWNrLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVUYWdDb21wbGV0ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlVGFnQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmF3UmVzdWx0ID0gdGhpcy5fdGFnO1xuXHRcdHRoaXMuX3Jlc3VsdCA9IHRoaXMucmVzdWx0Rm9ybWF0dGVyICYmIHRoaXMucmVzdWx0Rm9ybWF0dGVyKHRoaXMpIHx8IHRoaXMuX3Jhd1Jlc3VsdDtcblxuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5fc2hvd1RhZygpO1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSB0YWcgcmVxdWVzdCBoYXMgbm90IGxvYWRlZCB3aXRoaW4gdGhlIHRpbWUgc3BlY2lmaWVkIGluIGxvYWRUaW1lb3V0LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVFcnJvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBlcnJvciBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY2xlYW4oKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkV2ZW50KFwidGltZW91dFwiKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMsIGJ1dCBkb24ndCBkZXN0cm95IHRoZSByZXF1ZXN0IG9iamVjdFxuXHQgKiBAbWV0aG9kIF9jbGVhblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY2xlYW4gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl90YWcub25sb2FkID0gbnVsbDtcblx0XHR0aGlzLl90YWcub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblx0XHR0aGlzLl90YWcub25lcnJvciA9IG51bGw7XG5cdFx0aWYgKHRoaXMuX2FkZGVkVG9ET00gJiYgdGhpcy5fdGFnLnBhcmVudE5vZGUgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fdGFnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fdGFnKTtcblx0XHR9XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblx0fTtcblxuXHRwLl9oaWRlVGFnID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc3RhcnRUYWdWaXNpYmlsaXR5ID0gdGhpcy5fdGFnLnN0eWxlLnZpc2liaWxpdHk7XG5cdFx0dGhpcy5fdGFnLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuXHR9O1xuXG5cdHAuX3Nob3dUYWcgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl90YWcuc3R5bGUudmlzaWJpbGl0eSA9IHRoaXMuX3N0YXJ0VGFnVmlzaWJpbGl0eTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlIGEgc3RhbGxlZCBhdWRpbyBldmVudC4gVGhlIG1haW4gcGxhY2UgdGhpcyBoYXBwZW5zIGlzIHdpdGggSFRNTEF1ZGlvIGluIENocm9tZSB3aGVuIHBsYXlpbmcgYmFjayBhdWRpb1xuXHQgKiB0aGF0IGlzIGFscmVhZHkgaW4gYSBsb2FkLCBidXQgbm90IGNvbXBsZXRlLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVTdGFsbGVkXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVTdGFsbGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vSWdub3JlLCBsZXQgdGhlIHRpbWVvdXQgdGFrZSBjYXJlIG9mIGl0LiBTb21ldGltZXMgaXRzIG5vdCByZWFsbHkgc3RvcHBlZC5cblx0fTtcblxuXHRjcmVhdGVqcy5UYWdSZXF1ZXN0ID0gY3JlYXRlanMucHJvbW90ZShUYWdSZXF1ZXN0LCBcIkFic3RyYWN0UmVxdWVzdFwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIE1lZGlhVGFnUmVxdWVzdC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEFuIHt7I2Nyb3NzTGluayBcIlRhZ1JlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBsb2FkcyBIVE1MIHRhZ3MgZm9yIHZpZGVvIGFuZCBhdWRpby5cblx0ICogQGNsYXNzIE1lZGlhVGFnUmVxdWVzdFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0hUTUxBdWRpb0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gdGFnXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmNBdHRyaWJ1dGUgVGhlIHRhZyBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgdGhlIHNvdXJjZSwgc3VjaCBhcyBcInNyY1wiLCBcImhyZWZcIiwgZXRjLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIE1lZGlhVGFnUmVxdWVzdChsb2FkSXRlbSwgdGFnLCBzcmNBdHRyaWJ1dGUpIHtcblx0XHR0aGlzLkFic3RyYWN0UmVxdWVzdF9jb25zdHJ1Y3Rvcihsb2FkSXRlbSk7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuX3RhZyA9IHRhZztcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBzcmNBdHRyaWJ1dGU7XG5cdFx0dGhpcy5fbG9hZGVkSGFuZGxlciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRhZ0NvbXBsZXRlLCB0aGlzKTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChNZWRpYVRhZ1JlcXVlc3QsIGNyZWF0ZWpzLlRhZ1JlcXVlc3QpO1xuXHR2YXIgcyA9IE1lZGlhVGFnUmVxdWVzdDtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNjID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlU3RhbGxlZCwgdGhpcyk7XG5cdFx0dGhpcy5fc3RhbGxlZENhbGxiYWNrID0gc2M7XG5cblx0XHR2YXIgcGMgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVQcm9ncmVzcywgdGhpcyk7XG5cdFx0dGhpcy5faGFuZGxlUHJvZ3Jlc3MgPSBwYztcblxuXHRcdHRoaXMuX3RhZy5hZGRFdmVudExpc3RlbmVyKFwic3RhbGxlZFwiLCBzYyk7XG5cdFx0dGhpcy5fdGFnLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBwYyk7XG5cblx0XHQvLyBUaGlzIHdpbGwgdGVsbCB1cyB3aGVuIGF1ZGlvIGlzIGJ1ZmZlcmVkIGVub3VnaCB0byBwbGF5IHRocm91Z2gsIGJ1dCBub3Qgd2hlbiBpdHMgbG9hZGVkLlxuXHRcdC8vIFRoZSB0YWcgZG9lc24ndCBrZWVwIGxvYWRpbmcgaW4gQ2hyb21lIG9uY2UgZW5vdWdoIGhhcyBidWZmZXJlZCwgYW5kIHdlIGhhdmUgZGVjaWRlZCB0aGF0IGJlaGF2aW91ciBpcyBzdWZmaWNpZW50LlxuXHRcdHRoaXMuX3RhZy5hZGRFdmVudExpc3RlbmVyICYmIHRoaXMuX3RhZy5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fbG9hZGVkSGFuZGxlciwgZmFsc2UpOyAvLyBjYW5wbGF5dGhyb3VnaCBjYWxsYmFjayBkb2Vzbid0IHdvcmsgaW4gQ2hyb21lLCBzbyB3ZSB1c2UgYW4gZXZlbnQuXG5cblx0XHR0aGlzLlRhZ1JlcXVlc3RfbG9hZCgpO1xuXHR9O1xuXG5cdC8vIHByaXZhdGUgbWV0aG9kc1xuXHRwLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cdFx0Ly8gVGhpcyBpcyBzdHJpY3RseSBmb3IgdGFncyBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IG9ubG9hZC5cblx0XHR2YXIgdGFnID0gdGhpcy5fdGFnO1xuXG5cdFx0Ly8gQ29tcGxldGUgaXMgZm9yIG9sZCBJRSBzdXBwb3J0LlxuXHRcdGlmICh0YWcucmVhZHlTdGF0ZSA9PSBcImxvYWRlZFwiIHx8IHRhZy5yZWFkeVN0YXRlID09IFwiY29tcGxldGVcIikge1xuXHRcdFx0dGhpcy5faGFuZGxlVGFnQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0cC5faGFuZGxlU3RhbGxlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvL0lnbm9yZSwgbGV0IHRoZSB0aW1lb3V0IHRha2UgY2FyZSBvZiBpdC4gU29tZXRpbWVzIGl0cyBub3QgcmVhbGx5IHN0b3BwZWQuXG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIFhIUiByZXF1ZXN0IGhhcyByZXBvcnRlZCBwcm9ncmVzcy5cblx0ICogQG1ldGhvZCBfaGFuZGxlUHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgcHJvZ3Jlc3MgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICghZXZlbnQgfHwgZXZlbnQubG9hZGVkID4gMCAmJiBldmVudC50b3RhbCA9PSAwKSB7XG5cdFx0XHRyZXR1cm47IC8vIFNvbWV0aW1lcyB3ZSBnZXQgbm8gXCJ0b3RhbFwiLCBzbyBqdXN0IGlnbm9yZSB0aGUgcHJvZ3Jlc3MgZXZlbnQuXG5cdFx0fVxuXG5cdFx0dmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQoZXZlbnQubG9hZGVkLCBldmVudC50b3RhbCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHRwLl9jbGVhbiA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJiB0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX2xvYWRlZEhhbmRsZXIpO1xuXHRcdHRoaXMuX3RhZy5yZW1vdmVFdmVudExpc3RlbmVyKFwic3RhbGxlZFwiLCB0aGlzLl9zdGFsbGVkQ2FsbGJhY2spO1xuXHRcdHRoaXMuX3RhZy5yZW1vdmVFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgdGhpcy5fcHJvZ3Jlc3NDYWxsYmFjayk7XG5cblx0XHR0aGlzLlRhZ1JlcXVlc3RfX2NsZWFuKCk7XG5cdH07XG5cblx0Y3JlYXRlanMuTWVkaWFUYWdSZXF1ZXN0ID0gY3JlYXRlanMucHJvbW90ZShNZWRpYVRhZ1JlcXVlc3QsIFwiVGFnUmVxdWVzdFwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFhIUlJlcXVlc3QuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBwcmVsb2FkZXIgdGhhdCBsb2FkcyBpdGVtcyB1c2luZyBYSFIgcmVxdWVzdHMsIHVzdWFsbHkgWE1MSHR0cFJlcXVlc3QuIEhvd2V2ZXIgWERvbWFpblJlcXVlc3RzIHdpbGwgYmUgdXNlZFxuXHQgKiBmb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzIGlmIHBvc3NpYmxlLCBhbmQgb2xkZXIgdmVyc2lvbnMgb2YgSUUgZmFsbCBiYWNrIG9uIHRvIEFjdGl2ZVggb2JqZWN0cyB3aGVuIG5lY2Vzc2FyeS5cblx0ICogWEhSIHJlcXVlc3RzIGxvYWQgdGhlIGNvbnRlbnQgYXMgdGV4dCBvciBiaW5hcnkgZGF0YSwgcHJvdmlkZSBwcm9ncmVzcyBhbmQgY29uc2lzdGVudCBjb21wbGV0aW9uIGV2ZW50cywgYW5kXG5cdCAqIGNhbiBiZSBjYW5jZWxlZCBkdXJpbmcgbG9hZC4gTm90ZSB0aGF0IFhIUiBpcyBub3Qgc3VwcG9ydGVkIGluIElFIDYgb3IgZWFybGllciwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3Jcblx0ICogY3Jvc3MtZG9tYWluIGxvYWRpbmcuXG5cdCAqIEBjbGFzcyBYSFJSZXF1ZXN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgb2JqZWN0IHRoYXQgZGVmaW5lcyB0aGUgZmlsZSB0byBsb2FkLiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGFuIG92ZXJ2aWV3IG9mIHN1cHBvcnRlZCBmaWxlIHByb3BlcnRpZXMuXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqL1xuXHRmdW5jdGlvbiBYSFJSZXF1ZXN0IChpdGVtKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFJlcXVlc3RfY29uc3RydWN0b3IoaXRlbSk7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEEgcmVmZXJlbmNlIHRvIHRoZSBYSFIgcmVxdWVzdCB1c2VkIHRvIGxvYWQgdGhlIGNvbnRlbnQuXG5cdFx0ICogQHByb3BlcnR5IF9yZXF1ZXN0XG5cdFx0ICogQHR5cGUge1hNTEh0dHBSZXF1ZXN0IHwgWERvbWFpblJlcXVlc3QgfCBBY3RpdmVYLlhNTEhUVFB9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgbWFudWFsIGxvYWQgdGltZW91dCB0aGF0IGlzIHVzZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgdGhlIG9uVGltZW91dCBldmVudCBvbiBYSFIgKFhIUiBsZXZlbCAxLFxuXHRcdCAqIHR5cGljYWxseSBJRTkpLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZFRpbWVvdXRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZFRpbWVvdXQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGJyb3dzZXIncyBYSFIgKFhNTEhUVFBSZXF1ZXN0KSB2ZXJzaW9uLiBTdXBwb3J0ZWQgdmVyc2lvbnMgYXJlIDEgYW5kIDIuIFRoZXJlIGlzIG5vIG9mZmljaWFsIHdheSB0byBkZXRlY3Rcblx0XHQgKiB0aGUgdmVyc2lvbiwgc28gd2UgdXNlIGNhcGFiaWxpdGllcyB0byBtYWtlIGEgYmVzdCBndWVzcy5cblx0XHQgKiBAcHJvcGVydHkgX3hockxldmVsXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl94aHJMZXZlbCA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcmVzcG9uc2Ugb2YgYSBsb2FkZWQgZmlsZS4gVGhpcyBpcyBzZXQgYmVjYXVzZSBpdCBpcyBleHBlbnNpdmUgdG8gbG9vayB1cCBjb25zdGFudGx5LiBUaGlzIHByb3BlcnR5IHdpbGwgYmVcblx0XHQgKiBudWxsIHVudGlsIHRoZSBmaWxlIGlzIGxvYWRlZC5cblx0XHQgKiBAcHJvcGVydHkgX3Jlc3BvbnNlXG5cdFx0ICogQHR5cGUge21peGVkfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcmVzcG9uc2UgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJlc3BvbnNlIG9mIHRoZSBsb2FkZWQgZmlsZSBiZWZvcmUgaXQgaXMgbW9kaWZpZWQuIEluIG1vc3QgY2FzZXMsIGNvbnRlbnQgaXMgY29udmVydGVkIGZyb20gcmF3IHRleHQgdG9cblx0XHQgKiBhbiBIVE1MIHRhZyBvciBhIGZvcm1hdHRlZCBvYmplY3Qgd2hpY2ggaXMgc2V0IHRvIHRoZSA8Y29kZT5yZXN1bHQ8L2NvZGU+IHByb3BlcnR5LCBidXQgdGhlIGRldmVsb3BlciBtYXkgc3RpbGxcblx0XHQgKiB3YW50IHRvIGFjY2VzcyB0aGUgcmF3IGNvbnRlbnQgYXMgaXQgd2FzIGxvYWRlZC5cblx0XHQgKiBAcHJvcGVydHkgX3Jhd1Jlc3BvbnNlXG5cdFx0ICogQHR5cGUge1N0cmluZ3xPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9yYXdSZXNwb25zZSA9IG51bGw7XG5cblx0XHR0aGlzLl9jYW5jZWxlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gU2V0dXAgb3VyIGV2ZW50IGhhbmRsZXJzIG5vdy5cblx0XHR0aGlzLl9oYW5kbGVMb2FkU3RhcnRQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUxvYWRTdGFydCwgdGhpcyk7XG5cdFx0dGhpcy5faGFuZGxlUHJvZ3Jlc3NQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVByb2dyZXNzLCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVBYm9ydFByb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlQWJvcnQsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZUVycm9yUHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVFcnJvciwgdGhpcyk7XG5cdFx0dGhpcy5faGFuZGxlVGltZW91dFByb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGltZW91dCwgdGhpcyk7XG5cdFx0dGhpcy5faGFuZGxlTG9hZFByb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlTG9hZCwgdGhpcyk7XG5cdFx0dGhpcy5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVByb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSwgdGhpcyk7XG5cblx0XHRpZiAoIXRoaXMuX2NyZWF0ZVhIUihpdGVtKSkge1xuXHRcdFx0Ly9UT0RPOiBUaHJvdyBlcnJvcj9cblx0XHR9XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoWEhSUmVxdWVzdCwgY3JlYXRlanMuQWJzdHJhY3RSZXF1ZXN0KTtcblxuLy8gc3RhdGljIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIEEgbGlzdCBvZiBYTUxIVFRQIG9iamVjdCBJRHMgdG8gdHJ5IHdoZW4gYnVpbGRpbmcgYW4gQWN0aXZlWCBvYmplY3QgZm9yIFhIUiByZXF1ZXN0cyBpbiBlYXJsaWVyIHZlcnNpb25zIG9mIElFLlxuXHQgKiBAcHJvcGVydHkgQUNUSVZFWF9WRVJTSU9OU1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEBzaW5jZSAwLjQuMlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0WEhSUmVxdWVzdC5BQ1RJVkVYX1ZFUlNJT05TID0gW1xuXHRcdFwiTXN4bWwyLlhNTEhUVFAuNi4wXCIsXG5cdFx0XCJNc3htbDIuWE1MSFRUUC41LjBcIixcblx0XHRcIk1zeG1sMi5YTUxIVFRQLjQuMFwiLFxuXHRcdFwiTVNYTUwyLlhNTEhUVFAuMy4wXCIsXG5cdFx0XCJNU1hNTDIuWE1MSFRUUFwiLFxuXHRcdFwiTWljcm9zb2Z0LlhNTEhUVFBcIlxuXHRdO1xuXG4vLyBQdWJsaWMgbWV0aG9kc1xuXHQvKipcblx0ICogTG9vayB1cCB0aGUgbG9hZGVkIHJlc3VsdC5cblx0ICogQG1ldGhvZCBnZXRSZXN1bHRcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmF3PWZhbHNlXSBSZXR1cm4gYSByYXcgcmVzdWx0IGluc3RlYWQgb2YgYSBmb3JtYXR0ZWQgcmVzdWx0LiBUaGlzIGFwcGxpZXMgdG8gY29udGVudFxuXHQgKiBsb2FkZWQgdmlhIFhIUiBzdWNoIGFzIHNjcmlwdHMsIFhNTCwgQ1NTLCBhbmQgSW1hZ2VzLiBJZiB0aGVyZSBpcyBubyByYXcgcmVzdWx0LCB0aGUgZm9ybWF0dGVkIHJlc3VsdCB3aWxsIGJlXG5cdCAqIHJldHVybmVkIGluc3RlYWQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbnRlbnQgdGhhdCB3YXMgbG9hZGVkLCBzdWNoIGFzOlxuXHQgKiA8dWw+XG5cdCAqICAgICAgPGxpPkFuIGltYWdlIHRhZyAoJmx0O2ltYWdlIC8mZ3Q7KSBmb3IgaW1hZ2VzPC9saT5cblx0ICogICAgICA8bGk+QSBzY3JpcHQgdGFnIGZvciBKYXZhU2NyaXB0ICgmbHQ7c2NyaXB0IC8mZ3Q7KS4gTm90ZSB0aGF0IHNjcmlwdHMgbG9hZGVkIHdpdGggdGFncyBtYXkgYmUgYWRkZWQgdG8gdGhlXG5cdCAqICAgICAgSFRNTCBoZWFkLjwvbGk+XG5cdCAqICAgICAgPGxpPkEgc3R5bGUgdGFnIGZvciBDU1MgKCZsdDtzdHlsZSAvJmd0Oyk8L2xpPlxuXHQgKiAgICAgIDxsaT5SYXcgdGV4dCBmb3IgVEVYVDwvbGk+XG5cdCAqICAgICAgPGxpPkEgZm9ybWF0dGVkIEphdmFTY3JpcHQgb2JqZWN0IGRlZmluZWQgYnkgSlNPTjwvbGk+XG5cdCAqICAgICAgPGxpPkFuIFhNTCBkb2N1bWVudDwvbGk+XG5cdCAqICAgICAgPGxpPkFuIGJpbmFyeSBhcnJheWJ1ZmZlciBsb2FkZWQgYnkgWEhSPC9saT5cblx0ICogPC91bD5cblx0ICogTm90ZSB0aGF0IGlmIGEgcmF3IHJlc3VsdCBpcyByZXF1ZXN0ZWQsIGJ1dCBub3QgZm91bmQsIHRoZSByZXN1bHQgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkLlxuXHQgKi9cblx0cC5nZXRSZXN1bHQgPSBmdW5jdGlvbiAocmF3KSB7XG5cdFx0aWYgKHJhdyAmJiB0aGlzLl9yYXdSZXNwb25zZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3Jhd1Jlc3BvbnNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fcmVzcG9uc2U7XG5cdH07XG5cblx0Ly8gT3ZlcnJpZGVzIGFic3RyYWN0IG1ldGhvZCBpbiBBYnN0cmFjdFJlcXVlc3Rcblx0cC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5jYW5jZWxlZCA9IHRydWU7XG5cdFx0dGhpcy5fY2xlYW4oKTtcblx0XHR0aGlzLl9yZXF1ZXN0LmFib3J0KCk7XG5cdH07XG5cblx0Ly8gT3ZlcnJpZGVzIGFic3RyYWN0IG1ldGhvZCBpbiBBYnN0cmFjdExvYWRlclxuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QgPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5faGFuZGxlRXJyb3IoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvL0V2ZW50c1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZHN0YXJ0XCIsIHRoaXMuX2hhbmRsZUxvYWRTdGFydFByb3h5LCBmYWxzZSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVQcm9ncmVzc1Byb3h5LCBmYWxzZSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCB0aGlzLl9oYW5kbGVBYm9ydFByb3h5LCBmYWxzZSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9oYW5kbGVFcnJvclByb3h5LCBmYWxzZSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0aW1lb3V0XCIsIHRoaXMuX2hhbmRsZVRpbWVvdXRQcm94eSwgZmFsc2UpO1xuXG5cdFx0XHQvLyBOb3RlOiBXZSBkb24ndCBnZXQgb25sb2FkIGluIGFsbCBicm93c2VycyAoZWFybGllciBGRiBhbmQgSUUpLiBvblJlYWR5U3RhdGVDaGFuZ2UgaGFuZGxlcyB0aGVzZS5cblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5faGFuZGxlTG9hZFByb3h5LCBmYWxzZSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsIHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2VQcm94eSwgZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBJRTkgc3VwcG9ydFxuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmxvYWRzdGFydCA9IHRoaXMuX2hhbmRsZUxvYWRTdGFydFByb3h5O1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbnByb2dyZXNzID0gdGhpcy5faGFuZGxlUHJvZ3Jlc3NQcm94eTtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25hYm9ydCA9IHRoaXMuX2hhbmRsZUFib3J0UHJveHk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9uZXJyb3IgPSB0aGlzLl9oYW5kbGVFcnJvclByb3h5O1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbnRpbWVvdXQgPSB0aGlzLl9oYW5kbGVUaW1lb3V0UHJveHk7XG5cblx0XHRcdC8vIE5vdGU6IFdlIGRvbid0IGdldCBvbmxvYWQgaW4gYWxsIGJyb3dzZXJzIChlYXJsaWVyIEZGIGFuZCBJRSkuIG9uUmVhZHlTdGF0ZUNoYW5nZSBoYW5kbGVzIHRoZXNlLlxuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmxvYWQgPSB0aGlzLl9oYW5kbGVMb2FkUHJveHk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2VQcm94eTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdXAgYSB0aW1lb3V0IGlmIHdlIGRvbid0IGhhdmUgWEhSMlxuXHRcdGlmICh0aGlzLl94aHJMZXZlbCA9PSAxKSB7XG5cdFx0XHR0aGlzLl9sb2FkVGltZW91dCA9IHNldFRpbWVvdXQoY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGltZW91dCwgdGhpcyksIHRoaXMuX2l0ZW0ubG9hZFRpbWVvdXQpO1xuXHRcdH1cblxuXHRcdC8vIFNvbWV0aW1lcyB3ZSBnZXQgYmFjayA0MDRzIGltbWVkaWF0ZWx5LCBwYXJ0aWN1bGFybHkgd2hlbiB0aGVyZSBpcyBhIGNyb3NzIG9yaWdpbiByZXF1ZXN0LiAgLy8gbm90ZSB0aGlzIGRvZXMgbm90IGNhdGNoIGluIENocm9tZVxuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMuX2l0ZW0udmFsdWVzIHx8IHRoaXMuX2l0ZW0ubWV0aG9kID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkdFVCkge1xuXHRcdFx0XHR0aGlzLl9yZXF1ZXN0LnNlbmQoKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5faXRlbS5tZXRob2QgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuUE9TVCkge1xuXHRcdFx0XHR0aGlzLl9yZXF1ZXN0LnNlbmQoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmZvcm1hdFF1ZXJ5U3RyaW5nKHRoaXMuX2l0ZW0udmFsdWVzKSk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlhIUl9TRU5EXCIsIG51bGwsIGVycm9yKSk7XG5cdFx0fVxuXHR9O1xuXG5cdHAuc2V0UmVzcG9uc2VUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0XHQvLyBTb21lIG9sZCBicm93c2VycyBkb2Vzbid0IHN1cHBvcnQgYmxvYiwgc28gd2UgY29udmVydCBhcnJheWJ1ZmZlciB0byBibG9iIGFmdGVyIHJlc3BvbnNlIGlzIGRvd25sb2FkZWRcblx0XHRpZiAodHlwZSA9PT0gJ2Jsb2InKSB7XG5cdFx0XHR0eXBlID0gd2luZG93LlVSTCA/ICdibG9iJyA6ICdhcnJheWJ1ZmZlcic7XG5cdFx0XHR0aGlzLl9yZXNwb25zZVR5cGUgPSB0eXBlO1xuXHRcdH1cblx0XHR0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHR5cGU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBhbGwgdGhlIHJlc3BvbnNlIGhlYWRlcnMgZnJvbSB0aGUgWG1sSHR0cFJlcXVlc3QuXG5cdCAqXG5cdCAqIDxzdHJvbmc+RnJvbSB0aGUgZG9jczo8L3N0cm9uZz4gUmV0dXJuIGFsbCB0aGUgSFRUUCBoZWFkZXJzLCBleGNsdWRpbmcgaGVhZGVycyB0aGF0IGFyZSBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hcblx0ICogZm9yIFNldC1Db29raWUgb3IgU2V0LUNvb2tpZTIsIGFzIGEgc2luZ2xlIHN0cmluZywgd2l0aCBlYWNoIGhlYWRlciBsaW5lIHNlcGFyYXRlZCBieSBhIFUrMDAwRCBDUiBVKzAwMEEgTEYgcGFpcixcblx0ICogZXhjbHVkaW5nIHRoZSBzdGF0dXMgbGluZSwgYW5kIHdpdGggZWFjaCBoZWFkZXIgbmFtZSBhbmQgaGVhZGVyIHZhbHVlIHNlcGFyYXRlZCBieSBhIFUrMDAzQSBDT0xPTiBVKzAwMjAgU1BBQ0Vcblx0ICogcGFpci5cblx0ICogQG1ldGhvZCBnZXRBbGxSZXNwb25zZUhlYWRlcnNcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAc2luY2UgMC40LjFcblx0ICovXG5cdHAuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYSBzcGVjaWZpYyByZXNwb25zZSBoZWFkZXIgZnJvbSB0aGUgWG1sSHR0cFJlcXVlc3QuXG5cdCAqXG5cdCAqIDxzdHJvbmc+RnJvbSB0aGUgZG9jczo8L3N0cm9uZz4gUmV0dXJucyB0aGUgaGVhZGVyIGZpZWxkIHZhbHVlIGZyb20gdGhlIHJlc3BvbnNlIG9mIHdoaWNoIHRoZSBmaWVsZCBuYW1lIG1hdGNoZXNcblx0ICogaGVhZGVyLCB1bmxlc3MgdGhlIGZpZWxkIG5hbWUgaXMgU2V0LUNvb2tpZSBvciBTZXQtQ29va2llMi5cblx0ICogQG1ldGhvZCBnZXRSZXNwb25zZUhlYWRlclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyIFRoZSBoZWFkZXIgbmFtZSB0byByZXRyaWV2ZS5cblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAc2luY2UgMC40LjFcblx0ICovXG5cdHAuZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVyKSB7XG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIoaGVhZGVyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG4vLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogVGhlIFhIUiByZXF1ZXN0IGhhcyByZXBvcnRlZCBwcm9ncmVzcy5cblx0ICogQG1ldGhvZCBfaGFuZGxlUHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgcHJvZ3Jlc3MgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICghZXZlbnQgfHwgZXZlbnQubG9hZGVkID4gMCAmJiBldmVudC50b3RhbCA9PSAwKSB7XG5cdFx0XHRyZXR1cm47IC8vIFNvbWV0aW1lcyB3ZSBnZXQgbm8gXCJ0b3RhbFwiLCBzbyBqdXN0IGlnbm9yZSB0aGUgcHJvZ3Jlc3MgZXZlbnQuXG5cdFx0fVxuXG5cdFx0dmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQoZXZlbnQubG9hZGVkLCBldmVudC50b3RhbCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIFhIUiByZXF1ZXN0IGhhcyByZXBvcnRlZCBhIGxvYWQgc3RhcnQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUxvYWRTdGFydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBsb2FkU3RhcnQgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVMb2FkU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImxvYWRzdGFydFwiKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIFhIUiByZXF1ZXN0IGhhcyByZXBvcnRlZCBhbiBhYm9ydCBldmVudC5cblx0ICogQG1ldGhvZCBoYW5kbGVBYm9ydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBhYm9ydCBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUFib3J0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5fY2xlYW4oKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJYSFJfQUJPUlRFRFwiLCBudWxsLCBldmVudCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIGFuIGVycm9yIGV2ZW50LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVFcnJvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBlcnJvciBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5fY2xlYW4oKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoZXZlbnQubWVzc2FnZSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIGEgcmVhZHlTdGF0ZSBjaGFuZ2UuIE5vdGUgdGhhdCBvbGRlciBicm93c2VycyAoSUUgNyAmIDgpIGRvIG5vdCBwcm92aWRlIGFuIG9ubG9hZFxuXHQgKiBldmVudCwgc28gd2UgbXVzdCBtb25pdG9yIHRoZSByZWFkeVN0YXRlQ2hhbmdlIHRvIGRldGVybWluZSBpZiB0aGUgZmlsZSBpcyBsb2FkZWQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgcmVhZHlTdGF0ZUNoYW5nZSBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAodGhpcy5fcmVxdWVzdC5yZWFkeVN0YXRlID09IDQpIHtcblx0XHRcdHRoaXMuX2hhbmRsZUxvYWQoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgY29tcGxldGVkLiBUaGlzIGlzIGNhbGxlZCBieSB0aGUgWEhSIHJlcXVlc3QgZGlyZWN0bHksIG9yIGJ5IGEgcmVhZHlTdGF0ZUNoYW5nZSB0aGF0IGhhc1xuXHQgKiA8Y29kZT5yZXF1ZXN0LnJlYWR5U3RhdGUgPT0gNDwvY29kZT4uIE9ubHkgdGhlIGZpcnN0IGNhbGwgdG8gdGhpcyBtZXRob2Qgd2lsbCBiZSBwcm9jZXNzZWQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUxvYWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgbG9hZCBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAodGhpcy5sb2FkZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5sb2FkZWQgPSB0cnVlO1xuXG5cdFx0dmFyIGVycm9yID0gdGhpcy5fY2hlY2tFcnJvcigpO1xuXHRcdGlmIChlcnJvcikge1xuXHRcdFx0dGhpcy5faGFuZGxlRXJyb3IoZXJyb3IpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3Jlc3BvbnNlID0gdGhpcy5fZ2V0UmVzcG9uc2UoKTtcblx0XHQvLyBDb252ZXJ0IGFycmF5YnVmZmVyIGJhY2sgdG8gYmxvYlxuXHRcdGlmICh0aGlzLl9yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuX3Jlc3BvbnNlID0gbmV3IEJsb2IoW3RoaXMuX3Jlc3BvbnNlXSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHVzZSBCbG9iQnVpbGRlciBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0Ly8gVGVzdGVkIG9uIEFuZHJvaWQgMi4zIH4gNC4yIGFuZCBpT1M1IHNhZmFyaVxuXHRcdFx0XHR3aW5kb3cuQmxvYkJ1aWxkZXIgPSB3aW5kb3cuQmxvYkJ1aWxkZXIgfHwgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8IHdpbmRvdy5Nb3pCbG9iQnVpbGRlciB8fCB3aW5kb3cuTVNCbG9iQnVpbGRlcjtcblx0XHRcdFx0aWYgKGUubmFtZSA9PT0gJ1R5cGVFcnJvcicgJiYgd2luZG93LkJsb2JCdWlsZGVyKSB7XG5cdFx0XHRcdFx0dmFyIGJ1aWxkZXIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcblx0XHRcdFx0XHRidWlsZGVyLmFwcGVuZCh0aGlzLl9yZXNwb25zZSk7XG5cdFx0XHRcdFx0dGhpcy5fcmVzcG9uc2UgPSBidWlsZGVyLmdldEJsb2IoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9jbGVhbigpO1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FdmVudChcImNvbXBsZXRlXCIpKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIFhIUiByZXF1ZXN0IGhhcyB0aW1lZCBvdXQuIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBYSFIgcmVxdWVzdCBkaXJlY3RseSwgb3IgdmlhIGEgPGNvZGU+c2V0VGltZW91dDwvY29kZT5cblx0ICogY2FsbGJhY2suXG5cdCAqIEBtZXRob2QgX2hhbmRsZVRpbWVvdXRcblx0ICogQHBhcmFtIHtPYmplY3R9IFtldmVudF0gVGhlIFhIUiB0aW1lb3V0IGV2ZW50LiBUaGlzIGlzIG9jY2FzaW9uYWxseSBudWxsIHdoZW4gY2FsbGVkIGJ5IHRoZSBiYWNrdXAgc2V0VGltZW91dC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVRpbWVvdXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9USU1FT1VUXCIsIG51bGwsIGV2ZW50KSk7XG5cdH07XG5cbi8vIFByb3RlY3RlZFxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIHRoZXJlIGlzIGFuIGVycm9yIGluIHRoZSBjdXJyZW50IGxvYWQuIFRoaXMgY2hlY2tzIHRoZSBzdGF0dXMgb2YgdGhlIHJlcXVlc3QgZm9yIHByb2JsZW0gY29kZXMuIE5vdGVcblx0ICogdGhhdCB0aGlzIGRvZXMgbm90IGNoZWNrIGZvciBhbiBhY3R1YWwgcmVzcG9uc2UuIEN1cnJlbnRseSwgaXQgb25seSBjaGVja3MgZm9yIDQwNCBvciAwIGVycm9yIGNvZGUuXG5cdCAqIEBtZXRob2QgX2NoZWNrRXJyb3Jcblx0ICogQHJldHVybiB7aW50fSBJZiB0aGUgcmVxdWVzdCBzdGF0dXMgcmV0dXJucyBhbiBlcnJvciBjb2RlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY2hlY2tFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0XHQvL0xNOiBQcm9iYWJseSBuZWVkIGFkZGl0aW9uYWwgaGFuZGxlcnMgaGVyZSwgbWF5YmUgNTAxXG5cdFx0dmFyIHN0YXR1cyA9IHBhcnNlSW50KHRoaXMuX3JlcXVlc3Quc3RhdHVzKTtcblxuXHRcdHN3aXRjaCAoc3RhdHVzKSB7XG5cdFx0XHRjYXNlIDQwNDogICAvLyBOb3QgRm91bmRcblx0XHRcdGNhc2UgMDogICAgIC8vIE5vdCBMb2FkZWRcblx0XHRcdFx0cmV0dXJuIG5ldyBFcnJvcihzdGF0dXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogVmFsaWRhdGUgdGhlIHJlc3BvbnNlLiBEaWZmZXJlbnQgYnJvd3NlcnMgaGF2ZSBkaWZmZXJlbnQgYXBwcm9hY2hlcywgc29tZSBvZiB3aGljaCB0aHJvdyBlcnJvcnMgd2hlbiBhY2Nlc3NlZFxuXHQgKiBpbiBvdGhlciBicm93c2Vycy4gSWYgdGhlcmUgaXMgbm8gcmVzcG9uc2UsIHRoZSA8Y29kZT5fcmVzcG9uc2U8L2NvZGU+IHByb3BlcnR5IHdpbGwgcmVtYWluIG51bGwuXG5cdCAqIEBtZXRob2QgX2dldFJlc3BvbnNlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9nZXRSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVzcG9uc2UgIT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3Jlc3BvbnNlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlICE9IG51bGwpIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFuZHJvaWQgMi4yIHVzZXMgLnJlc3BvbnNlVGV4dFxuXHRcdHRyeSB7XG5cdFx0XHRpZiAodGhpcy5fcmVxdWVzdC5yZXNwb25zZVRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVxdWVzdC5yZXNwb25zZVRleHQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gbG9hZGluZyBYTUwsIElFOSBkb2VzIG5vdCByZXR1cm4gLnJlc3BvbnNlLCBpbnN0ZWFkIGl0IHJldHVybnMgcmVzcG9uc2VYTUwueG1sXG5cdFx0dHJ5IHtcblx0XHRcdGlmICh0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlWE1MICE9IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlcXVlc3QucmVzcG9uc2VYTUw7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gWEhSIHJlcXVlc3QuIERlcGVuZGluZyBvbiBhIG51bWJlciBvZiBmYWN0b3JzLCB3ZSBnZXQgdG90YWxseSBkaWZmZXJlbnQgcmVzdWx0cy5cblx0ICogPG9sPjxsaT5Tb21lIGJyb3dzZXJzIGdldCBhbiA8Y29kZT5YRG9tYWluUmVxdWVzdDwvY29kZT4gd2hlbiBsb2FkaW5nIGNyb3NzLWRvbWFpbi48L2xpPlxuXHQgKiAgICAgIDxsaT5YTUxIdHRwUmVxdWVzdCBhcmUgY3JlYXRlZCB3aGVuIGF2YWlsYWJsZS48L2xpPlxuXHQgKiAgICAgIDxsaT5BY3RpdmVYLlhNTEhUVFAgb2JqZWN0cyBhcmUgdXNlZCBpbiBvbGRlciBJRSBicm93c2Vycy48L2xpPlxuXHQgKiAgICAgIDxsaT5UZXh0IHJlcXVlc3RzIG92ZXJyaWRlIHRoZSBtaW1lIHR5cGUgaWYgcG9zc2libGU8L2xpPlxuXHQgKiAgICAgIDxsaT5PcmlnaW4gaGVhZGVycyBhcmUgc2VudCBmb3IgY3Jvc3Nkb21haW4gcmVxdWVzdHMgaW4gc29tZSBicm93c2Vycy48L2xpPlxuXHQgKiAgICAgIDxsaT5CaW5hcnkgbG9hZHMgc2V0IHRoZSByZXNwb25zZSB0eXBlIHRvIFwiYXJyYXlidWZmZXJcIjwvbGk+PC9vbD5cblx0ICogQG1ldGhvZCBfY3JlYXRlWEhSXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSByZXF1ZXN0ZWQgaXRlbSB0aGF0IGlzIGJlaW5nIGxvYWRlZC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgYW4gWEhSIHJlcXVlc3Qgb3IgZXF1aXZhbGVudCB3YXMgc3VjY2Vzc2Z1bGx5IGNyZWF0ZWQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jcmVhdGVYSFIgPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdC8vIENoZWNrIGZvciBjcm9zcy1kb21haW4gbG9hZHMuIFdlIGNhbid0IGZ1bGx5IHN1cHBvcnQgdGhlbSwgYnV0IHdlIGNhbiB0cnkuXG5cdFx0dmFyIGNyb3NzZG9tYWluID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzQ3Jvc3NEb21haW4oaXRlbSk7XG5cdFx0dmFyIGhlYWRlcnMgPSB7fTtcblxuXHRcdC8vIENyZWF0ZSB0aGUgcmVxdWVzdC4gRmFsbGJhY2sgdG8gd2hhdGV2ZXIgc3VwcG9ydCB3ZSBoYXZlLlxuXHRcdHZhciByZXEgPSBudWxsO1xuXHRcdGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcblx0XHRcdHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdFx0Ly8gVGhpcyBpcyA4IG9yIDksIHNvIHVzZSBYRG9tYWluUmVxdWVzdCBpbnN0ZWFkLlxuXHRcdFx0aWYgKGNyb3NzZG9tYWluICYmIHJlcS53aXRoQ3JlZGVudGlhbHMgPT09IHVuZGVmaW5lZCAmJiB3aW5kb3cuWERvbWFpblJlcXVlc3QpIHtcblx0XHRcdFx0cmVxID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgLy8gT2xkIElFIHZlcnNpb25zIHVzZSBhIGRpZmZlcmVudCBhcHByb2FjaFxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzLkFDVElWRVhfVkVSU0lPTlMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBheFZlcnNpb24gPSBzLkFDVElWRVhfVkVSU0lPTlNbaV07XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmVxID0gbmV3IEFjdGl2ZVhPYmplY3QoYXhWZXJzaW9uKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAocmVxID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIERlZmF1bHQgdG8gdXRmLTggZm9yIFRleHQgcmVxdWVzdHMuXG5cdFx0aWYgKGl0ZW0ubWltZVR5cGUgPT0gbnVsbCAmJiBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNUZXh0KGl0ZW0udHlwZSkpIHtcblx0XHRcdGl0ZW0ubWltZVR5cGUgPSBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIjtcblx0XHR9XG5cblx0XHQvLyBJRTkgZG9lc24ndCBzdXBwb3J0IG92ZXJyaWRlTWltZVR5cGUoKSwgc28gd2UgbmVlZCB0byBjaGVjayBmb3IgaXQuXG5cdFx0aWYgKGl0ZW0ubWltZVR5cGUgJiYgcmVxLm92ZXJyaWRlTWltZVR5cGUpIHtcblx0XHRcdHJlcS5vdmVycmlkZU1pbWVUeXBlKGl0ZW0ubWltZVR5cGUpO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSB0aGUgWEhSIGxldmVsXG5cdFx0dGhpcy5feGhyTGV2ZWwgPSAodHlwZW9mIHJlcS5yZXNwb25zZVR5cGUgPT09IFwic3RyaW5nXCIpID8gMiA6IDE7XG5cblx0XHR2YXIgc3JjID0gbnVsbDtcblx0XHRpZiAoaXRlbS5tZXRob2QgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuR0VUKSB7XG5cdFx0XHRzcmMgPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuYnVpbGRQYXRoKGl0ZW0uc3JjLCBpdGVtLnZhbHVlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNyYyA9IGl0ZW0uc3JjO1xuXHRcdH1cblxuXHRcdC8vIE9wZW4gdGhlIHJlcXVlc3QuICBTZXQgY3Jvc3MtZG9tYWluIGZsYWdzIGlmIGl0IGlzIHN1cHBvcnRlZCAoWEhSIGxldmVsIDEgb25seSlcblx0XHRyZXEub3BlbihpdGVtLm1ldGhvZCB8fCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5HRVQsIHNyYywgdHJ1ZSk7XG5cblx0XHRpZiAoY3Jvc3Nkb21haW4gJiYgcmVxIGluc3RhbmNlb2YgWE1MSHR0cFJlcXVlc3QgJiYgdGhpcy5feGhyTGV2ZWwgPT0gMSkge1xuXHRcdFx0aGVhZGVyc1tcIk9yaWdpblwiXSA9IGxvY2F0aW9uLm9yaWdpbjtcblx0XHR9XG5cblx0XHQvLyBUbyBzZW5kIGRhdGEgd2UgbmVlZCB0byBzZXQgdGhlIENvbnRlbnQtdHlwZSBoZWFkZXIpXG5cdFx0aWYgKGl0ZW0udmFsdWVzICYmIGl0ZW0ubWV0aG9kID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlBPU1QpIHtcblx0XHRcdGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiO1xuXHRcdH1cblxuXHRcdGlmICghY3Jvc3Nkb21haW4gJiYgIWhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdKSB7XG5cdFx0XHRoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHR9XG5cblx0XHRpZiAoaXRlbS5oZWFkZXJzKSB7XG5cdFx0XHRmb3IgKHZhciBuIGluIGl0ZW0uaGVhZGVycykge1xuXHRcdFx0XHRoZWFkZXJzW25dID0gaXRlbS5oZWFkZXJzW25dO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAobiBpbiBoZWFkZXJzKSB7XG5cdFx0XHRyZXEuc2V0UmVxdWVzdEhlYWRlcihuLCBoZWFkZXJzW25dKVxuXHRcdH1cblxuXHRcdGlmIChyZXEgaW5zdGFuY2VvZiBYTUxIdHRwUmVxdWVzdCAmJiBpdGVtLndpdGhDcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXEud2l0aENyZWRlbnRpYWxzID0gaXRlbS53aXRoQ3JlZGVudGlhbHM7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVxdWVzdCA9IHJlcTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIHJlcXVlc3QgaGFzIGNvbXBsZXRlZCAob3IgZmFpbGVkIG9yIGNhbmNlbGVkKSwgYW5kIG5lZWRzIHRvIGJlIGRpc3Bvc2VkLlxuXHQgKiBAbWV0aG9kIF9jbGVhblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY2xlYW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblxuXHRcdGlmICh0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZHN0YXJ0XCIsIHRoaXMuX2hhbmRsZUxvYWRTdGFydFByb3h5KTtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZVByb2dyZXNzUHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgdGhpcy5faGFuZGxlQWJvcnRQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9oYW5kbGVFcnJvclByb3h5KTtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRpbWVvdXRcIiwgdGhpcy5faGFuZGxlVGltZW91dFByb3h5KTtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5faGFuZGxlTG9hZFByb3h5KTtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIiwgdGhpcy5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVByb3h5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmxvYWRzdGFydCA9IG51bGw7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmFib3J0ID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25lcnJvciA9IG51bGw7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9udGltZW91dCA9IG51bGw7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ubG9hZCA9IG51bGw7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW1ByZWxvYWRKUyBYSFJSZXF1ZXN0XVwiO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlhIUlJlcXVlc3QgPSBjcmVhdGVqcy5wcm9tb3RlKFhIUlJlcXVlc3QsIFwiQWJzdHJhY3RSZXF1ZXN0XCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTG9hZFF1ZXVlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKlxuIFRPRE86IFdJTkRPV1MgSVNTVUVTXG4gKiBObyBlcnJvciBmb3IgSFRNTCBhdWRpbyBpbiBJRSA2NzhcbiAqIFNWRyBubyBmYWlsdXJlIGVycm9yIGluIElFIDY3IChtYXliZSA4KSBUQUdTIEFORCBYSFJcbiAqIE5vIHNjcmlwdCBjb21wbGV0ZSBoYW5kbGVyIGluIElFIDY3IFRBR1MgKFhIUiBpcyBmaW5lKVxuICogTm8gWE1ML0pTT04gaW4gSUU2IFRBR1NcbiAqIE5lZWQgdG8gaGlkZSBsb2FkaW5nIFNWRyBpbiBPcGVyYSBUQUdTXG4gKiBObyBDU1Mgb25sb2FkL3JlYWR5c3RhdGVjaGFuZ2UgaW4gU2FmYXJpIG9yIEFuZHJvaWQgVEFHUyAocmVxdWlyZXMgcnVsZSBjaGVja2luZylcbiAqIFNWRyBubyBsb2FkIG9yIGZhaWx1cmUgaW4gT3BlcmEgWEhSXG4gKiBSZXBvcnRlZCBpc3N1ZXMgd2l0aCBJRTcvOFxuICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogVGhlIExvYWRRdWV1ZSBjbGFzcyBpcyB0aGUgbWFpbiBBUEkgZm9yIHByZWxvYWRpbmcgY29udGVudC4gTG9hZFF1ZXVlIGlzIGEgbG9hZCBtYW5hZ2VyLCB3aGljaCBjYW4gcHJlbG9hZCBlaXRoZXJcblx0ICogYSBzaW5nbGUgZmlsZSwgb3IgcXVldWUgb2YgZmlsZXMuXG5cdCAqXG5cdCAqIDxiPkNyZWF0aW5nIGEgUXVldWU8L2I+PGJyIC8+XG5cdCAqIFRvIHVzZSBMb2FkUXVldWUsIGNyZWF0ZSBhIExvYWRRdWV1ZSBpbnN0YW5jZS4gSWYgeW91IHdhbnQgdG8gZm9yY2UgdGFnIGxvYWRpbmcgd2hlcmUgcG9zc2libGUsIHNldCB0aGUgcHJlZmVyWEhSXG5cdCAqIGFyZ3VtZW50IHRvIGZhbHNlLlxuXHQgKlxuXHQgKiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUodHJ1ZSk7XG5cdCAqXG5cdCAqIDxiPkxpc3RlbmluZyBmb3IgRXZlbnRzPC9iPjxiciAvPlxuXHQgKiBBZGQgYW55IGxpc3RlbmVycyB5b3Ugd2FudCB0byB0aGUgcXVldWUuIFNpbmNlIFByZWxvYWRKUyAwLjMuMCwgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBsZXRzIHlvdSBhZGQgYXMgbWFueSBsaXN0ZW5lcnMgYXMgeW91IHdhbnQgZm9yIGV2ZW50cy4gWW91IGNhbiBzdWJzY3JpYmUgdG8gdGhlIGZvbGxvd2luZyBldmVudHM6PHVsPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2NvbXBsZXRlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319OiBmaXJlZCB3aGVuIGEgcXVldWUgY29tcGxldGVzIGxvYWRpbmcgYWxsXG5cdCAqICAgICBmaWxlczwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZXJyb3I6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX06IGZpcmVkIHdoZW4gdGhlIHF1ZXVlIGVuY291bnRlcnMgYW4gZXJyb3Igd2l0aFxuXHQgKiAgICAgYW55IGZpbGUuPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9wcm9ncmVzczpldmVudFwifX17ey9jcm9zc0xpbmt9fTogUHJvZ3Jlc3MgZm9yIHRoZSBlbnRpcmUgcXVldWUgaGFzXG5cdCAqICAgICBjaGFuZ2VkLjwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319OiBBIHNpbmdsZSBmaWxlIGhhcyBjb21wbGV0ZWQgbG9hZGluZy48L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlcHJvZ3Jlc3M6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX06IFByb2dyZXNzIGZvciBhIHNpbmdsZSBmaWxlIGhhcyBjaGFuZ2VzLiBOb3RlXG5cdCAqICAgICB0aGF0IG9ubHkgZmlsZXMgbG9hZGVkIHdpdGggWEhSIChvciBwb3NzaWJseSBieSBwbHVnaW5zKSB3aWxsIGZpcmUgcHJvZ3Jlc3MgZXZlbnRzIG90aGVyIHRoYW4gMCBvciAxMDAlLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqICAgICAgcXVldWUub24oXCJmaWxlbG9hZFwiLCBoYW5kbGVGaWxlTG9hZCwgdGhpcyk7XG5cdCAqICAgICAgcXVldWUub24oXCJjb21wbGV0ZVwiLCBoYW5kbGVDb21wbGV0ZSwgdGhpcyk7XG5cdCAqXG5cdCAqIDxiPkFkZGluZyBmaWxlcyBhbmQgbWFuaWZlc3RzPC9iPjxiciAvPlxuXHQgKiBBZGQgZmlsZXMgeW91IHdhbnQgdG8gbG9hZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gb3IgYWRkIG11bHRpcGxlIGZpbGVzIGF0IGFcblx0ICogdGltZSB1c2luZyBhIGxpc3Qgb3IgYSBtYW5pZmVzdCBkZWZpbml0aW9uIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0uIEZpbGVzIGFyZVxuXHQgKiBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhY3RpdmUgcXVldWUsIHNvIHlvdSBjYW4gdXNlIHRoZXNlIG1ldGhvZHMgYXMgbWFueSB0aW1lcyBhcyB5b3UgbGlrZSwgd2hlbmV2ZXIgeW91XG5cdCAqIGxpa2UuXG5cdCAqXG5cdCAqICAgICAgcXVldWUubG9hZEZpbGUoXCJmaWxlUGF0aC9maWxlLmpwZ1wiKTtcblx0ICogICAgICBxdWV1ZS5sb2FkRmlsZSh7aWQ6XCJpbWFnZVwiLCBzcmM6XCJmaWxlUGF0aC9maWxlLmpwZ1wifSk7XG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KFtcImZpbGVQYXRoL2ZpbGUuanBnXCIsIHtpZDpcImltYWdlXCIsIHNyYzpcImZpbGVQYXRoL2ZpbGUuanBnXCJ9XSk7XG5cdCAqXG5cdCAqICAgICAgLy8gVXNlIGFuIGV4dGVybmFsIG1hbmlmZXN0XG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KFwicGF0aC90by9tYW5pZmVzdC5qc29uXCIpO1xuXHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdCh7c3JjOlwibWFuaWZlc3QuanNvblwiLCB0eXBlOlwibWFuaWZlc3RcIn0pO1xuXHQgKlxuXHQgKiBJZiB5b3UgcGFzcyBgZmFsc2VgIGFzIHRoZSBgbG9hZE5vd2AgcGFyYW1ldGVyLCB0aGUgcXVldWUgd2lsbCBub3Qga2ljayBvZiB0aGUgbG9hZCBvZiB0aGUgZmlsZXMsIGJ1dCBpdCB3aWxsIG5vdFxuXHQgKiBzdG9wIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZC4gQ2FsbCB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvbG9hZFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgdG8gYmVnaW5cblx0ICogYSBwYXVzZWQgcXVldWUuIE5vdGUgdGhhdCBhIHBhdXNlZCBxdWV1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgcmVzdW1lIHdoZW4gbmV3IGZpbGVzIGFyZSBhZGRlZCB0byBpdCB3aXRoIGFcblx0ICogYGxvYWROb3dgIGFyZ3VtZW50IG9mIGB0cnVlYC5cblx0ICpcblx0ICogICAgICBxdWV1ZS5sb2FkKCk7XG5cdCAqXG5cdCAqIDxiPkZpbGUgVHlwZXM8L2I+PGJyIC8+XG5cdCAqIFRoZSBmaWxlIHR5cGUgb2YgYSBtYW5pZmVzdCBpdGVtIGlzIGF1dG8tZGV0ZXJtaW5lZCBieSB0aGUgZmlsZSBleHRlbnNpb24uIFRoZSBwYXR0ZXJuIG1hdGNoaW5nIGluIFByZWxvYWRKU1xuXHQgKiBzaG91bGQgaGFuZGxlIHRoZSBtYWpvcml0eSBvZiBzdGFuZGFyZCBmaWxlIGFuZCB1cmwgZm9ybWF0cywgYW5kIHdvcmtzIHdpdGggY29tbW9uIGZpbGUgZXh0ZW5zaW9ucy4gSWYgeW91IGhhdmVcblx0ICogZWl0aGVyIGEgbm9uLXN0YW5kYXJkIGZpbGUgZXh0ZW5zaW9uLCBvciBhcmUgc2VydmluZyB0aGUgZmlsZSB1c2luZyBhIHByb3h5IHNjcmlwdCwgdGhlbiB5b3UgY2FuIHBhc3MgaW4gYVxuXHQgKiA8Y29kZT50eXBlPC9jb2RlPiBwcm9wZXJ0eSB3aXRoIGFueSBtYW5pZmVzdCBpdGVtLlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLmxvYWRGaWxlKHtzcmM6XCJwYXRoL3RvL215RmlsZS5tcDN4XCIsIHR5cGU6Y3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU09VTkR9KTtcblx0ICpcblx0ICogICAgICAvLyBOb3RlIHRoYXQgUHJlbG9hZEpTIHdpbGwgbm90IHJlYWQgYSBmaWxlIGV4dGVuc2lvbiBmcm9tIHRoZSBxdWVyeSBzdHJpbmdcblx0ICogICAgICBxdWV1ZS5sb2FkRmlsZSh7c3JjOlwiaHR0cDovL3NlcnZlci5jb20vcHJveHk/ZmlsZT1pbWFnZS5qcGdcIiwgdHlwZTpjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5JTUFHRX0pO1xuXHQgKlxuXHQgKiBTdXBwb3J0ZWQgdHlwZXMgYXJlIGRlZmluZWQgb24gdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzLCBhbmQgaW5jbHVkZTpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0JJTkFSWTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogUmF3IGJpbmFyeSBkYXRhIHZpYSBYSFI8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0NTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogQ1NTIGZpbGVzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9JTUFHRTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogQ29tbW9uIGltYWdlIGZvcm1hdHM8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pBVkFTQ1JJUFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEphdmFTY3JpcHQgZmlsZXM8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT046cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEpTT04gZGF0YTwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSlNPTlA6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEpTT04gZmlsZXMgY3Jvc3MtZG9tYWluPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogQSBsaXN0IG9mIGZpbGVzIHRvIGxvYWQgaW4gSlNPTiBmb3JtYXQsIHNlZVxuXHQgKiAgICAge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319PC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TT1VORDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogQXVkaW8gZmlsZSBmb3JtYXRzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TUFJJVEVTSEVFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogSlNPTiBTcHJpdGVTaGVldCBkZWZpbml0aW9ucy4gVGhpc1xuXHQgKiAgICAgd2lsbCBhbHNvIGxvYWQgc3ViLWltYWdlcywgYW5kIHByb3ZpZGUgYSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZS48L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NWRzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogU1ZHIGZpbGVzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9URVhUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBUZXh0IGZpbGVzIC0gWEhSIG9ubHk8L2xpPlxuICAgICAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvVklERU86cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFZpZGVvIG9iamVjdHM8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1hNTDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogWE1MIGRhdGE8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiA8ZW0+Tm90ZTogTG9hZGVyIHR5cGVzIHVzZWQgdG8gYmUgZGVmaW5lZCBvbiBMb2FkUXVldWUsIGJ1dCBoYXZlIGJlZW4gbW92ZWQgdG8gQWJzdHJhY3RMb2FkZXIgZm9yIGJldHRlclxuXHQgKiBwb3J0YWJpbGl0eSBvZiBsb2FkZXIgY2xhc3Nlcywgd2hpY2ggY2FuIGJlIHVzZWQgaW5kaXZpZHVhbGx5IG5vdy4gVGhlIHByb3BlcnRpZXMgb24gTG9hZFF1ZXVlIHN0aWxsIGV4aXN0LCBidXRcblx0ICogYXJlIGRlcHJlY2F0ZWQuPC9lbT5cblx0ICpcblx0ICogPGI+SGFuZGxpbmcgUmVzdWx0czwvYj48YnIgLz5cblx0ICogV2hlbiBhIGZpbGUgaXMgZmluaXNoZWQgZG93bmxvYWRpbmcsIGEge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGlzXG5cdCAqIGRpc3BhdGNoZWQuIEluIGFuIGV4YW1wbGUgYWJvdmUsIHRoZXJlIGlzIGFuIGV2ZW50IGxpc3RlbmVyIHNuaXBwZXQgZm9yIGZpbGVsb2FkLiBMb2FkZWQgZmlsZXMgYXJlIHVzdWFsbHkgYVxuXHQgKiBmb3JtYXR0ZWQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgaW1tZWRpYXRlbHksIGluY2x1ZGluZzpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPkJpbmFyeTogVGhlIGJpbmFyeSBsb2FkZWQgcmVzdWx0PC9saT5cblx0ICogICAgIDxsaT5DU1M6IEEgJmx0O2xpbmsgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5JbWFnZTogQW4gJmx0O2ltZyAvJmd0OyB0YWc8L2xpPlxuXHQgKiAgICAgPGxpPkphdmFTY3JpcHQ6IEEgJmx0O3NjcmlwdCAvJmd0OyB0YWc8L2xpPlxuXHQgKiAgICAgPGxpPkpTT04vSlNPTlA6IEEgZm9ybWF0dGVkIEphdmFTY3JpcHQgT2JqZWN0PC9saT5cblx0ICogICAgIDxsaT5NYW5pZmVzdDogQSBKYXZhU2NyaXB0IG9iamVjdC5cblx0ICogICAgIDxsaT5Tb3VuZDogQW4gJmx0O2F1ZGlvIC8mZ3Q7IHRhZzwvYT5cblx0ICogICAgIDxsaT5TcHJpdGVTaGVldDogQSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZSwgY29udGFpbmluZyBsb2FkZWQgaW1hZ2VzLlxuXHQgKiAgICAgPGxpPlNWRzogQW4gJmx0O29iamVjdCAvJmd0OyB0YWc8L2xpPlxuXHQgKiAgICAgPGxpPlRleHQ6IFJhdyB0ZXh0PC9saT5cbiAgICAgKiAgICAgPGxpPlZpZGVvOiBBIFZpZGVvIERPTSBub2RlPC9saT5cblx0ICogICAgIDxsaT5YTUw6IEFuIFhNTCBET00gbm9kZTwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlRmlsZUxvYWQoZXZlbnQpIHtcblx0ICogICAgICAgICAgdmFyIGl0ZW0gPSBldmVudC5pdGVtOyAvLyBBIHJlZmVyZW5jZSB0byB0aGUgaXRlbSB0aGF0IHdhcyBwYXNzZWQgaW4gdG8gdGhlIExvYWRRdWV1ZVxuXHQgKiAgICAgICAgICB2YXIgdHlwZSA9IGl0ZW0udHlwZTtcblx0ICpcblx0ICogICAgICAgICAgLy8gQWRkIGFueSBpbWFnZXMgdG8gdGhlIHBhZ2UgYm9keS5cblx0ICogICAgICAgICAgaWYgKHR5cGUgPT0gY3JlYXRlanMuTG9hZFF1ZXVlLklNQUdFKSB7XG5cdCAqICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGV2ZW50LnJlc3VsdCk7XG5cdCAqICAgICAgICAgIH1cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEF0IGFueSB0aW1lIGFmdGVyIHRoZSBmaWxlIGhhcyBiZWVuIGxvYWRlZCAodXN1YWxseSBhZnRlciB0aGUgcXVldWUgaGFzIGNvbXBsZXRlZCksIGFueSByZXN1bHQgY2FuIGJlIGxvb2tlZCB1cFxuXHQgKiB2aWEgaXRzIFwiaWRcIiB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319LiBJZiBubyBpZCB3YXMgcHJvdmlkZWQsIHRoZW4gdGhlXG5cdCAqIFwic3JjXCIgb3IgZmlsZSBwYXRoIGNhbiBiZSB1c2VkIGluc3RlYWQsIGluY2x1ZGluZyB0aGUgYHBhdGhgIGRlZmluZWQgYnkgYSBtYW5pZmVzdCwgYnV0IDxzdHJvbmc+bm90IGluY2x1ZGluZzwvc3Ryb25nPlxuXHQgKiBhIGJhc2UgcGF0aCBkZWZpbmVkIG9uIHRoZSBMb2FkUXVldWUuIEl0IGlzIHJlY29tbWVuZGVkIHRvIGFsd2F5cyBwYXNzIGFuIGlkIGlmIHlvdSB3YW50IHRvIGxvb2sgdXAgY29udGVudC5cblx0ICpcblx0ICogICAgICB2YXIgaW1hZ2UgPSBxdWV1ZS5nZXRSZXN1bHQoXCJpbWFnZVwiKTtcblx0ICogICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltYWdlKTtcblx0ICpcblx0ICogUmF3IGxvYWRlZCBjb250ZW50IGNhbiBiZSBhY2Nlc3NlZCB1c2luZyB0aGUgPGNvZGU+cmF3UmVzdWx0PC9jb2RlPiBwcm9wZXJ0eSBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50LCBvciBjYW4gYmUgbG9va2VkIHVwIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9nZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX0sIHBhc3NpbmcgYHRydWVgIGFzIHRoZSAybmRcblx0ICogYXJndW1lbnQuIFRoaXMgaXMgb25seSBhcHBsaWNhYmxlIGZvciBjb250ZW50IHRoYXQgaGFzIGJlZW4gcGFyc2VkIGZvciB0aGUgYnJvd3Nlciwgc3BlY2lmaWNhbGx5OiBKYXZhU2NyaXB0LFxuXHQgKiBDU1MsIFhNTCwgU1ZHLCBhbmQgSlNPTiBvYmplY3RzLCBvciBhbnl0aGluZyBsb2FkZWQgd2l0aCBYSFIuXG5cdCAqXG5cdCAqICAgICAgdmFyIGltYWdlID0gcXVldWUuZ2V0UmVzdWx0KFwiaW1hZ2VcIiwgdHJ1ZSk7IC8vIGxvYWQgdGhlIGJpbmFyeSBpbWFnZSBkYXRhIGxvYWRlZCB3aXRoIFhIUi5cblx0ICpcblx0ICogPGI+UGx1Z2luczwvYj48YnIgLz5cblx0ICogTG9hZFF1ZXVlIGhhcyBhIHNpbXBsZSBwbHVnaW4gYXJjaGl0ZWN0dXJlIHRvIGhlbHAgcHJvY2VzcyBhbmQgcHJlbG9hZCBjb250ZW50LiBGb3IgZXhhbXBsZSwgdG8gcHJlbG9hZCBhdWRpbyxcblx0ICogbWFrZSBzdXJlIHRvIGluc3RhbGwgdGhlIDxhIGhyZWY9XCJodHRwOi8vc291bmRqcy5jb21cIj5Tb3VuZEpTPC9hPiBTb3VuZCBjbGFzcywgd2hpY2ggd2lsbCBoZWxwIGxvYWQgSFRNTCBhdWRpbyxcblx0ICogRmxhc2ggYXVkaW8sIGFuZCBXZWJBdWRpbyBmaWxlcy4gVGhpcyBzaG91bGQgYmUgaW5zdGFsbGVkIDxzdHJvbmc+YmVmb3JlPC9zdHJvbmc+IGxvYWRpbmcgYW55IGF1ZGlvIGZpbGVzLlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLmluc3RhbGxQbHVnaW4oY3JlYXRlanMuU291bmQpO1xuXHQgKlxuXHQgKiA8aDQ+S25vd24gQnJvd3NlciBJc3N1ZXM8L2g0PlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+QnJvd3NlcnMgd2l0aG91dCBhdWRpbyBzdXBwb3J0IGNhbiBub3QgbG9hZCBhdWRpbyBmaWxlcy48L2xpPlxuXHQgKiAgICAgPGxpPlNhZmFyaSBvbiBNYWMgT1MgWCBjYW4gb25seSBwbGF5IEhUTUwgYXVkaW8gaWYgUXVpY2tUaW1lIGlzIGluc3RhbGxlZDwvbGk+XG5cdCAqICAgICA8bGk+SFRNTCBBdWRpbyB0YWdzIHdpbGwgb25seSBkb3dubG9hZCB1bnRpbCB0aGVpciA8Y29kZT5jYW5QbGF5VGhyb3VnaDwvY29kZT4gZXZlbnQgaXMgZmlyZWQuIEJyb3dzZXJzIG90aGVyXG5cdCAqICAgICB0aGFuIENocm9tZSB3aWxsIGNvbnRpbnVlIHRvIGRvd25sb2FkIGluIHRoZSBiYWNrZ3JvdW5kLjwvbGk+XG5cdCAqICAgICA8bGk+V2hlbiBsb2FkaW5nIHNjcmlwdHMgdXNpbmcgdGFncywgdGhleSBhcmUgYXV0b21hdGljYWxseSBhZGRlZCB0byB0aGUgZG9jdW1lbnQuPC9saT5cblx0ICogICAgIDxsaT5TY3JpcHRzIGxvYWRlZCB2aWEgWEhSIG1heSBub3QgYmUgcHJvcGVybHkgaW5zcGVjdGFibGUgd2l0aCBicm93c2VyIHRvb2xzLjwvbGk+XG5cdCAqICAgICA8bGk+SUU2IGFuZCBJRTcgKGFuZCBzb21lIG90aGVyIGJyb3dzZXJzKSBtYXkgbm90IGJlIGFibGUgdG8gbG9hZCBYTUwsIFRleHQsIG9yIEpTT04sIHNpbmNlIHRoZXkgcmVxdWlyZVxuXHQgKiAgICAgWEhSIHRvIHdvcmsuPC9saT5cblx0ICogICAgIDxsaT5Db250ZW50IGxvYWRlZCB2aWEgdGFncyB3aWxsIG5vdCBzaG93IHByb2dyZXNzLCBhbmQgd2lsbCBjb250aW51ZSB0byBkb3dubG9hZCBpbiB0aGUgYmFja2dyb3VuZCB3aGVuXG5cdCAqICAgICBjYW5jZWxlZCwgYWx0aG91Z2ggbm8gZXZlbnRzIHdpbGwgYmUgZGlzcGF0Y2hlZC48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiBAY2xhc3MgTG9hZFF1ZXVlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZWZlclhIUj10cnVlXSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHByZWxvYWQgaW5zdGFuY2Ugd2lsbCBmYXZvciBsb2FkaW5nIHdpdGggWEhSIChYTUwgSFRUUFxuXHQgKiBSZXF1ZXN0cyksIG9yIEhUTUwgdGFncy4gV2hlbiB0aGlzIGlzIGBmYWxzZWAsIHRoZSBxdWV1ZSB3aWxsIHVzZSB0YWcgbG9hZGluZyB3aGVuIHBvc3NpYmxlLCBhbmQgZmFsbCBiYWNrIG9uIFhIUlxuXHQgKiB3aGVuIG5lY2Vzc2FyeS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aD1cIlwiXSBBIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCBvbiB0byB0aGUgc291cmNlIHBhcmFtZXRlciBvZiBhbGwgaXRlbXMgaW4gdGhlIHF1ZXVlXG5cdCAqIGJlZm9yZSB0aGV5IGFyZSBsb2FkZWQuICBTb3VyY2VzIGJlZ2lubmluZyB3aXRoIGEgcHJvdG9jb2wgc3VjaCBhcyBgaHR0cDovL2Agb3IgYSByZWxhdGl2ZSBwYXRoIHN1Y2ggYXMgYC4uL2Bcblx0ICogd2lsbCBub3QgcmVjZWl2ZSBhIGJhc2UgcGF0aC5cblx0ICogQHBhcmFtIHtTdHJpbmd8Qm9vbGVhbn0gW2Nyb3NzT3JpZ2luPVwiXCJdIEFuIG9wdGlvbmFsIGZsYWcgdG8gc3VwcG9ydCBpbWFnZXMgbG9hZGVkIGZyb20gYSBDT1JTLWVuYWJsZWQgc2VydmVyLiBUb1xuXHQgKiB1c2UgaXQsIHNldCB0aGlzIHZhbHVlIHRvIGB0cnVlYCwgd2hpY2ggd2lsbCBkZWZhdWx0IHRoZSBjcm9zc09yaWdpbiBwcm9wZXJ0eSBvbiBpbWFnZXMgdG8gXCJBbm9ueW1vdXNcIi4gQW55XG5cdCAqIHN0cmluZyB2YWx1ZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoLCBidXQgb25seSBcIlwiIGFuZCBcIkFub255bW91c1wiIGFyZSByZWNvbW1lbmRlZC4gPHN0cm9uZz5Ob3RlOiBUaGUgY3Jvc3NPcmlnaW5cblx0ICogcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBMb2FkSXRlbS5jcm9zc09yaWdpbiBpbnN0ZWFkPC9zdHJvbmc+XG5cdCAqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKi9cblx0ZnVuY3Rpb24gTG9hZFF1ZXVlIChwcmVmZXJYSFIsIGJhc2VQYXRoLCBjcm9zc09yaWdpbikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IoKTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIHRoZSBwbHVnaW5zIHJlZ2lzdGVyZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2luc3RhbGxQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9wbHVnaW5zXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNi4xXG5cdFx0ICovXG5cdFx0dGhpcy5fcGx1Z2lucyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgY2FsbGJhY2tzIHRoYXQgYXJlIGZpcmVkIGZvciBlYWNoIGZpbGUgdHlwZSBiZWZvcmUgdGhlIGZpbGUgaXMgbG9hZGVkLCBnaXZpbmcgcGx1Z2lucyB0aGVcblx0XHQgKiBhYmlsaXR5IHRvIG92ZXJyaWRlIHByb3BlcnRpZXMgb2YgdGhlIGxvYWQuIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9pbnN0YWxsUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBfdHlwZUNhbGxiYWNrc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl90eXBlQ2FsbGJhY2tzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBjYWxsYmFja3MgdGhhdCBhcmUgZmlyZWQgZm9yIGVhY2ggZmlsZSBleHRlbnNpb24gYmVmb3JlIHRoZSBmaWxlIGlzIGxvYWRlZCwgZ2l2aW5nIHBsdWdpbnMgdGhlXG5cdFx0ICogYWJpbGl0eSB0byBvdmVycmlkZSBwcm9wZXJ0aWVzIG9mIHRoZSBsb2FkLiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvaW5zdGFsbFBsdWdpblwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIG1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX2V4dGVuc2lvbkNhbGxiYWNrc1xuXHRcdCAqIEB0eXBlIHtudWxsfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fZXh0ZW5zaW9uQ2FsbGJhY2tzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbmV4dCBwcmVsb2FkIHF1ZXVlIHRvIHByb2Nlc3Mgd2hlbiB0aGlzIG9uZSBpcyBjb21wbGV0ZS4gSWYgYW4gZXJyb3IgaXMgdGhyb3duIGluIHRoZSBjdXJyZW50IHF1ZXVlLCBhbmRcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc3RvcE9uRXJyb3I6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgYHRydWVgLCB0aGUgbmV4dCBxdWV1ZSB3aWxsIG5vdCBiZSBwcm9jZXNzZWQuXG5cdFx0ICogQHByb3BlcnR5IG5leHRcblx0XHQgKiBAdHlwZSB7TG9hZFF1ZXVlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm5leHQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogRW5zdXJlIGxvYWRlZCBzY3JpcHRzIFwiY29tcGxldGVcIiBpbiB0aGUgb3JkZXIgdGhleSBhcmUgc3BlY2lmaWVkLiBMb2FkZWQgc2NyaXB0cyBhcmUgYWRkZWQgdG8gdGhlIGRvY3VtZW50IGhlYWRcblx0XHQgKiBvbmNlIHRoZXkgYXJlIGxvYWRlZC4gU2NyaXB0cyBsb2FkZWQgdmlhIHRhZ3Mgd2lsbCBsb2FkIG9uZS1hdC1hLXRpbWUgd2hlbiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCwgd2hlcmVhc1xuXHRcdCAqIHNjcmlwdHMgbG9hZGVkIHVzaW5nIFhIUiBjYW4gbG9hZCBpbiBhbnkgb3JkZXIsIGJ1dCB3aWxsIFwiZmluaXNoXCIgYW5kIGJlIGFkZGVkIHRvIHRoZSBkb2N1bWVudCBpbiB0aGUgb3JkZXJcblx0XHQgKiBzcGVjaWZpZWQuXG5cdFx0ICpcblx0XHQgKiBBbnkgaXRlbXMgY2FuIGJlIHNldCB0byBsb2FkIGluIG9yZGVyIGJ5IHNldHRpbmcgdGhlIHt7I2Nyb3NzTGluayBcIm1haW50YWluT3JkZXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBwcm9wZXJ0eSBvbiB0aGUgbG9hZCBpdGVtLCBvciBieSBlbnN1cmluZyB0aGF0IG9ubHkgb25lIGNvbm5lY3Rpb24gY2FuIGJlIG9wZW4gYXQgYSB0aW1lIHVzaW5nXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319LiBOb3RlIHRoYXQgd2hlbiB0aGUgYG1haW50YWluU2NyaXB0T3JkZXJgIHByb3BlcnR5XG5cdFx0ICogaXMgc2V0IHRvIGB0cnVlYCwgc2NyaXB0cyBpdGVtcyBhcmUgYXV0b21hdGljYWxseSBzZXQgdG8gYG1haW50YWluT3JkZXI9dHJ1ZWAsIGFuZCBjaGFuZ2luZyB0aGVcblx0XHQgKiBgbWFpbnRhaW5TY3JpcHRPcmRlcmAgdG8gYGZhbHNlYCBkdXJpbmcgYSBsb2FkIHdpbGwgbm90IGNoYW5nZSBpdGVtcyBhbHJlYWR5IGluIGEgcXVldWUuXG5cdFx0ICpcblx0XHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdFx0ICpcblx0XHQgKiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcblx0XHQgKiAgICAgIHF1ZXVlLnNldE1heENvbm5lY3Rpb25zKDMpOyAvLyBTZXQgYSBoaWdoZXIgbnVtYmVyIHRvIGxvYWQgbXVsdGlwbGUgaXRlbXMgYXQgb25jZVxuXHRcdCAqICAgICAgcXVldWUubWFpbnRhaW5TY3JpcHRPcmRlciA9IHRydWU7IC8vIEVuc3VyZSBzY3JpcHRzIGFyZSBsb2FkZWQgaW4gb3JkZXJcblx0XHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChbXG5cdFx0ICogICAgICAgICAgXCJzY3JpcHQxLmpzXCIsXG5cdFx0ICogICAgICAgICAgXCJzY3JpcHQyLmpzXCIsXG5cdFx0ICogICAgICAgICAgXCJpbWFnZS5wbmdcIiwgLy8gTG9hZCBhbnkgdGltZVxuXHRcdCAqICAgICAgICAgIHtzcmM6IFwiaW1hZ2UyLnBuZ1wiLCBtYWludGFpbk9yZGVyOiB0cnVlfSAvLyBXaWxsIHdhaXQgZm9yIHNjcmlwdDIuanNcblx0XHQgKiAgICAgICAgICBcImltYWdlMy5wbmdcIixcblx0XHQgKiAgICAgICAgICBcInNjcmlwdDMuanNcIiAvLyBXaWxsIHdhaXQgZm9yIGltYWdlMi5wbmcgYmVmb3JlIGxvYWRpbmcgKG9yIGNvbXBsZXRpbmcgd2hlbiBsb2FkaW5nIHdpdGggWEhSKVxuXHRcdCAqICAgICAgXSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgbWFpbnRhaW5TY3JpcHRPcmRlclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLm1haW50YWluU2NyaXB0T3JkZXIgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgTG9hZFF1ZXVlIHdpbGwgc3RvcCBwcm9jZXNzaW5nIHRoZSBjdXJyZW50IHF1ZXVlIHdoZW4gYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuXG5cdFx0ICogQHByb3BlcnR5IHN0b3BPbkVycm9yXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLnN0b3BPbkVycm9yID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIG1heGltdW0gb3BlbiBjb25uZWN0aW9ucyB0aGF0IGEgbG9hZFF1ZXVlIHRyaWVzIHRvIG1haW50YWluLiBQbGVhc2Ugc2VlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbWF4Q29ubmVjdGlvbnNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX21heENvbm5lY3Rpb25zID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGludGVybmFsIGxpc3Qgb2YgYWxsIHRoZSBkZWZhdWx0IExvYWRlcnMgdGhhdCBhcmUgaW5jbHVkZWQgd2l0aCBQcmVsb2FkSlMuIEJlZm9yZSBhbiBpdGVtIGlzIGxvYWRlZCwgdGhlXG5cdFx0ICogYXZhaWxhYmxlIGxvYWRlciBsaXN0IGlzIGl0ZXJhdGVkLCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgaW5jbHVkZWQsIGFuZCBhcyBzb29uIGFzIGEgbG9hZGVyIGluZGljYXRlcyBpdCBjYW5cblx0XHQgKiBoYW5kbGUgdGhlIGNvbnRlbnQsIGl0IHdpbGwgYmUgc2VsZWN0ZWQuIFRoZSBkZWZhdWx0IGxvYWRlciwgKHt7I2Nyb3NzTGluayBcIlRleHRMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gaXNcblx0XHQgKiBsYXN0IGluIHRoZSBsaXN0LCBzbyBpdCB3aWxsIGJlIHVzZWQgaWYgbm8gb3RoZXIgbWF0Y2ggaXMgZm91bmQuIFR5cGljYWxseSwgbG9hZGVycyB3aWxsIG1hdGNoIGJhc2VkIG9uIHRoZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3R5cGVcIn19e3svY3Jvc3NMaW5rfX0sIHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lZCB1c2luZyB0aGUgZmlsZSBleHRlbnNpb24gb2Zcblx0XHQgKiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vc3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqXG5cdFx0ICogTG9hZGVycyBjYW4gYmUgcmVtb3ZlZCBmcm9tIFByZWxvYWRKUyBieSBzaW1wbHkgbm90IGluY2x1ZGluZyB0aGVtLlxuXHRcdCAqXG5cdFx0ICogQ3VzdG9tIGxvYWRlcnMgaW5zdGFsbGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcInJlZ2lzdGVyTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoaXMgbGlzdFxuXHRcdCAqIHNvIHRoYXQgdGhleSBhcmUgY2hlY2tlZCBmaXJzdC5cblx0XHQgKiBAcHJvcGVydHkgX2F2YWlsYWJsZUxvYWRlcnNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC42LjBcblx0XHQgKi9cblx0XHR0aGlzLl9hdmFpbGFibGVMb2FkZXJzID0gW1xuXHRcdFx0Y3JlYXRlanMuSW1hZ2VMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5KYXZhU2NyaXB0TG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuQ1NTTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuSlNPTkxvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkpTT05QTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuU291bmRMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5NYW5pZmVzdExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlNwcml0ZVNoZWV0TG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuWE1MTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuU1ZHTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuQmluYXJ5TG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuVmlkZW9Mb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5UZXh0TG9hZGVyXG5cdFx0XTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2YgYnVpbHQgaW4gbG9hZGVycywgc28gdGhleSBjYW4ndCBiZSByZW1vdmVkIGJ5IHt7I2Nyb3NzTGluayBcInVucmVnaXN0ZXJMb2FkZXJcIn19e3svY3Jvc3NMaW5rfS5cblx0XHRcdFx0ICogQHByb3BlcnR5IF9kZWZhdWx0TG9hZGVyTGVuZ3RoXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMuX2RlZmF1bHRMb2FkZXJMZW5ndGggPSB0aGlzLl9hdmFpbGFibGVMb2FkZXJzLmxlbmd0aDtcblxuXHRcdHRoaXMuaW5pdChwcmVmZXJYSFIsIGJhc2VQYXRoLCBjcm9zc09yaWdpbik7XG5cdH1cblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChMb2FkUXVldWUsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBMb2FkUXVldWU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cdC8qKlxuXHQgKiBBbiBpbnRlcm5hbCBpbml0aWFsaXphdGlvbiBtZXRob2QsIHdoaWNoIGlzIHVzZWQgZm9yIGluaXRpYWwgc2V0IHVwLCBidXQgYWxzbyB0byByZXNldCB0aGUgTG9hZFF1ZXVlLlxuXHQgKiBAbWV0aG9kIGluaXRcblx0ICogQHBhcmFtIHByZWZlclhIUlxuXHQgKiBAcGFyYW0gYmFzZVBhdGhcblx0ICogQHBhcmFtIGNyb3NzT3JpZ2luXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLmluaXQgPSBmdW5jdGlvbiAocHJlZmVyWEhSLCBiYXNlUGF0aCwgY3Jvc3NPcmlnaW4pIHtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IHVzZVhIUlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZmVyWEhSIGluc3RlYWQuXG5cdFx0ICovXG5cdFx0dGhpcy51c2VYSFIgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogVHJ5IGFuZCB1c2UgWE1MSHR0cFJlcXVlc3QgKFhIUikgd2hlbiBwb3NzaWJsZS4gTm90ZSB0aGF0IExvYWRRdWV1ZSB3aWxsIGRlZmF1bHQgdG8gdGFnIGxvYWRpbmcgb3IgWEhSXG5cdFx0ICogbG9hZGluZyBkZXBlbmRpbmcgb24gdGhlIHJlcXVpcmVtZW50cyBmb3IgYSBtZWRpYSB0eXBlLiBGb3IgZXhhbXBsZSwgSFRNTCBhdWRpbyBjYW4gbm90IGJlIGxvYWRlZCB3aXRoIFhIUixcblx0XHQgKiBhbmQgcGxhaW4gdGV4dCBjYW4gbm90IGJlIGxvYWRlZCB3aXRoIHRhZ3MsIHNvIGl0IHdpbGwgZGVmYXVsdCB0aGUgdGhlIGNvcnJlY3QgdHlwZSBpbnN0ZWFkIG9mIHVzaW5nIHRoZVxuXHRcdCAqIHVzZXItZGVmaW5lZCB0eXBlLlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiBAc2luY2UgMC42LjBcblx0XHQgKi9cblx0XHR0aGlzLnByZWZlclhIUiA9IHRydWU7IC8vVE9ETzogR2V0L1NldFxuXHRcdHRoaXMuX3ByZWZlclhIUiA9IHRydWU7XG5cdFx0dGhpcy5zZXRQcmVmZXJYSFIocHJlZmVyWEhSKTtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgcXVldWUgaXMgY3VycmVudGx5IHBhdXNlZCBvciBub3QuXG5cdFx0ICogQHByb3BlcnR5IF9wYXVzZWRcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgb24gdG8gdGhlIGl0ZW0ncyB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9zcmM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uIFRoZVxuXHRcdCAqIGBfYmFzZVBhdGhgIHByb3BlcnR5IHdpbGwgb25seSBiZSB1c2VkIGlmIGFuIGl0ZW0ncyBzb3VyY2UgaXMgcmVsYXRpdmUsIGFuZCBkb2VzIG5vdCBpbmNsdWRlIGEgcHJvdG9jb2wgc3VjaFxuXHRcdCAqIGFzIGBodHRwOi8vYCwgb3IgYSByZWxhdGl2ZSBwYXRoIHN1Y2ggYXMgYC4uL2AuXG5cdFx0ICogQHByb3BlcnR5IF9iYXNlUGF0aFxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC4zLjFcblx0XHQgKi9cblx0XHR0aGlzLl9iYXNlUGF0aCA9IGJhc2VQYXRoO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb3B0aW9uYWwgZmxhZyB0byBzZXQgb24gaW1hZ2VzIHRoYXQgYXJlIGxvYWRlZCB1c2luZyBQcmVsb2FkSlMsIHdoaWNoIGVuYWJsZXMgQ09SUyBzdXBwb3J0LiBJbWFnZXMgbG9hZGVkXG5cdFx0ICogY3Jvc3MtZG9tYWluIGJ5IHNlcnZlcnMgdGhhdCBzdXBwb3J0IENPUlMgcmVxdWlyZSB0aGUgY3Jvc3NPcmlnaW4gZmxhZyB0byBiZSBsb2FkZWQgYW5kIGludGVyYWN0ZWQgd2l0aCBieVxuXHRcdCAqIGEgY2FudmFzLiBXaGVuIGxvYWRpbmcgbG9jYWxseSwgb3Igd2l0aCBhIHNlcnZlciB3aXRoIG5vIENPUlMgc3VwcG9ydCwgdGhpcyBmbGFnIGNhbiBjYXVzZSBvdGhlciBzZWN1cml0eSBpc3N1ZXMsXG5cdFx0ICogc28gaXQgaXMgcmVjb21tZW5kZWQgdG8gb25seSBzZXQgaXQgaWYgeW91IGFyZSBzdXJlIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgaXQuIEN1cnJlbnRseSwgc3VwcG9ydGVkIHZhbHVlcyBhcmUgXCJcIlxuXHRcdCAqIGFuZCBcIkFub255bW91c1wiLlxuXHRcdCAqIEBwcm9wZXJ0eSBfY3Jvc3NPcmlnaW5cblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IFwiXCJcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjQuMVxuXHRcdCAqL1xuXHRcdHRoaXMuX2Nyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkU3RhcnQgZXZlbnQgd2FzIGRpc3BhdGNoZWQgYWxyZWFkeS4gVGhpcyBldmVudCBpcyBvbmx5IGZpcmVkIG9uZSB0aW1lLCB3aGVuIHRoZSBmaXJzdFxuXHRcdCAqIGZpbGUgaXMgcmVxdWVzdGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZFN0YXJ0V2FzRGlzcGF0Y2hlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkU3RhcnRXYXNEaXNwYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGN1cnJlbnRseSBhIHNjcmlwdCBsb2FkaW5nLiBUaGlzIGhlbHBzIGVuc3VyZSB0aGF0IG9ubHkgYSBzaW5nbGUgc2NyaXB0IGxvYWRzIGF0IG9uY2Ugd2hlblxuXHRcdCAqIHVzaW5nIGEgc2NyaXB0IHRhZyB0byBkbyBwcmVsb2FkaW5nLlxuXHRcdCAqIEBwcm9wZXJ0eSBfY3VycmVudGx5TG9hZGluZ1NjcmlwdFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fY3VycmVudGx5TG9hZGluZ1NjcmlwdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBjb250YWluaW5nIHRoZSBjdXJyZW50bHkgZG93bmxvYWRpbmcgZmlsZXMuXG5cdFx0ICogQHByb3BlcnR5IF9jdXJyZW50TG9hZHNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9jdXJyZW50TG9hZHMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHF1ZXVlZCBpdGVtcyB0aGF0IGhhdmUgbm90IHlldCBzdGFydGVkIGRvd25sb2FkaW5nLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZFF1ZXVlXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZFF1ZXVlID0gW107XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBjb250YWluaW5nIGRvd25sb2FkcyB0aGF0IGhhdmUgbm90IGNvbXBsZXRlZCwgc28gdGhhdCB0aGUgTG9hZFF1ZXVlIGNhbiBiZSBwcm9wZXJseSByZXNldC5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRRdWV1ZUJhY2t1cFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRRdWV1ZUJhY2t1cCA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgaXRlbXMgdGhhdCBoYXZlIGZpbmlzaGVkIGRvd25sb2FkaW5nLCBpbmRleGVkIGJ5IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIGlkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZEl0ZW1zQnlJZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkSXRlbXNCeUlkID0ge307XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBpdGVtcyB0aGF0IGhhdmUgZmluaXNoZWQgZG93bmxvYWRpbmcsIGluZGV4ZWQgYnkge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBzb3VyY2UuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkSXRlbXNCeVNyY1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkSXRlbXNCeVNyYyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgbG9hZGVkIGl0ZW1zLCBpbmRleGVkIGJ5IHRoZSBJRCBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkZWRSZXN1bHRzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRlZFJlc3VsdHMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIHVuLXBhcnNlZCBsb2FkZWQgaXRlbXMsIGluZGV4ZWQgYnkgdGhlIElEIG9mIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRlZFJhd1Jlc3VsdHNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZGVkUmF3UmVzdWx0cyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBpdGVtcyB0aGF0IGhhdmUgYmVlbiByZXF1ZXN0ZWQuIFRoaXMgaGVscHMgbWFuYWdlIGFuIG92ZXJhbGwgcHJvZ3Jlc3Mgd2l0aG91dCBrbm93aW5nIGhvdyBsYXJnZVxuXHRcdCAqIHRoZSBmaWxlcyBhcmUgYmVmb3JlIHRoZXkgYXJlIGRvd25sb2FkZWQuIFRoaXMgZG9lcyBub3QgaW5jbHVkZSBpdGVtcyBpbnNpZGUgb2YgbG9hZGVycyBzdWNoIGFzIHRoZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbnVtSXRlbXNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX251bUl0ZW1zID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2YgaXRlbXMgdGhhdCBoYXZlIGNvbXBsZXRlZCBsb2FkZWQuIFRoaXMgaGVscHMgbWFuYWdlIGFuIG92ZXJhbGwgcHJvZ3Jlc3Mgd2l0aG91dCBrbm93aW5nIGhvdyBsYXJnZVxuXHRcdCAqIHRoZSBmaWxlcyBhcmUgYmVmb3JlIHRoZXkgYXJlIGRvd25sb2FkZWQuXG5cdFx0ICogQHByb3BlcnR5IF9udW1JdGVtc0xvYWRlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbnVtSXRlbXNMb2FkZWQgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBsaXN0IG9mIHNjcmlwdHMgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSByZXF1ZXN0ZWQuIFRoaXMgaGVscHMgZW5zdXJlIHRoYXQgc2NyaXB0cyBhcmUgXCJjb21wbGV0ZWRcIiBpbiB0aGUgcmlnaHRcblx0XHQgKiBvcmRlci5cblx0XHQgKiBAcHJvcGVydHkgX3NjcmlwdE9yZGVyXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fc2NyaXB0T3JkZXIgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgbGlzdCBvZiBzY3JpcHRzIHRoYXQgaGF2ZSBiZWVuIGxvYWRlZC4gSXRlbXMgYXJlIGFkZGVkIHRvIHRoaXMgbGlzdCBhcyA8Y29kZT5udWxsPC9jb2RlPiB3aGVuIHRoZXkgYXJlXG5cdFx0ICogcmVxdWVzdGVkLCBjb250YWluIHRoZSBsb2FkZWQgaXRlbSBpZiBpdCBoYXMgY29tcGxldGVkLCBidXQgbm90IGJlZW4gZGlzcGF0Y2hlZCB0byB0aGUgdXNlciwgYW5kIDxjb2RlPnRydWU8L3RydWU+XG5cdFx0ICogb25jZSB0aGV5IGFyZSBjb21wbGV0ZSBhbmQgaGF2ZSBiZWVuIGRpc3BhdGNoZWQuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkZWRTY3JpcHRzXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZGVkU2NyaXB0cyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxhc3QgcHJvZ3Jlc3MgYW1vdW50LiBUaGlzIGlzIHVzZWQgdG8gc3VwcHJlc3MgZHVwbGljYXRlIHByb2dyZXNzIGV2ZW50cy5cblx0XHQgKiBAcHJvcGVydHkgX2xhc3RQcm9ncmVzc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC42LjBcblx0XHQgKi9cblx0XHR0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBOYU47XG5cblx0fTtcblxuLy8gc3RhdGljIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byBhc3N1bWUgYSBsb2FkIGhhcyBmYWlsZWQuIEFuIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2Vycm9yOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGlzIGRpc3BhdGNoZWQgaWYgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCBiZWZvcmUgYW55IGRhdGEgaXMgcmVjZWl2ZWQuXG5cdCAqIEBwcm9wZXJ0eSBsb2FkVGltZW91dFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAZGVmYXVsdCA4MDAwXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqIEBkZXByZWNhdGVkIEluIGZhdm91ciBvZiB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9MT0FEX1RJTUVPVVRfREVGQVVMVDpwcm9wZXJ0eX19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkuXG5cdCAqL1xuXHRzLmxvYWRUaW1lb3V0ID0gODAwMDtcblxuXHQvKipcblx0ICogVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIGFzc3VtZSBhIGxvYWQgaGFzIGZhaWxlZC5cblx0ICogQHByb3BlcnR5IExPQURfVElNRU9VVFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAwXG5cdCAqIEBkZXByZWNhdGVkIGluIGZhdm9yIG9mIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZFRpbWVvdXQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkuXG5cdCAqL1xuXHRzLkxPQURfVElNRU9VVCA9IDA7XG5cbi8vIFByZWxvYWQgVHlwZXNcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBCSU5BUllcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgYmluYXJ5XG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9CSU5BUlk6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuQklOQVJZID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQklOQVJZO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgQ1NTXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGNzc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQ1NTOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLkNTUyA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkNTUztcblxuXHQvKipcblx0ICogQHByb3BlcnR5IElNQUdFXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGltYWdlXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9DU1M6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuSU1BR0UgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5JTUFHRTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IEpBVkFTQ1JJUFRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgamF2YXNjcmlwdFxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSkFWQVNDUklQVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5KQVZBU0NSSVBUID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSkFWQVNDUklQVDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IEpTT05cblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQganNvblxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSlNPTjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5KU09OID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTjtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IEpTT05QXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGpzb25wXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KU09OUDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5KU09OUCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT05QO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgTUFOSUZFU1Rcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgbWFuaWZlc3Rcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjFcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5NQU5JRkVTVCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLk1BTklGRVNUO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgU09VTkRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgc291bmRcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pBVkFTQ1JJUFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuU09VTkQgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TT1VORDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IFZJREVPXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHZpZGVvXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KQVZBU0NSSVBUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLlZJREVPID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVklERU87XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBTVkdcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgc3ZnXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TVkc6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuU1ZHID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1ZHO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgVEVYVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB0ZXh0XG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9URVhUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLlRFWFQgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5URVhUO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgWE1MXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHhtbFxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvWE1MOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLlhNTCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlhNTDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IFBPU1Rcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9QT1NUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLlBPU1QgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5QT1NUO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgR0VUXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvR0VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLkdFVCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkdFVDtcblxuLy8gZXZlbnRzXG5cdC8qKlxuXHQgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYW4gaW5kaXZpZHVhbCBmaWxlIGhhcyBsb2FkZWQsIGFuZCBiZWVuIHByb2Nlc3NlZC5cblx0ICogQGV2ZW50IGZpbGVsb2FkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIGZpbGUgaXRlbSB3aGljaCB3YXMgc3BlY2lmaWVkIGluIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fSBjYWxsLiBJZiBvbmx5IGEgc3RyaW5nIHBhdGggb3IgdGFnIHdhcyBzcGVjaWZpZWQsIHRoZVxuXHQgKiBvYmplY3Qgd2lsbCBjb250YWluIHRoYXQgdmFsdWUgYXMgYSBgc3JjYCBwcm9wZXJ0eS5cblx0ICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCBUaGUgSFRNTCB0YWcgb3IgcGFyc2VkIHJlc3VsdCBvZiB0aGUgbG9hZGVkIGl0ZW0uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByYXdSZXN1bHQgVGhlIHVucHJvY2Vzc2VkIHJlc3VsdCwgdXN1YWxseSB0aGUgcmF3IHRleHQgb3IgYmluYXJ5IGRhdGEgYmVmb3JlIGl0IGlzIGNvbnZlcnRlZFxuXHQgKiB0byBhIHVzYWJsZSBvYmplY3QuXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhpcyB7eyNjcm9zc0xpbmsgXCJQcm9ncmVzc0V2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiBhbiBhbiBpbmRpdmlkdWFsIGZpbGUncyBwcm9ncmVzcyBjaGFuZ2VzLlxuXHQgKiBAZXZlbnQgZmlsZXByb2dyZXNzXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGFuIGluZGl2aWR1YWwgZmlsZSBzdGFydHMgdG8gbG9hZC5cblx0ICogQGV2ZW50IGZpbGVzdGFydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIGZpbGUgaXRlbSB3aGljaCB3YXMgc3BlY2lmaWVkIGluIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fSBjYWxsLiBJZiBvbmx5IGEgc3RyaW5nIHBhdGggb3IgdGFnIHdhcyBzcGVjaWZpZWQsIHRoZVxuXHQgKiBvYmplY3Qgd2lsbCBjb250YWluIHRoYXQgdmFsdWUgYXMgYSBwcm9wZXJ0eS5cblx0ICovXG5cblx0LyoqXG5cdCAqIEFsdGhvdWdoIGl0IGV4dGVuZHMge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0sIHRoZSBgaW5pdGlhbGl6ZWAgZXZlbnQgaXMgbmV2ZXIgZmlyZWQgZnJvbVxuXHQgKiBhIExvYWRRdWV1ZSBpbnN0YW5jZS5cblx0ICogQGV2ZW50IGluaXRpYWxpemVcblx0ICogQHByaXZhdGVcblx0ICovXG5cbi8vIHB1YmxpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhIGN1c3RvbSBsb2FkZXJzIGNsYXNzLiBOZXcgbG9hZGVycyBhcmUgZ2l2ZW4gcHJlY2VkZW5jZSBvdmVyIGxvYWRlcnMgYWRkZWQgZWFybGllciBhbmQgZGVmYXVsdCBsb2FkZXJzLlxuXHQgKiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IGxvYWRlcnMgZXh0ZW5kIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LiBMb2FkZXJzIGNhbiBvbmx5IGJlIGFkZGVkXG5cdCAqIG9uY2UsIGFuZCB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGUgbGlzdCBvZiBhdmFpbGFibGUgbG9hZGVycy5cblx0ICogQG1ldGhvZCByZWdpc3RlckxvYWRlclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufEFic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIEFic3RyYWN0TG9hZGVyIGNsYXNzIHRvIGFkZC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLnJlZ2lzdGVyTG9hZGVyID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdGlmICghbG9hZGVyIHx8ICFsb2FkZXIuY2FuTG9hZEl0ZW0pIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImxvYWRlciBpcyBvZiBhbiBpbmNvcnJlY3QgdHlwZS5cIik7XG5cdFx0fSBlbHNlIGlmICh0aGlzLl9hdmFpbGFibGVMb2FkZXJzLmluZGV4T2YobG9hZGVyKSAhPSAtMSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibG9hZGVyIGFscmVhZHkgZXhpc3RzLlwiKTsgLy9MTTogTWF5YmUganVzdCBzaWxlbnRseSBmYWlsIGhlcmVcblx0XHR9XG5cblx0XHR0aGlzLl9hdmFpbGFibGVMb2FkZXJzLnVuc2hpZnQobG9hZGVyKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIGEgY3VzdG9tIGxvYWRlciBhZGRlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJyZWdpc3RlckxvYWRlclwifX17ey9jcm9zc0xpbmt9fS4gT25seSBjdXN0b20gbG9hZGVycyBjYW4gYmVcblx0ICogdW5yZWdpc3RlcmVkLCB0aGUgZGVmYXVsdCBsb2FkZXJzIHdpbGwgYWx3YXlzIGJlIGF2YWlsYWJsZS5cblx0ICogQG1ldGhvZCB1bnJlZ2lzdGVyTG9hZGVyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb258QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgQWJzdHJhY3RMb2FkZXIgY2xhc3MgdG8gcmVtb3ZlXG5cdCAqL1xuXHRwLnVucmVnaXN0ZXJMb2FkZXIgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0dmFyIGlkeCA9IHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMuaW5kZXhPZihsb2FkZXIpO1xuXHRcdGlmIChpZHggIT0gLTEgJiYgaWR4IDwgdGhpcy5fZGVmYXVsdExvYWRlckxlbmd0aCAtIDEpIHtcblx0XHRcdHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHNldFVzZVhIUlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFRoZSBuZXcgdXNlWEhSIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIG5ldyB1c2VYSFIgdmFsdWUuIElmIFhIUiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLCB0aGlzIHdpbGwgcmV0dXJuIGZhbHNlLCBldmVuIGlmXG5cdCAqIHRoZSBwcm92aWRlZCB2YWx1ZSBhcmd1bWVudCB3YXMgdHJ1ZS5cblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqIEBkZXByZWNhdGVkIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3ByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSwgb3IgdGhlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRVc2VYSFJcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGluc3RlYWQuXG5cdCAqL1xuXHRwLnNldFVzZVhIUiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLnNldFByZWZlclhIUih2YWx1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENoYW5nZSB0aGUge3sjY3Jvc3NMaW5rIFwicHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHZhbHVlLiBOb3RlIHRoYXQgaWYgdGhpcyBpcyBzZXQgdG8gYHRydWVgLCBpdCBtYXlcblx0ICogZmFpbCwgb3IgYmUgaWdub3JlZCBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXIncyBjYXBhYmlsaXRpZXMgYW5kIHRoZSBsb2FkIHR5cGUuXG5cdCAqIEBtZXRob2Qgc2V0UHJlZmVyWEhSXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcblx0ICogQHJldHVybnMge0Jvb2xlYW59IFRoZSB2YWx1ZSBvZiB7eyNjcm9zc0xpbmsgXCJwcmVmZXJYSFJcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCB3YXMgc3VjY2Vzc2Z1bGx5IHNldC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLnNldFByZWZlclhIUiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdC8vIERldGVybWluZSBpZiB3ZSBjYW4gdXNlIFhIUi4gWEhSIGRlZmF1bHRzIHRvIFRSVUUsIGJ1dCB0aGUgYnJvd3NlciBtYXkgbm90IHN1cHBvcnQgaXQuXG5cdFx0Ly9UT0RPOiBTaG91bGQgd2UgYmUgY2hlY2tpbmcgZm9yIHRoZSBvdGhlciBYSFIgdHlwZXM/IE1pZ2h0IGhhdmUgdG8gZG8gYSB0cnkvY2F0Y2ggb24gdGhlIGRpZmZlcmVudCB0eXBlcyBzaW1pbGFyIHRvIGNyZWF0ZVhIUi5cblx0XHR0aGlzLnByZWZlclhIUiA9ICh2YWx1ZSAhPSBmYWxzZSAmJiB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgIT0gbnVsbCk7XG5cdFx0cmV0dXJuIHRoaXMucHJlZmVyWEhSO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wcyBhbGwgcXVldWVkIGFuZCBsb2FkaW5nIGl0ZW1zLCBhbmQgY2xlYXJzIHRoZSBxdWV1ZS4gVGhpcyBhbHNvIHJlbW92ZXMgYWxsIGludGVybmFsIHJlZmVyZW5jZXMgdG8gbG9hZGVkXG5cdCAqIGNvbnRlbnQsIGFuZCBhbGxvd3MgdGhlIHF1ZXVlIHRvIGJlIHVzZWQgYWdhaW4uXG5cdCAqIEBtZXRob2QgcmVtb3ZlQWxsXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblx0cC5yZW1vdmVBbGwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5yZW1vdmUoKTtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcHMgYW4gaXRlbSBmcm9tIGJlaW5nIGxvYWRlZCwgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgcXVldWUuIElmIG5vdGhpbmcgaXMgcGFzc2VkLCBhbGwgaXRlbXMgYXJlIHJlbW92ZWQuXG5cdCAqIFRoaXMgYWxzbyByZW1vdmVzIGludGVybmFsIHJlZmVyZW5jZXMgdG8gbG9hZGVkIGl0ZW0ocykuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBxdWV1ZS5sb2FkTWFuaWZlc3QoW1xuXHQgKiAgICAgICAgICB7c3JjOlwidGVzdC5wbmdcIiwgaWQ6XCJwbmdcIn0sXG5cdCAqICAgICAgICAgIHtzcmM6XCJ0ZXN0LmpwZ1wiLCBpZDpcImpwZ1wifSxcblx0ICogICAgICAgICAge3NyYzpcInRlc3QubXAzXCIsIGlkOlwibXAzXCJ9XG5cdCAqICAgICAgXSk7XG5cdCAqICAgICAgcXVldWUucmVtb3ZlKFwicG5nXCIpOyAvLyBTaW5nbGUgaXRlbSBieSBJRFxuXHQgKiAgICAgIHF1ZXVlLnJlbW92ZShcInBuZ1wiLCBcInRlc3QuanBnXCIpOyAvLyBJdGVtcyBhcyBhcmd1bWVudHMuIE1peGVkIGlkIGFuZCBzcmMuXG5cdCAqICAgICAgcXVldWUucmVtb3ZlKFtcInRlc3QucG5nXCIsIFwianBnXCJdKTsgLy8gSXRlbXMgaW4gYW4gQXJyYXkuIE1peGVkIGlkIGFuZCBzcmMuXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVtb3ZlXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgQXJyYXl9IGlkc09yVXJscyogVGhlIGlkIG9yIGlkcyB0byByZW1vdmUgZnJvbSB0aGlzIHF1ZXVlLiBZb3UgY2FuIHBhc3MgYW4gaXRlbSwgYW4gYXJyYXkgb2Zcblx0ICogaXRlbXMsIG9yIG11bHRpcGxlIGl0ZW1zIGFzIGFyZ3VtZW50cy5cblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXHRwLnJlbW92ZSA9IGZ1bmN0aW9uIChpZHNPclVybHMpIHtcblx0XHR2YXIgYXJncyA9IG51bGw7XG5cblx0XHRpZiAoaWRzT3JVcmxzICYmICFBcnJheS5pc0FycmF5KGlkc09yVXJscykpIHtcblx0XHRcdGFyZ3MgPSBbaWRzT3JVcmxzXTtcblx0XHR9IGVsc2UgaWYgKGlkc09yVXJscykge1xuXHRcdFx0YXJncyA9IGlkc09yVXJscztcblx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGl0ZW1zV2VyZVJlbW92ZWQgPSBmYWxzZTtcblxuXHRcdC8vIERlc3Ryb3kgZXZlcnl0aGluZ1xuXHRcdGlmICghYXJncykge1xuXHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdFx0Zm9yICh2YXIgbiBpbiB0aGlzLl9sb2FkSXRlbXNCeUlkKSB7XG5cdFx0XHRcdHRoaXMuX2Rpc3Bvc2VJdGVtKHRoaXMuX2xvYWRJdGVtc0J5SWRbbl0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pbml0KHRoaXMucHJlZmVyWEhSLCB0aGlzLl9iYXNlUGF0aCk7XG5cblx0XHRcdC8vIFJlbW92ZSBzcGVjaWZpYyBpdGVtc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aGlsZSAoYXJncy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBhcmdzLnBvcCgpO1xuXHRcdFx0XHR2YXIgciA9IHRoaXMuZ2V0UmVzdWx0KGl0ZW0pO1xuXG5cdFx0XHRcdC8vUmVtb3ZlIGZyb20gdGhlIG1haW4gbG9hZCBRdWV1ZVxuXHRcdFx0XHRmb3IgKGkgPSB0aGlzLl9sb2FkUXVldWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRsb2FkSXRlbSA9IHRoaXMuX2xvYWRRdWV1ZVtpXS5nZXRJdGVtKCk7XG5cdFx0XHRcdFx0aWYgKGxvYWRJdGVtLmlkID09IGl0ZW0gfHwgbG9hZEl0ZW0uc3JjID09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2xvYWRRdWV1ZS5zcGxpY2UoaSwgMSlbMF0uY2FuY2VsKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL1JlbW92ZSBmcm9tIHRoZSBiYWNrdXAgcXVldWVcblx0XHRcdFx0Zm9yIChpID0gdGhpcy5fbG9hZFF1ZXVlQmFja3VwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0bG9hZEl0ZW0gPSB0aGlzLl9sb2FkUXVldWVCYWNrdXBbaV0uZ2V0SXRlbSgpO1xuXHRcdFx0XHRcdGlmIChsb2FkSXRlbS5pZCA9PSBpdGVtIHx8IGxvYWRJdGVtLnNyYyA9PSBpdGVtKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9sb2FkUXVldWVCYWNrdXAuc3BsaWNlKGksIDEpWzBdLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHIpIHtcblx0XHRcdFx0XHR0aGlzLl9kaXNwb3NlSXRlbSh0aGlzLmdldEl0ZW0oaXRlbSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSB0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRcdHZhciBsb2FkSXRlbSA9IHRoaXMuX2N1cnJlbnRMb2Fkc1tpXS5nZXRJdGVtKCk7XG5cdFx0XHRcdFx0XHRpZiAobG9hZEl0ZW0uaWQgPT0gaXRlbSB8fCBsb2FkSXRlbS5zcmMgPT0gaXRlbSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9jdXJyZW50TG9hZHMuc3BsaWNlKGksIDEpWzBdLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0XHRpdGVtc1dlcmVSZW1vdmVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGNhbGxlZCBkdXJpbmcgYSBsb2FkLCB0cnkgdG8gbG9hZCB0aGUgbmV4dCBpdGVtLlxuXHRcdFx0aWYgKGl0ZW1zV2VyZVJlbW92ZWQpIHtcblx0XHRcdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3BzIGFsbCBvcGVuIGxvYWRzLCBkZXN0cm95cyBhbnkgbG9hZGVkIGl0ZW1zLCBhbmQgcmVzZXRzIHRoZSBxdWV1ZSwgc28gYWxsIGl0ZW1zIGNhblxuXHQgKiBiZSByZWxvYWRlZCBhZ2FpbiBieSBjYWxsaW5nIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2xvYWRcIn19e3svY3Jvc3NMaW5rfX0uIEl0ZW1zIGFyZSBub3QgcmVtb3ZlZCBmcm9tIHRoZVxuXHQgKiBxdWV1ZS4gVG8gcmVtb3ZlIGl0ZW1zIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcmVtb3ZlQWxsXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogQG1ldGhvZCByZXNldFxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cdHAucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5jbG9zZSgpO1xuXHRcdGZvciAodmFyIG4gaW4gdGhpcy5fbG9hZEl0ZW1zQnlJZCkge1xuXHRcdFx0dGhpcy5fZGlzcG9zZUl0ZW0odGhpcy5fbG9hZEl0ZW1zQnlJZFtuXSk7XG5cdFx0fVxuXG5cdFx0Ly9SZXNldCB0aGUgcXVldWUgdG8gaXRzIHN0YXJ0IHN0YXRlXG5cdFx0dmFyIGEgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2xvYWRRdWV1ZUJhY2t1cC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGEucHVzaCh0aGlzLl9sb2FkUXVldWVCYWNrdXBbaV0uZ2V0SXRlbSgpKTtcblx0XHR9XG5cblx0XHR0aGlzLmxvYWRNYW5pZmVzdChhLCBmYWxzZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGEgcGx1Z2luLiBQbHVnaW5zIGNhbiBtYXAgdG8gbG9hZCB0eXBlcyAoc291bmQsIGltYWdlLCBldGMpLCBvciBzcGVjaWZpYyBleHRlbnNpb25zIChwbmcsIG1wMywgZXRjKS5cblx0ICogQ3VycmVudGx5LCBvbmx5IG9uZSBwbHVnaW4gY2FuIGV4aXN0IHBlciB0eXBlL2V4dGVuc2lvbi5cblx0ICpcblx0ICogV2hlbiBhIHBsdWdpbiBpcyBpbnN0YWxsZWQsIGEgPGNvZGU+Z2V0UHJlbG9hZEhhbmRsZXJzKCk8L2NvZGU+IG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBvbiBpdC4gRm9yIG1vcmUgaW5mb3JtYXRpb25cblx0ICogb24gdGhpcyBtZXRob2QsIGNoZWNrIG91dCB0aGUge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL2dldFByZWxvYWRIYW5kbGVyc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgaW4gdGhlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpblwifX17ey9jcm9zc0xpbmt9fSBjbGFzcy5cblx0ICpcblx0ICogQmVmb3JlIGEgZmlsZSBpcyBsb2FkZWQsIGEgbWF0Y2hpbmcgcGx1Z2luIGhhcyBhbiBvcHBvcnR1bml0eSB0byBtb2RpZnkgdGhlIGxvYWQuIElmIGEgYGNhbGxiYWNrYCBpcyByZXR1cm5lZFxuXHQgKiBmcm9tIHRoZSB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW4vZ2V0UHJlbG9hZEhhbmRsZXJzXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCwgaXQgd2lsbCBiZSBpbnZva2VkIGZpcnN0LCBhbmQgaXRzXG5cdCAqIHJlc3VsdCBtYXkgY2FuY2VsIG9yIG1vZGlmeSB0aGUgaXRlbS4gVGhlIGNhbGxiYWNrIG1ldGhvZCBjYW4gYWxzbyByZXR1cm4gYSBgY29tcGxldGVIYW5kbGVyYCB0byBiZSBmaXJlZCB3aGVuXG5cdCAqIHRoZSBmaWxlIGlzIGxvYWRlZCwgb3IgYSBgdGFnYCBvYmplY3QsIHdoaWNoIHdpbGwgbWFuYWdlIHRoZSBhY3R1YWwgZG93bmxvYWQuIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlXG5cdCAqIG1ldGhvZHMsIGNoZWNrIG91dCB0aGUge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL3ByZWxvYWRIYW5kbGVyXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW4vZmlsZUxvYWRIYW5kbGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZHMgb24gdGhlIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogQG1ldGhvZCBpbnN0YWxsUGx1Z2luXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHBsdWdpbiBUaGUgcGx1Z2luIGNsYXNzIHRvIGluc3RhbGwuXG5cdCAqL1xuXHRwLmluc3RhbGxQbHVnaW4gPSBmdW5jdGlvbiAocGx1Z2luKSB7XG5cdFx0aWYgKHBsdWdpbiA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHBsdWdpbi5nZXRQcmVsb2FkSGFuZGxlcnMgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcGx1Z2lucy5wdXNoKHBsdWdpbik7XG5cdFx0XHR2YXIgbWFwID0gcGx1Z2luLmdldFByZWxvYWRIYW5kbGVycygpO1xuXHRcdFx0bWFwLnNjb3BlID0gcGx1Z2luO1xuXG5cdFx0XHRpZiAobWFwLnR5cGVzICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBtYXAudHlwZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5fdHlwZUNhbGxiYWNrc1ttYXAudHlwZXNbaV1dID0gbWFwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXAuZXh0ZW5zaW9ucyAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAoaSA9IDAsIGwgPSBtYXAuZXh0ZW5zaW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLl9leHRlbnNpb25DYWxsYmFja3NbbWFwLmV4dGVuc2lvbnNbaV1dID0gbWFwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbmN1cnJlbnQgY29ubmVjdGlvbnMuIE5vdGUgdGhhdCBicm93c2VycyBhbmQgc2VydmVycyBtYXkgaGF2ZSBhIGJ1aWx0LWluIG1heGltdW1cblx0ICogbnVtYmVyIG9mIG9wZW4gY29ubmVjdGlvbnMsIHNvIGFueSBhZGRpdGlvbmFsIGNvbm5lY3Rpb25zIG1heSByZW1haW4gaW4gYSBwZW5kaW5nIHN0YXRlIHVudGlsIHRoZSBicm93c2VyXG5cdCAqIG9wZW5zIHRoZSBjb25uZWN0aW9uLiBXaGVuIGxvYWRpbmcgc2NyaXB0cyB1c2luZyB0YWdzLCBhbmQgd2hlbiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbWFpbnRhaW5TY3JpcHRPcmRlcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpcyBgdHJ1ZWAsIG9ubHkgb25lIHNjcmlwdCBpcyBsb2FkZWQgYXQgYSB0aW1lIGR1ZSB0byBicm93c2VyIGxpbWl0YXRpb25zLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIHF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSgpO1xuXHQgKiAgICAgIHF1ZXVlLnNldE1heENvbm5lY3Rpb25zKDEwKTsgLy8gQWxsb3cgMTAgY29uY3VycmVudCBsb2Fkc1xuXHQgKlxuXHQgKiBAbWV0aG9kIHNldE1heENvbm5lY3Rpb25zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgbG9hZHMgdG8gYWxsb3cuIEJ5IGRlZmF1bHQsIG9ubHkgYSBzaW5nbGUgY29ubmVjdGlvbiBwZXIgTG9hZFF1ZXVlXG5cdCAqIGlzIG9wZW4gYXQgYW55IHRpbWUuXG5cdCAqL1xuXHRwLnNldE1heENvbm5lY3Rpb25zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5fbWF4Q29ubmVjdGlvbnMgPSB2YWx1ZTtcblx0XHRpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl9sb2FkUXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIExvYWQgYSBzaW5nbGUgZmlsZS4gVG8gYWRkIG11bHRpcGxlIGZpbGVzIGF0IG9uY2UsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqXG5cdCAqIEZpbGVzIGFyZSBhbHdheXMgYXBwZW5kZWQgdG8gdGhlIGN1cnJlbnQgcXVldWUsIHNvIHRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIG11bHRpcGxlIHRpbWVzIHRvIGFkZCBmaWxlcy5cblx0ICogVG8gY2xlYXIgdGhlIHF1ZXVlIGZpcnN0LCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2Nsb3NlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogQG1ldGhvZCBsb2FkRmlsZVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdHxTdHJpbmd9IGZpbGUgVGhlIGZpbGUgb2JqZWN0IG9yIHBhdGggdG8gbG9hZC4gQSBmaWxlIGNhbiBiZSBlaXRoZXJcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPkEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2U8L2xpPlxuXHQgKiAgICAgPGxpPkFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgZGVmaW5lZCBieSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fTwvbGk+XG5cdCAqICAgICA8bGk+T1IgQSBzdHJpbmcgcGF0aCB0byBhIHJlc291cmNlLiBOb3RlIHRoYXQgdGhpcyBraW5kIG9mIGxvYWQgaXRlbSB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqICAgICBpbiB0aGUgYmFja2dyb3VuZC48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb2FkTm93PXRydWVdIEtpY2sgb2ZmIGFuIGltbWVkaWF0ZSBsb2FkICh0cnVlKSBvciB3YWl0IGZvciBhIGxvYWQgY2FsbCAoZmFsc2UpLiBUaGUgZGVmYXVsdFxuXHQgKiB2YWx1ZSBpcyB0cnVlLiBJZiB0aGUgcXVldWUgaXMgcGF1c2VkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRQYXVzZWRcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB0aGUgdmFsdWUgaXNcblx0ICogYHRydWVgLCB0aGUgcXVldWUgd2lsbCByZXN1bWUgYXV0b21hdGljYWxseS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aF0gQSBiYXNlIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIGZpbGUuIFRoZSBiYXNlUGF0aCBhcmd1bWVudCBvdmVycmlkZXMgdGhlXG5cdCAqIHBhdGggc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3Rvci4gTm90ZSB0aGF0IGlmIHlvdSBsb2FkIGEgbWFuaWZlc3QgdXNpbmcgYSBmaWxlIG9mIHR5cGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGl0cyBmaWxlcyB3aWxsIDxzdHJvbmc+Tk9UPC9zdHJvbmc+IHVzZSB0aGUgYmFzZVBhdGggcGFyYW1ldGVyLiA8c3Ryb25nPlRoZSBiYXNlUGF0aCBwYXJhbWV0ZXIgaXMgZGVwcmVjYXRlZC48L3N0cm9uZz5cblx0ICogVGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIFBsZWFzZSBlaXRoZXIgdXNlIHRoZSBgYmFzZVBhdGhgIHBhcmFtZXRlciBpbiB0aGUgTG9hZFF1ZXVlXG5cdCAqIGNvbnN0cnVjdG9yLCBvciBhIGBwYXRoYCBwcm9wZXJ0eSBpbiBhIG1hbmlmZXN0IGRlZmluaXRpb24uXG5cdCAqL1xuXHRwLmxvYWRGaWxlID0gZnVuY3Rpb24gKGZpbGUsIGxvYWROb3csIGJhc2VQYXRoKSB7XG5cdFx0aWYgKGZpbGUgPT0gbnVsbCkge1xuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX05PX0ZJTEVcIik7XG5cdFx0XHR0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9hZGRJdGVtKGZpbGUsIG51bGwsIGJhc2VQYXRoKTtcblxuXHRcdGlmIChsb2FkTm93ICE9PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQoZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFBhdXNlZCh0cnVlKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIExvYWQgYW4gYXJyYXkgb2YgZmlsZXMuIFRvIGxvYWQgYSBzaW5nbGUgZmlsZSwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBUaGUgZmlsZXMgaW4gdGhlIG1hbmlmZXN0IGFyZSByZXF1ZXN0ZWQgaW4gdGhlIHNhbWUgb3JkZXIsIGJ1dCBtYXkgY29tcGxldGUgaW4gYSBkaWZmZXJlbnQgb3JkZXIgaWYgdGhlIG1heFxuXHQgKiBjb25uZWN0aW9ucyBhcmUgc2V0IGFib3ZlIDEgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319LiBTY3JpcHRzIHdpbGwgbG9hZFxuXHQgKiBpbiB0aGUgcmlnaHQgb3JkZXIgYXMgbG9uZyBhcyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbWFpbnRhaW5TY3JpcHRPcmRlclwifX17ey9jcm9zc0xpbmt9fSBpcyB0cnVlICh3aGljaCBpc1xuXHQgKiBkZWZhdWx0KS5cblx0ICpcblx0ICogRmlsZXMgYXJlIGFsd2F5cyBhcHBlbmRlZCB0byB0aGUgY3VycmVudCBxdWV1ZSwgc28gdGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgbXVsdGlwbGUgdGltZXMgdG8gYWRkIGZpbGVzLlxuXHQgKiBUbyBjbGVhciB0aGUgcXVldWUgZmlyc3QsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY2xvc2VcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBAbWV0aG9kIGxvYWRNYW5pZmVzdFxuXHQgKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xPYmplY3R9IG1hbmlmZXN0IEFuIGxpc3Qgb2YgZmlsZXMgdG8gbG9hZC4gVGhlIGxvYWRNYW5pZmVzdCBjYWxsIHN1cHBvcnRzIGZvdXIgdHlwZXMgb2Zcblx0ICogbWFuaWZlc3RzOlxuXHQgKiA8b2w+XG5cdCAqICAgICA8bGk+QSBzdHJpbmcgcGF0aCwgd2hpY2ggcG9pbnRzIHRvIGEgbWFuaWZlc3QgZmlsZSwgd2hpY2ggaXMgYSBKU09OIGZpbGUgdGhhdCBjb250YWlucyBhIFwibWFuaWZlc3RcIiBwcm9wZXJ0eSxcblx0ICogICAgIHdoaWNoIGRlZmluZXMgdGhlIGxpc3Qgb2YgZmlsZXMgdG8gbG9hZCwgYW5kIGNhbiBvcHRpb25hbGx5IGNvbnRhaW4gYSBcInBhdGhcIiBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBiZVxuXHQgKiAgICAgcHJlcGVuZGVkIHRvIGVhY2ggZmlsZSBpbiB0aGUgbGlzdC48L2xpPlxuXHQgKiAgICAgPGxpPkFuIG9iamVjdCB3aGljaCBkZWZpbmVzIGEgXCJzcmNcIiwgd2hpY2ggaXMgYSBKU09OIG9yIEpTT05QIGZpbGUuIEEgXCJjYWxsYmFja1wiIGNhbiBiZSBkZWZpbmVkIGZvciBKU09OUFxuXHQgKiAgICAgZmlsZS4gVGhlIEpTT04vSlNPTlAgZmlsZSBzaG91bGQgY29udGFpbiBhIFwibWFuaWZlc3RcIiBwcm9wZXJ0eSwgd2hpY2ggZGVmaW5lcyB0aGUgbGlzdCBvZiBmaWxlcyB0byBsb2FkLFxuXHQgKiAgICAgYW5kIGNhbiBvcHRpb25hbGx5IGNvbnRhaW4gYSBcInBhdGhcIiBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBiZSBwcmVwZW5kZWQgdG8gZWFjaCBmaWxlIGluIHRoZSBsaXN0LjwvbGk+XG5cdCAqICAgICA8bGk+QW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGEgXCJtYW5pZmVzdFwiIHByb3BlcnR5LCB3aGljaCBkZWZpbmVzIHRoZSBsaXN0IG9mIGZpbGVzIHRvIGxvYWQsIGFuZCBjYW5cblx0ICogICAgIG9wdGlvbmFsbHkgY29udGFpbiBhIFwicGF0aFwiIHByb3BlcnR5LCB3aGljaCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIGZpbGUgaW4gdGhlIGxpc3QuPC9saT5cblx0ICogICAgIDxsaT5BbiBBcnJheSBvZiBmaWxlcyB0byBsb2FkLjwvbGk+XG5cdCAqIDwvb2w+XG5cdCAqXG5cdCAqIEVhY2ggXCJmaWxlXCIgaW4gYSBtYW5pZmVzdCBjYW4gYmUgZWl0aGVyOlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+QSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZTwvbGk+XG5cdCAqICAgICA8bGk+QW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBkZWZpbmVkIGJ5IHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319PC9saT5cblx0ICogICAgIDxsaT5PUiBBIHN0cmluZyBwYXRoIHRvIGEgcmVzb3VyY2UuIE5vdGUgdGhhdCB0aGlzIGtpbmQgb2YgbG9hZCBpdGVtIHdpbGwgYmUgY29udmVydGVkIHRvIGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogICAgIGluIHRoZSBiYWNrZ3JvdW5kLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2xvYWROb3c9dHJ1ZV0gS2ljayBvZmYgYW4gaW1tZWRpYXRlIGxvYWQgKHRydWUpIG9yIHdhaXQgZm9yIGEgbG9hZCBjYWxsIChmYWxzZSkuIFRoZSBkZWZhdWx0XG5cdCAqIHZhbHVlIGlzIHRydWUuIElmIHRoZSBxdWV1ZSBpcyBwYXVzZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldFBhdXNlZFwifX17ey9jcm9zc0xpbmt9fSBhbmQgdGhpcyB2YWx1ZSBpc1xuXHQgKiBgdHJ1ZWAsIHRoZSBxdWV1ZSB3aWxsIHJlc3VtZSBhdXRvbWF0aWNhbGx5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2Jhc2VQYXRoXSBBIGJhc2UgcGF0aCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggZmlsZS4gVGhlIGJhc2VQYXRoIGFyZ3VtZW50IG92ZXJyaWRlcyB0aGVcblx0ICogcGF0aCBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLiBOb3RlIHRoYXQgaWYgeW91IGxvYWQgYSBtYW5pZmVzdCB1c2luZyBhIGZpbGUgb2YgdHlwZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGl0cyBmaWxlcyB3aWxsIDxzdHJvbmc+Tk9UPC9zdHJvbmc+IHVzZSB0aGUgYmFzZVBhdGggcGFyYW1ldGVyLiA8c3Ryb25nPlRoZSBiYXNlUGF0aCBwYXJhbWV0ZXIgaXMgZGVwcmVjYXRlZC48L3N0cm9uZz5cblx0ICogVGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIFBsZWFzZSBlaXRoZXIgdXNlIHRoZSBgYmFzZVBhdGhgIHBhcmFtZXRlciBpbiB0aGUgTG9hZFF1ZXVlXG5cdCAqIGNvbnN0cnVjdG9yLCBvciBhIGBwYXRoYCBwcm9wZXJ0eSBpbiBhIG1hbmlmZXN0IGRlZmluaXRpb24uXG5cdCAqL1xuXHRwLmxvYWRNYW5pZmVzdCA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgbG9hZE5vdywgYmFzZVBhdGgpIHtcblx0XHR2YXIgZmlsZUxpc3QgPSBudWxsO1xuXHRcdHZhciBwYXRoID0gbnVsbDtcblxuXHRcdC8vIEFycmF5LWJhc2VkIGxpc3Qgb2YgaXRlbXNcblx0XHRpZiAoQXJyYXkuaXNBcnJheShtYW5pZmVzdCkpIHtcblx0XHRcdGlmIChtYW5pZmVzdC5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfTUFOSUZFU1RfRU1QVFlcIik7XG5cdFx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGZpbGVMaXN0ID0gbWFuaWZlc3Q7XG5cblx0XHRcdC8vIFN0cmluZy1iYXNlZC4gT25seSBmaWxlIG1hbmlmZXN0cyBjYW4gYmUgc3BlY2lmaWVkIHRoaXMgd2F5LiBBbnkgb3RoZXIgdHlwZXMgd2lsbCBjYXVzZSBhbiBlcnJvciB3aGVuIGxvYWRlZC5cblx0XHR9IGVsc2UgaWYgKHR5cGVvZihtYW5pZmVzdCkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdGZpbGVMaXN0ID0gW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3JjOiBtYW5pZmVzdCxcblx0XHRcdFx0XHR0eXBlOiBzLk1BTklGRVNUXG5cdFx0XHRcdH1cblx0XHRcdF07XG5cblx0XHR9IGVsc2UgaWYgKHR5cGVvZihtYW5pZmVzdCkgPT0gXCJvYmplY3RcIikge1xuXG5cdFx0XHQvLyBBbiBvYmplY3QgdGhhdCBkZWZpbmVzIGEgbWFuaWZlc3QgcGF0aFxuXHRcdFx0aWYgKG1hbmlmZXN0LnNyYyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmIChtYW5pZmVzdC50eXBlID09IG51bGwpIHtcblx0XHRcdFx0XHRtYW5pZmVzdC50eXBlID0gcy5NQU5JRkVTVDtcblx0XHRcdFx0fSBlbHNlIGlmIChtYW5pZmVzdC50eXBlICE9IHMuTUFOSUZFU1QpIHtcblx0XHRcdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfTUFOSUZFU1RfVFlQRVwiKTtcblx0XHRcdFx0XHR0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZpbGVMaXN0ID0gW21hbmlmZXN0XTtcblxuXHRcdFx0XHQvLyBBbiBvYmplY3QgdGhhdCBkZWZpbmVzIGEgbWFuaWZlc3Rcblx0XHRcdH0gZWxzZSBpZiAobWFuaWZlc3QubWFuaWZlc3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRmaWxlTGlzdCA9IG1hbmlmZXN0Lm1hbmlmZXN0O1xuXHRcdFx0XHRwYXRoID0gbWFuaWZlc3QucGF0aDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVW5zdXBwb3J0ZWQuIFRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvci5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX01BTklGRVNUX05VTExcIik7XG5cdFx0XHR0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gZmlsZUxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR0aGlzLl9hZGRJdGVtKGZpbGVMaXN0W2ldLCBwYXRoLCBiYXNlUGF0aCk7XG5cdFx0fVxuXG5cdFx0aWYgKGxvYWROb3cgIT09IGZhbHNlKSB7XG5cdFx0XHR0aGlzLnNldFBhdXNlZChmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0UGF1c2VkKHRydWUpO1xuXHRcdH1cblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFydCBhIExvYWRRdWV1ZSB0aGF0IHdhcyBjcmVhdGVkLCBidXQgbm90IGF1dG9tYXRpY2FsbHkgc3RhcnRlZC5cblx0ICogQG1ldGhvZCBsb2FkXG5cdCAqL1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zZXRQYXVzZWQoZmFsc2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBMb29rIHVwIGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0gdXNpbmcgZWl0aGVyIHRoZSBcImlkXCIgb3IgXCJzcmNcIiB0aGF0IHdhcyBzcGVjaWZpZWQgd2hlbiBsb2FkaW5nIGl0LiBOb3RlIHRoYXQgaWYgbm8gXCJpZFwiIHdhc1xuXHQgKiBzdXBwbGllZCB3aXRoIHRoZSBsb2FkIGl0ZW0sIHRoZSBJRCB3aWxsIGJlIHRoZSBcInNyY1wiLCBpbmNsdWRpbmcgYSBgcGF0aGAgcHJvcGVydHkgZGVmaW5lZCBieSBhIG1hbmlmZXN0LiBUaGVcblx0ICogYGJhc2VQYXRoYCB3aWxsIG5vdCBiZSBwYXJ0IG9mIHRoZSBJRC5cblx0ICogQG1ldGhvZCBnZXRJdGVtXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgPGNvZGU+aWQ8L2NvZGU+IG9yIDxjb2RlPnNyYzwvY29kZT4gb2YgdGhlIGxvYWQgaXRlbS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgbG9hZCBpdGVtIHRoYXQgd2FzIGluaXRpYWxseSByZXF1ZXN0ZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9yIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0uIFRoaXMgb2JqZWN0IGlzIGFsc28gcmV0dXJuZWQgdmlhIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgYXMgdGhlIGBpdGVtYCBwYXJhbWV0ZXIuXG5cdCAqL1xuXHRwLmdldEl0ZW0gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZEl0ZW1zQnlJZFt2YWx1ZV0gfHwgdGhpcy5fbG9hZEl0ZW1zQnlTcmNbdmFsdWVdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBMb29rIHVwIGEgbG9hZGVkIHJlc3VsdCB1c2luZyBlaXRoZXIgdGhlIFwiaWRcIiBvciBcInNyY1wiIHRoYXQgd2FzIHNwZWNpZmllZCB3aGVuIGxvYWRpbmcgaXQuIE5vdGUgdGhhdCBpZiBubyBcImlkXCJcblx0ICogd2FzIHN1cHBsaWVkIHdpdGggdGhlIGxvYWQgaXRlbSwgdGhlIElEIHdpbGwgYmUgdGhlIFwic3JjXCIsIGluY2x1ZGluZyBhIGBwYXRoYCBwcm9wZXJ0eSBkZWZpbmVkIGJ5IGEgbWFuaWZlc3QuIFRoZVxuXHQgKiBgYmFzZVBhdGhgIHdpbGwgbm90IGJlIHBhcnQgb2YgdGhlIElELlxuXHQgKiBAbWV0aG9kIGdldFJlc3VsdFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIDxjb2RlPmlkPC9jb2RlPiBvciA8Y29kZT5zcmM8L2NvZGU+IG9mIHRoZSBsb2FkIGl0ZW0uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Jhd1Jlc3VsdD1mYWxzZV0gUmV0dXJuIGEgcmF3IHJlc3VsdCBpbnN0ZWFkIG9mIGEgZm9ybWF0dGVkIHJlc3VsdC4gVGhpcyBhcHBsaWVzIHRvIGNvbnRlbnRcblx0ICogbG9hZGVkIHZpYSBYSFIgc3VjaCBhcyBzY3JpcHRzLCBYTUwsIENTUywgYW5kIEltYWdlcy4gSWYgdGhlcmUgaXMgbm8gcmF3IHJlc3VsdCwgdGhlIGZvcm1hdHRlZCByZXN1bHQgd2lsbCBiZVxuXHQgKiByZXR1cm5lZCBpbnN0ZWFkLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgcmVzdWx0IG9iamVjdCBjb250YWluaW5nIHRoZSBjb250ZW50IHRoYXQgd2FzIGxvYWRlZCwgc3VjaCBhczpcblx0ICogPHVsPlxuXHQgKiAgICAgIDxsaT5BbiBpbWFnZSB0YWcgKCZsdDtpbWFnZSAvJmd0OykgZm9yIGltYWdlczwvbGk+XG5cdCAqICAgICAgPGxpPkEgc2NyaXB0IHRhZyBmb3IgSmF2YVNjcmlwdCAoJmx0O3NjcmlwdCAvJmd0OykuIE5vdGUgdGhhdCBzY3JpcHRzIGFyZSBhdXRvbWF0aWNhbGx5IGFkZGVkIHRvIHRoZSBIVE1MXG5cdCAqICAgICAgRE9NLjwvbGk+XG5cdCAqICAgICAgPGxpPkEgc3R5bGUgdGFnIGZvciBDU1MgKCZsdDtzdHlsZSAvJmd0OyBvciAmbHQ7bGluayAmZ3Q7KTwvbGk+XG5cdCAqICAgICAgPGxpPlJhdyB0ZXh0IGZvciBURVhUPC9saT5cblx0ICogICAgICA8bGk+QSBmb3JtYXR0ZWQgSmF2YVNjcmlwdCBvYmplY3QgZGVmaW5lZCBieSBKU09OPC9saT5cblx0ICogICAgICA8bGk+QW4gWE1MIGRvY3VtZW50PC9saT5cblx0ICogICAgICA8bGk+QSBiaW5hcnkgYXJyYXlidWZmZXIgbG9hZGVkIGJ5IFhIUjwvbGk+XG5cdCAqICAgICAgPGxpPkFuIGF1ZGlvIHRhZyAoJmx0O2F1ZGlvICZndDspIGZvciBIVE1MIGF1ZGlvLiBOb3RlIHRoYXQgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIFNvdW5kSlMgQVBJcyB0byBwbGF5XG5cdCAqICAgICAgbG9hZGVkIGF1ZGlvLiBTcGVjaWZpY2FsbHksIGF1ZGlvIGxvYWRlZCBieSBGbGFzaCBhbmQgV2ViQXVkaW8gd2lsbCByZXR1cm4gYSBsb2FkZXIgb2JqZWN0IHVzaW5nIHRoaXMgbWV0aG9kXG5cdCAqICAgICAgd2hpY2ggY2FuIG5vdCBiZSB1c2VkIHRvIHBsYXkgYXVkaW8gYmFjay48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBUaGlzIG9iamVjdCBpcyBhbHNvIHJldHVybmVkIHZpYSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGFzIHRoZSAnaXRlbWBcblx0ICogcGFyYW1ldGVyLiBOb3RlIHRoYXQgaWYgYSByYXcgcmVzdWx0IGlzIHJlcXVlc3RlZCwgYnV0IG5vdCBmb3VuZCwgdGhlIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQuXG5cdCAqL1xuXHRwLmdldFJlc3VsdCA9IGZ1bmN0aW9uICh2YWx1ZSwgcmF3UmVzdWx0KSB7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzLl9sb2FkSXRlbXNCeUlkW3ZhbHVlXSB8fCB0aGlzLl9sb2FkSXRlbXNCeVNyY1t2YWx1ZV07XG5cdFx0aWYgKGl0ZW0gPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHZhciBpZCA9IGl0ZW0uaWQ7XG5cdFx0aWYgKHJhd1Jlc3VsdCAmJiB0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2lkXSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaWRdO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbG9hZGVkUmVzdWx0c1tpZF07XG5cdH07XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGFuIGxpc3Qgb2YgaXRlbXMgbG9hZGVkIGJ5IHRoaXMgcXVldWUuXG5cdCAqIEBtZXRob2QgZ2V0SXRlbXNcblx0ICogQHBhcmFtIHtCb29sZWFufSBsb2FkZWQgRGV0ZXJtaW5lcyBpZiBvbmx5IGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIGxvYWRlZCBzaG91bGQgYmUgcmV0dXJuZWQuIElmIGZhbHNlLCBpbi1wcm9ncmVzc1xuXHQgKiBhbmQgZmFpbGVkIGxvYWQgaXRlbXMgd2lsbCBhbHNvIGJlIGluY2x1ZGVkLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbGlzdCBvZiBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGxvYWRlZC4gRWFjaCBpdGVtIGluY2x1ZGVzIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogcmVzdWx0LCBhbmQgcmF3UmVzdWx0LlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZ2V0SXRlbXMgPSBmdW5jdGlvbiAobG9hZGVkKSB7XG5cdFx0dmFyIGFyciA9IFtdO1xuXHRcdGZvciAodmFyIG4gaW4gdGhpcy5fbG9hZEl0ZW1zQnlJZCkge1xuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzLl9sb2FkSXRlbXNCeUlkW25dO1xuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMuZ2V0UmVzdWx0KG4pO1xuXHRcdFx0aWYgKGxvYWRlZCA9PT0gdHJ1ZSAmJiByZXN1bHQgPT0gbnVsbCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGFyci5wdXNoKHtcblx0XHRcdFx0aXRlbTogaXRlbSxcblx0XHRcdFx0cmVzdWx0OiByZXN1bHQsXG5cdFx0XHRcdHJhd1Jlc3VsdDogdGhpcy5nZXRSZXN1bHQobiwgdHJ1ZSlcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXVzZSBvciByZXN1bWUgdGhlIGN1cnJlbnQgbG9hZC4gQWN0aXZlIGxvYWRzIHdpbGwgbm90IGJlIGNhbmNlbGxlZCwgYnV0IHRoZSBuZXh0IGl0ZW1zIGluIHRoZSBxdWV1ZSB3aWxsIG5vdFxuXHQgKiBiZSBwcm9jZXNzZWQgd2hlbiBhY3RpdmUgbG9hZHMgY29tcGxldGUuIExvYWRRdWV1ZXMgYXJlIG5vdCBwYXVzZWQgYnkgZGVmYXVsdC5cblx0ICpcblx0ICogTm90ZSB0aGF0IGlmIG5ldyBpdGVtcyBhcmUgYWRkZWQgdG8gdGhlIHF1ZXVlIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fSBvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319LCBhIHBhdXNlZCBxdWV1ZSB3aWxsIGJlIHJlc3VtZWQsIHVubGVzcyB0aGUgYGxvYWROb3dgXG5cdCAqIGFyZ3VtZW50IGlzIGBmYWxzZWAuXG5cdCAqIEBtZXRob2Qgc2V0UGF1c2VkXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgV2hldGhlciB0aGUgcXVldWUgc2hvdWxkIGJlIHBhdXNlZCBvciBub3QuXG5cdCAqL1xuXHRwLnNldFBhdXNlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHRoaXMuX3BhdXNlZCA9IHZhbHVlO1xuXHRcdGlmICghdGhpcy5fcGF1c2VkKSB7XG5cdFx0XHR0aGlzLl9sb2FkTmV4dCgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2xvc2UgdGhlIGFjdGl2ZSBxdWV1ZS4gQ2xvc2luZyBhIHF1ZXVlIGNvbXBsZXRlbHkgZW1wdGllcyB0aGUgcXVldWUsIGFuZCBwcmV2ZW50cyBhbnkgcmVtYWluaW5nIGl0ZW1zIGZyb21cblx0ICogc3RhcnRpbmcgdG8gZG93bmxvYWQuIE5vdGUgdGhhdCBjdXJyZW50bHkgYW55IGFjdGl2ZSBsb2FkcyB3aWxsIHJlbWFpbiBvcGVuLCBhbmQgZXZlbnRzIG1heSBiZSBwcm9jZXNzZWQuXG5cdCAqXG5cdCAqIFRvIHN0b3AgYW5kIHJlc3RhcnQgYSBxdWV1ZSwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0UGF1c2VkXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGNsb3NlXG5cdCAqL1xuXHRwLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHRcdHdoaWxlICh0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLl9jdXJyZW50TG9hZHMucG9wKCkuY2FuY2VsKCk7XG5cdFx0fVxuXHRcdHRoaXMuX3NjcmlwdE9yZGVyLmxlbmd0aCA9IDA7XG5cdFx0dGhpcy5fbG9hZGVkU2NyaXB0cy5sZW5ndGggPSAwO1xuXHRcdHRoaXMubG9hZFN0YXJ0V2FzRGlzcGF0Y2hlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2l0ZW1Db3VudCA9IDA7XG5cdFx0dGhpcy5fbGFzdFByb2dyZXNzID0gTmFOO1xuXHR9O1xuXG4vLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogQWRkIGFuIGl0ZW0gdG8gdGhlIHF1ZXVlLiBJdGVtcyBhcmUgZm9ybWF0dGVkIGludG8gYSB1c2FibGUgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBwcm9wZXJ0aWVzIG5lY2Vzc2FyeSB0b1xuXHQgKiBsb2FkIHRoZSBjb250ZW50LiBUaGUgbG9hZCBxdWV1ZSBpcyBwb3B1bGF0ZWQgd2l0aCB0aGUgbG9hZGVyIGluc3RhbmNlIHRoYXQgaGFuZGxlcyBwcmVsb2FkaW5nLCBhbmQgbm90IHRoZSBsb2FkXG5cdCAqIGl0ZW0gdGhhdCB3YXMgcGFzc2VkIGluIGJ5IHRoZSB1c2VyLiBUbyBsb29rIHVwIHRoZSBsb2FkIGl0ZW0gYnkgaWQgb3Igc3JjLCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS5nZXRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICogQG1ldGhvZCBfYWRkSXRlbVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHZhbHVlIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgcXVldWUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF0gQW4gb3B0aW9uYWwgcGF0aCBwcmVwZW5kZWQgdG8gdGhlIGBzcmNgLiBUaGUgcGF0aCB3aWxsIG9ubHkgYmUgcHJlcGVuZGVkIGlmIHRoZSBzcmMgaXNcblx0ICogcmVsYXRpdmUsIGFuZCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgcHJvdG9jb2wgc3VjaCBhcyBgaHR0cDovL2AsIG9yIGEgcGF0aCBsaWtlIGAuLi9gLiBJZiB0aGUgTG9hZFF1ZXVlIHdhc1xuXHQgKiBwcm92aWRlZCBhIHt7I2Nyb3NzTGluayBcIl9iYXNlUGF0aFwifX17ey9jcm9zc0xpbmt9fSwgdGhlbiBpdCB3aWxsIG9wdGlvbmFsbHkgYmUgcHJlcGVuZGVkIGFmdGVyLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2Jhc2VQYXRoXSA8c3Ryb25nPkRlcHJlY2F0ZWQ8L3N0cm9uZz5BbiBvcHRpb25hbCBiYXNlUGF0aCBwYXNzZWQgaW50byBhIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319IGNhbGwuIFRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB0YWdnZWRcblx0ICogdmVyc2lvbi5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2FkZEl0ZW0gPSBmdW5jdGlvbiAodmFsdWUsIHBhdGgsIGJhc2VQYXRoKSB7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzLl9jcmVhdGVMb2FkSXRlbSh2YWx1ZSwgcGF0aCwgYmFzZVBhdGgpOyAvLyBiYXNlUGF0aCBhbmQgbWFuaWZlc3QgcGF0aCBhcmUgYWRkZWQgdG8gdGhlIHNyYy5cblx0XHRpZiAoaXRlbSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvLyBTb21ldGltZXMgcGx1Z2lucyBvciB0eXBlcyBzaG91bGQgYmUgc2tpcHBlZC5cblx0XHR2YXIgbG9hZGVyID0gdGhpcy5fY3JlYXRlTG9hZGVyKGl0ZW0pO1xuXHRcdGlmIChsb2FkZXIgIT0gbnVsbCkge1xuXHRcdFx0aWYgKFwicGx1Z2luc1wiIGluIGxvYWRlcikge1xuXHRcdFx0XHRsb2FkZXIucGx1Z2lucyA9IHRoaXMuX3BsdWdpbnM7XG5cdFx0XHR9XG5cdFx0XHRpdGVtLl9sb2FkZXIgPSBsb2FkZXI7XG5cdFx0XHR0aGlzLl9sb2FkUXVldWUucHVzaChsb2FkZXIpO1xuXHRcdFx0dGhpcy5fbG9hZFF1ZXVlQmFja3VwLnB1c2gobG9hZGVyKTtcblxuXHRcdFx0dGhpcy5fbnVtSXRlbXMrKztcblx0XHRcdHRoaXMuX3VwZGF0ZVByb2dyZXNzKCk7XG5cblx0XHRcdC8vIE9ubHkgd29ycnkgYWJvdXQgc2NyaXB0IG9yZGVyIHdoZW4gdXNpbmcgWEhSIHRvIGxvYWQgc2NyaXB0cy4gVGFncyBhcmUgb25seSBsb2FkaW5nIG9uZSBhdCBhIHRpbWUuXG5cdFx0XHRpZiAoKHRoaXMubWFpbnRhaW5TY3JpcHRPcmRlclxuXHRcdFx0XHRcdCYmIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5Mb2FkUXVldWUuSkFWQVNDUklQVFxuXHRcdFx0XHRcdFx0Ly8mJiBsb2FkZXIgaW5zdGFuY2VvZiBjcmVhdGVqcy5YSFJMb2FkZXIgLy9OT1RFOiBIYXZlIHRvIHRyYWNrIGFsbCBKUyBmaWxlcyB0aGlzIHdheVxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHR8fCBpdGVtLm1haW50YWluT3JkZXIgPT09IHRydWUpIHtcblx0XHRcdFx0dGhpcy5fc2NyaXB0T3JkZXIucHVzaChpdGVtKTtcblx0XHRcdFx0dGhpcy5fbG9hZGVkU2NyaXB0cy5wdXNoKG51bGwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgcmVmaW5lZCB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSwgd2hpY2ggY29udGFpbnMgYWxsIHRoZSByZXF1aXJlZCBwcm9wZXJ0aWVzLiBUaGUgdHlwZSBvZlxuXHQgKiBpdGVtIGlzIGRldGVybWluZWQgYnkgYnJvd3NlciBzdXBwb3J0LCByZXF1aXJlbWVudHMgYmFzZWQgb24gdGhlIGZpbGUgdHlwZSwgYW5kIGRldmVsb3BlciBzZXR0aW5ncy4gRm9yIGV4YW1wbGUsXG5cdCAqIFhIUiBpcyBvbmx5IHVzZWQgZm9yIGZpbGUgdHlwZXMgdGhhdCBzdXBwb3J0IGl0IGluIG5ldyBicm93c2Vycy5cblx0ICpcblx0ICogQmVmb3JlIHRoZSBpdGVtIGlzIHJldHVybmVkLCBhbnkgcGx1Z2lucyByZWdpc3RlcmVkIHRvIGhhbmRsZSB0aGUgdHlwZSBvciBleHRlbnNpb24gd2lsbCBiZSBmaXJlZCwgd2hpY2ggbWF5XG5cdCAqIGFsdGVyIHRoZSBsb2FkIGl0ZW0uXG5cdCAqIEBtZXRob2QgX2NyZWF0ZUxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgT2JqZWN0IHwgSFRNTEF1ZGlvRWxlbWVudCB8IEhUTUxJbWFnZUVsZW1lbnR9IHZhbHVlIFRoZSBpdGVtIHRoYXQgbmVlZHMgdG8gYmUgcHJlbG9hZGVkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdIEEgcGF0aCB0byBwcmVwZW5kIHRvIHRoZSBpdGVtJ3Mgc291cmNlLiBTb3VyY2VzIGJlZ2lubmluZyB3aXRoIGh0dHA6Ly8gb3Igc2ltaWxhciB3aWxsXG5cdCAqIG5vdCByZWNlaXZlIGEgcGF0aC4gU2luY2UgUHJlbG9hZEpTIDAuNC4xLCB0aGUgc3JjIHdpbGwgYmUgbW9kaWZpZWQgdG8gaW5jbHVkZSB0aGUgYHBhdGhgIGFuZCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvX2Jhc2VQYXRoOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdoZW4gaXQgaXMgYWRkZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGhdIDxzdHJvbmc+RGVwcmVjdGF0ZWQ8L3N0cm9uZz4gQSBiYXNlIHBhdGggdG8gcHJlcGVuZCB0byB0aGUgaXRlbXMgc291cmNlIGluIGFkZGl0aW9uIHRvXG5cdCAqIHRoZSBwYXRoIGFyZ3VtZW50LlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBsb2FkZXIgaW5zdGFuY2UgdGhhdCB3aWxsIGJlIHVzZWQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jcmVhdGVMb2FkSXRlbSA9IGZ1bmN0aW9uICh2YWx1ZSwgcGF0aCwgYmFzZVBhdGgpIHtcblx0XHR2YXIgaXRlbSA9IGNyZWF0ZWpzLkxvYWRJdGVtLmNyZWF0ZSh2YWx1ZSk7XG5cdFx0aWYgKGl0ZW0gPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIGJwID0gXCJcIjsgLy8gU3RvcmUgdGhlIGdlbmVyYXRlZCBiYXNlUGF0aFxuXHRcdHZhciB1c2VCYXNlUGF0aCA9IGJhc2VQYXRoIHx8IHRoaXMuX2Jhc2VQYXRoO1xuXG5cdFx0aWYgKGl0ZW0uc3JjIGluc3RhbmNlb2YgT2JqZWN0KSB7XG5cdFx0XHRpZiAoIWl0ZW0udHlwZSkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gLy8gdGhlIHRoZSBzcmMgaXMgYW4gb2JqZWN0LCB0eXBlIGlzIHJlcXVpcmVkIHRvIHBhc3Mgb2ZmIHRvIHBsdWdpblxuXHRcdFx0aWYgKHBhdGgpIHtcblx0XHRcdFx0YnAgPSBwYXRoO1xuXHRcdFx0XHR2YXIgcGF0aE1hdGNoID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLnBhcnNlVVJJKHBhdGgpO1xuXHRcdFx0XHQvLyBBbHNvIGFwcGVuZCBiYXNlUGF0aFxuXHRcdFx0XHRpZiAodXNlQmFzZVBhdGggIT0gbnVsbCAmJiAhcGF0aE1hdGNoLmFic29sdXRlICYmICFwYXRoTWF0Y2gucmVsYXRpdmUpIHtcblx0XHRcdFx0XHRicCA9IHVzZUJhc2VQYXRoICsgYnA7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodXNlQmFzZVBhdGggIT0gbnVsbCkge1xuXHRcdFx0XHRicCA9IHVzZUJhc2VQYXRoO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBEZXRlcm1pbmUgRXh0ZW5zaW9uLCBldGMuXG5cdFx0XHR2YXIgbWF0Y2ggPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMucGFyc2VVUkkoaXRlbS5zcmMpO1xuXHRcdFx0aWYgKG1hdGNoLmV4dGVuc2lvbikge1xuXHRcdFx0XHRpdGVtLmV4dCA9IG1hdGNoLmV4dGVuc2lvbjtcblx0XHRcdH1cblx0XHRcdGlmIChpdGVtLnR5cGUgPT0gbnVsbCkge1xuXHRcdFx0XHRpdGVtLnR5cGUgPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuZ2V0VHlwZUJ5RXh0ZW5zaW9uKGl0ZW0uZXh0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5qZWN0IHBhdGggJiBiYXNlUGF0aFxuXHRcdFx0dmFyIGF1dG9JZCA9IGl0ZW0uc3JjO1xuXHRcdFx0aWYgKCFtYXRjaC5hYnNvbHV0ZSAmJiAhbWF0Y2gucmVsYXRpdmUpIHtcblx0XHRcdFx0aWYgKHBhdGgpIHtcblx0XHRcdFx0XHRicCA9IHBhdGg7XG5cdFx0XHRcdFx0dmFyIHBhdGhNYXRjaCA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5wYXJzZVVSSShwYXRoKTtcblx0XHRcdFx0XHRhdXRvSWQgPSBwYXRoICsgYXV0b0lkO1xuXHRcdFx0XHRcdC8vIEFsc28gYXBwZW5kIGJhc2VQYXRoXG5cdFx0XHRcdFx0aWYgKHVzZUJhc2VQYXRoICE9IG51bGwgJiYgIXBhdGhNYXRjaC5hYnNvbHV0ZSAmJiAhcGF0aE1hdGNoLnJlbGF0aXZlKSB7XG5cdFx0XHRcdFx0XHRicCA9IHVzZUJhc2VQYXRoICsgYnA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHVzZUJhc2VQYXRoICE9IG51bGwpIHtcblx0XHRcdFx0XHRicCA9IHVzZUJhc2VQYXRoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpdGVtLnNyYyA9IGJwICsgaXRlbS5zcmM7XG5cdFx0fVxuXHRcdGl0ZW0ucGF0aCA9IGJwO1xuXG5cdFx0Ly8gSWYgdGhlcmUncyBubyBpZCwgc2V0IG9uZSBub3cuXG5cdFx0aWYgKGl0ZW0uaWQgPT09IHVuZGVmaW5lZCB8fCBpdGVtLmlkID09PSBudWxsIHx8IGl0ZW0uaWQgPT09IFwiXCIpIHtcblx0XHRcdGl0ZW0uaWQgPSBhdXRvSWQ7XG5cdFx0fVxuXG5cdFx0Ly8gR2l2ZSBwbHVnaW5zIGEgY2hhbmNlIHRvIG1vZGlmeSB0aGUgbG9hZEl0ZW06XG5cdFx0dmFyIGN1c3RvbUhhbmRsZXIgPSB0aGlzLl90eXBlQ2FsbGJhY2tzW2l0ZW0udHlwZV0gfHwgdGhpcy5fZXh0ZW5zaW9uQ2FsbGJhY2tzW2l0ZW0uZXh0XTtcblx0XHRpZiAoY3VzdG9tSGFuZGxlcikge1xuXHRcdFx0Ly8gUGx1Z2lucyBhcmUgbm93IHBhc3NlZCBib3RoIHRoZSBmdWxsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIGNvbWJpbmVkIHBhdGgrYmFzZVBhdGggKGFwcHJvcHJpYXRlbHkpXG5cdFx0XHR2YXIgcmVzdWx0ID0gY3VzdG9tSGFuZGxlci5jYWxsYmFjay5jYWxsKGN1c3RvbUhhbmRsZXIuc2NvcGUsIGl0ZW0sIHRoaXMpO1xuXG5cdFx0XHQvLyBUaGUgcGx1Z2luIHdpbGwgaGFuZGxlIHRoZSBsb2FkLCBvciBoYXMgY2FuY2VsZWQgaXQuIElnbm9yZSBpdC5cblx0XHRcdGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdC8vIExvYWQgYXMgbm9ybWFsOlxuXHRcdFx0fSBlbHNlIGlmIChyZXN1bHQgPT09IHRydWUpIHtcblx0XHRcdFx0Ly8gRG8gTm90aGluZ1xuXG5cdFx0XHRcdC8vIFJlc3VsdCBpcyBhIGxvYWRlciBjbGFzczpcblx0XHRcdH0gZWxzZSBpZiAocmVzdWx0ICE9IG51bGwpIHtcblx0XHRcdFx0aXRlbS5fbG9hZGVyID0gcmVzdWx0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgdGhlIGV4dGVuc2lvbiBpbiBjYXNlIHRoZSB0eXBlIGNoYW5nZWQ6XG5cdFx0XHRtYXRjaCA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5wYXJzZVVSSShpdGVtLnNyYyk7XG5cdFx0XHRpZiAobWF0Y2guZXh0ZW5zaW9uICE9IG51bGwpIHtcblx0XHRcdFx0aXRlbS5leHQgPSBtYXRjaC5leHRlbnNpb247XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgdGhlIGl0ZW0gZm9yIGxvb2t1cC4gVGhpcyBhbHNvIGhlbHBzIGNsZWFuLXVwIGxhdGVyLlxuXHRcdHRoaXMuX2xvYWRJdGVtc0J5SWRbaXRlbS5pZF0gPSBpdGVtO1xuXHRcdHRoaXMuX2xvYWRJdGVtc0J5U3JjW2l0ZW0uc3JjXSA9IGl0ZW07XG5cblx0XHRpZiAoaXRlbS5jcm9zc09yaWdpbiA9PSBudWxsKSB7XG5cdFx0XHRpdGVtLmNyb3NzT3JpZ2luID0gdGhpcy5fY3Jvc3NPcmlnaW47XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGl0ZW07XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGxvYWRlciBmb3IgYSBsb2FkIGl0ZW0uXG5cdCAqIEBtZXRob2QgX2NyZWF0ZUxvYWRlclxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBBIGZvcm1hdHRlZCBsb2FkIGl0ZW0gdGhhdCBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSBhIGxvYWRlci5cblx0ICogQHJldHVybiB7QWJzdHJhY3RMb2FkZXJ9IEEgbG9hZGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gbG9hZCBjb250ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY3JlYXRlTG9hZGVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRpZiAoaXRlbS5fbG9hZGVyICE9IG51bGwpIHsgLy8gQSBwbHVnaW4gYWxyZWFkeSBzcGVjaWZpZWQgYSBsb2FkZXJcblx0XHRcdHJldHVybiBpdGVtLl9sb2FkZXI7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdGlhbGx5LCB0cnkgYW5kIHVzZSB0aGUgcHJvdmlkZWQvc3VwcG9ydGVkIFhIUiBtb2RlOlxuXHRcdHZhciBwcmVmZXJYSFIgPSB0aGlzLnByZWZlclhIUjtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYXZhaWxhYmxlTG9hZGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGxvYWRlciA9IHRoaXMuX2F2YWlsYWJsZUxvYWRlcnNbaV07XG5cdFx0XHRpZiAobG9hZGVyICYmIGxvYWRlci5jYW5Mb2FkSXRlbShpdGVtKSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IGxvYWRlcihpdGVtLCBwcmVmZXJYSFIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFRPRE86IExvZyBlcnJvciAocmVxdWlyZXMgY3JlYXRlanMubG9nKVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBMb2FkIHRoZSBuZXh0IGl0ZW0gaW4gdGhlIHF1ZXVlLiBJZiB0aGUgcXVldWUgaXMgZW1wdHkgKGFsbCBpdGVtcyBoYXZlIGJlZW4gbG9hZGVkKSwgdGhlbiB0aGUgY29tcGxldGUgZXZlbnRcblx0ICogaXMgcHJvY2Vzc2VkLiBUaGUgcXVldWUgd2lsbCBcImZpbGwgdXBcIiBhbnkgZW1wdHkgc2xvdHMsIHVwIHRvIHRoZSBtYXggY29ubmVjdGlvbiBzcGVjaWZpZWQgdXNpbmdcblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlLnNldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC4gVGhlIG9ubHkgZXhjZXB0aW9uIGlzIHNjcmlwdHMgdGhhdCBhcmUgbG9hZGVkXG5cdCAqIHVzaW5nIHRhZ3MsIHdoaWNoIGhhdmUgdG8gYmUgbG9hZGVkIG9uZSBhdCBhIHRpbWUgdG8gbWFpbnRhaW4gbG9hZCBvcmRlci5cblx0ICogQG1ldGhvZCBfbG9hZE5leHRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2xvYWROZXh0ID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9wYXVzZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmx5IGRpc3BhdGNoIGxvYWRzdGFydCBldmVudCB3aGVuIHRoZSBmaXJzdCBmaWxlIGlzIGxvYWRlZC5cblx0XHRpZiAoIXRoaXMuX2xvYWRTdGFydFdhc0Rpc3BhdGNoZWQpIHtcblx0XHRcdHRoaXMuX3NlbmRMb2FkU3RhcnQoKTtcblx0XHRcdHRoaXMuX2xvYWRTdGFydFdhc0Rpc3BhdGNoZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBxdWV1ZSBoYXMgY29tcGxldGVkLlxuXHRcdGlmICh0aGlzLl9udW1JdGVtcyA9PSB0aGlzLl9udW1JdGVtc0xvYWRlZCkge1xuXHRcdFx0dGhpcy5sb2FkZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cblx0XHRcdC8vIExvYWQgdGhlIG5leHQgcXVldWUsIGlmIGl0IGhhcyBiZWVuIGRlZmluZWQuXG5cdFx0XHRpZiAodGhpcy5uZXh0ICYmIHRoaXMubmV4dC5sb2FkKSB7XG5cdFx0XHRcdHRoaXMubmV4dC5sb2FkKCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubG9hZGVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gTXVzdCBpdGVyYXRlIGZvcndhcmRzIHRvIGxvYWQgaW4gdGhlIHJpZ2h0IG9yZGVyLlxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbG9hZFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5fY3VycmVudExvYWRzLmxlbmd0aCA+PSB0aGlzLl9tYXhDb25uZWN0aW9ucykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHZhciBsb2FkZXIgPSB0aGlzLl9sb2FkUXVldWVbaV07XG5cblx0XHRcdC8vIERldGVybWluZSBpZiB3ZSBzaG91bGQgYmUgb25seSBsb2FkaW5nIG9uZSB0YWctc2NyaXB0IGF0IGEgdGltZTpcblx0XHRcdC8vIE5vdGU6IG1haW50YWluT3JkZXIgaXRlbXMgZG9uJ3QgZG8gYW55dGhpbmcgaGVyZSBiZWNhdXNlIHdlIGNhbiBob2xkIG9udG8gdGhlaXIgbG9hZGVkIHZhbHVlXG5cdFx0XHRpZiAoIXRoaXMuX2NhblN0YXJ0TG9hZChsb2FkZXIpKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fbG9hZFF1ZXVlLnNwbGljZShpLCAxKTtcblx0XHRcdGktLTtcblx0XHRcdHRoaXMuX2xvYWRJdGVtKGxvYWRlcik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbiBsb2FkaW5nIGFuIGl0ZW0uIEV2ZW50IGxpc3RlbmVycyBhcmUgbm90IGFkZGVkIHRvIHRoZSBsb2FkZXJzIHVudGlsIHRoZSBsb2FkIHN0YXJ0cy5cblx0ICogQG1ldGhvZCBfbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyIFRoZSBsb2FkZXIgaW5zdGFuY2UgdG8gc3RhcnQuIEN1cnJlbnRseSwgdGhpcyB3aWxsIGJlIGFuIFhIUkxvYWRlciBvciBUYWdMb2FkZXIuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9sb2FkSXRlbSA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHRsb2FkZXIub24oXCJmaWxlbG9hZFwiLCB0aGlzLl9oYW5kbGVGaWxlTG9hZCwgdGhpcyk7XG5cdFx0bG9hZGVyLm9uKFwicHJvZ3Jlc3NcIiwgdGhpcy5faGFuZGxlUHJvZ3Jlc3MsIHRoaXMpO1xuXHRcdGxvYWRlci5vbihcImNvbXBsZXRlXCIsIHRoaXMuX2hhbmRsZUZpbGVDb21wbGV0ZSwgdGhpcyk7XG5cdFx0bG9hZGVyLm9uKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlRXJyb3IsIHRoaXMpO1xuXHRcdGxvYWRlci5vbihcImZpbGVlcnJvclwiLCB0aGlzLl9oYW5kbGVGaWxlRXJyb3IsIHRoaXMpO1xuXHRcdHRoaXMuX2N1cnJlbnRMb2Fkcy5wdXNoKGxvYWRlcik7XG5cdFx0dGhpcy5fc2VuZEZpbGVTdGFydChsb2FkZXIuZ2V0SXRlbSgpKTtcblx0XHRsb2FkZXIubG9hZCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgY2FsbGJhY2sgdGhhdCBpcyBmaXJlZCB3aGVuIGEgbG9hZGVyIGxvYWRzIGEgZmlsZS4gVGhpcyBlbmFibGVzIGxvYWRlcnMgbGlrZSB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB0byBtYWludGFpbiBpbnRlcm5hbCBxdWV1ZXMsIGJ1dCBmb3IgdGhpcyBxdWV1ZSB0byBkaXNwYXRjaCB0aGUge3sjY3Jvc3NMaW5rIFwiZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnRzLlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgZnJvbSB0aGUgbG9hZGVyLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX2hhbmRsZUZpbGVMb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQudGFyZ2V0ID0gbnVsbDtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgY2FsbGJhY2sgdGhhdCBpcyBmaXJlZCB3aGVuIGEgbG9hZGVyIGVuY291bnRlcnMgYW4gZXJyb3IgZnJvbSBhbiBpbnRlcm5hbCBmaWxlIGxvYWQgb3BlcmF0aW9uLiBUaGlzIGVuYWJsZXNcblx0ICogbG9hZGVycyBsaWtlIE1cblx0ICogQHBhcmFtIGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVGaWxlRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgbmV3RXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIkZJTEVfTE9BRF9FUlJPUlwiLCBudWxsLCBldmVudC5pdGVtKTtcblx0XHR0aGlzLl9zZW5kRXJyb3IobmV3RXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgY2FsbGJhY2sgdGhhdCBpcyBmaXJlZCB3aGVuIGEgbG9hZGVyIGVuY291bnRlcnMgYW4gZXJyb3IuIFRoZSBxdWV1ZSB3aWxsIGNvbnRpbnVlIGxvYWRpbmcgdW5sZXNzIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zdG9wT25FcnJvcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpcyBzZXQgdG8gYHRydWVgLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVFcnJvclxuXHQgKiBAcGFyYW0ge0Vycm9yRXZlbnR9IGV2ZW50IFRoZSBlcnJvciBldmVudCwgY29udGFpbmluZyByZWxldmFudCBlcnJvciBpbmZvcm1hdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIGxvYWRlciA9IGV2ZW50LnRhcmdldDtcblx0XHR0aGlzLl9udW1JdGVtc0xvYWRlZCsrO1xuXG5cdFx0dGhpcy5fZmluaXNoT3JkZXJlZEl0ZW0obG9hZGVyLCB0cnVlKTtcblx0XHR0aGlzLl91cGRhdGVQcm9ncmVzcygpO1xuXG5cdFx0dmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJGSUxFX0xPQURfRVJST1JcIiwgbnVsbCwgbG9hZGVyLmdldEl0ZW0oKSk7XG5cdFx0Ly8gVE9ETzogUHJvcGFnYXRlIGFjdHVhbCBlcnJvciBtZXNzYWdlLlxuXG5cdFx0dGhpcy5fc2VuZEVycm9yKG5ld0V2ZW50KTtcblxuXHRcdGlmICghdGhpcy5zdG9wT25FcnJvcikge1xuXHRcdFx0dGhpcy5fcmVtb3ZlTG9hZEl0ZW0obG9hZGVyKTtcblx0XHRcdHRoaXMuX2NsZWFuTG9hZEl0ZW0obG9hZGVyKTtcblx0XHRcdHRoaXMuX2xvYWROZXh0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0UGF1c2VkKHRydWUpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQW4gaXRlbSBoYXMgZmluaXNoZWQgbG9hZGluZy4gV2UgY2FuIGFzc3VtZSB0aGF0IGl0IGlzIHRvdGFsbHkgbG9hZGVkLCBoYXMgYmVlbiBwYXJzZWQgZm9yIGltbWVkaWF0ZSB1c2UsIGFuZFxuXHQgKiBpcyBhdmFpbGFibGUgYXMgdGhlIFwicmVzdWx0XCIgcHJvcGVydHkgb24gdGhlIGxvYWQgaXRlbS4gVGhlIHJhdyB0ZXh0IHJlc3VsdCBmb3IgYSBwYXJzZWQgaXRlbSAoc3VjaCBhcyBKU09OLCBYTUwsXG5cdCAqIENTUywgSmF2YVNjcmlwdCwgZXRjKSBpcyBhdmFpbGFibGUgYXMgdGhlIFwicmF3UmVzdWx0XCIgcHJvcGVydHksIGFuZCBjYW4gYWxzbyBiZSBsb29rZWQgdXAgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2dldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBfaGFuZGxlRmlsZUNvbXBsZXRlXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCBvYmplY3QgZnJvbSB0aGUgbG9hZGVyLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlRmlsZUNvbXBsZXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIGxvYWRlciA9IGV2ZW50LnRhcmdldDtcblx0XHR2YXIgaXRlbSA9IGxvYWRlci5nZXRJdGVtKCk7XG5cblx0XHR2YXIgcmVzdWx0ID0gbG9hZGVyLmdldFJlc3VsdCgpO1xuXHRcdHRoaXMuX2xvYWRlZFJlc3VsdHNbaXRlbS5pZF0gPSByZXN1bHQ7XG5cdFx0dmFyIHJhd1Jlc3VsdCA9IGxvYWRlci5nZXRSZXN1bHQodHJ1ZSk7XG5cdFx0aWYgKHJhd1Jlc3VsdCAhPSBudWxsICYmIHJhd1Jlc3VsdCAhPT0gcmVzdWx0KSB7XG5cdFx0XHR0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2l0ZW0uaWRdID0gcmF3UmVzdWx0O1xuXHRcdH1cblxuXHRcdHRoaXMuX3NhdmVMb2FkZWRJdGVtcyhsb2FkZXIpO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBsb2FkIGl0ZW1cblx0XHR0aGlzLl9yZW1vdmVMb2FkSXRlbShsb2FkZXIpO1xuXG5cdFx0aWYgKCF0aGlzLl9maW5pc2hPcmRlcmVkSXRlbShsb2FkZXIpKSB7XG5cdFx0XHQvLyBUaGUgaXRlbSB3YXMgTk9UIG1hbmFnZWQsIHNvIHByb2Nlc3MgaXQgbm93XG5cdFx0XHR0aGlzLl9wcm9jZXNzRmluaXNoZWRMb2FkKGl0ZW0sIGxvYWRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGxvYWQgaXRlbVxuXHRcdHRoaXMuX2NsZWFuTG9hZEl0ZW0obG9hZGVyKTtcblx0fTtcblxuXHQvKipcblx0ICogU29tZSBsb2FkZXJzIG1pZ2h0IGxvYWQgYWRkaXRpb25hbCBjb250ZW50LCBvdGhlciB0aGFuIHRoZSBpdGVtIHRoZXkgd2VyZSBwYXNzZWQgKHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0pLlxuXHQgKiBBbnkgaXRlbXMgZXhwb3NlZCBieSB0aGUgbG9hZGVyIHVzaW5nIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2dldExvYWRJdGVtc1wifX17ey9jcm9zc0xpbmt9fSBhcmUgYWRkZWQgdG8gdGhlXG5cdCAqIExvYWRRdWV1ZSdzIGxvb2stdXBzLCBpbmNsdWRpbmcge3sjY3Jvc3NMaW5rIFwiZ2V0SXRlbVwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZHMuXG5cdCAqIEBtZXRob2QgX3NhdmVMb2FkZWRJdGVtc1xuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX3NhdmVMb2FkZWRJdGVtcyA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHQvLyBUT0RPOiBOb3Qgc3VyZSBob3cgdG8gaGFuZGxlIHRoaXMuIFdvdWxkIGJlIG5pY2UgdG8gZXhwb3NlIHRoZSBpdGVtcy5cblx0XHQvLyBMb2FkZXJzIG1heSBsb2FkIHN1Yi1pdGVtcy4gVGhpcyBhZGRzIHRoZW0gdG8gdGhpcyBxdWV1ZVxuXHRcdHZhciBsaXN0ID0gbG9hZGVyLmdldExvYWRlZEl0ZW1zKCk7XG5cdFx0aWYgKGxpc3QgPT09IG51bGwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbGlzdFtpXS5pdGVtO1xuXG5cdFx0XHQvLyBTdG9yZSBpdGVtIGxvb2t1cHNcblx0XHRcdHRoaXMuX2xvYWRJdGVtc0J5U3JjW2l0ZW0uc3JjXSA9IGl0ZW07XG5cdFx0XHR0aGlzLl9sb2FkSXRlbXNCeUlkW2l0ZW0uaWRdID0gaXRlbTtcblxuXHRcdFx0Ly8gU3RvcmUgbG9hZGVkIGNvbnRlbnRcblx0XHRcdHRoaXMuX2xvYWRlZFJlc3VsdHNbaXRlbS5pZF0gPSBsaXN0W2ldLnJlc3VsdDtcblx0XHRcdHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaXRlbS5pZF0gPSBsaXN0W2ldLnJhd1Jlc3VsdDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEZsYWcgYW4gaXRlbSBhcyBmaW5pc2hlZC4gSWYgdGhlIGl0ZW0ncyBvcmRlciBpcyBiZWluZyBtYW5hZ2VkLCB0aGVuIGVuc3VyZSB0aGF0IGl0IGlzIGFsbG93ZWQgdG8gZmluaXNoLCBhbmQgaWZcblx0ICogc28sIHRyaWdnZXIgcHJpb3IgaXRlbXMgdG8gdHJpZ2dlciBhcyB3ZWxsLlxuXHQgKiBAbWV0aG9kIF9maW5pc2hPcmRlcmVkSXRlbVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHBhcmFtIHtCb29sZWFufSBsb2FkRmFpbGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBpdGVtJ3Mgb3JkZXIgaXMgYmVpbmcgbWFuYWdlZC4gVGhpcyBhbGxvd3MgdGhlIGNhbGxlciB0byB0YWtlIGFuIGFsdGVybmF0ZVxuXHQgKiBiZWhhdmlvdXIgaWYgaXQgaXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9maW5pc2hPcmRlcmVkSXRlbSA9IGZ1bmN0aW9uIChsb2FkZXIsIGxvYWRGYWlsZWQpIHtcblx0XHR2YXIgaXRlbSA9IGxvYWRlci5nZXRJdGVtKCk7XG5cblx0XHRpZiAoKHRoaXMubWFpbnRhaW5TY3JpcHRPcmRlciAmJiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuTG9hZFF1ZXVlLkpBVkFTQ1JJUFQpXG5cdFx0XHRcdHx8IGl0ZW0ubWFpbnRhaW5PcmRlcikge1xuXG5cdFx0XHQvL1RPRE86IEV2YWx1YXRlIHJlbW92YWwgb2YgdGhlIF9jdXJyZW50bHlMb2FkaW5nU2NyaXB0XG5cdFx0XHRpZiAobG9hZGVyIGluc3RhbmNlb2YgY3JlYXRlanMuSmF2YVNjcmlwdExvYWRlcikge1xuXHRcdFx0XHR0aGlzLl9jdXJyZW50bHlMb2FkaW5nU2NyaXB0ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpbmRleCA9IGNyZWF0ZWpzLmluZGV4T2YodGhpcy5fc2NyaXB0T3JkZXIsIGl0ZW0pO1xuXHRcdFx0aWYgKGluZGV4ID09IC0xKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gLy8gVGhpcyBsb2FkZXIgbm8gbG9uZ2VyIGV4aXN0c1xuXHRcdFx0dGhpcy5fbG9hZGVkU2NyaXB0c1tpbmRleF0gPSAobG9hZEZhaWxlZCA9PT0gdHJ1ZSkgPyB0cnVlIDogaXRlbTtcblxuXHRcdFx0dGhpcy5fY2hlY2tTY3JpcHRMb2FkT3JkZXIoKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogRW5zdXJlIHRoZSBzY3JpcHRzIGxvYWQgYW5kIGRpc3BhdGNoIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBXaGVuIHVzaW5nIFhIUiwgc2NyaXB0cyBhcmUgc3RvcmVkIGluIGFuIGFycmF5IGluIHRoZVxuXHQgKiBvcmRlciB0aGV5IHdlcmUgYWRkZWQsIGJ1dCB3aXRoIGEgXCJudWxsXCIgdmFsdWUuIFdoZW4gdGhleSBhcmUgY29tcGxldGVkLCB0aGUgdmFsdWUgaXMgc2V0IHRvIHRoZSBsb2FkIGl0ZW0sXG5cdCAqIGFuZCB0aGVuIHdoZW4gdGhleSBhcmUgcHJvY2Vzc2VkIGFuZCBkaXNwYXRjaGVkLCB0aGUgdmFsdWUgaXMgc2V0IHRvIGB0cnVlYC4gVGhpcyBtZXRob2Qgc2ltcGx5XG5cdCAqIGl0ZXJhdGVzIHRoZSBhcnJheSwgYW5kIGVuc3VyZXMgdGhhdCBhbnkgbG9hZGVkIGl0ZW1zIHRoYXQgYXJlIG5vdCBwcmVjZWRlZCBieSBhIGBudWxsYCB2YWx1ZSBhcmVcblx0ICogZGlzcGF0Y2hlZC5cblx0ICogQG1ldGhvZCBfY2hlY2tTY3JpcHRMb2FkT3JkZXJcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NoZWNrU2NyaXB0TG9hZE9yZGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsID0gdGhpcy5fbG9hZGVkU2NyaXB0cy5sZW5ndGg7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzLl9sb2FkZWRTY3JpcHRzW2ldO1xuXHRcdFx0aWYgKGl0ZW0gPT09IG51bGwpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9IC8vIFRoaXMgaXMgc3RpbGwgbG9hZGluZy4gRG8gbm90IHByb2Nlc3MgZnVydGhlci5cblx0XHRcdGlmIChpdGVtID09PSB0cnVlKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSAvLyBUaGlzIGhhcyBjb21wbGV0ZWQsIGFuZCBiZWVuIHByb2Nlc3NlZC4gTW92ZSBvbi5cblxuXHRcdFx0dmFyIGxvYWRJdGVtID0gdGhpcy5fbG9hZGVkUmVzdWx0c1tpdGVtLmlkXTtcblx0XHRcdGlmIChpdGVtLnR5cGUgPT0gY3JlYXRlanMuTG9hZFF1ZXVlLkpBVkFTQ1JJUFQpIHtcblx0XHRcdFx0Ly8gQXBwZW5kIHNjcmlwdCB0YWdzIHRvIHRoZSBoZWFkIGF1dG9tYXRpY2FsbHkuXG5cdFx0XHRcdGNyZWF0ZWpzLkRvbVV0aWxzLmFwcGVuZFRvSGVhZChsb2FkSXRlbSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsb2FkZXIgPSBpdGVtLl9sb2FkZXI7XG5cdFx0XHR0aGlzLl9wcm9jZXNzRmluaXNoZWRMb2FkKGl0ZW0sIGxvYWRlcik7XG5cdFx0XHR0aGlzLl9sb2FkZWRTY3JpcHRzW2ldID0gdHJ1ZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgZmlsZSBoYXMgY29tcGxldGVkIGxvYWRpbmcsIGFuZCB0aGUgTG9hZFF1ZXVlIGNhbiBtb3ZlIG9uLiBUaGlzIHRyaWdnZXJzIHRoZSBjb21wbGV0ZSBldmVudCwgYW5kIGtpY2stc3RhcnRzXG5cdCAqIHRoZSBuZXh0IGl0ZW0uXG5cdCAqIEBtZXRob2QgX3Byb2Nlc3NGaW5pc2hlZExvYWRcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW1cblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3Byb2Nlc3NGaW5pc2hlZExvYWQgPSBmdW5jdGlvbiAoaXRlbSwgbG9hZGVyKSB7XG5cdFx0dGhpcy5fbnVtSXRlbXNMb2FkZWQrKztcblxuXHRcdC8vIFNpbmNlIExvYWRRdWV1ZSBuZWVkcyBtYWludGFpbiBvcmRlciwgd2UgY2FuJ3QgYXBwZW5kIHNjcmlwdHMgaW4gdGhlIGxvYWRlci5cblx0XHQvLyBTbyB3ZSBkbyBpdCBoZXJlIGluc3RlYWQuIE9yIGluIF9jaGVja1NjcmlwdExvYWRPcmRlcigpO1xuXHRcdGlmICghdGhpcy5tYWludGFpblNjcmlwdE9yZGVyICYmIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5Mb2FkUXVldWUuSkFWQVNDUklQVCkge1xuXHRcdFx0dmFyIHRhZyA9IGxvYWRlci5nZXRUYWcoKTtcblx0XHRcdGNyZWF0ZWpzLkRvbVV0aWxzLmFwcGVuZFRvSGVhZCh0YWcpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVByb2dyZXNzKCk7XG5cdFx0dGhpcy5fc2VuZEZpbGVDb21wbGV0ZShpdGVtLCBsb2FkZXIpO1xuXHRcdHRoaXMuX2xvYWROZXh0KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuc3VyZSBpdGVtcyB3aXRoIGBtYWludGFpbk9yZGVyPXRydWVgIHRoYXQgYXJlIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGl0ZW0gaGF2ZSBsb2FkZWQuIFRoaXMgb25seSBhcHBsaWVzIHRvXG5cdCAqIEphdmFTY3JpcHQgaXRlbXMgdGhhdCBhcmUgYmVpbmcgbG9hZGVkIHdpdGggYSBUYWdMb2FkZXIsIHNpbmNlIHRoZXkgaGF2ZSB0byBiZSBsb2FkZWQgYW5kIGNvbXBsZXRlZCA8c3Ryb25nPmJlZm9yZTwvc3Ryb25nPlxuXHQgKiB0aGUgc2NyaXB0IGNhbiBldmVuIGJlIHN0YXJ0ZWQsIHNpbmNlIGl0IGV4aXN0IGluIHRoZSBET00gd2hpbGUgbG9hZGluZy5cblx0ICogQG1ldGhvZCBfY2FuU3RhcnRMb2FkXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgbG9hZGVyIGZvciB0aGUgaXRlbVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBpdGVtIGNhbiBzdGFydCBhIGxvYWQgb3Igbm90LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY2FuU3RhcnRMb2FkID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdGlmICghdGhpcy5tYWludGFpblNjcmlwdE9yZGVyIHx8IGxvYWRlci5wcmVmZXJYSFIpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHR2YXIgaXRlbSA9IGxvYWRlci5nZXRJdGVtKCk7XG5cdFx0aWYgKGl0ZW0udHlwZSAhPSBjcmVhdGVqcy5Mb2FkUXVldWUuSkFWQVNDUklQVCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9jdXJyZW50bHlMb2FkaW5nU2NyaXB0KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fc2NyaXB0T3JkZXIuaW5kZXhPZihpdGVtKTtcblx0XHR2YXIgaSA9IDA7XG5cdFx0d2hpbGUgKGkgPCBpbmRleCkge1xuXHRcdFx0dmFyIGNoZWNrSXRlbSA9IHRoaXMuX2xvYWRlZFNjcmlwdHNbaV07XG5cdFx0XHRpZiAoY2hlY2tJdGVtID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aSsrO1xuXHRcdH1cblx0XHR0aGlzLl9jdXJyZW50bHlMb2FkaW5nU2NyaXB0ID0gdHJ1ZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQSBsb2FkIGl0ZW0gaXMgY29tcGxldGVkIG9yIHdhcyBjYW5jZWxlZCwgYW5kIG5lZWRzIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgTG9hZFF1ZXVlLlxuXHQgKiBAbWV0aG9kIF9yZW1vdmVMb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXIgQSBsb2FkZXIgaW5zdGFuY2UgdG8gcmVtb3ZlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fcmVtb3ZlTG9hZEl0ZW0gPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0dmFyIGwgPSB0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5fY3VycmVudExvYWRzW2ldID09IGxvYWRlcikge1xuXHRcdFx0XHR0aGlzLl9jdXJyZW50TG9hZHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSB1bm5lZWRlZCByZWZlcmVuY2VzIGZyb20gYSBsb2FkZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSBsb2FkZXJcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NsZWFuTG9hZEl0ZW0gPSBmdW5jdGlvbihsb2FkZXIpIHtcblx0XHR2YXIgaXRlbSA9IGxvYWRlci5nZXRJdGVtKCk7XG5cdFx0aWYgKGl0ZW0pIHtcblx0XHRcdGRlbGV0ZSBpdGVtLl9sb2FkZXI7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEFuIGl0ZW0gaGFzIGRpc3BhdGNoZWQgcHJvZ3Jlc3MuIFByb3BhZ2F0ZSB0aGF0IHByb2dyZXNzLCBhbmQgdXBkYXRlIHRoZSBMb2FkUXVldWUncyBvdmVyYWxsIHByb2dyZXNzLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge1Byb2dyZXNzRXZlbnR9IGV2ZW50IFRoZSBwcm9ncmVzcyBldmVudCBmcm9tIHRoZSBpdGVtLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgbG9hZGVyID0gZXZlbnQudGFyZ2V0O1xuXHRcdHRoaXMuX3NlbmRGaWxlUHJvZ3Jlc3MobG9hZGVyLmdldEl0ZW0oKSwgbG9hZGVyLnByb2dyZXNzKTtcblx0XHR0aGlzLl91cGRhdGVQcm9ncmVzcygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBPdmVyYWxsIHByb2dyZXNzIGhhcyBjaGFuZ2VkLCBzbyBkZXRlcm1pbmUgdGhlIG5ldyBwcm9ncmVzcyBhbW91bnQgYW5kIGRpc3BhdGNoIGl0LiBUaGlzIGNoYW5nZXMgYW55IHRpbWUgYW5cblx0ICogaXRlbSBkaXNwYXRjaGVzIHByb2dyZXNzIG9yIGNvbXBsZXRlcy4gTm90ZSB0aGF0IHNpbmNlIHdlIGRvbid0IGFsd2F5cyBrbm93IHRoZSBhY3R1YWwgZmlsZXNpemUgb2YgaXRlbXMgYmVmb3JlXG5cdCAqIHRoZXkgYXJlIGxvYWRlZC4gSW4gdGhpcyBjYXNlLCB3ZSBkZWZpbmUgYSBcInNsb3RcIiBmb3IgZWFjaCBpdGVtICgxIGl0ZW0gaW4gMTAgd291bGQgZ2V0IDEwJSksIGFuZCB0aGVuIGFwcGVuZFxuXHQgKiBsb2FkZWQgcHJvZ3Jlc3Mgb24gdG9wIG9mIHRoZSBhbHJlYWR5LWxvYWRlZCBpdGVtcy5cblx0ICpcblx0ICogRm9yIGV4YW1wbGUsIGlmIDUvMTAgaXRlbXMgaGF2ZSBsb2FkZWQsIGFuZCBpdGVtIDYgaXMgMjAlIGxvYWRlZCwgdGhlIHRvdGFsIHByb2dyZXNzIHdvdWxkIGJlOlxuXHQgKiA8dWw+XG5cdCAqICAgICAgPGxpPjUvMTAgb2YgdGhlIGl0ZW1zIGluIHRoZSBxdWV1ZSAoNTAlKTwvbGk+XG5cdCAqICAgICAgPGxpPnBsdXMgMjAlIG9mIGl0ZW0gNidzIHNsb3QgKDIlKTwvbGk+XG5cdCAqICAgICAgPGxpPmVxdWFscyA1MiU8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAbWV0aG9kIF91cGRhdGVQcm9ncmVzc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fdXBkYXRlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGxvYWRlZCA9IHRoaXMuX251bUl0ZW1zTG9hZGVkIC8gdGhpcy5fbnVtSXRlbXM7IC8vIEZ1bGx5IExvYWRlZCBQcm9ncmVzc1xuXHRcdHZhciByZW1haW5pbmcgPSB0aGlzLl9udW1JdGVtcyAtIHRoaXMuX251bUl0ZW1zTG9hZGVkO1xuXHRcdGlmIChyZW1haW5pbmcgPiAwKSB7XG5cdFx0XHR2YXIgY2h1bmsgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNodW5rICs9IHRoaXMuX2N1cnJlbnRMb2Fkc1tpXS5wcm9ncmVzcztcblx0XHRcdH1cblx0XHRcdGxvYWRlZCArPSAoY2h1bmsgLyByZW1haW5pbmcpICogKHJlbWFpbmluZyAvIHRoaXMuX251bUl0ZW1zKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbGFzdFByb2dyZXNzICE9IGxvYWRlZCkge1xuXHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKGxvYWRlZCk7XG5cdFx0XHR0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBsb2FkZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiBvdXQgaXRlbSByZXN1bHRzLCB0byBmcmVlIHRoZW0gZnJvbSBtZW1vcnkuIE1haW5seSwgdGhlIGxvYWRlZCBpdGVtIGFuZCByZXN1bHRzIGFyZSBjbGVhcmVkIGZyb20gaW50ZXJuYWxcblx0ICogaGFzaGVzLlxuXHQgKiBAbWV0aG9kIF9kaXNwb3NlSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgaXRlbSB0aGF0IHdhcyBwYXNzZWQgaW4gZm9yIHByZWxvYWRpbmcuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9kaXNwb3NlSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0ZGVsZXRlIHRoaXMuX2xvYWRlZFJlc3VsdHNbaXRlbS5pZF07XG5cdFx0ZGVsZXRlIHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaXRlbS5pZF07XG5cdFx0ZGVsZXRlIHRoaXMuX2xvYWRJdGVtc0J5SWRbaXRlbS5pZF07XG5cdFx0ZGVsZXRlIHRoaXMuX2xvYWRJdGVtc0J5U3JjW2l0ZW0uc3JjXTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSBcImZpbGVwcm9ncmVzc1wiIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LiBQbGVhc2Ugc2VlIHRoZSBMb2FkUXVldWUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVwcm9ncmVzczpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBmb3IgZGV0YWlscyBvbiB0aGUgZXZlbnQgcGF5bG9hZC5cblx0ICogQG1ldGhvZCBfc2VuZEZpbGVQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgaXRlbSB0aGF0IGlzIGJlaW5nIGxvYWRlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHByb2dyZXNzIFRoZSBhbW91bnQgdGhlIGl0ZW0gaGFzIGJlZW4gbG9hZGVkIChiZXR3ZWVuIDAgYW5kIDEpLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kRmlsZVByb2dyZXNzID0gZnVuY3Rpb24gKGl0ZW0sIHByb2dyZXNzKSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSB8fCB0aGlzLl9wYXVzZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCF0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJmaWxlcHJvZ3Jlc3NcIikpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvL0xNOiBSZXdvcmsgUHJvZ3Jlc3NFdmVudCB0byBzdXBwb3J0IHRoaXM/XG5cdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZXByb2dyZXNzXCIpO1xuXHRcdGV2ZW50LnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5cdFx0ZXZlbnQubG9hZGVkID0gcHJvZ3Jlc3M7XG5cdFx0ZXZlbnQudG90YWwgPSAxO1xuXHRcdGV2ZW50Lml0ZW0gPSBpdGVtO1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSBmaWxlbG9hZCB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGZvclxuXHQgKiBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuXHQgKiBAbWV0aG9kIF9zZW5kRmlsZUNvbXBsZXRlXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW1PYmplY3R9IGl0ZW0gVGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBsb2FkZWQuXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kRmlsZUNvbXBsZXRlID0gZnVuY3Rpb24gKGl0ZW0sIGxvYWRlcikge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkgfHwgdGhpcy5fcGF1c2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZWxvYWRcIik7XG5cdFx0ZXZlbnQubG9hZGVyID0gbG9hZGVyO1xuXHRcdGV2ZW50Lml0ZW0gPSBpdGVtO1xuXHRcdGV2ZW50LnJlc3VsdCA9IHRoaXMuX2xvYWRlZFJlc3VsdHNbaXRlbS5pZF07XG5cdFx0ZXZlbnQucmF3UmVzdWx0ID0gdGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpdGVtLmlkXTtcblxuXHRcdC8vIFRoaXMgY2FsbHMgYSBoYW5kbGVyIHNwZWNpZmllZCBvbiB0aGUgYWN0dWFsIGxvYWQgaXRlbS4gQ3VycmVudGx5LCB0aGUgU291bmRKUyBwbHVnaW4gdXNlcyB0aGlzLlxuXHRcdGlmIChpdGVtLmNvbXBsZXRlSGFuZGxlcikge1xuXHRcdFx0aXRlbS5jb21wbGV0ZUhhbmRsZXIoZXZlbnQpO1xuXHRcdH1cblxuXHRcdHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcImZpbGVsb2FkXCIpICYmIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEgZmlsZXN0YXJ0IHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGltbWVkaWF0ZWx5IGJlZm9yZSBhIGZpbGUgc3RhcnRzIHRvIGxvYWQuIFBsZWFzZSBzZWVcblx0ICogdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlc3RhcnQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgZm9yIGRldGFpbHMgb24gdGhlIGV2ZW50IHBheWxvYWQuXG5cdCAqIEBtZXRob2QgX3NlbmRGaWxlU3RhcnRcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBsb2FkZWQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRGaWxlU3RhcnQgPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVzdGFydFwiKTtcblx0XHRldmVudC5pdGVtID0gaXRlbTtcblx0XHR0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJmaWxlc3RhcnRcIikgJiYgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltQcmVsb2FkSlMgTG9hZFF1ZXVlXVwiO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkxvYWRRdWV1ZSA9IGNyZWF0ZWpzLnByb21vdGUoTG9hZFF1ZXVlLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFRleHRMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgVGV4dCBmaWxlcy5cblx0ICogQGNsYXNzIFRleHRMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gVGV4dExvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQpO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFRleHRMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBUZXh0TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBsb2FkcyBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1RFWFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGJ1dCBpcyBhbHNvIHRoZSBkZWZhdWx0IGxvYWRlciBpZiBhIGZpbGUgdHlwZSBjYW4gbm90IGJlIGRldGVybWluZWQuXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVEVYVDtcblx0fTtcblxuXHRjcmVhdGVqcy5UZXh0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShUZXh0TG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQmluYXJ5TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIGJpbmFyeSBmaWxlcy4gVGhpcyBpcyB1c2VmdWwgZm9yIGxvYWRpbmcgd2ViIGF1ZGlvLCBvciBjb250ZW50IHRoYXQgcmVxdWlyZXMgYW4gQXJyYXlCdWZmZXIuXG5cdCAqIEBjbGFzcyBCaW5hcnlMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gQmluYXJ5TG9hZGVyKGxvYWRJdGVtKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgdHJ1ZSwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQklOQVJZKTtcblx0XHR0aGlzLm9uKFwiaW5pdGlhbGl6ZVwiLCB0aGlzLl91cGRhdGVYSFIsIHRoaXMpO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEJpbmFyeUxvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IEJpbmFyeUxvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0JJTkFSWTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkJJTkFSWTtcblx0fTtcblxuXHQvLyBwcml2YXRlIG1ldGhvZHNcblx0LyoqXG5cdCAqIEJlZm9yZSB0aGUgaXRlbSBsb2Fkcywgc2V0IHRoZSByZXNwb25zZSB0eXBlIHRvIFwiYXJyYXlidWZmZXJcIlxuXHQgKiBAcHJvcGVydHkgX3VwZGF0ZVhIUlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fdXBkYXRlWEhSID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQubG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkJpbmFyeUxvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoQmluYXJ5TG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQ1NTTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIENTUyBmaWxlcy5cblx0ICogQGNsYXNzIENTU0xvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBDU1NMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQ1NTKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IFwiaHJlZlwiO1xuXG5cdFx0aWYgKHByZWZlclhIUikge1xuXHRcdFx0dGhpcy5fdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl90YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblx0XHR9XG5cblx0XHR0aGlzLl90YWcucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cdFx0dGhpcy5fdGFnLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQ1NTTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gQ1NTTG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQ1NTOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkNTUztcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIENTUyBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7SFRNTExpbmtFbGVtZW50fEhUTUxTdHlsZUVsZW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0aWYgKHRoaXMuX3ByZWZlclhIUikge1xuXHRcdFx0dmFyIHRhZyA9IGxvYWRlci5nZXRUYWcoKTtcblxuXHRcdFx0aWYgKHRhZy5zdHlsZVNoZWV0KSB7IC8vIElFXG5cdFx0XHRcdHRhZy5zdHlsZVNoZWV0LmNzc1RleHQgPSBsb2FkZXIuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobG9hZGVyLmdldFJlc3VsdCh0cnVlKSk7XG5cdFx0XHRcdHRhZy5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhZyA9IHRoaXMuX3RhZztcblx0XHR9XG5cblx0XHRjcmVhdGVqcy5Eb21VdGlscy5hcHBlbmRUb0hlYWQodGFnKTtcblxuXHRcdHJldHVybiB0YWc7XG5cdH07XG5cblx0Y3JlYXRlanMuQ1NTTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShDU1NMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBJbWFnZUxvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBpbWFnZSBmaWxlcy5cblx0ICogQGNsYXNzIEltYWdlTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEltYWdlTG9hZGVyIChsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5JTUFHRSk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcInNyY1wiO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIHByZWxvYWQgaXRlbSBpcyBhbHJlYWR5IGEgdGFnLlxuXHRcdGlmIChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNJbWFnZVRhZyhsb2FkSXRlbSkpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGxvYWRJdGVtO1xuXHRcdH0gZWxzZSBpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzSW1hZ2VUYWcobG9hZEl0ZW0uc3JjKSkge1xuXHRcdFx0dGhpcy5fdGFnID0gbG9hZEl0ZW0uc3JjO1xuXHRcdH0gZWxzZSBpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzSW1hZ2VUYWcobG9hZEl0ZW0udGFnKSkge1xuXHRcdFx0dGhpcy5fdGFnID0gbG9hZEl0ZW0udGFnO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl90YWcgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcHJlZmVyWEhSID0gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3RhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbihcImluaXRpYWxpemVcIiwgdGhpcy5fdXBkYXRlWEhSLCB0aGlzKTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChJbWFnZUxvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IEltYWdlTG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSU1BR0U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSU1BR0U7XG5cdH07XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90YWcuc3JjICE9IFwiXCIgJiYgdGhpcy5fdGFnLmNvbXBsZXRlKSB7XG5cdFx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY3Jvc3NPcmlnaW4gPSB0aGlzLl9pdGVtLmNyb3NzT3JpZ2luO1xuXHRcdGlmIChjcm9zc09yaWdpbiA9PSB0cnVlKSB7IGNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIjsgfVxuXHRcdGlmIChjcm9zc09yaWdpbiAhPSBudWxsICYmICFjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNMb2NhbCh0aGlzLl9pdGVtLnNyYykpIHtcblx0XHRcdHRoaXMuX3RhZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuXHRcdH1cblxuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfbG9hZCgpO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBCZWZvcmUgdGhlIGl0ZW0gbG9hZHMsIHNldCBpdHMgbWltZVR5cGUgYW5kIHJlc3BvbnNlVHlwZS5cblx0ICogQHByb3BlcnR5IF91cGRhdGVYSFJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3VwZGF0ZVhIUiA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LmxvYWRlci5taW1lVHlwZSA9ICd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkLWJpbmFyeSc7XG5cblx0XHQvLyBPbmx5IGV4aXN0cyBmb3IgWEhSXG5cdFx0aWYgKGV2ZW50LmxvYWRlci5zZXRSZXNwb25zZVR5cGUpIHtcblx0XHRcdGV2ZW50LmxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJibG9iXCIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIEltYWdlIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtIVE1MSW1hZ2VFbGVtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHJldHVybiB0aGlzLl9mb3JtYXRJbWFnZTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIGFzeW5jaHJvbm91cyBpbWFnZSBmb3JtYXR0ZXIgZnVuY3Rpb24uIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBpbWFnZXMgaGF2ZVxuXHQgKiBhIHNob3J0IGRlbGF5IGJlZm9yZSB0aGV5IGFyZSByZWFkeS5cblx0ICogQG1ldGhvZCBfZm9ybWF0SW1hZ2Vcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2Vzc0NhbGxiYWNrIFRoZSBtZXRob2QgdG8gY2FsbCB3aGVuIHRoZSByZXN1bHQgaGFzIGZpbmlzaGVkIGZvcm1hdHRpbmdcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3JDYWxsYmFjayBUaGUgbWV0aG9kIHRvIGNhbGwgaWYgYW4gZXJyb3Igb2NjdXJzIGR1cmluZyBmb3JtYXR0aW5nXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRJbWFnZSA9IGZ1bmN0aW9uIChzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcblx0XHR2YXIgdGFnID0gdGhpcy5fdGFnO1xuXHRcdHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG5cblx0XHRpZiAoIXRoaXMuX3ByZWZlclhIUikge1xuXHRcdFx0Ly9kb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRhZyk7XG5cdFx0fSBlbHNlIGlmIChVUkwpIHtcblx0XHRcdHZhciBvYmpVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHRoaXMuZ2V0UmVzdWx0KHRydWUpKTtcblx0XHRcdHRhZy5zcmMgPSBvYmpVUkw7XG5cblx0XHRcdHRhZy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLl9jbGVhblVwVVJMLCBmYWxzZSk7XG5cdFx0XHR0YWcuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX2NsZWFuVXBVUkwsIGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFnLnNyYyA9IHRoaXMuX2l0ZW0uc3JjO1xuXHRcdH1cblxuXHRcdGlmICh0YWcuY29tcGxldGUpIHtcblx0XHRcdHN1Y2Nlc3NDYWxsYmFjayh0YWcpO1xuXHRcdH0gZWxzZSB7XG4gICAgICAgICAgICB0YWcub25sb2FkID0gY3JlYXRlanMucHJveHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHRoaXMuX3RhZyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdGFnLm9uZXJyb3IgPSBjcmVhdGVqcy5wcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKF90aGlzLl90YWcpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0aGUgT2JqZWN0VVJMLCB0aGUgdGFnIGlzIGRvbmUgd2l0aCBpdC4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgcnVuXG5cdCAqIGFzIGFuIGV2ZW50IGxpc3RlbmVyIHdpdGhvdXQgYSBwcm94eS9jbG9zdXJlLCBhcyBpdCBkb2Vzbid0IHJlcXVpcmUgaXQgLSBzbyBkbyBub3Rcblx0ICogaW5jbHVkZSBhbnkgZnVuY3Rpb25hbGl0eSB0aGF0IHJlcXVpcmVzIHNjb3BlIHdpdGhvdXQgY2hhbmdpbmcgaXQuXG5cdCAqIEBtZXRob2QgX2NsZWFuVXBVUkxcblx0ICogQHBhcmFtIGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jbGVhblVwVVJMID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcblx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKGV2ZW50LnRhcmdldC5zcmMpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkltYWdlTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShJbWFnZUxvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEphdmFTY3JpcHRMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgSmF2YVNjcmlwdCBmaWxlcy5cblx0ICogQGNsYXNzIEphdmFTY3JpcHRMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gSmF2YVNjcmlwdExvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KQVZBU0NSSVBUKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IFwic3JjXCI7XG5cdFx0dGhpcy5zZXRUYWcoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSmF2YVNjcmlwdExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IEphdmFTY3JpcHRMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KQVZBU0NSSVBUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSkFWQVNDUklQVDtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIEphdmFTY3JpcHQgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge0hUTUxMaW5rRWxlbWVudHxIVE1MU3R5bGVFbGVtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHZhciB0YWcgPSBsb2FkZXIuZ2V0VGFnKCk7XG5cdFx0aWYgKHRoaXMuX3ByZWZlclhIUikge1xuXHRcdFx0dGFnLnRleHQgPSBsb2FkZXIuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGFnO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkphdmFTY3JpcHRMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEphdmFTY3JpcHRMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBKU09OTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIEpTT04gZmlsZXMuIFRvIGxvYWQgSlNPTiBjcm9zcy1kb21haW4sIHVzZSBKU09OUCBhbmQgdGhlIHt7I2Nyb3NzTGluayBcIkpTT05QTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGluc3RlYWQuIFRvIGxvYWQgSlNPTi1mb3JtYXR0ZWQgbWFuaWZlc3RzLCB1c2Uge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB0b1xuXHQgKiBsb2FkIEVhc2VsSlMgU3ByaXRlU2hlZXRzLCB1c2Uge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBjbGFzcyBKU09OTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEpTT05Mb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSlNPTkxvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IEpTT05Mb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KU09OOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT047XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBKU09OIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtIVE1MTGlua0VsZW1lbnR8SFRNTFN0eWxlRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHR2YXIganNvbiA9IG51bGw7XG5cdFx0dHJ5IHtcblx0XHRcdGpzb24gPSBjcmVhdGVqcy5EYXRhVXRpbHMucGFyc2VKU09OKGxvYWRlci5nZXRSZXN1bHQodHJ1ZSkpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiSlNPTl9GT1JNQVRcIiwgbnVsbCwgZSk7XG5cdFx0XHR0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuXHRcdFx0cmV0dXJuIGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpzb247XG5cdH07XG5cblx0Y3JlYXRlanMuSlNPTkxvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoSlNPTkxvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEpTT05QTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIEpTT05QIGZpbGVzLCB3aGljaCBhcmUgSlNPTi1mb3JtYXR0ZWQgdGV4dCBmaWxlcywgd3JhcHBlZCBpbiBhIGNhbGxiYWNrLiBUbyBsb2FkIHJlZ3VsYXIgSlNPTlxuXHQgKiB3aXRob3V0IGEgY2FsbGJhY2sgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJKU09OTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuIFRvIGxvYWQgSlNPTi1mb3JtYXR0ZWQgbWFuaWZlc3RzLFxuXHQgKiB1c2Uge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB0byBsb2FkIEVhc2VsSlMgU3ByaXRlU2hlZXRzLCB1c2Vcblx0ICoge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIEpTT05QIGlzIGEgZm9ybWF0IHRoYXQgcHJvdmlkZXMgYSBzb2x1dGlvbiBmb3IgbG9hZGluZyBKU09OIGZpbGVzIGNyb3NzLWRvbWFpbiA8ZW0+d2l0aG91dDwvZW0+IHJlcXVpcmluZyBDT1JTLlxuXHQgKiBKU09OUCBmaWxlcyBhcmUgbG9hZGVkIGFzIEphdmFTY3JpcHQsIGFuZCB0aGUgXCJjYWxsYmFja1wiIGlzIGV4ZWN1dGVkIG9uY2UgdGhleSBhcmUgbG9hZGVkLiBUaGUgY2FsbGJhY2sgaW4gdGhlXG5cdCAqIEpTT05QIG11c3QgbWF0Y2ggdGhlIGNhbGxiYWNrIHBhc3NlZCB0byB0aGUgbG9hZEl0ZW0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlIEpTT05QPC9oND5cblx0ICpcblx0ICogXHRcdGNhbGxiYWNrTmFtZSh7XG5cdCAqIFx0XHRcdFwibmFtZVwiOiBcInZhbHVlXCIsXG5cdCAqXHQgXHRcdFwibnVtXCI6IDMsXG5cdCAqXHRcdFx0XCJvYmpcIjogeyBcImJvb2xcIjp0cnVlIH1cblx0ICogXHRcdH0pO1xuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqIFx0XHR2YXIgbG9hZEl0ZW0gPSB7aWQ6XCJqc29uXCIsIHR5cGU6XCJqc29ucFwiLCBzcmM6XCJodHRwOi8vc2VydmVyLmNvbS90ZXh0Lmpzb25cIiwgY2FsbGJhY2s6XCJjYWxsYmFja05hbWVcIn1cblx0ICogXHRcdHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcblx0ICogXHRcdHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgaGFuZGxlQ29tcGxldGUpO1xuXHQgKiBcdFx0cXVldWUubG9hZEl0ZW0obG9hZEl0ZW0pO1xuXHQgKlxuXHQgKiBcdFx0ZnVuY3Rpb24gaGFuZGxlQ29tcGxldGUoZXZlbnQpIH1cblx0ICogXHRcdFx0dmFyIGpzb24gPSBxdWV1ZS5nZXRSZXN1bHQoXCJqc29uXCIpO1xuXHQgKiBcdFx0XHRjb25zb2xlLmxvZyhqc29uLm9iai5ib29sKTsgLy8gdHJ1ZVxuXHQgKiBcdFx0fVxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgSlNPTlAgZmlsZXMgbG9hZGVkIGNvbmN1cnJlbnRseSByZXF1aXJlIGEgPGVtPnVuaXF1ZTwvZW0+IGNhbGxiYWNrLiBUbyBlbnN1cmUgSlNPTlAgZmlsZXMgYXJlIGxvYWRlZFxuXHQgKiBpbiBvcmRlciwgZWl0aGVyIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCAoc2V0IHRvIDEpLFxuXHQgKiBvciBzZXQge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vbWFpbnRhaW5PcmRlcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBvbiBpdGVtcyB3aXRoIHRoZSBzYW1lIGNhbGxiYWNrLlxuXHQgKlxuXHQgKiBAY2xhc3MgSlNPTlBMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gSlNPTlBMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBmYWxzZSwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTlApO1xuXHRcdHRoaXMuc2V0VGFnKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpO1xuXHRcdHRoaXMuZ2V0VGFnKCkudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSlNPTlBMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBKU09OUExvYWRlcjtcblxuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSlNPTlA6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTlA7XG5cdH07XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jYW5jZWwoKTtcblx0XHR0aGlzLl9kaXNwb3NlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIExvYWRzIHRoZSBKU09OcCBmaWxlLiAgQmVjYXVzZSBvZiB0aGUgdW5pcXVlIGxvYWRpbmcgbmVlZHMgb2YgSlNPTnBcblx0ICogd2UgZG9uJ3QgdXNlIHRoZSBBYnN0cmFjdExvYWRlci5sb2FkKCkgbWV0aG9kLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICpcblx0ICovXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5faXRlbS5jYWxsYmFjayA9PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIGlzIHJlcXVpcmVkIGZvciBsb2FkaW5nIEpTT05QIHJlcXVlc3RzLicpO1xuXHRcdH1cblxuXHRcdC8vIFRPRE86IExvb2sgaW50byBjcmVhdGluZyBvdXIgb3duIGlGcmFtZSB0byBoYW5kbGUgdGhlIGxvYWRcblx0XHQvLyBJbiB0aGUgZmlyc3QgYXR0ZW1wdCwgRkYgZGlkIG5vdCBnZXQgdGhlIHJlc3VsdFxuXHRcdC8vICAgcmVzdWx0IGluc3RhbmNlb2YgT2JqZWN0IGRpZCBub3Qgd29yayBlaXRoZXJcblx0XHQvLyAgIHNvIHdlIHdvdWxkIG5lZWQgdG8gY2xvbmUgdGhlIHJlc3VsdC5cblx0XHRpZiAod2luZG93W3RoaXMuX2l0ZW0uY2FsbGJhY2tdICE9IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XCJKU09OUCBjYWxsYmFjayAnXCIgK1xuXHRcdFx0XHR0aGlzLl9pdGVtLmNhbGxiYWNrICtcblx0XHRcdFx0XCInIGFscmVhZHkgZXhpc3RzIG9uIHdpbmRvdy4gWW91IG5lZWQgdG8gc3BlY2lmeSBhIGRpZmZlcmVudCBjYWxsYmFjayBvciByZS1uYW1lIHRoZSBjdXJyZW50IG9uZS5cIik7XG5cdFx0fVxuXG5cdFx0d2luZG93W3RoaXMuX2l0ZW0uY2FsbGJhY2tdID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlTG9hZCwgdGhpcyk7XG5cdFx0d2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fdGFnKTtcblxuXHRcdHRoaXMuX2xvYWRUaW1lb3V0ID0gc2V0VGltZW91dChjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUaW1lb3V0LCB0aGlzKSwgdGhpcy5faXRlbS5sb2FkVGltZW91dCk7XG5cblx0XHQvLyBMb2FkIHRoZSB0YWdcblx0XHR0aGlzLl90YWcuc3JjID0gdGhpcy5faXRlbS5zcmM7XG5cdH07XG5cblx0Ly8gcHJpdmF0ZSBtZXRob2RzXG5cdC8qKlxuXHQgKiBIYW5kbGUgdGhlIEpTT05QIGNhbGxiYWNrLCB3aGljaCBpcyBhIHB1YmxpYyBtZXRob2QgZGVmaW5lZCBvbiBgd2luZG93YC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZm9ybWF0dGVkIEpTT04gZGF0YS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUxvYWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3Jhd1Jlc3VsdCA9IGRhdGE7XG5cdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cblx0XHR0aGlzLl9kaXNwb3NlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSB0YWcgcmVxdWVzdCBoYXMgbm90IGxvYWRlZCB3aXRoaW4gdGhlIHRpbWUgc3BlY2ZpZWQgaW4gbG9hZFRpbWVvdXQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGVycm9yIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9kaXNwb3NlKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwidGltZW91dFwiKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFuIHVwIHRoZSBKU09OUCBsb2FkLiBUaGlzIGNsZWFycyBvdXQgdGhlIGNhbGxiYWNrIGFuZCBzY3JpcHQgdGFnIHRoYXQgdGhpcyBsb2FkZXIgY3JlYXRlcy5cblx0ICogQG1ldGhvZCBfZGlzcG9zZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR3aW5kb3cuZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLl90YWcpO1xuXHRcdGRlbGV0ZSB3aW5kb3dbdGhpcy5faXRlbS5jYWxsYmFja107XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkpTT05QTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShKU09OUExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIE1hbmlmZXN0TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIEpTT04gbWFuaWZlc3RzLiBJdGVtcyBpbnNpZGUgdGhlIG1hbmlmZXN0IGFyZSBsb2FkZWQgYmVmb3JlIHRoZSBsb2FkZXIgY29tcGxldGVzLiBUbyBsb2FkIG1hbmlmZXN0c1xuXHQgKiB1c2luZyBKU09OUCwgc3BlY2lmeSBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL2NhbGxiYWNrOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGFzIHBhcnQgb2YgdGhlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBUaGUgbGlzdCBvZiBmaWxlcyBpbiB0aGUgbWFuaWZlc3QgbXVzdCBiZSBkZWZpbmVkIG9uIHRoZSB0b3AtbGV2ZWwgSlNPTiBvYmplY3QgaW4gYSBgbWFuaWZlc3RgIHByb3BlcnR5LiBUaGlzXG5cdCAqIGV4YW1wbGUgc2hvd3MgYSBzYW1wbGUgbWFuaWZlc3QgZGVmaW5pdGlvbiwgYXMgd2VsbCBhcyBob3cgdG8gdG8gaW5jbHVkZSBhIHN1Yi1tYW5pZmVzdC5cblx0ICpcblx0ICogXHRcdHtcblx0ICogXHRcdFx0XCJwYXRoXCI6IFwiYXNzZXRzL1wiLFxuXHQgKlx0IFx0ICAgIFwibWFuaWZlc3RcIjogW1xuXHQgKlx0XHRcdFx0XCJpbWFnZS5wbmdcIixcblx0ICpcdFx0XHRcdHtcInNyY1wiOiBcImltYWdlMi5wbmdcIiwgXCJpZFwiOlwiaW1hZ2UyXCJ9LFxuXHQgKlx0XHRcdFx0e1wic3JjXCI6IFwic3ViLW1hbmlmZXN0Lmpzb25cIiwgXCJ0eXBlXCI6XCJtYW5pZmVzdFwiLCBcImNhbGxiYWNrXCI6XCJqc29uQ2FsbGJhY2tcIn1cblx0ICpcdCBcdCAgICBdXG5cdCAqXHQgXHR9XG5cdCAqXG5cdCAqIFdoZW4gYSBNYW5pZmVzdExvYWRlciBoYXMgY29tcGxldGVkIGxvYWRpbmcsIHRoZSBwYXJlbnQgbG9hZGVyICh1c3VhbGx5IGEge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBidXQgY291bGQgYWxzbyBiZSBhbm90aGVyIE1hbmlmZXN0TG9hZGVyKSB3aWxsIGluaGVyaXQgYWxsIHRoZSBsb2FkZWQgaXRlbXMsIHNvIHlvdSBjYW4gYWNjZXNzIHRoZW0gZGlyZWN0bHkuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTkxvYWRlclwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiSlNPTlBMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYXJlXG5cdCAqIGhpZ2hlciBwcmlvcml0eSBsb2FkZXJzLCBzbyBtYW5pZmVzdHMgPHN0cm9uZz5tdXN0PC9zdHJvbmc+IHNldCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vdHlwZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSB0byB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGNsYXNzIE1hbmlmZXN0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIE1hbmlmZXN0TG9hZGVyKGxvYWRJdGVtKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgbnVsbCwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuTUFOSUZFU1QpO1xuXG5cdC8vIFB1YmxpYyBQcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgb2YgdGhlIHBsdWdpbnMgcmVnaXN0ZXJlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvaW5zdGFsbFBsdWdpblwifX17ey9jcm9zc0xpbmt9fSxcblx0XHQgKiB1c2VkIHRvIHBhc3MgcGx1Z2lucyB0byBuZXcgTG9hZFF1ZXVlcyB0aGF0IG1heSBiZSBjcmVhdGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGx1Z2luc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMVxuXHRcdCAqL1xuXHRcdHRoaXMucGx1Z2lucyA9IG51bGw7XG5cblxuXHQvLyBQcm90ZWN0ZWQgUHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEFuIGludGVybmFsIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGxvYWRzIHRoZSBjb250ZW50cyBvZiB0aGUgbWFuaWZlc3QuXG5cdFx0ICogQHByb3BlcnR5IF9tYW5pZmVzdFF1ZXVlXG5cdFx0ICogQHR5cGUge0xvYWRRdWV1ZX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX21hbmlmZXN0UXVldWUgPSBudWxsO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKE1hbmlmZXN0TG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gTWFuaWZlc3RMb2FkZXI7XG5cblx0Ly8gc3RhdGljIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIFRoZSBhbW91bnQgb2YgcHJvZ3Jlc3MgdGhhdCB0aGUgbWFuaWZlc3QgaXRzZWxmIHRha2VzIHVwLlxuXHQgKiBAcHJvcGVydHkgTUFOSUZFU1RfUFJPR1JFU1Ncblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQGRlZmF1bHQgMC4yNSAoMjUlKVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLk1BTklGRVNUX1BST0dSRVNTID0gMC4yNTtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuTUFOSUZFU1Q7XG5cdH07XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfbG9hZCgpO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdHAuX2NyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSB0aGlzLl9pdGVtLmNhbGxiYWNrO1xuXHRcdGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLkpTT05QTG9hZGVyKHRoaXMuX2l0ZW0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLkpTT05Mb2FkZXIodGhpcy5faXRlbSk7XG5cdFx0fVxuXHR9O1xuXG5cdHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcblx0XHRcdGNhc2UgXCJjb21wbGV0ZVwiOlxuXHRcdFx0XHR0aGlzLl9yYXdSZXN1bHQgPSBldmVudC50YXJnZXQuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdFx0XHR0aGlzLl9yZXN1bHQgPSBldmVudC50YXJnZXQuZ2V0UmVzdWx0KCk7XG5cdFx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhzLk1BTklGRVNUX1BST0dSRVNTKTtcblx0XHRcdFx0dGhpcy5fbG9hZE1hbmlmZXN0KHRoaXMuX3Jlc3VsdCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGNhc2UgXCJwcm9ncmVzc1wiOlxuXHRcdFx0XHRldmVudC5sb2FkZWQgKj0gcy5NQU5JRkVTVF9QUk9HUkVTUztcblx0XHRcdFx0dGhpcy5wcm9ncmVzcyA9IGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsO1xuXHRcdFx0XHRpZiAoaXNOYU4odGhpcy5wcm9ncmVzcykgfHwgdGhpcy5wcm9ncmVzcyA9PSBJbmZpbml0eSkgeyB0aGlzLnByb2dyZXNzID0gMDsgfVxuXHRcdFx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3MoZXZlbnQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfaGFuZGxlRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdHAuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfZGVzdHJveSgpO1xuXHRcdHRoaXMuX21hbmlmZXN0UXVldWUuY2xvc2UoKTtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGFuZCBsb2FkIHRoZSBtYW5pZmVzdCBpdGVtcyBvbmNlIHRoZSBhY3R1YWwgbWFuaWZlc3QgaGFzIGJlZW4gbG9hZGVkLlxuXHQgKiBAbWV0aG9kIF9sb2FkTWFuaWZlc3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IGpzb25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2xvYWRNYW5pZmVzdCA9IGZ1bmN0aW9uIChqc29uKSB7XG5cdFx0aWYgKGpzb24gJiYganNvbi5tYW5pZmVzdCkge1xuXHRcdFx0dmFyIHF1ZXVlID0gdGhpcy5fbWFuaWZlc3RRdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcblx0XHRcdHF1ZXVlLm9uKFwiZmlsZWxvYWRcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RGaWxlTG9hZCwgdGhpcyk7XG5cdFx0XHRxdWV1ZS5vbihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3MsIHRoaXMpO1xuXHRcdFx0cXVldWUub24oXCJjb21wbGV0ZVwiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdENvbXBsZXRlLCB0aGlzLCB0cnVlKTtcblx0XHRcdHF1ZXVlLm9uKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RFcnJvciwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRmb3IodmFyIGkgPSAwLCBsID0gdGhpcy5wbHVnaW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1x0Ly8gY29uc2VydmUgb3JkZXIgb2YgcGx1Z2luc1xuXHRcdFx0XHRxdWV1ZS5pbnN0YWxsUGx1Z2luKHRoaXMucGx1Z2luc1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRxdWV1ZS5sb2FkTWFuaWZlc3QoanNvbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQW4gaXRlbSBmcm9tIHRoZSB7eyNjcm9zc0xpbmsgXCJfbWFuaWZlc3RRdWV1ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBoYXMgY29tcGxldGVkLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNYW5pZmVzdEZpbGVMb2FkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdEZpbGVMb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQudGFyZ2V0ID0gbnVsbDtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbWFuaWZlc3QgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLiBUaGlzIHRyaWdnZXJzIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSBmcm9tIHRoZSBNYW5pZmVzdExvYWRlci5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RDb21wbGV0ZVxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX2xvYWRlZEl0ZW1zID0gdGhpcy5fbWFuaWZlc3RRdWV1ZS5nZXRJdGVtcyh0cnVlKTtcblx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG1hbmlmZXN0IGhhcyByZXBvcnRlZCBwcm9ncmVzcy5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge1Byb2dyZXNzRXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdFByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5wcm9ncmVzcyA9IGV2ZW50LnByb2dyZXNzICogKDEgLSBzLk1BTklGRVNUX1BST0dSRVNTKSArIHMuTUFOSUZFU1RfUFJPR1JFU1M7XG5cdFx0dGhpcy5fc2VuZFByb2dyZXNzKHRoaXMucHJvZ3Jlc3MpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbWFuaWZlc3QgaGFzIHJlcG9ydGVkIGFuIGVycm9yIHdpdGggb25lIG9mIHRoZSBmaWxlcy5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RFcnJvclxuXHQgKiBAcGFyYW0ge0Vycm9yRXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdEVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZWVycm9yXCIpO1xuXHRcdG5ld0V2ZW50Lml0ZW0gPSBldmVudC5kYXRhO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdH07XG5cblx0Y3JlYXRlanMuTWFuaWZlc3RMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKE1hbmlmZXN0TG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU291bmRMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgSFRNTCBhdWRpbyBmaWxlcy4gUHJlbG9hZEpTIGNhbiBub3QgbG9hZCBXZWJBdWRpbyBmaWxlcywgYXMgYSBXZWJBdWRpbyBjb250ZXh0IGlzIHJlcXVpcmVkLCB3aGljaFxuXHQgKiBzaG91bGQgYmUgY3JlYXRlZCBieSBlaXRoZXIgYSBsaWJyYXJ5IHBsYXlpbmcgdGhlIHNvdW5kIChzdWNoIGFzIDxhIGhyZWY9XCJodHRwOi8vc291bmRqcy5jb21cIj5Tb3VuZEpTPC9hPiwgb3IgYW5cblx0ICogZXh0ZXJuYWwgZnJhbWV3b3JrIHRoYXQgaGFuZGxlcyBhdWRpbyBwbGF5YmFjay4gVG8gbG9hZCBjb250ZW50IHRoYXQgY2FuIGJlIHBsYXllZCBieSBXZWJBdWRpbywgdXNlIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJCaW5hcnlMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCBoYW5kbGUgdGhlIGF1ZGlvIGNvbnRleHQgZGVjb2RpbmcgbWFudWFsbHkuXG5cdCAqIEBjbGFzcyBTb3VuZExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RNZWRpYUxvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFNvdW5kTG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TWVkaWFMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU09VTkQpO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHRpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzQXVkaW9UYWcobG9hZEl0ZW0pKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBsb2FkSXRlbTtcblx0XHR9IGVsc2UgaWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0F1ZGlvVGFnKGxvYWRJdGVtLnNyYykpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGxvYWRJdGVtO1xuXHRcdH0gZWxzZSBpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzQXVkaW9UYWcobG9hZEl0ZW0udGFnKSkge1xuXHRcdFx0dGhpcy5fdGFnID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzQXVkaW9UYWcobG9hZEl0ZW0pID8gbG9hZEl0ZW0gOiBsb2FkSXRlbS5zcmM7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3RhZyAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9wcmVmZXJYSFIgPSBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU291bmRMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TWVkaWFMb2FkZXIpO1xuXHR2YXIgcyA9IFNvdW5kTG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvU09VTkQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU09VTkQ7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0cC5fY3JlYXRlVGFnID0gZnVuY3Rpb24gKHNyYykge1xuXHRcdHZhciB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYXVkaW9cIik7XG5cdFx0dGFnLmF1dG9wbGF5ID0gZmFsc2U7XG5cdFx0dGFnLnByZWxvYWQgPSBcIm5vbmVcIjtcblxuXHRcdC8vTE06IEZpcmVmb3ggZmFpbHMgd2hlbiB0aGlzIHRoZSBwcmVsb2FkPVwibm9uZVwiIGZvciBvdGhlciB0YWdzLCBidXQgaXQgbmVlZHMgdG8gYmUgXCJub25lXCIgdG8gZW5zdXJlIFByZWxvYWRKUyB3b3Jrcy5cblx0XHR0YWcuc3JjID0gc3JjO1xuXHRcdHJldHVybiB0YWc7XG5cdH07XG5cblx0Y3JlYXRlanMuU291bmRMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFNvdW5kTG9hZGVyLCBcIkFic3RyYWN0TWVkaWFMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBWaWRlb0xvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciB2aWRlbyBmaWxlcy5cblx0ICogQGNsYXNzIFZpZGVvTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdE1lZGlhTG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gVmlkZW9Mb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RNZWRpYUxvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5WSURFTyk7XG5cblx0XHRpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzVmlkZW9UYWcobG9hZEl0ZW0pIHx8IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc1ZpZGVvVGFnKGxvYWRJdGVtLnNyYykpIHtcblx0XHRcdHRoaXMuc2V0VGFnKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc1ZpZGVvVGFnKGxvYWRJdGVtKT9sb2FkSXRlbTpsb2FkSXRlbS5zcmMpO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCB1c2UgWEhSIGZvciBhIHRhZyB0aGF0J3MgcGFzc2VkIGluLlxuXHRcdFx0dGhpcy5fcHJlZmVyWEhSID0gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0VGFnKHRoaXMuX2NyZWF0ZVRhZygpKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoVmlkZW9Mb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TWVkaWFMb2FkZXIpO1xuXHR2YXIgcyA9IFZpZGVvTG9hZGVyO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgdmlkZW8gdGFnXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NyZWF0ZVRhZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuXHR9O1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvVklERU86cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVklERU87XG5cdH07XG5cblx0Y3JlYXRlanMuVmlkZW9Mb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFZpZGVvTG9hZGVyLCBcIkFic3RyYWN0TWVkaWFMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTcHJpdGVTaGVldExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBFYXNlbEpTIFNwcml0ZVNoZWV0cy4gSW1hZ2VzIGluc2lkZSB0aGUgc3ByaXRlc2hlZXQgZGVmaW5pdGlvbiBhcmUgbG9hZGVkIGJlZm9yZSB0aGUgbG9hZGVyXG5cdCAqIGNvbXBsZXRlcy4gVG8gbG9hZCBTcHJpdGVTaGVldHMgdXNpbmcgSlNPTlAsIHNwZWNpZnkgYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9jYWxsYmFjazpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhcyBwYXJ0IG9mIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGF0IHRoZSB7eyNjcm9zc0xpbmsgXCJKU09OTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCB7eyNjcm9zc0xpbmsgXCJKU09OUExvYWRlclwifX17ey9jcm9zc0xpbmt9fSBhcmUgaGlnaGVyIHByaW9yaXR5IGxvYWRlcnMsIHNvIFNwcml0ZVNoZWV0cyA8c3Ryb25nPm11c3Q8L3N0cm9uZz5cblx0ICogc2V0IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS90eXBlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5XG5cdCAqIHRvIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NQUklURVNIRUVUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0ge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vY3Jvc3NPcmlnaW46cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gYXMgd2VsbFxuXHQgKiBhcyB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlJ3NcIn19e3svY3Jvc3NMaW5rfX0gYGJhc2VQYXRoYCBhcmd1bWVudCBhbmQge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL19wcmVmZXJYSFJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogcHJvcGVydHkgc3VwcGxpZWQgdG8gdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSBhcmUgcGFzc2VkIG9uIHRvIHRoZSBzdWItbWFuaWZlc3QgdGhhdCBsb2Fkc1xuXHQgKiB0aGUgU3ByaXRlU2hlZXQgaW1hZ2VzLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIFNwcml0ZVNoZWV0IEpTT04gZG9lcyBub3QgcmVzcGVjdCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL19wcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogcHJvcGVydHksIHdoaWNoIHNob3VsZCBpbnN0ZWFkIGJlIGRldGVybWluZWQgYnkgdGhlIHByZXNlbmNlIG9mIGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vY2FsbGJhY2s6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogcHJvcGVydHkgb24gdGhlIFNwcml0ZVNoZWV0IGxvYWQgaXRlbS4gVGhpcyBpcyBiZWNhdXNlIHRoZSBKU09OIGxvYWRlZCB3aWxsIGhhdmUgYSBkaWZmZXJlbnQgZm9ybWF0IGRlcGVuZGluZyBvblxuXHQgKiBpZiBpdCBpcyBsb2FkZWQgYXMgSlNPTiwgc28ganVzdCBjaGFuZ2luZyBgcHJlZmVyWEhSYCBpcyBub3QgZW5vdWdoIHRvIGNoYW5nZSBob3cgaXQgaXMgbG9hZGVkLlxuXHQgKiBAY2xhc3MgU3ByaXRlU2hlZXRMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gU3ByaXRlU2hlZXRMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1BSSVRFU0hFRVQpO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBBbiBpbnRlcm5hbCBxdWV1ZSB3aGljaCBsb2FkcyB0aGUgU3ByaXRlU2hlZXQncyBpbWFnZXMuXG5cdFx0ICogQG1ldGhvZCBfbWFuaWZlc3RRdWV1ZVxuXHRcdCAqIEB0eXBlIHtMb2FkUXVldWV9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlID0gbnVsbDtcblx0fVxuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNwcml0ZVNoZWV0TG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gU3ByaXRlU2hlZXRMb2FkZXI7XG5cblx0Ly8gc3RhdGljIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIFRoZSBhbW91bnQgb2YgcHJvZ3Jlc3MgdGhhdCB0aGUgbWFuaWZlc3QgaXRzZWxmIHRha2VzIHVwLlxuXHQgKiBAcHJvcGVydHkgU1BSSVRFU0hFRVRfUFJPR1JFU1Ncblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQGRlZmF1bHQgMC4yNSAoMjUlKVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlNQUklURVNIRUVUX1BST0dSRVNTID0gMC4yNTtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NQUklURVNIRUVUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1BSSVRFU0hFRVQ7XG5cdH07XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9kZXN0cm95O1xuXHRcdHRoaXMuX21hbmlmZXN0UXVldWUuY2xvc2UoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHRwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gdGhpcy5faXRlbS5jYWxsYmFjaztcblx0XHRpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5KU09OUExvYWRlcih0aGlzLl9pdGVtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5KU09OTG9hZGVyKHRoaXMuX2l0ZW0pO1xuXHRcdH1cblx0fTtcblxuXHRwLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0c3dpdGNoIChldmVudC50eXBlKSB7XG5cdFx0XHRjYXNlIFwiY29tcGxldGVcIjpcblx0XHRcdFx0dGhpcy5fcmF3UmVzdWx0ID0gZXZlbnQudGFyZ2V0LmdldFJlc3VsdCh0cnVlKTtcblx0XHRcdFx0dGhpcy5fcmVzdWx0ID0gZXZlbnQudGFyZ2V0LmdldFJlc3VsdCgpO1xuXHRcdFx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3Mocy5TUFJJVEVTSEVFVF9QUk9HUkVTUyk7XG5cdFx0XHRcdHRoaXMuX2xvYWRNYW5pZmVzdCh0aGlzLl9yZXN1bHQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRjYXNlIFwicHJvZ3Jlc3NcIjpcblx0XHRcdFx0ZXZlbnQubG9hZGVkICo9IHMuU1BSSVRFU0hFRVRfUFJPR1JFU1M7XG5cdFx0XHRcdHRoaXMucHJvZ3Jlc3MgPSBldmVudC5sb2FkZWQgLyBldmVudC50b3RhbDtcblx0XHRcdFx0aWYgKGlzTmFOKHRoaXMucHJvZ3Jlc3MpIHx8IHRoaXMucHJvZ3Jlc3MgPT0gSW5maW5pdHkpIHsgdGhpcy5wcm9ncmVzcyA9IDA7IH1cblx0XHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKGV2ZW50KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2hhbmRsZUV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGFuZCBsb2FkIHRoZSBpbWFnZXMgb25jZSB0aGUgU3ByaXRlU2hlZXQgSlNPTiBoYXMgYmVlbiBsb2FkZWQuXG5cdCAqIEBtZXRob2QgX2xvYWRNYW5pZmVzdFxuXHQgKiBAcGFyYW0ge09iamVjdH0ganNvblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fbG9hZE1hbmlmZXN0ID0gZnVuY3Rpb24gKGpzb24pIHtcblx0XHRpZiAoanNvbiAmJiBqc29uLmltYWdlcykge1xuXHRcdFx0dmFyIHF1ZXVlID0gdGhpcy5fbWFuaWZlc3RRdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUodGhpcy5fcHJlZmVyWEhSLCB0aGlzLl9pdGVtLnBhdGgsIHRoaXMuX2l0ZW0uY3Jvc3NPcmlnaW4pO1xuXHRcdFx0cXVldWUub24oXCJjb21wbGV0ZVwiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdENvbXBsZXRlLCB0aGlzLCB0cnVlKTtcblx0XHRcdHF1ZXVlLm9uKFwiZmlsZWxvYWRcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RGaWxlTG9hZCwgdGhpcyk7XG5cdFx0XHRxdWV1ZS5vbihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3MsIHRoaXMpO1xuXHRcdFx0cXVldWUub24oXCJlcnJvclwiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdEVycm9yLCB0aGlzLCB0cnVlKTtcblx0XHRcdHF1ZXVlLmxvYWRNYW5pZmVzdChqc29uLmltYWdlcyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBpdGVtIGZyb20gdGhlIHt7I2Nyb3NzTGluayBcIl9tYW5pZmVzdFF1ZXVlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGhhcyBjb21wbGV0ZWQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgaW1hZ2UgPSBldmVudC5yZXN1bHQ7XG5cdFx0aWYgKGltYWdlICE9IG51bGwpIHtcblx0XHRcdHZhciBpbWFnZXMgPSB0aGlzLmdldFJlc3VsdCgpLmltYWdlcztcblx0XHRcdHZhciBwb3MgPSBpbWFnZXMuaW5kZXhPZihldmVudC5pdGVtLnNyYyk7XG5cdFx0XHRpbWFnZXNbcG9zXSA9IGltYWdlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVGhlIGltYWdlcyBoYXZlIGNvbXBsZXRlZCBsb2FkaW5nLiBUaGlzIHRyaWdnZXJzIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSBmcm9tIHRoZSBTcHJpdGVTaGVldExvYWRlci5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RDb21wbGV0ZVxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX3Jlc3VsdCA9IG5ldyBjcmVhdGVqcy5TcHJpdGVTaGVldCh0aGlzLl9yZXN1bHQpO1xuXHRcdHRoaXMuX2xvYWRlZEl0ZW1zID0gdGhpcy5fbWFuaWZlc3RRdWV1ZS5nZXRJdGVtcyh0cnVlKTtcblx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIGltYWdlcyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gaGFzIHJlcG9ydGVkIHByb2dyZXNzLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNYW5pZmVzdFByb2dyZXNzXG5cdCAqIEBwYXJhbSB7UHJvZ3Jlc3NFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLnByb2dyZXNzID0gZXZlbnQucHJvZ3Jlc3MgKiAoMSAtIHMuU1BSSVRFU0hFRVRfUFJPR1JFU1MpICsgcy5TUFJJVEVTSEVFVF9QUk9HUkVTUztcblx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3ModGhpcy5wcm9ncmVzcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIGltYWdlIGhhcyByZXBvcnRlZCBhbiBlcnJvci5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RFcnJvclxuXHQgKiBAcGFyYW0ge0Vycm9yRXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdEVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZWVycm9yXCIpO1xuXHRcdG5ld0V2ZW50Lml0ZW0gPSBldmVudC5kYXRhO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdH07XG5cblx0Y3JlYXRlanMuU3ByaXRlU2hlZXRMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFNwcml0ZVNoZWV0TG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU1ZHTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIFNWRyBmaWxlcy5cblx0ICogQGNsYXNzIFNWR0xvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBTVkdMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1ZHKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IFwiZGF0YVwiO1xuXG5cdFx0aWYgKHByZWZlclhIUikge1xuXHRcdFx0dGhpcy5zZXRUYWcoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN2Z1wiKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0VGFnKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvYmplY3RcIikpO1xuXHRcdFx0dGhpcy5nZXRUYWcoKS50eXBlID0gXCJpbWFnZS9zdmcreG1sXCI7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNWR0xvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IFNWR0xvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NWRzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNWRztcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIFNWRyBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdC8vIG1pbWUgc2hvdWxkIGJlIGltYWdlL3N2Zyt4bWwsIGJ1dCBPcGVyYSByZXF1aXJlcyB0ZXh0L3htbFxuXHRcdHZhciB4bWwgPSBjcmVhdGVqcy5EYXRhVXRpbHMucGFyc2VYTUwobG9hZGVyLmdldFJlc3VsdCh0cnVlKSwgXCJ0ZXh0L3htbFwiKTtcblx0XHR2YXIgdGFnID0gbG9hZGVyLmdldFRhZygpO1xuXG5cdFx0aWYgKCF0aGlzLl9wcmVmZXJYSFIgJiYgZG9jdW1lbnQuYm9keS5jb250YWlucyh0YWcpKSB7XG5cdFx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRhZyk7XG5cdFx0fVxuXG5cdFx0aWYgKHhtbC5kb2N1bWVudEVsZW1lbnQgIT0gbnVsbCkge1xuXHRcdFx0dGFnLmFwcGVuZENoaWxkKHhtbC5kb2N1bWVudEVsZW1lbnQpO1xuXHRcdFx0dGFnLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcblx0XHRcdHJldHVybiB0YWc7XG5cdFx0fSBlbHNlIHsgLy8gRm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBTVkcsIGp1c3QgZ2l2ZSB0aGVtIHRoZSBYTUwuIChJRSA5LTgpXG5cdFx0XHRyZXR1cm4geG1sO1xuXHRcdH1cblx0fTtcblxuXHRjcmVhdGVqcy5TVkdMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFNWR0xvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFhNTExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBDU1MgZmlsZXMuXG5cdCAqIEBjbGFzcyBYTUxMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gWE1MTG9hZGVyKGxvYWRJdGVtKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgdHJ1ZSwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuWE1MKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoWE1MTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gWE1MTG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvWE1MOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlhNTDtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIFhNTCBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7WE1MRG9jdW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZWpzLkRhdGFVdGlscy5wYXJzZVhNTChsb2FkZXIuZ2V0UmVzdWx0KHRydWUpLCBcInRleHQveG1sXCIpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlhNTExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoWE1MTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gdmVyc2lvbi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblxuXHQvKipcblx0ICogU3RhdGljIGNsYXNzIGhvbGRpbmcgbGlicmFyeSBzcGVjaWZpYyBpbmZvcm1hdGlvbiBzdWNoIGFzIHRoZSB2ZXJzaW9uIGFuZCBidWlsZERhdGUgb2YgdGhlIGxpYnJhcnkuXG5cdCAqIFRoZSBTb3VuZEpTIGNsYXNzIGhhcyBiZWVuIHJlbmFtZWQge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX0uICBQbGVhc2Ugc2VlIHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBpbmZvcm1hdGlvbiBvbiB1c2luZyBzb3VuZC5cblx0ICogQGNsYXNzIFNvdW5kSlNcblx0ICoqL1xuXHR2YXIgcyA9IGNyZWF0ZWpzLlNvdW5kSlMgPSBjcmVhdGVqcy5Tb3VuZEpTIHx8IHt9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdmVyc2lvbiBzdHJpbmcgZm9yIHRoaXMgcmVsZWFzZS5cblx0ICogQHByb3BlcnR5IHZlcnNpb25cblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLnZlcnNpb24gPSAvKj12ZXJzaW9uKi9cIjAuNi4yXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxuXHQvKipcblx0ICogVGhlIGJ1aWxkIGRhdGUgZm9yIHRoaXMgcmVsZWFzZSBpbiBVVEMgZm9ybWF0LlxuXHQgKiBAcHJvcGVydHkgYnVpbGREYXRlXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy5idWlsZERhdGUgPSAvKj1kYXRlKi9cIlRodSwgMjYgTm92IDIwMTUgMjA6NDQ6MzEgR01UXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxufSkoKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEluZGV4T2YuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBzcGVjaWZpZWQgdmFsdWUgc2VhcmNoRWxlbWVudCBpbiB0aGUgcGFzc2VkIGluIGFycmF5LCBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2ZcbiAqIHRoYXQgdmFsdWUuICBSZXR1cm5zIC0xIGlmIHZhbHVlIGlzIG5vdCBmb3VuZC5cbiAqXG4gKiAgICAgIHZhciBpID0gY3JlYXRlanMuaW5kZXhPZihteUFycmF5LCBteUVsZW1lbnRUb0ZpbmQpO1xuICpcbiAqIEBtZXRob2QgaW5kZXhPZlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gc2VhcmNoIGZvciBzZWFyY2hFbGVtZW50XG4gKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGZpbmQgaW4gYXJyYXkuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBmaXJzdCBpbmRleCBvZiBzZWFyY2hFbGVtZW50IGluIGFycmF5LlxuICovXG5jcmVhdGVqcy5pbmRleE9mID0gZnVuY3Rpb24gKGFycmF5LCBzZWFyY2hFbGVtZW50KXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Zm9yICh2YXIgaSA9IDAsbD1hcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRpZiAoc2VhcmNoRWxlbWVudCA9PT0gYXJyYXlbaV0pIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gUHJveHkuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8qKlxuICogVmFyaW91cyB1dGlsaXRpZXMgdGhhdCB0aGUgQ3JlYXRlSlMgU3VpdGUgdXNlcy4gVXRpbGl0aWVzIGFyZSBjcmVhdGVkIGFzIHNlcGFyYXRlIGZpbGVzLCBhbmQgd2lsbCBiZSBhdmFpbGFibGUgb24gdGhlXG4gKiBjcmVhdGVqcyBuYW1lc3BhY2UgZGlyZWN0bHkuXG4gKlxuICogPGg0PkV4YW1wbGU8L2g0PlxuICpcbiAqICAgICAgbXlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBjcmVhdGVqcy5wcm94eShteU1ldGhvZCwgc2NvcGUpKTtcbiAqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKiBAbWFpbiBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBIGZ1bmN0aW9uIHByb3h5IGZvciBtZXRob2RzLiBCeSBkZWZhdWx0LCBKYXZhU2NyaXB0IG1ldGhvZHMgZG8gbm90IG1haW50YWluIHNjb3BlLCBzbyBwYXNzaW5nIGEgbWV0aG9kIGFzIGFcblx0ICogY2FsbGJhY2sgd2lsbCByZXN1bHQgaW4gdGhlIG1ldGhvZCBnZXR0aW5nIGNhbGxlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIGNhbGxlci4gVXNpbmcgYSBwcm94eSBlbnN1cmVzIHRoYXQgdGhlXG5cdCAqIG1ldGhvZCBnZXRzIGNhbGxlZCBpbiB0aGUgY29ycmVjdCBzY29wZS5cblx0ICpcblx0ICogQWRkaXRpb25hbCBhcmd1bWVudHMgY2FuIGJlIHBhc3NlZCB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZnVuY3Rpb24gd2hlbiBpdCBpcyBjYWxsZWQuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBteU9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwiZXZlbnRcIiwgY3JlYXRlanMucHJveHkobXlIYW5kbGVyLCB0aGlzLCBhcmcxLCBhcmcyKSk7XG5cdCAqXG5cdCAqICAgICAgZnVuY3Rpb24gbXlIYW5kbGVyKGFyZzEsIGFyZzIpIHtcblx0ICogICAgICAgICAgIC8vIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBteU9iamVjdC5teUNhbGxiYWNrIGlzIGV4ZWN1dGVkLlxuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQG1ldGhvZCBwcm94eVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgVGhlIGZ1bmN0aW9uIHRvIGNhbGxcblx0ICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFRoZSBzY29wZSB0byBjYWxsIHRoZSBtZXRob2QgbmFtZSBvblxuXHQgKiBAcGFyYW0ge21peGVkfSBbYXJnXSAqIEFyZ3VtZW50cyB0aGF0IGFyZSBhcHBlbmRlZCB0byB0aGUgY2FsbGJhY2sgZm9yIGFkZGl0aW9uYWwgcGFyYW1zLlxuXHQgKiBAcHVibGljXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdGNyZWF0ZWpzLnByb3h5ID0gZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUpIHtcblx0XHR2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gbWV0aG9kLmFwcGx5KHNjb3BlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLmNvbmNhdChhQXJncykpO1xuXHRcdH07XG5cdH1cblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEJyb3dzZXJEZXRlY3QuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBbiBvYmplY3QgdGhhdCBkZXRlcm1pbmVzIHRoZSBjdXJyZW50IGJyb3dzZXIsIHZlcnNpb24sIG9wZXJhdGluZyBzeXN0ZW0sIGFuZCBvdGhlciBlbnZpcm9ubWVudFxuXHQgKiB2YXJpYWJsZXMgdmlhIHVzZXIgYWdlbnQgc3RyaW5nLlxuXHQgKlxuXHQgKiBVc2VkIGZvciBhdWRpbyBiZWNhdXNlIGZlYXR1cmUgZGV0ZWN0aW9uIGlzIHVuYWJsZSB0byBkZXRlY3QgdGhlIG1hbnkgbGltaXRhdGlvbnMgb2YgbW9iaWxlIGRldmljZXMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBpZiAoY3JlYXRlanMuQnJvd3NlckRldGVjdC5pc0lPUykgeyAvLyBkbyBzdHVmZiB9XG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBCcm93c2VyRGV0ZWN0XG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNGaXJlZm94IFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgRmlyZWZveC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpc09wZXJhIFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgb3BlcmEuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNDaHJvbWUgVHJ1ZSBpZiBvdXIgYnJvd3NlciBpcyBDaHJvbWUuICBOb3RlIHRoYXQgQ2hyb21lIGZvciBBbmRyb2lkIHJldHVybnMgdHJ1ZSwgYnV0IGlzIGFcblx0ICogY29tcGxldGVseSBkaWZmZXJlbnQgYnJvd3NlciB3aXRoIGRpZmZlcmVudCBhYmlsaXRpZXMuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJT1MgVHJ1ZSBpZiBvdXIgYnJvd3NlciBpcyBzYWZhcmkgZm9yIGlPUyBkZXZpY2VzIChpUGFkLCBpUGhvbmUsIGFuZCBpUG9kKS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0FuZHJvaWQgVHJ1ZSBpZiBvdXIgYnJvd3NlciBpcyBBbmRyb2lkLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmxhY2tiZXJyeSBUcnVlIGlmIG91ciBicm93c2VyIGlzIEJsYWNrYmVycnkuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRmdW5jdGlvbiBCcm93c2VyRGV0ZWN0KCkge1xuXHRcdHRocm93IFwiQnJvd3NlckRldGVjdCBjYW5ub3QgYmUgaW5zdGFudGlhdGVkXCI7XG5cdH07XG5cblx0dmFyIGFnZW50ID0gQnJvd3NlckRldGVjdC5hZ2VudCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXHRCcm93c2VyRGV0ZWN0LmlzV2luZG93UGhvbmUgPSAoYWdlbnQuaW5kZXhPZihcIklFTW9iaWxlXCIpID4gLTEpIHx8IChhZ2VudC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKSA+IC0xKTtcblx0QnJvd3NlckRldGVjdC5pc0ZpcmVmb3ggPSAoYWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgPiAtMSk7XG5cdEJyb3dzZXJEZXRlY3QuaXNPcGVyYSA9ICh3aW5kb3cub3BlcmEgIT0gbnVsbCk7XG5cdEJyb3dzZXJEZXRlY3QuaXNDaHJvbWUgPSAoYWdlbnQuaW5kZXhPZihcIkNocm9tZVwiKSA+IC0xKTsgIC8vIE5PVEUgdGhhdCBDaHJvbWUgb24gQW5kcm9pZCByZXR1cm5zIHRydWUgYnV0IGlzIGEgY29tcGxldGVseSBkaWZmZXJlbnQgYnJvd3NlciB3aXRoIGRpZmZlcmVudCBhYmlsaXRpZXNcblx0QnJvd3NlckRldGVjdC5pc0lPUyA9IChhZ2VudC5pbmRleE9mKFwiaVBvZFwiKSA+IC0xIHx8IGFnZW50LmluZGV4T2YoXCJpUGhvbmVcIikgPiAtMSB8fCBhZ2VudC5pbmRleE9mKFwiaVBhZFwiKSA+IC0xKSAmJiAhQnJvd3NlckRldGVjdC5pc1dpbmRvd1Bob25lO1xuXHRCcm93c2VyRGV0ZWN0LmlzQW5kcm9pZCA9IChhZ2VudC5pbmRleE9mKFwiQW5kcm9pZFwiKSA+IC0xKSAmJiAhQnJvd3NlckRldGVjdC5pc1dpbmRvd1Bob25lO1xuXHRCcm93c2VyRGV0ZWN0LmlzQmxhY2tiZXJyeSA9IChhZ2VudC5pbmRleE9mKFwiQmxhY2tiZXJyeVwiKSA+IC0xKTtcblxuXHRjcmVhdGVqcy5Ccm93c2VyRGV0ZWN0ID0gQnJvd3NlckRldGVjdDtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEF1ZGlvU3ByaXRlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vLyAgTk9URSB0aGlzIGlzIFwiQ2xhc3NcIiBpcyBwdXJlbHkgdG8gZG9jdW1lbnQgYXVkaW9TcHJpdGUgU2V0dXAgYW5kIHVzYWdlLlxuXG5cbi8qKlxuICogPHN0cm9uZz5Ob3RlOiBBdWRpb1Nwcml0ZSBpcyBub3QgYSBjbGFzcywgYnV0IGl0cyB1c2FnZSBpcyBlYXNpbHkgbG9zdCBpbiB0aGUgZG9jdW1lbnRhdGlvbiwgc28gaXQgaGFzIGJlZW4gY2FsbGVkXG4gKiBvdXQgaGVyZSBmb3IgcXVpY2sgcmVmZXJlbmNlLjwvc3Ryb25nPlxuICpcbiAqIEF1ZGlvIHNwcml0ZXMgYXJlIG11Y2ggbGlrZSBDU1Mgc3ByaXRlcyBvciBpbWFnZSBzcHJpdGUgc2hlZXRzOiBtdWx0aXBsZSBhdWRpbyBhc3NldHMgZ3JvdXBlZCBpbnRvIGEgc2luZ2xlIGZpbGUuXG4gKiBBdWRpbyBzcHJpdGVzIHdvcmsgYXJvdW5kIGxpbWl0YXRpb25zIGluIGNlcnRhaW4gYnJvd3NlcnMsIHdoZXJlIG9ubHkgYSBzaW5nbGUgc291bmQgY2FuIGJlIGxvYWRlZCBhbmQgcGxheWVkIGF0IGFcbiAqIHRpbWUuIFdlIHJlY29tbWVuZCBhdCBsZWFzdCAzMDBtcyBvZiBzaWxlbmNlIGJldHdlZW4gYXVkaW8gY2xpcHMgdG8gZGVhbCB3aXRoIEhUTUwgYXVkaW8gdGFnIGluYWNjdXJhY3ksIGFuZCB0byBwcmV2ZW50XG4gKiBhY2NpZGVudGFsbHkgcGxheWluZyBiaXRzIG9mIHRoZSBuZWlnaGJvdXJpbmcgY2xpcHMuXG4gKlxuICogPHN0cm9uZz5CZW5lZml0cyBvZiBBdWRpbyBTcHJpdGVzOjwvc3Ryb25nPlxuICogPHVsPlxuICogICAgIDxsaT5Nb3JlIHJvYnVzdCBzdXBwb3J0IGZvciBvbGRlciBicm93c2VycyBhbmQgZGV2aWNlcyB0aGF0IG9ubHkgYWxsb3cgYSBzaW5nbGUgYXVkaW8gaW5zdGFuY2UsIHN1Y2ggYXMgaU9TIDUuPC9saT5cbiAqICAgICA8bGk+VGhleSBwcm92aWRlIGEgd29yayBhcm91bmQgZm9yIHRoZSBJbnRlcm5ldCBFeHBsb3JlciA5IGF1ZGlvIHRhZyBsaW1pdCwgd2hpY2ggcmVzdHJpY3RzIGhvdyBtYW55IGRpZmZlcmVudFxuICogICAgIHNvdW5kcyB0aGF0IGNvdWxkIGJlIGxvYWRlZCBhdCBvbmNlLjwvbGk+XG4gKiAgICAgPGxpPkZhc3RlciBsb2FkaW5nIGJ5IG9ubHkgcmVxdWlyaW5nIGEgc2luZ2xlIG5ldHdvcmsgcmVxdWVzdCBmb3Igc2V2ZXJhbCBzb3VuZHMsIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZXNcbiAqIHdoZXJlIHRoZSBuZXR3b3JrIHJvdW5kIHRyaXAgZm9yIGVhY2ggZmlsZSBjYW4gYWRkIHNpZ25pZmljYW50IGxhdGVuY3kuPC9saT5cbiAqIDwvdWw+XG4gKlxuICogPHN0cm9uZz5EcmF3YmFja3Mgb2YgQXVkaW8gU3ByaXRlczwvc3Ryb25nPlxuICogPHVsPlxuICogICAgIDxsaT5ObyBndWFyYW50ZWUgb2Ygc21vb3RoIGxvb3Bpbmcgd2hlbiB1c2luZyBIVE1MIG9yIEZsYXNoIGF1ZGlvLiBJZiB5b3UgaGF2ZSBhIHRyYWNrIHRoYXQgbmVlZHMgdG8gbG9vcFxuICogXHRcdHNtb290aGx5IGFuZCB5b3UgYXJlIHN1cHBvcnRpbmcgbm9uLXdlYiBhdWRpbyBicm93c2VycywgZG8gbm90IHVzZSBhdWRpbyBzcHJpdGVzIGZvciB0aGF0IHNvdW5kIGlmIHlvdSBjYW4gYXZvaWRcbiAqIFx0XHRpdC48L2xpPlxuICogICAgIDxsaT5ObyBndWFyYW50ZWUgdGhhdCBIVE1MIGF1ZGlvIHdpbGwgcGxheSBiYWNrIGltbWVkaWF0ZWx5LCBlc3BlY2lhbGx5IHRoZSBmaXJzdCB0aW1lLiBJbiBzb21lIGJyb3dzZXJzXG4gKiAgICAgKENocm9tZSEpLCBIVE1MIGF1ZGlvIHdpbGwgb25seSBsb2FkIGVub3VnaCB0byBwbGF5IHRocm91Z2ggYXQgdGhlIGN1cnJlbnQgZG93bmxvYWQgc3BlZWQgw6LigqzigJwgc28gd2UgcmVseSBvbiB0aGVcbiAqICAgICBgY2FucGxheXRocm91Z2hgIGV2ZW50IHRvIGRldGVybWluZSBpZiB0aGUgYXVkaW8gaXMgbG9hZGVkLiBTaW5jZSBhdWRpbyBzcHJpdGVzIG11c3QganVtcCBhaGVhZCB0byBwbGF5IHNwZWNpZmljXG4gKiAgICAgc291bmRzLCB0aGUgYXVkaW8gbWF5IG5vdCB5ZXQgaGF2ZSBkb3dubG9hZGVkIGZ1bGx5LjwvbGk+XG4gKiAgICAgPGxpPkF1ZGlvIHNwcml0ZXMgc2hhcmUgdGhlIHNhbWUgY29yZSBzb3VyY2UsIHNvIGlmIHlvdSBoYXZlIGEgc3ByaXRlIHdpdGggNSBzb3VuZHMgYW5kIGFyZSBsaW1pdGVkIHRvIDJcbiAqIFx0XHRjb25jdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZXMsIHlvdSBjYW4gb25seSBwbGF5IDIgb2YgdGhlIHNvdW5kcyBhdCB0aGUgc2FtZSB0aW1lLjwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIDxoND5FeGFtcGxlPC9oND5cbiAqXG4gKlx0XHRjcmVhdGVqcy5Tb3VuZC5pbml0aWFsaXplRGVmYXVsdFBsdWdpbnMoKTtcbiAqXHRcdHZhciBhc3NldHNQYXRoID0gXCIuL2Fzc2V0cy9cIjtcbiAqXHRcdHZhciBzb3VuZHMgPSBbe1xuICpcdFx0XHRzcmM6XCJNeUF1ZGlvU3ByaXRlLm9nZ1wiLCBkYXRhOiB7XG4gKlx0XHRcdFx0YXVkaW9TcHJpdGU6IFtcbiAqXHRcdFx0XHRcdHtpZDpcInNvdW5kMVwiLCBzdGFydFRpbWU6MCwgZHVyYXRpb246NTAwfSxcbiAqXHRcdFx0XHRcdHtpZDpcInNvdW5kMlwiLCBzdGFydFRpbWU6MTAwMCwgZHVyYXRpb246NDAwfSxcbiAqXHRcdFx0XHRcdHtpZDpcInNvdW5kM1wiLCBzdGFydFRpbWU6MTcwMCwgZHVyYXRpb246IDEwMDB9XG4gKlx0XHRcdFx0XX1cbiAqXHRcdFx0fVxuICpcdFx0XTtcbiAqXHRcdGNyZWF0ZWpzLlNvdW5kLmFsdGVybmF0ZUV4dGVuc2lvbnMgPSBbXCJtcDNcIl07XG4gKlx0XHRjcmVhdGVqcy5Tb3VuZC5vbihcImZpbGVsb2FkXCIsIGxvYWRTb3VuZCk7XG4gKlx0XHRjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kcyhzb3VuZHMsIGFzc2V0c1BhdGgpO1xuICpcdFx0Ly8gYWZ0ZXIgbG9hZCBpcyBjb21wbGV0ZVxuICpcdFx0Y3JlYXRlanMuU291bmQucGxheShcInNvdW5kMlwiKTtcbiAqXG4gKiBZb3UgY2FuIGFsc28gY3JlYXRlIGF1ZGlvIHNwcml0ZXMgb24gdGhlIGZseSBieSBzZXR0aW5nIHRoZSBzdGFydFRpbWUgYW5kIGR1cmF0aW9uIHdoZW4gY3JlYXRpbmcgYW4gbmV3IEFic3RyYWN0U291bmRJbnN0YW5jZS5cbiAqXG4gKiBcdFx0Y3JlYXRlanMuU291bmQucGxheShcIk15QXVkaW9TcHJpdGVcIiwge3N0YXJ0VGltZTogMTAwMCwgZHVyYXRpb246IDQwMH0pO1xuICpcbiAqIFRoZSBleGNlbGxlbnQgQ3JlYXRlSlMgY29tbXVuaXR5IGhhcyBjcmVhdGVkIGEgdG9vbCB0byBjcmVhdGUgYXVkaW8gc3ByaXRlcywgYXZhaWxhYmxlIGF0XG4gKiA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL3RvbmlzdGlpZ2kvYXVkaW9zcHJpdGVcIiB0YXJnZXQ9XCJfYmxhbmtcIj5odHRwczovL2dpdGh1Yi5jb20vdG9uaXN0aWlnaS9hdWRpb3Nwcml0ZTwvYT4sXG4gKiBhcyB3ZWxsIGFzIGEgPGEgaHJlZj1cImh0dHA6Ly9qc2ZpZGRsZS5uZXQvYmhhcmF0X2JhdHR1L2c4ZkZQLzEyL1wiIHRhcmdldD1cIl9ibGFua1wiPmpzZmlkZGxlPC9hPiB0byBjb252ZXJ0IHRoZSBvdXRwdXRcbiAqIHRvIFNvdW5kSlMgZm9ybWF0LlxuICpcbiAqIEBjbGFzcyBBdWRpb1Nwcml0ZVxuICogQHNpbmNlIDAuNi4wXG4gKi9cblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFBsYXlQcm9wc0NvbmZpZy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHRvIHN0b3JlIHRoZSBvcHRpb25hbCBwbGF5IHByb3BlcnRpZXMgcGFzc2VkIGluIHt7I2Nyb3NzTGluayBcIlNvdW5kL3BsYXlcIn19e3svY3Jvc3NMaW5rfX0gYW5kXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9wbGF5XCJ9fXt7L2Nyb3NzTGlua319IGNhbGxzLlxuXHQgKlxuXHQgKiBPcHRpb25hbCBQbGF5IFByb3BlcnRpZXMgSW5jbHVkZTpcblx0ICogPHVsPlxuXHQgKiA8bGk+aW50ZXJydXB0IC0gSG93IHRvIGludGVycnVwdCBhbnkgY3VycmVudGx5IHBsYXlpbmcgaW5zdGFuY2VzIG9mIGF1ZGlvIHdpdGggdGhlIHNhbWUgc291cmNlLFxuXHQgKiBpZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgaW5zdGFuY2VzIG9mIHRoZSBzb3VuZCBhcmUgYWxyZWFkeSBwbGF5aW5nLiBWYWx1ZXMgYXJlIGRlZmluZWQgYXMgPGNvZGU+SU5URVJSVVBUX1RZUEU8L2NvZGU+XG5cdCAqIGNvbnN0YW50cyBvbiB0aGUgU291bmQgY2xhc3MsIHdpdGggdGhlIGRlZmF1bHQgZGVmaW5lZCBieSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9kZWZhdWx0SW50ZXJydXB0QmVoYXZpb3I6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uPC9saT5cblx0ICogPGxpPmRlbGF5IC0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IHRoZSBzdGFydCBvZiBhdWRpbyBwbGF5YmFjaywgaW4gbWlsbGlzZWNvbmRzLjwvbGk+XG5cdCAqIDxsaT5vZmZzZXQgLSBUaGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBhdWRpbyB0byBiZWdpbiBwbGF5YmFjaywgaW4gbWlsbGlzZWNvbmRzLjwvbGk+XG5cdCAqIDxsaT5sb29wIC0gSG93IG1hbnkgdGltZXMgdGhlIGF1ZGlvIGxvb3BzIHdoZW4gaXQgcmVhY2hlcyB0aGUgZW5kIG9mIHBsYXliYWNrLiBUaGUgZGVmYXVsdCBpcyAwIChub1xuXHQgKiBsb29wcyksIGFuZCAtMSBjYW4gYmUgdXNlZCBmb3IgaW5maW5pdGUgcGxheWJhY2suPC9saT5cblx0ICogPGxpPnZvbHVtZSAtIFRoZSB2b2x1bWUgb2YgdGhlIHNvdW5kLCBiZXR3ZWVuIDAgYW5kIDEuIE5vdGUgdGhhdCB0aGUgbWFzdGVyIHZvbHVtZSBpcyBhcHBsaWVkXG5cdCAqIGFnYWluc3QgdGhlIGluZGl2aWR1YWwgdm9sdW1lLjwvbGk+XG5cdCAqIDxsaT5wYW4gLSBUaGUgbGVmdC1yaWdodCBwYW4gb2YgdGhlIHNvdW5kIChpZiBzdXBwb3J0ZWQpLCBiZXR3ZWVuIC0xIChsZWZ0KSBhbmQgMSAocmlnaHQpLjwvbGk+XG5cdCAqIDxsaT5zdGFydFRpbWUgLSBUbyBjcmVhdGUgYW4gYXVkaW8gc3ByaXRlICh3aXRoIGR1cmF0aW9uKSwgdGhlIGluaXRpYWwgb2Zmc2V0IHRvIHN0YXJ0IHBsYXliYWNrIGFuZCBsb29wIGZyb20sIGluIG1pbGxpc2Vjb25kcy48L2xpPlxuXHQgKiA8bGk+ZHVyYXRpb24gLSBUbyBjcmVhdGUgYW4gYXVkaW8gc3ByaXRlICh3aXRoIHN0YXJ0VGltZSksIHRoZSBhbW91bnQgb2YgdGltZSB0byBwbGF5IHRoZSBjbGlwIGZvciwgaW4gbWlsbGlzZWNvbmRzLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogXHR2YXIgcHBjID0gbmV3IGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZygpLnNldCh7aW50ZXJydXB0OiBjcmVhdGVqcy5Tb3VuZC5JTlRFUlJVUFRfQU5ZLCBsb29wOiAtMSwgdm9sdW1lOiAwLjV9KVxuXHQgKiBcdGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJteVNvdW5kXCIsIHBwYyk7XG5cdCAqIFx0bXlTb3VuZEluc3RhbmNlLnBsYXkocHBjKTtcblx0ICpcblx0ICogQGNsYXNzIFBsYXlQcm9wc0NvbmZpZ1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHNpbmNlIDAuNi4xXG5cdCAqL1xuXHQvLyBUT0RPIHRoaW5rIG9mIGEgYmV0dGVyIG5hbWUgZm9yIHRoaXMgY2xhc3Ncblx0dmFyIFBsYXlQcm9wc0NvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbi8vIFB1YmxpYyBQcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogSG93IHRvIGludGVycnVwdCBhbnkgY3VycmVudGx5IHBsYXlpbmcgaW5zdGFuY2VzIG9mIGF1ZGlvIHdpdGggdGhlIHNhbWUgc291cmNlLFxuXHRcdCAqIGlmIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBhbHJlYWR5IHBsYXlpbmcuIFZhbHVlcyBhcmUgZGVmaW5lZCBhc1xuXHRcdCAqIDxjb2RlPklOVEVSUlVQVF9UWVBFPC9jb2RlPiBjb25zdGFudHMgb24gdGhlIFNvdW5kIGNsYXNzLCB3aXRoIHRoZSBkZWZhdWx0IGRlZmluZWQgYnlcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9kZWZhdWx0SW50ZXJydXB0QmVoYXZpb3I6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IGludGVycnVwdFxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuaW50ZXJydXB0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSB0aGUgc3RhcnQgb2YgYXVkaW8gcGxheWJhY2ssIGluIG1pbGxpc2Vjb25kcy5cblx0XHQgKiBAcHJvcGVydHkgZGVsYXlcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmRlbGF5ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGF1ZGlvIHRvIGJlZ2luIHBsYXliYWNrLCBpbiBtaWxsaXNlY29uZHMuXG5cdFx0ICogQHByb3BlcnR5IG9mZnNldFxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMub2Zmc2V0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyBtYW55IHRpbWVzIHRoZSBhdWRpbyBsb29wcyB3aGVuIGl0IHJlYWNoZXMgdGhlIGVuZCBvZiBwbGF5YmFjay4gVGhlIGRlZmF1bHQgaXMgMCAobm9cblx0XHQgKiBsb29wcyksIGFuZCAtMSBjYW4gYmUgdXNlZCBmb3IgaW5maW5pdGUgcGxheWJhY2suXG5cdFx0ICogQHByb3BlcnR5IGxvb3Bcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmxvb3AgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHZvbHVtZSBvZiB0aGUgc291bmQsIGJldHdlZW4gMCBhbmQgMS4gTm90ZSB0aGF0IHRoZSBtYXN0ZXIgdm9sdW1lIGlzIGFwcGxpZWRcblx0XHQgKiBhZ2FpbnN0IHRoZSBpbmRpdmlkdWFsIHZvbHVtZS5cblx0XHQgKiBAcHJvcGVydHkgdm9sdW1lXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy52b2x1bWUgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxlZnQtcmlnaHQgcGFuIG9mIHRoZSBzb3VuZCAoaWYgc3VwcG9ydGVkKSwgYmV0d2VlbiAtMSAobGVmdCkgYW5kIDEgKHJpZ2h0KS5cblx0XHQgKiBAcHJvcGVydHkgcGFuXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5wYW4gPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVXNlZCB0byBjcmVhdGUgYW4gYXVkaW8gc3ByaXRlICh3aXRoIGR1cmF0aW9uKSwgdGhlIGluaXRpYWwgb2Zmc2V0IHRvIHN0YXJ0IHBsYXliYWNrIGFuZCBsb29wIGZyb20sIGluIG1pbGxpc2Vjb25kcy5cblx0XHQgKiBAcHJvcGVydHkgc3RhcnRUaW1lXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5zdGFydFRpbWUgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVXNlZCB0byBjcmVhdGUgYW4gYXVkaW8gc3ByaXRlICh3aXRoIHN0YXJ0VGltZSksIHRoZSBhbW91bnQgb2YgdGltZSB0byBwbGF5IHRoZSBjbGlwIGZvciwgaW4gbWlsbGlzZWNvbmRzLlxuXHRcdCAqIEBwcm9wZXJ0eSBkdXJhdGlvblxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuZHVyYXRpb24gPSBudWxsO1xuXHR9O1xuXHR2YXIgcCA9IFBsYXlQcm9wc0NvbmZpZy5wcm90b3R5cGUgPSB7fTtcblx0dmFyIHMgPSBQbGF5UHJvcHNDb25maWc7XG5cblxuLy8gU3RhdGljIE1ldGhvZHNcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBQbGF5UHJvcHNDb25maWcgZnJvbSBhbm90aGVyIFBsYXlQcm9wc0NvbmZpZyBvciBhbiBPYmplY3QuXG5cdCAqXG5cdCAqIEBtZXRob2QgY3JlYXRlXG5cdCAqIEBwYXJhbSB7UGxheVByb3BzQ29uZmlnfE9iamVjdH0gdmFsdWUgVGhlIHBsYXkgcHJvcGVydGllc1xuXHQgKiBAcmV0dXJucyB7UGxheVByb3BzQ29uZmlnfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIHMgfHwgdmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcblx0XHRcdHZhciBwcGMgPSBuZXcgY3JlYXRlanMuUGxheVByb3BzQ29uZmlnKCk7XG5cdFx0XHRwcGMuc2V0KHZhbHVlKTtcblx0XHRcdHJldHVybiBwcGM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlR5cGUgbm90IHJlY29nbml6ZWQuXCIpO1xuXHRcdH1cblx0fTtcblxuLy8gUHVibGljIE1ldGhvZHNcblx0LyoqXG5cdCAqIFByb3ZpZGVzIGEgY2hhaW5hYmxlIHNob3J0Y3V0IG1ldGhvZCBmb3Igc2V0dGluZyBhIG51bWJlciBvZiBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBQbGF5UHJvcHNDb25maWcgPSBuZXcgY3JlYXRlanMuUGxheVByb3BzQ29uZmlnKCkuc2V0KHtsb29wOi0xLCB2b2x1bWU6MC43fSk7XG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjb3B5IHRvIHRoZSBQbGF5UHJvcHNDb25maWcgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge1BsYXlQcm9wc0NvbmZpZ30gUmV0dXJucyB0aGUgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQqL1xuXHRwLnNldCA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1BsYXlQcm9wc0NvbmZpZ11cIjtcblx0fTtcblxuXHRjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcgPSBzO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU291bmQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgU291bmQgY2xhc3MgaXMgdGhlIHB1YmxpYyBBUEkgZm9yIGNyZWF0aW5nIHNvdW5kcywgY29udHJvbGxpbmcgdGhlIG92ZXJhbGwgc291bmQgbGV2ZWxzLCBhbmQgbWFuYWdpbmcgcGx1Z2lucy5cblx0ICogQWxsIFNvdW5kIEFQSXMgb24gdGhpcyBjbGFzcyBhcmUgc3RhdGljLlxuXHQgKlxuXHQgKiA8Yj5SZWdpc3RlcmluZyBhbmQgUHJlbG9hZGluZzwvYj48YnIgLz5cblx0ICogQmVmb3JlIHlvdSBjYW4gcGxheSBhIHNvdW5kLCBpdCA8Yj5tdXN0PC9iPiBiZSByZWdpc3RlcmVkLiBZb3UgY2FuIGRvIHRoaXMgd2l0aCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBvciByZWdpc3RlciBtdWx0aXBsZSBzb3VuZHMgdXNpbmcge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0uIElmIHlvdSBkb24ndCByZWdpc3RlciBhXG5cdCAqIHNvdW5kIHByaW9yIHRvIGF0dGVtcHRpbmcgdG8gcGxheSBpdCB1c2luZyB7eyNjcm9zc0xpbmsgXCJTb3VuZC9wbGF5XCJ9fXt7L2Nyb3NzTGlua319IG9yIGNyZWF0ZSBpdCB1c2luZyB7eyNjcm9zc0xpbmsgXCJTb3VuZC9jcmVhdGVJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogdGhlIHNvdW5kIHNvdXJjZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVnaXN0ZXJlZCBidXQgcGxheWJhY2sgd2lsbCBmYWlsIGFzIHRoZSBzb3VyY2Ugd2lsbCBub3QgYmUgcmVhZHkuIElmIHlvdSB1c2Vcblx0ICogPGEgaHJlZj1cImh0dHA6Ly9wcmVsb2FkanMuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+UHJlbG9hZEpTPC9hPiwgcmVnaXN0cmF0aW9uIGlzIGhhbmRsZWQgZm9yIHlvdSB3aGVuIHRoZSBzb3VuZCBpc1xuXHQgKiBwcmVsb2FkZWQuIEl0IGlzIHJlY29tbWVuZGVkIHRvIHByZWxvYWQgc291bmRzIGVpdGhlciBpbnRlcm5hbGx5IHVzaW5nIHRoZSByZWdpc3RlciBmdW5jdGlvbnMgb3IgZXh0ZXJuYWxseSB1c2luZ1xuXHQgKiBQcmVsb2FkSlMgc28gdGhleSBhcmUgcmVhZHkgd2hlbiB5b3Ugd2FudCB0byB1c2UgdGhlbS5cblx0ICpcblx0ICogPGI+UGxheWJhY2s8L2I+PGJyIC8+XG5cdCAqIFRvIHBsYXkgYSBzb3VuZCBvbmNlIGl0J3MgYmVlbiByZWdpc3RlcmVkIGFuZCBwcmVsb2FkZWQsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiU291bmQvcGxheVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdCAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gd2hpY2ggY2FuIGJlIHBhdXNlZCwgcmVzdW1lZCwgbXV0ZWQsIGV0Yy5cblx0ICogUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IGRvY3VtZW50YXRpb24gZm9yIG1vcmUgb24gdGhlIGluc3RhbmNlIGNvbnRyb2wgQVBJcy5cblx0ICpcblx0ICogPGI+UGx1Z2luczwvYj48YnIgLz5cblx0ICogQnkgZGVmYXVsdCwgdGhlIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319IG9yIHRoZSB7eyNjcm9zc0xpbmsgXCJIVE1MQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYXJlIHVzZWQgKHdoZW4gYXZhaWxhYmxlKSwgYWx0aG91Z2ggZGV2ZWxvcGVycyBjYW4gY2hhbmdlIHBsdWdpbiBwcmlvcml0eSBvciBhZGQgbmV3IHBsdWdpbnMgKHN1Y2ggYXMgdGhlXG5cdCAqIHByb3ZpZGVkIHt7I2Nyb3NzTGluayBcIkZsYXNoQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0pLiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSBBUElcblx0ICogbWV0aG9kcyBmb3IgbW9yZSBvbiB0aGUgcGxheWJhY2sgYW5kIHBsdWdpbiBBUElzLiBUbyBpbnN0YWxsIHBsdWdpbnMsIG9yIHNwZWNpZnkgYSBkaWZmZXJlbnQgcGx1Z2luIG9yZGVyLCBzZWVcblx0ICoge3sjY3Jvc3NMaW5rIFwiU291bmQvaW5zdGFsbFBsdWdpbnNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5GbGFzaEF1ZGlvUGx1Z2luLnN3ZlBhdGggPSBcIi4uL3NyYy9zb3VuZGpzL2ZsYXNoYXVkaW9cIjtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclBsdWdpbnMoW2NyZWF0ZWpzLldlYkF1ZGlvUGx1Z2luLCBjcmVhdGVqcy5GbGFzaEF1ZGlvUGx1Z2luXSk7XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQuYWx0ZXJuYXRlRXh0ZW5zaW9ucyA9IFtcIm1wM1wiXTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5vbihcImZpbGVsb2FkXCIsIHRoaXMubG9hZEhhbmRsZXIsIHRoaXMpO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyU291bmQoXCJwYXRoL3RvL215U291bmQub2dnXCIsIFwic291bmRcIik7XG5cdCAqICAgICAgZnVuY3Rpb24gbG9hZEhhbmRsZXIoZXZlbnQpIHtcbiAgICAgKiAgICAgICAgICAvLyBUaGlzIGlzIGZpcmVkIGZvciBlYWNoIHNvdW5kIHRoYXQgaXMgcmVnaXN0ZXJlZC5cbiAgICAgKiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVqcy5Tb3VuZC5wbGF5KFwic291bmRcIik7ICAvLyBwbGF5IHVzaW5nIGlkLiAgQ291bGQgYWxzbyB1c2UgZnVsbCBzb3VyY2UgcGF0aCBvciBldmVudC5zcmMuXG4gICAgICogICAgICAgICAgaW5zdGFuY2Uub24oXCJjb21wbGV0ZVwiLCB0aGlzLmhhbmRsZUNvbXBsZXRlLCB0aGlzKTtcbiAgICAgKiAgICAgICAgICBpbnN0YW5jZS52b2x1bWUgPSAwLjU7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29uY3VycmVudGx5IHBsYXlpbmcgaW5zdGFuY2VzIG9mIHRoZSBzYW1lIHNvdW5kIGNhbiBiZSBzcGVjaWZpZWQgaW4gdGhlIFwiZGF0YVwiIGFyZ3VtZW50XG5cdCAqIG9mIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRcIn19e3svY3Jvc3NMaW5rfX0uICBOb3RlIHRoYXQgaWYgbm90IHNwZWNpZmllZCwgdGhlIGFjdGl2ZSBwbHVnaW4gd2lsbCBhcHBseVxuXHQgKiBhIGRlZmF1bHQgbGltaXQuICBDdXJyZW50bHkgSFRNTEF1ZGlvUGx1Z2luIHNldHMgYSBkZWZhdWx0IGxpbWl0IG9mIDIsIHdoaWxlIFdlYkF1ZGlvUGx1Z2luIGFuZCBGbGFzaEF1ZGlvUGx1Z2luIHNldCBhXG5cdCAqIGRlZmF1bHQgbGltaXQgb2YgMTAwLlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyU291bmQoXCJzb3VuZC5tcDNcIiwgXCJzb3VuZElkXCIsIDQpO1xuXHQgKlxuXHQgKiBTb3VuZCBjYW4gYmUgdXNlZCBhcyBhIHBsdWdpbiB3aXRoIFByZWxvYWRKUyB0byBoZWxwIHByZWxvYWQgYXVkaW8gcHJvcGVybHkuIEF1ZGlvIHByZWxvYWRlZCB3aXRoIFByZWxvYWRKUyBpc1xuXHQgKiBhdXRvbWF0aWNhbGx5IHJlZ2lzdGVyZWQgd2l0aCB0aGUgU291bmQgY2xhc3MuIFdoZW4gYXVkaW8gaXMgbm90IHByZWxvYWRlZCwgU291bmQgd2lsbCBkbyBhbiBhdXRvbWF0aWMgaW50ZXJuYWxcblx0ICogbG9hZC4gQXMgYSByZXN1bHQsIGl0IG1heSBmYWlsIHRvIHBsYXkgdGhlIGZpcnN0IHRpbWUgcGxheSBpcyBjYWxsZWQgaWYgdGhlIGF1ZGlvIGlzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLiBVc2Vcblx0ICogdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IHRvIGRldGVybWluZSB3aGVuIGEgc291bmQgaGFzIGZpbmlzaGVkIGludGVybmFsbHlcblx0ICogcHJlbG9hZGluZy4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCBhbGwgYXVkaW8gaXMgcHJlbG9hZGVkIGJlZm9yZSBpdCBpcyBwbGF5ZWQuXG5cdCAqXG5cdCAqICAgICAgdmFyIHF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSgpO1xuXHQgKlx0XHRxdWV1ZS5pbnN0YWxsUGx1Z2luKGNyZWF0ZWpzLlNvdW5kKTtcblx0ICpcblx0ICogPGI+QXVkaW8gU3ByaXRlczwvYj48YnIgLz5cblx0ICogU291bmRKUyBoYXMgYWRkZWQgc3VwcG9ydCBmb3Ige3sjY3Jvc3NMaW5rIFwiQXVkaW9TcHJpdGVcIn19e3svY3Jvc3NMaW5rfX0sIGF2YWlsYWJsZSBhcyBvZiB2ZXJzaW9uIDAuNi4wLlxuXHQgKiBGb3IgdGhvc2UgdW5mYW1pbGlhciB3aXRoIGF1ZGlvIHNwcml0ZXMsIHRoZXkgYXJlIG11Y2ggbGlrZSBDU1Mgc3ByaXRlcyBvciBzcHJpdGUgc2hlZXRzOiBtdWx0aXBsZSBhdWRpbyBhc3NldHNcblx0ICogZ3JvdXBlZCBpbnRvIGEgc2luZ2xlIGZpbGUuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0dmFyIGFzc2V0c1BhdGggPSBcIi4vYXNzZXRzL1wiO1xuXHQgKlx0XHR2YXIgc291bmRzID0gW3tcblx0ICpcdFx0XHRzcmM6XCJNeUF1ZGlvU3ByaXRlLm9nZ1wiLCBkYXRhOiB7XG5cdCAqXHRcdFx0XHRhdWRpb1Nwcml0ZTogW1xuXHQgKlx0XHRcdFx0XHR7aWQ6XCJzb3VuZDFcIiwgc3RhcnRUaW1lOjAsIGR1cmF0aW9uOjUwMH0sXG5cdCAqXHRcdFx0XHRcdHtpZDpcInNvdW5kMlwiLCBzdGFydFRpbWU6MTAwMCwgZHVyYXRpb246NDAwfSxcblx0ICpcdFx0XHRcdFx0e2lkOlwic291bmQzXCIsIHN0YXJ0VGltZToxNzAwLCBkdXJhdGlvbjogMTAwMH1cblx0ICpcdFx0XHRcdF19XG4gXHQgKlx0XHRcdH1cblx0ICpcdFx0XTtcblx0ICpcdFx0Y3JlYXRlanMuU291bmQuYWx0ZXJuYXRlRXh0ZW5zaW9ucyA9IFtcIm1wM1wiXTtcblx0ICpcdFx0Y3JlYXRlanMuU291bmQub24oXCJmaWxlbG9hZFwiLCBsb2FkU291bmQpO1xuXHQgKlx0XHRjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kcyhzb3VuZHMsIGFzc2V0c1BhdGgpO1xuXHQgKlx0XHQvLyBhZnRlciBsb2FkIGlzIGNvbXBsZXRlXG5cdCAqXHRcdGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJzb3VuZDJcIik7XG5cdCAqXG5cdCAqIDxiPk1vYmlsZSBQbGF5YmFjazwvYj48YnIgLz5cblx0ICogRGV2aWNlcyBydW5uaW5nIGlPUyByZXF1aXJlIHRoZSBXZWJBdWRpbyBjb250ZXh0IHRvIGJlIFwidW5sb2NrZWRcIiBieSBwbGF5aW5nIGF0IGxlYXN0IG9uZSBzb3VuZCBpbnNpZGUgb2YgYSB1c2VyLVxuXHQgKiBpbml0aWF0ZWQgZXZlbnQgKHN1Y2ggYXMgdG91Y2gvY2xpY2spLiBFYXJsaWVyIHZlcnNpb25zIG9mIFNvdW5kSlMgaW5jbHVkZWQgYSBcIk1vYmlsZVNhZmVcIiBzYW1wbGUsIGJ1dCB0aGlzIGlzIG5vXG5cdCAqIGxvbmdlciBuZWNlc3NhcnkgYXMgb2YgU291bmRKUyAwLjYuMi5cblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPlxuXHQgKiAgICAgICAgIEluIFNvdW5kSlMgMC40LjEgYW5kIGFib3ZlLCB5b3UgY2FuIGVpdGhlciBpbml0aWFsaXplIHBsdWdpbnMgb3IgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpbi9wbGF5RW1wdHlTb3VuZFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiAgICAgICAgIG1ldGhvZCBpbiB0aGUgY2FsbCBzdGFjayBvZiBhIHVzZXIgaW5wdXQgZXZlbnQgdG8gbWFudWFsbHkgdW5sb2NrIHRoZSBhdWRpbyBjb250ZXh0LlxuXHQgKiAgICAgPC9saT5cblx0ICogICAgIDxsaT5cblx0ICogICAgICAgICBJbiBTb3VuZEpTIDAuNi4yIGFuZCBhYm92ZSwgU291bmRKUyB3aWxsIGF1dG9tYXRpY2FsbHkgbGlzdGVuIGZvciB0aGUgZmlyc3QgZG9jdW1lbnQtbGV2ZWwgXCJtb3VzZWRvd25cIlxuXHQgKiAgICAgICAgIGFuZCBcInRvdWNoZW5kXCIgZXZlbnQsIGFuZCB1bmxvY2sgV2ViQXVkaW8uIFRoaXMgd2lsbCBjb250aW51ZSB0byBjaGVjayB0aGVzZSBldmVudHMgdW50aWwgdGhlIFdlYkF1ZGlvXG5cdCAqICAgICAgICAgY29udGV4dCBiZWNvbWVzIFwidW5sb2NrZWRcIiAoY2hhbmdlcyBmcm9tIFwic3VzcGVuZGVkXCIgdG8gXCJydW5uaW5nXCIpXG5cdCAqICAgICA8L2xpPlxuXHQgKiAgICAgPGxpPlxuXHQgKiAgICAgICAgIEJvdGggdGhlIFwibW91c2Vkb3duXCIgYW5kIFwidG91Y2hlbmRcIiBldmVudHMgY2FuIGJlIHVzZWQgdG8gdW5sb2NrIGF1ZGlvIGluIGlPUzkrLCB0aGUgXCJ0b3VjaHN0YXJ0XCIgZXZlbnRcblx0ICogICAgICAgICB3aWxsIHdvcmsgaW4gaU9TOCBhbmQgYmVsb3cuIFRoZSBcInRvdWNoZW5kXCIgZXZlbnQgd2lsbCBvbmx5IHdvcmsgaW4gaU9TOSB3aGVuIHRoZSBnZXN0dXJlIGlzIGludGVycHJldGVkXG5cdCAqICAgICAgICAgYXMgYSBcImNsaWNrXCIsIHNvIGlmIHRoZSB1c2VyIGxvbmctcHJlc3NlcyB0aGUgYnV0dG9uLCBpdCB3aWxsIG5vIGxvbmdlciB3b3JrLlxuXHQgKiAgICAgPC9saT5cblx0ICogICAgIDxsaT5cblx0ICogICAgICAgICBXaGVuIHVzaW5nIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dy5jcmVhdGVqcy5jb20vZG9jcy9lYXNlbGpzL2NsYXNzZXMvVG91Y2guaHRtbFwiPkVhc2VsSlMgVG91Y2ggY2xhc3M8L2E+LFxuXHQgKiAgICAgICAgIHRoZSBcIm1vdXNlZG93blwiIGV2ZW50IHdpbGwgbm90IGZpcmUgd2hlbiBhIGNhbnZhcyBpcyBjbGlja2VkLCBzaW5jZSBNb3VzZUV2ZW50cyBhcmUgcHJldmVudGVkLCB0byBlbnN1cmVcblx0ICogICAgICAgICBvbmx5IHRvdWNoIGV2ZW50cyBmaXJlLiBUbyBnZXQgYXJvdW5kIHRoaXMsIHlvdSBjYW4gZWl0aGVyIHJlbHkgb24gXCJ0b3VjaGVuZFwiLCBvcjpcblx0ICogICAgICAgICA8b2w+XG5cdCAqICAgICAgICAgICAgIDxsaT5TZXQgdGhlIGBhbGxvd0RlZmF1bHRgIHByb3BlcnR5IG9uIHRoZSBUb3VjaCBjbGFzcyBjb25zdHJ1Y3RvciB0byBgdHJ1ZWAgKGRlZmF1bHRzIHRvIGBmYWxzZWApLjwvbGk+XG5cdCAqICAgICAgICAgICAgIDxsaT5TZXQgdGhlIGBwcmV2ZW50U2VsZWN0aW9uYCBwcm9wZXJ0eSBvbiB0aGUgRWFzZWxKUyBgU3RhZ2VgIHRvIGBmYWxzZWAuPC9saT5cblx0ICogICAgICAgICA8L29sPlxuXHQgKiAgICAgICAgIFRoZXNlIHNldHRpbmdzIG1heSBjaGFuZ2UgaG93IHlvdXIgYXBwbGljYXRpb24gYmVoYXZlcywgYW5kIGFyZSBub3QgcmVjb21tZW5kZWQuXG5cdCAqICAgICA8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiA8Yj5Mb2FkaW5nIEFsdGVybmF0ZSBQYXRocyBhbmQgRXh0ZW5zaW9uLWxlc3MgRmlsZXM8L2I+PGJyIC8+XG5cdCAqIFNvdW5kSlMgc3VwcG9ydHMgbG9hZGluZyBhbHRlcm5hdGUgcGF0aHMgYW5kIGV4dGVuc2lvbi1sZXNzIGZpbGVzIGJ5IHBhc3NpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYSBzdHJpbmcgZm9yXG5cdCAqIHRoZSBgc3JjYCBwcm9wZXJ0eSwgd2hpY2ggaXMgYSBoYXNoIHVzaW5nIHRoZSBmb3JtYXQgYHtleHRlbnNpb246XCJwYXRoXCIsIGV4dGVuc2lvbjI6XCJwYXRoMlwifWAuIFRoZXNlIGxhYmVscyBhcmVcblx0ICogaG93IFNvdW5kSlMgZGV0ZXJtaW5lcyBpZiB0aGUgYnJvd3NlciB3aWxsIHN1cHBvcnQgdGhlIHNvdW5kLiBUaGlzIGFsc28gZW5hYmxlcyBtdWx0aXBsZSBmb3JtYXRzIHRvIGxpdmUgaW5cblx0ICogZGlmZmVyZW50IGZvbGRlcnMsIG9yIG9uIENETnMsIHdoaWNoIG9mdGVuIGhhcyBjb21wbGV0ZWx5IGRpZmZlcmVudCBmaWxlbmFtZXMgZm9yIGVhY2ggZmlsZS5cblx0ICpcblx0ICogUHJpb3JpdHkgaXMgZGV0ZXJtaW5lZCBieSB0aGUgcHJvcGVydHkgb3JkZXIgKGZpcnN0IHByb3BlcnR5IGlzIHRyaWVkIGZpcnN0KS4gIFRoaXMgaXMgc3VwcG9ydGVkIGJ5IGJvdGggaW50ZXJuYWwgbG9hZGluZ1xuXHQgKiBhbmQgbG9hZGluZyB3aXRoIFByZWxvYWRKUy5cblx0ICpcblx0ICogPGVtPk5vdGU6IGFuIGlkIGlzIHJlcXVpcmVkIGZvciBwbGF5YmFjay48L2VtPlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqXHRcdHZhciBzb3VuZHMgPSB7cGF0aDpcIi4vYXVkaW9QYXRoL1wiLFxuXHQgKiBcdFx0XHRcdG1hbmlmZXN0OiBbXG5cdCAqXHRcdFx0XHR7aWQ6IFwiY29vbFwiLCBzcmM6IHttcDM6XCJtcDMvYXdlc29tZS5tcDNcIiwgb2dnOlwibm9FeHRlbnNpb25PZ2dGaWxlXCJ9fVxuXHQgKlx0XHRdfTtcblx0ICpcblx0ICpcdFx0Y3JlYXRlanMuU291bmQuYWx0ZXJuYXRlRXh0ZW5zaW9ucyA9IFtcIm1wM1wiXTtcblx0ICpcdFx0Y3JlYXRlanMuU291bmQuYWRkRXZlbnRMaXN0ZW5lcihcImZpbGVsb2FkXCIsIGhhbmRsZUxvYWQpO1xuXHQgKlx0XHRjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kcyhzb3VuZHMpO1xuXHQgKlxuXHQgKiA8aDM+S25vd24gQnJvd3NlciBhbmQgT1MgaXNzdWVzPC9oMz5cblx0ICogPGI+SUUgOSBIVE1MIEF1ZGlvIGxpbWl0YXRpb25zPC9iPjxiciAvPlxuXHQgKiA8dWw+PGxpPlRoZXJlIGlzIGEgZGVsYXkgaW4gYXBwbHlpbmcgdm9sdW1lIGNoYW5nZXMgdG8gdGFncyB0aGF0IG9jY3VycyBvbmNlIHBsYXliYWNrIGlzIHN0YXJ0ZWQuIFNvIGlmIHlvdSBoYXZlXG5cdCAqIG11dGVkIGFsbCBzb3VuZHMsIHRoZXkgd2lsbCBhbGwgcGxheSBkdXJpbmcgdGhpcyBkZWxheSB1bnRpbCB0aGUgbXV0ZSBhcHBsaWVzIGludGVybmFsbHkuIFRoaXMgaGFwcGVucyByZWdhcmRsZXNzIG9mXG5cdCAqIHdoZW4gb3IgaG93IHlvdSBhcHBseSB0aGUgdm9sdW1lIGNoYW5nZSwgYXMgdGhlIHRhZyBzZWVtcyB0byBuZWVkIHRvIHBsYXkgdG8gYXBwbHkgaXQuPC9saT5cbiAgICAgKiA8bGk+TVAzIGVuY29kaW5nIHdpbGwgbm90IGFsd2F5cyB3b3JrIGZvciBhdWRpbyB0YWdzLCBwYXJ0aWN1bGFybHkgaW4gSW50ZXJuZXQgRXhwbG9yZXIuIFdlJ3ZlIGZvdW5kIGRlZmF1bHRcblx0ICogZW5jb2Rpbmcgd2l0aCA2NGticHMgd29ya3MuPC9saT5cblx0ICogPGxpPk9jY2FzaW9uYWxseSB2ZXJ5IHNob3J0IHNhbXBsZXMgd2lsbCBnZXQgY3V0IG9mZi48L2xpPlxuXHQgKiA8bGk+VGhlcmUgaXMgYSBsaW1pdCB0byBob3cgbWFueSBhdWRpbyB0YWdzIHlvdSBjYW4gbG9hZCBhbmQgcGxheSBhdCBvbmNlLCB3aGljaCBhcHBlYXJzIHRvIGJlIGRldGVybWluZWQgYnlcblx0ICogaGFyZHdhcmUgYW5kIGJyb3dzZXIgc2V0dGluZ3MuICBTZWUge3sjY3Jvc3NMaW5rIFwiSFRNTEF1ZGlvUGx1Z2luLk1BWF9JTlNUQU5DRVNcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGEgc2FmZVxuXHQgKiBlc3RpbWF0ZS48L2xpPjwvdWw+XG5cdCAqXG5cdCAqIDxiPkZpcmVmb3ggMjUgV2ViIEF1ZGlvIGxpbWl0YXRpb25zPC9iPlxuXHQgKiA8dWw+PGxpPm1wMyBhdWRpbyBmaWxlcyBkbyBub3QgbG9hZCBwcm9wZXJseSBvbiBhbGwgd2luZG93cyBtYWNoaW5lcywgcmVwb3J0ZWRcblx0ICogPGEgaHJlZj1cImh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTkyOTk2OVwiIHRhcmdldD1cIl9ibGFua1wiPmhlcmU8L2E+LiA8L2JyPlxuXHQgKiBGb3IgdGhpcyByZWFzb24gaXQgaXMgcmVjb21tZW5kZWQgdG8gcGFzcyBhbm90aGVyIEZGIHN1cHBvcnRlZCB0eXBlIChpZSBvZ2cpIGZpcnN0IHVudGlsIHRoaXMgYnVnIGlzIHJlc29sdmVkLCBpZlxuXHQgKiBwb3NzaWJsZS48L2xpPjwvdWw+XG5cblx0ICogPGI+U2FmYXJpIGxpbWl0YXRpb25zPC9iPjxiciAvPlxuXHQgKiA8dWw+PGxpPlNhZmFyaSByZXF1aXJlcyBRdWlja3RpbWUgdG8gYmUgaW5zdGFsbGVkIGZvciBhdWRpbyBwbGF5YmFjay48L2xpPjwvdWw+XG5cdCAqXG5cdCAqIDxiPmlPUyA2IFdlYiBBdWRpbyBsaW1pdGF0aW9uczwvYj48YnIgLz5cblx0ICogPHVsPjxsaT5Tb3VuZCBpcyBpbml0aWFsbHkgbG9ja2VkLCBhbmQgbXVzdCBiZSB1bmxvY2tlZCB2aWEgYSB1c2VyLWluaXRpYXRlZCBldmVudC4gUGxlYXNlIHNlZSB0aGUgc2VjdGlvbiBvblxuXHQgKiBNb2JpbGUgUGxheWJhY2sgYWJvdmUuPC9saT5cblx0ICogPGxpPkEgYnVnIGV4aXN0cyB0aGF0IHdpbGwgZGlzdG9ydCB1bi1jYWNoZWQgd2ViIGF1ZGlvIHdoZW4gYSB2aWRlbyBlbGVtZW50IGlzIHByZXNlbnQgaW4gdGhlIERPTSB0aGF0IGhhcyBhdWRpb1xuXHQgKiBhdCBhIGRpZmZlcmVudCBzYW1wbGVSYXRlLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIDxiPkFuZHJvaWQgSFRNTCBBdWRpbyBsaW1pdGF0aW9uczwvYj48YnIgLz5cblx0ICogPHVsPjxsaT5XZSBoYXZlIG5vIGNvbnRyb2wgb3ZlciBhdWRpbyB2b2x1bWUuIE9ubHkgdGhlIHVzZXIgY2FuIHNldCB2b2x1bWUgb24gdGhlaXIgZGV2aWNlLjwvbGk+XG5cdCAqIDxsaT5XZSBjYW4gb25seSBwbGF5IGF1ZGlvIGluc2lkZSBhIHVzZXIgZXZlbnQgKHRvdWNoL2NsaWNrKS4gIFRoaXMgY3VycmVudGx5IG1lYW5zIHlvdSBjYW5ub3QgbG9vcCBzb3VuZCBvciB1c2Vcblx0ICogYSBkZWxheS48L2xpPjwvdWw+XG5cdCAqXG5cdCAqIDxiPldlYiBBdWRpbyBhbmQgUHJlbG9hZEpTPC9iPjxiciAvPlxuXHQgKiA8dWw+PGxpPldlYiBBdWRpbyBtdXN0IGJlIGxvYWRlZCB0aHJvdWdoIFhIUiwgdGhlcmVmb3JlIHdoZW4gdXNlZCB3aXRoIFByZWxvYWRKUywgdGFnIGxvYWRpbmcgaXMgbm90IHBvc3NpYmxlLlxuXHQgKiBUaGlzIG1lYW5zIHRoYXQgdGFnIGxvYWRpbmcgY2FuIG5vdCBiZSB1c2VkIHRvIGF2b2lkIGNyb3NzIGRvbWFpbiBpc3N1ZXMuPC9saT48dWw+XG5cdCAqXG5cdCAqIEBjbGFzcyBTb3VuZFxuXHQgKiBAc3RhdGljXG5cdCAqIEB1c2VzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKi9cblx0ZnVuY3Rpb24gU291bmQoKSB7XG5cdFx0dGhyb3cgXCJTb3VuZCBjYW5ub3QgYmUgaW5zdGFudGlhdGVkXCI7XG5cdH1cblxuXHR2YXIgcyA9IFNvdW5kO1xuXG5cbi8vIFN0YXRpYyBQcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBUaGUgaW50ZXJydXB0IHZhbHVlIHRvIGludGVycnVwdCBhbnkgY3VycmVudGx5IHBsYXlpbmcgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBzb3VyY2UsIGlmIHRoZSBtYXhpbXVtIG51bWJlciBvZlxuXHQgKiBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBhbHJlYWR5IHBsYXlpbmcuXG5cdCAqIEBwcm9wZXJ0eSBJTlRFUlJVUFRfQU5ZXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGFueVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLklOVEVSUlVQVF9BTlkgPSBcImFueVwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgaW50ZXJydXB0IHZhbHVlIHRvIGludGVycnVwdCB0aGUgZWFybGllc3QgY3VycmVudGx5IHBsYXlpbmcgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBzb3VyY2UgdGhhdCBwcm9ncmVzc2VkIHRoZVxuXHQgKiBsZWFzdCBkaXN0YW5jZSBpbiB0aGUgYXVkaW8gdHJhY2ssIGlmIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBhbHJlYWR5IHBsYXlpbmcuXG5cdCAqIEBwcm9wZXJ0eSBJTlRFUlJVUFRfRUFSTFlcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgZWFybHlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5JTlRFUlJVUFRfRUFSTFkgPSBcImVhcmx5XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBpbnRlcnJ1cHQgdmFsdWUgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIHNvdXJjZSB0aGF0IHByb2dyZXNzZWQgdGhlIG1vc3Rcblx0ICogZGlzdGFuY2UgaW4gdGhlIGF1ZGlvIHRyYWNrLCBpZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgaW5zdGFuY2VzIG9mIHRoZSBzb3VuZCBhcmUgYWxyZWFkeSBwbGF5aW5nLlxuXHQgKiBAcHJvcGVydHkgSU5URVJSVVBUX0xBVEVcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgbGF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLklOVEVSUlVQVF9MQVRFID0gXCJsYXRlXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBpbnRlcnJ1cHQgdmFsdWUgdG8gbm90IGludGVycnVwdCBhbnkgY3VycmVudGx5IHBsYXlpbmcgaW5zdGFuY2VzIHdpdGggdGhlIHNhbWUgc291cmNlLCBpZiB0aGUgbWF4aW11bSBudW1iZXIgb2Zcblx0ICogaW5zdGFuY2VzIG9mIHRoZSBzb3VuZCBhcmUgYWxyZWFkeSBwbGF5aW5nLlxuXHQgKiBAcHJvcGVydHkgSU5URVJSVVBUX05PTkVcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgbm9uZVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLklOVEVSUlVQVF9OT05FID0gXCJub25lXCI7XG5cblx0LyoqXG5cdCAqIERlZmluZXMgdGhlIHBsYXlTdGF0ZSBvZiBhbiBpbnN0YW5jZSB0aGF0IGlzIHN0aWxsIGluaXRpYWxpemluZy5cblx0ICogQHByb3BlcnR5IFBMQVlfSU5JVEVEXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHBsYXlJbml0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5QTEFZX0lOSVRFRCA9IFwicGxheUluaXRlZFwiO1xuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIHRoZSBwbGF5U3RhdGUgb2YgYW4gaW5zdGFuY2UgdGhhdCBpcyBjdXJyZW50bHkgcGxheWluZyBvciBwYXVzZWQuXG5cdCAqIEBwcm9wZXJ0eSBQTEFZX1NVQ0NFRURFRFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBwbGF5U3VjY2VlZGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuUExBWV9TVUNDRUVERUQgPSBcInBsYXlTdWNjZWVkZWRcIjtcblxuXHQvKipcblx0ICogRGVmaW5lcyB0aGUgcGxheVN0YXRlIG9mIGFuIGluc3RhbmNlIHRoYXQgd2FzIGludGVycnVwdGVkIGJ5IGFub3RoZXIgaW5zdGFuY2UuXG5cdCAqIEBwcm9wZXJ0eSBQTEFZX0lOVEVSUlVQVEVEXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHBsYXlJbnRlcnJ1cHRlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlBMQVlfSU5URVJSVVBURUQgPSBcInBsYXlJbnRlcnJ1cHRlZFwiO1xuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIHRoZSBwbGF5U3RhdGUgb2YgYW4gaW5zdGFuY2UgdGhhdCBjb21wbGV0ZWQgcGxheWJhY2suXG5cdCAqIEBwcm9wZXJ0eSBQTEFZX0ZJTklTSEVEXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHBsYXlGaW5pc2hlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlBMQVlfRklOSVNIRUQgPSBcInBsYXlGaW5pc2hlZFwiO1xuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIHRoZSBwbGF5U3RhdGUgb2YgYW4gaW5zdGFuY2UgdGhhdCBmYWlsZWQgdG8gcGxheS4gVGhpcyBpcyB1c3VhbGx5IGNhdXNlZCBieSBhIGxhY2sgb2YgYXZhaWxhYmxlIGNoYW5uZWxzXG5cdCAqIHdoZW4gdGhlIGludGVycnVwdCBtb2RlIHdhcyBcIklOVEVSUlVQVF9OT05FXCIsIHRoZSBwbGF5YmFjayBzdGFsbGVkLCBvciB0aGUgc291bmQgY291bGQgbm90IGJlIGZvdW5kLlxuXHQgKiBAcHJvcGVydHkgUExBWV9GQUlMRURcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgcGxheUZhaWxlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlBMQVlfRkFJTEVEID0gXCJwbGF5RmFpbGVkXCI7XG5cblx0LyoqXG5cdCAqIEEgbGlzdCBvZiB0aGUgZGVmYXVsdCBzdXBwb3J0ZWQgZXh0ZW5zaW9ucyB0aGF0IFNvdW5kIHdpbGwgPGk+dHJ5PC9pPiB0byBwbGF5LiBQbHVnaW5zIHdpbGwgY2hlY2sgaWYgdGhlIGJyb3dzZXJcblx0ICogY2FuIHBsYXkgdGhlc2UgdHlwZXMsIHNvIG1vZGlmeWluZyB0aGlzIGxpc3QgYmVmb3JlIGEgcGx1Z2luIGlzIGluaXRpYWxpemVkIHdpbGwgYWxsb3cgdGhlIHBsdWdpbnMgdG8gdHJ5IHRvXG5cdCAqIHN1cHBvcnQgYWRkaXRpb25hbCBtZWRpYSB0eXBlcy5cblx0ICpcblx0ICogTk9URSB0aGlzIGRvZXMgbm90IGN1cnJlbnRseSB3b3JrIGZvciB7eyNjcm9zc0xpbmsgXCJGbGFzaEF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBNb3JlIGRldGFpbHMgb24gZmlsZSBmb3JtYXRzIGNhbiBiZSBmb3VuZCBhdCA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BdWRpb19maWxlX2Zvcm1hdFwiIHRhcmdldD1cIl9ibGFua1wiPmh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXVkaW9fZmlsZV9mb3JtYXQ8L2E+LjxiciAvPlxuXHQgKiBBIHZlcnkgZGV0YWlsZWQgbGlzdCBvZiBmaWxlIGZvcm1hdHMgY2FuIGJlIGZvdW5kIGF0IDxhIGhyZWY9XCJodHRwOi8vd3d3LmZpbGVpbmZvLmNvbS9maWxldHlwZXMvYXVkaW9cIiB0YXJnZXQ9XCJfYmxhbmtcIj5odHRwOi8vd3d3LmZpbGVpbmZvLmNvbS9maWxldHlwZXMvYXVkaW88L2E+LlxuXHQgKiBAcHJvcGVydHkgU1VQUE9SVEVEX0VYVEVOU0lPTlNcblx0ICogQHR5cGUge0FycmF5W1N0cmluZ119XG5cdCAqIEBkZWZhdWx0IFtcIm1wM1wiLCBcIm9nZ1wiLCBcIm9wdXNcIiwgXCJtcGVnXCIsIFwid2F2XCIsIFwibTRhXCIsIFwibXA0XCIsIFwiYWlmZlwiLCBcIndtYVwiLCBcIm1pZFwiXVxuXHQgKiBAc2luY2UgMC40LjBcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5TVVBQT1JURURfRVhURU5TSU9OUyA9IFtcIm1wM1wiLCBcIm9nZ1wiLCBcIm9wdXNcIiwgXCJtcGVnXCIsIFwid2F2XCIsIFwibTRhXCIsIFwibXA0XCIsIFwiYWlmZlwiLCBcIndtYVwiLCBcIm1pZFwiXTtcblxuXHQvKipcblx0ICogU29tZSBleHRlbnNpb25zIHVzZSBhbm90aGVyIHR5cGUgb2YgZXh0ZW5zaW9uIHN1cHBvcnQgdG8gcGxheSAob25lIG9mIHRoZW0gaXMgYSBjb2RleCkuICBUaGlzIGFsbG93cyB5b3UgdG8gbWFwXG5cdCAqIHRoYXQgc3VwcG9ydCBzbyBwbHVnaW5zIGNhbiBhY2N1cmF0ZWx5IGRldGVybWluZSBpZiBhbiBleHRlbnNpb24gaXMgc3VwcG9ydGVkLiAgQWRkaW5nIHRvIHRoaXMgbGlzdCBjYW4gaGVscFxuXHQgKiBwbHVnaW5zIGRldGVybWluZSBtb3JlIGFjY3VyYXRlbHkgaWYgYW4gZXh0ZW5zaW9uIGlzIHN1cHBvcnRlZC5cblx0ICpcbiBcdCAqIEEgdXNlZnVsIGxpc3Qgb2YgZXh0ZW5zaW9ucyBmb3IgZWFjaCBmb3JtYXQgY2FuIGJlIGZvdW5kIGF0IDxhIGhyZWY9XCJodHRwOi8vaHRtbDVkb2N0b3IuY29tL2h0bWw1LWF1ZGlvLXRoZS1zdGF0ZS1vZi1wbGF5L1wiIHRhcmdldD1cIl9ibGFua1wiPmh0dHA6Ly9odG1sNWRvY3Rvci5jb20vaHRtbDUtYXVkaW8tdGhlLXN0YXRlLW9mLXBsYXkvPC9hPi5cblx0ICogQHByb3BlcnR5IEVYVEVOU0lPTl9NQVBcblx0ICogQHR5cGUge09iamVjdH1cblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqIEBkZWZhdWx0IHttNGE6XCJtcDRcIn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5FWFRFTlNJT05fTUFQID0ge1xuXHRcdG00YTpcIm1wNFwiXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBSZWdFeHAgcGF0dGVybiB1c2VkIHRvIHBhcnNlIGZpbGUgVVJJcy4gVGhpcyBzdXBwb3J0cyBzaW1wbGUgZmlsZSBuYW1lcywgYXMgd2VsbCBhcyBmdWxsIGRvbWFpbiBVUklzIHdpdGhcblx0ICogcXVlcnkgc3RyaW5ncy4gVGhlIHJlc3VsdGluZyBtYXRjaCBpczogcHJvdG9jb2w6JDEgZG9tYWluOiQyIHBhdGg6JDMgZmlsZTokNCBleHRlbnNpb246JDUgcXVlcnk6JDYuXG5cdCAqIEBwcm9wZXJ0eSBGSUxFX1BBVFRFUk5cblx0ICogQHR5cGUge1JlZ0V4cH1cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLkZJTEVfUEFUVEVSTiA9IC9eKD86KFxcdys6KVxcL3syfShcXHcrKD86XFwuXFx3KykqXFwvPykpPyhbLy5dKj8oPzpbXj9dKyk/XFwvKT8oKD86W14vP10rKVxcLihcXHcrKSkoPzpcXD8oXFxTKyk/KT8kLztcblxuXG4vLyBDbGFzcyBQdWJsaWMgcHJvcGVydGllc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyB0aGUgZGVmYXVsdCBiZWhhdmlvciBmb3IgaW50ZXJydXB0aW5nIG90aGVyIGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlcyB3aXRoIHRoZSBzYW1lIHNvdXJjZSwgaWYgdGhlXG5cdCAqIG1heGltdW0gbnVtYmVyIG9mIGluc3RhbmNlcyBvZiB0aGUgc291bmQgYXJlIGFscmVhZHkgcGxheWluZy4gIEN1cnJlbnRseSB0aGUgZGVmYXVsdCBpcyB7eyNjcm9zc0xpbmsgXCJTb3VuZC9JTlRFUlJVUFRfTk9ORTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBidXQgdGhpcyBjYW4gYmUgc2V0IGFuZCB3aWxsIGNoYW5nZSBwbGF5YmFjayBiZWhhdmlvciBhY2NvcmRpbmdseS4gIFRoaXMgaXMgb25seSB1c2VkIHdoZW4ge3sjY3Jvc3NMaW5rIFwiU291bmQvcGxheVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpcyBjYWxsZWQgd2l0aG91dCBwYXNzaW5nIGEgdmFsdWUgZm9yIGludGVycnVwdC5cblx0ICogQHByb3BlcnR5IGRlZmF1bHRJbnRlcnJ1cHRCZWhhdmlvclxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBTb3VuZC5JTlRFUlJVUFRfTk9ORSwgb3IgXCJub25lXCJcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjBcblx0ICovXG5cdHMuZGVmYXVsdEludGVycnVwdEJlaGF2aW9yID0gcy5JTlRFUlJVUFRfTk9ORTsgIC8vIE9KUiBkb2VzIHMuSU5URVJSVVBUX0FOWSBtYWtlIG1vcmUgc2Vuc2UgYXMgZGVmYXVsdD8gIE5lZWRzIGdhbWUgZGV2IHRlc3RpbmcgdG8gc2VlIHdoaWNoIGNhc2UgbWFrZXMgbW9yZSBzZW5zZS5cblxuXHQvKipcblx0ICogQW4gYXJyYXkgb2YgZXh0ZW5zaW9ucyB0byBhdHRlbXB0IHRvIHVzZSB3aGVuIGxvYWRpbmcgc291bmQsIGlmIHRoZSBkZWZhdWx0IGlzIHVuc3VwcG9ydGVkIGJ5IHRoZSBhY3RpdmUgcGx1Z2luLlxuXHQgKiBUaGVzZSBhcmUgYXBwbGllZCBpbiBvcmRlciwgc28gaWYgeW91IHRyeSB0byBMb2FkIFRodW5kZXIub2dnIGluIGEgYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgb2dnLCBhbmQgeW91clxuXHQgKiBleHRlbnNpb25zIGFycmF5IGlzIFtcIm1wM1wiLCBcIm00YVwiLCBcIndhdlwiXSBpdCB3aWxsIGNoZWNrIG1wMyBzdXBwb3J0LCB0aGVuIG00YSwgdGhlbiB3YXYuIFRoZSBhdWRpbyBmaWxlcyBuZWVkXG5cdCAqIHRvIGV4aXN0IGluIHRoZSBzYW1lIGxvY2F0aW9uLCBhcyBvbmx5IHRoZSBleHRlbnNpb24gaXMgYWx0ZXJlZC5cblx0ICpcblx0ICogTm90ZSB0aGF0IHJlZ2FyZGxlc3Mgb2Ygd2hpY2ggZmlsZSBpcyBsb2FkZWQsIHlvdSBjYW4gY2FsbCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9jcmVhdGVJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQge3sjY3Jvc3NMaW5rIFwiU291bmQvcGxheVwifX17ey9jcm9zc0xpbmt9fSB1c2luZyB0aGUgc2FtZSBpZCBvciBmdWxsIHNvdXJjZSBwYXRoIHBhc3NlZCBmb3IgbG9hZGluZy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0dmFyIHNvdW5kcyA9IFtcblx0ICpcdFx0e3NyYzpcIm15UGF0aC9teVNvdW5kLm9nZ1wiLCBpZDpcImV4YW1wbGVcIn0sXG5cdCAqXHRdO1xuXHQgKlx0Y3JlYXRlanMuU291bmQuYWx0ZXJuYXRlRXh0ZW5zaW9ucyA9IFtcIm1wM1wiXTsgLy8gbm93IGlmIG9nZyBpcyBub3Qgc3VwcG9ydGVkLCBTb3VuZEpTIHdpbGwgdHJ5IGFzc2V0MC5tcDNcblx0ICpcdGNyZWF0ZWpzLlNvdW5kLm9uKFwiZmlsZWxvYWRcIiwgaGFuZGxlTG9hZCk7IC8vIGNhbGwgaGFuZGxlTG9hZCB3aGVuIGVhY2ggc291bmQgbG9hZHNcblx0ICpcdGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyU291bmRzKHNvdW5kcywgYXNzZXRQYXRoKTtcblx0ICpcdC8vIC4uLlxuXHQgKlx0Y3JlYXRlanMuU291bmQucGxheShcIm15UGF0aC9teVNvdW5kLm9nZ1wiKTsgLy8gd29ya3MgcmVnYXJkbGVzcyBvZiB3aGF0IGV4dGVuc2lvbiBpcyBzdXBwb3J0ZWQuICBOb3RlIGNhbGxpbmcgd2l0aCBJRCBpcyBhIGJldHRlciBhcHByb2FjaFxuXHQgKlxuXHQgKiBAcHJvcGVydHkgYWx0ZXJuYXRlRXh0ZW5zaW9uc1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEBzaW5jZSAwLjUuMlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmFsdGVybmF0ZUV4dGVuc2lvbnMgPSBbXTtcblxuXHQvKipcblx0ICogVGhlIGN1cnJlbnRseSBhY3RpdmUgcGx1Z2luLiBJZiB0aGlzIGlzIG51bGwsIHRoZW4gbm8gcGx1Z2luIGNvdWxkIGJlIGluaXRpYWxpemVkLiBJZiBubyBwbHVnaW4gd2FzIHNwZWNpZmllZCxcblx0ICogU291bmQgYXR0ZW1wdHMgdG8gYXBwbHkgdGhlIGRlZmF1bHQgcGx1Z2luczoge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0sIGZvbGxvd2VkIGJ5XG5cdCAqIHt7I2Nyb3NzTGluayBcIkhUTUxBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQHByb3BlcnR5IGFjdGl2ZVBsdWdpblxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICAgIHMuYWN0aXZlUGx1Z2luID0gbnVsbDtcblxuXG4vLyBjbGFzcyBnZXR0ZXIgLyBzZXR0ZXIgcHJvcGVydGllc1xuXHQvKipcblx0ICogU2V0IHRoZSBtYXN0ZXIgdm9sdW1lIG9mIFNvdW5kLiBUaGUgbWFzdGVyIHZvbHVtZSBpcyBtdWx0aXBsaWVkIGFnYWluc3QgZWFjaCBzb3VuZCdzIGluZGl2aWR1YWwgdm9sdW1lLiAgRm9yXG5cdCAqIGV4YW1wbGUsIGlmIG1hc3RlciB2b2x1bWUgaXMgMC41IGFuZCBhIHNvdW5kJ3Mgdm9sdW1lIGlzIDAuNSwgdGhlIHJlc3VsdGluZyB2b2x1bWUgaXMgMC4yNS4gVG8gc2V0IGluZGl2aWR1YWxcblx0ICogc291bmQgdm9sdW1lLCB1c2UgQWJzdHJhY3RTb3VuZEluc3RhbmNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS92b2x1bWU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgY3JlYXRlanMuU291bmQudm9sdW1lID0gMC41O1xuXHQgKlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgdm9sdW1lXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDFcblx0ICogQHNpbmNlIDAuNi4xXG5cdCAqL1xuXHRzLl9tYXN0ZXJWb2x1bWUgPSAxO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkocywgXCJ2b2x1bWVcIiwge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge3JldHVybiB0aGlzLl9tYXN0ZXJWb2x1bWU7fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRpZiAoTnVtYmVyKHZhbHVlKSA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblx0XHRcdFx0dmFsdWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB2YWx1ZSkpO1xuXHRcdFx0XHRzLl9tYXN0ZXJWb2x1bWUgPSB2YWx1ZTtcblx0XHRcdFx0aWYgKCF0aGlzLmFjdGl2ZVBsdWdpbiB8fCAhdGhpcy5hY3RpdmVQbHVnaW4uc2V0Vm9sdW1lIHx8ICF0aGlzLmFjdGl2ZVBsdWdpbi5zZXRWb2x1bWUodmFsdWUpKSB7XG5cdFx0XHRcdFx0dmFyIGluc3RhbmNlcyA9IHRoaXMuX2luc3RhbmNlcztcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGluc3RhbmNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGluc3RhbmNlc1tpXS5zZXRNYXN0ZXJWb2x1bWUodmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogTXV0ZS9Vbm11dGUgYWxsIGF1ZGlvLiBOb3RlIHRoYXQgbXV0ZWQgYXVkaW8gc3RpbGwgcGxheXMgYXQgMCB2b2x1bWUuIFRoaXMgZ2xvYmFsIG11dGUgdmFsdWUgaXMgbWFpbnRhaW5lZFxuXHQgKiBzZXBhcmF0ZWx5IGFuZCB3aGVuIHNldCB3aWxsIG92ZXJyaWRlLCBidXQgbm90IGNoYW5nZSB0aGUgbXV0ZSBwcm9wZXJ0eSBvZiBpbmRpdmlkdWFsIGluc3RhbmNlcy4gVG8gbXV0ZSBhbiBpbmRpdmlkdWFsXG5cdCAqIGluc3RhbmNlLCB1c2UgQWJzdHJhY3RTb3VuZEluc3RhbmNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9tdXRlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICBjcmVhdGVqcy5Tb3VuZC5tdXRlZCA9IHRydWU7XG5cdCAqXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBtdXRlZFxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICogQHNpbmNlIDAuNi4xXG5cdCAqL1xuXHRzLl9tYXN0ZXJNdXRlID0gZmFsc2U7XG5cdC8vIE9KUiByZWZlcmVuY2VzIHRvIHRoZSBtZXRob2RzIHdlcmUgbm90IHdvcmtpbmcsIHNvIHRoZSBjb2RlIGhhZCB0byBiZSBkdXBsaWNhdGVkIGhlcmVcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIFwibXV0ZWRcIiwge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge3JldHVybiB0aGlzLl9tYXN0ZXJNdXRlO30sXG5cdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0aWYgKHZhbHVlID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXG5cdFx0XHRcdHRoaXMuX21hc3Rlck11dGUgPSB2YWx1ZTtcblx0XHRcdFx0aWYgKCF0aGlzLmFjdGl2ZVBsdWdpbiB8fCAhdGhpcy5hY3RpdmVQbHVnaW4uc2V0TXV0ZSB8fCAhdGhpcy5hY3RpdmVQbHVnaW4uc2V0TXV0ZSh2YWx1ZSkpIHtcblx0XHRcdFx0XHR2YXIgaW5zdGFuY2VzID0gdGhpcy5faW5zdGFuY2VzO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaW5zdGFuY2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0aW5zdGFuY2VzW2ldLnNldE1hc3Rlck11dGUodmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgYWN0aXZlIHBsdWdpbnMgY2FwYWJpbGl0aWVzLCB3aGljaCBoZWxwIGRldGVybWluZSBpZiBhIHBsdWdpbiBjYW4gYmUgdXNlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCxcblx0ICogb3IgaWYgdGhlIHBsdWdpbiBzdXBwb3J0cyBhIHNwZWNpZmljIGZlYXR1cmUuIENhcGFiaWxpdGllcyBpbmNsdWRlOlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+PGI+cGFubmluZzo8L2I+IElmIHRoZSBwbHVnaW4gY2FuIHBhbiBhdWRpbyBmcm9tIGxlZnQgdG8gcmlnaHQ8L2xpPlxuXHQgKiAgICAgPGxpPjxiPnZvbHVtZTs8L2I+IElmIHRoZSBwbHVnaW4gY2FuIGNvbnRyb2wgYXVkaW8gdm9sdW1lLjwvbGk+XG5cdCAqICAgICA8bGk+PGI+dHJhY2tzOjwvYj4gVGhlIG1heGltdW0gbnVtYmVyIG9mIGF1ZGlvIHRyYWNrcyB0aGF0IGNhbiBiZSBwbGF5ZWQgYmFjayBhdCBhIHRpbWUuIFRoaXMgd2lsbCBiZSAtMVxuXHQgKiAgICAgaWYgdGhlcmUgaXMgbm8ga25vd24gbGltaXQuPC9saT5cblx0ICogPGJyIC8+QW4gZW50cnkgZm9yIGVhY2ggZmlsZSB0eXBlIGluIHt7I2Nyb3NzTGluayBcIlNvdW5kL1NVUFBPUlRFRF9FWFRFTlNJT05TOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OlxuXHQgKiAgICAgPGxpPjxiPm1wMzo8L2I+IElmIE1QMyBhdWRpbyBpcyBzdXBwb3J0ZWQuPC9saT5cblx0ICogICAgIDxsaT48Yj5vZ2c6PC9iPiBJZiBPR0cgYXVkaW8gaXMgc3VwcG9ydGVkLjwvbGk+XG5cdCAqICAgICA8bGk+PGI+d2F2OjwvYj4gSWYgV0FWIGF1ZGlvIGlzIHN1cHBvcnRlZC48L2xpPlxuXHQgKiAgICAgPGxpPjxiPm1wZWc6PC9iPiBJZiBNUEVHIGF1ZGlvIGlzIHN1cHBvcnRlZC48L2xpPlxuXHQgKiAgICAgPGxpPjxiPm00YTo8L2I+IElmIE00QSBhdWRpbyBpcyBzdXBwb3J0ZWQuPC9saT5cblx0ICogICAgIDxsaT48Yj5tcDQ6PC9iPiBJZiBNUDQgYXVkaW8gaXMgc3VwcG9ydGVkLjwvbGk+XG5cdCAqICAgICA8bGk+PGI+YWlmZjo8L2I+IElmIGFpZmYgYXVkaW8gaXMgc3VwcG9ydGVkLjwvbGk+XG5cdCAqICAgICA8bGk+PGI+d21hOjwvYj4gSWYgd21hIGF1ZGlvIGlzIHN1cHBvcnRlZC48L2xpPlxuXHQgKiAgICAgPGxpPjxiPm1pZDo8L2I+IElmIG1pZCBhdWRpbyBpcyBzdXBwb3J0ZWQuPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogWW91IGNhbiBnZXQgYSBzcGVjaWZpYyBjYXBhYmlsaXR5IG9mIHRoZSBhY3RpdmUgcGx1Z2luIHVzaW5nIHN0YW5kYXJkIG9iamVjdCBub3RhdGlvblxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIG1wMyA9IGNyZWF0ZWpzLlNvdW5kLmNhcGFiaWxpdGllcy5tcDM7XG5cdCAqXG5cdCAqIE5vdGUgdGhpcyBwcm9wZXJ0eSBpcyByZWFkIG9ubHkuXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBjYXBhYmlsaXRpZXNcblx0ICogQHR5cGUge09iamVjdH1cblx0ICogQHN0YXRpY1xuXHQgKiBAcmVhZE9ubHlcblx0ICogQHNpbmNlIDAuNi4xXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkocywgXCJjYXBhYmlsaXRpZXNcIiwge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmIChzLmFjdGl2ZVBsdWdpbiA9PSBudWxsKSB7cmV0dXJuIG51bGw7fVxuXHRcdFx0XHRcdHJldHVybiBzLmFjdGl2ZVBsdWdpbi5fY2FwYWJpbGl0aWVzO1xuXHRcdFx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBmYWxzZTt9XG5cdH0pO1xuXG5cbi8vIENsYXNzIFByaXZhdGUgcHJvcGVydGllc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgcGx1Z2lucyBoYXZlIGJlZW4gcmVnaXN0ZXJlZC4gSWYgZmFsc2UsIHRoZSBmaXJzdCBjYWxsIHRvIHBsYXkoKSB3aWxsIGluc3RhbnRpYXRlIHRoZSBkZWZhdWx0XG5cdCAqIHBsdWdpbnMgKHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LCBmb2xsb3dlZCBieSB7eyNjcm9zc0xpbmsgXCJIVE1MQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0pLlxuXHQgKiBJZiBwbHVnaW5zIGhhdmUgYmVlbiByZWdpc3RlcmVkLCBidXQgbm9uZSBhcmUgYXBwbGljYWJsZSwgdGhlbiBzb3VuZCBwbGF5YmFjayB3aWxsIGZhaWwuXG5cdCAqIEBwcm9wZXJ0eSBfcGx1Z2luc1JlZ2lzdGVyZWRcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5fcGx1Z2luc1JlZ2lzdGVyZWQgPSBmYWxzZTtcblxuXHQvKipcblx0ICogVXNlZCBpbnRlcm5hbGx5IHRvIGFzc2lnbiB1bmlxdWUgSURzIHRvIGVhY2ggQWJzdHJhY3RTb3VuZEluc3RhbmNlLlxuXHQgKiBAcHJvcGVydHkgX2xhc3RJRFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuX2xhc3RJRCA9IDA7XG5cblx0LyoqXG5cdCAqIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlcy4gVGhpcyBhbGxvd3MgU291bmQgdG8gY29udHJvbCB0aGUgdm9sdW1lLCBtdXRlLCBhbmQgcGxheWJhY2sgb2Zcblx0ICogYWxsIGluc3RhbmNlcyB3aGVuIHVzaW5nIHN0YXRpYyBBUElzIGxpa2Uge3sjY3Jvc3NMaW5rIFwiU291bmQvc3RvcFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiU291bmQvc2V0Vm9sdW1lXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBXaGVuIGFuIGluc3RhbmNlIGhhcyBmaW5pc2hlZCBwbGF5YmFjaywgaXQgZ2V0cyByZW1vdmVkIHZpYSB0aGUge3sjY3Jvc3NMaW5rIFwiU291bmQvZmluaXNoZWRQbGF5aW5nXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC4gSWYgdGhlIHVzZXIgcmVwbGF5cyBhbiBpbnN0YW5jZSwgaXQgZ2V0cyBhZGRlZCBiYWNrIGluIHZpYSB0aGUge3sjY3Jvc3NMaW5rIFwiU291bmQvX2JlZ2luUGxheWluZ1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBwcm9wZXJ0eSBfaW5zdGFuY2VzXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9pbnN0YW5jZXMgPSBbXTtcblxuXHQvKipcblx0ICogQW4gb2JqZWN0IGhhc2ggc3RvcmluZyBvYmplY3RzIHdpdGggc291bmQgc291cmNlcywgc3RhcnRUaW1lLCBhbmQgZHVyYXRpb24gdmlhIHRoZXJlIGNvcnJlc3BvbmRpbmcgSUQuXG5cdCAqIEBwcm9wZXJ0eSBfaWRIYXNoXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5faWRIYXNoID0ge307XG5cblx0LyoqXG5cdCAqIEFuIG9iamVjdCBoYXNoIHRoYXQgc3RvcmVzIHByZWxvYWRpbmcgc291bmQgc291cmNlcyB2aWEgdGhlIHBhcnNlZCBzb3VyY2UgdGhhdCBpcyBwYXNzZWQgdG8gdGhlIHBsdWdpbi4gIENvbnRhaW5zIHRoZVxuXHQgKiBzb3VyY2UsIGlkLCBhbmQgZGF0YSB0aGF0IHdhcyBwYXNzZWQgaW4gYnkgdGhlIHVzZXIuICBQYXJzZWQgc291cmNlcyBjYW4gY29udGFpbiBtdWx0aXBsZSBpbnN0YW5jZXMgb2Ygc291cmNlLCBpZCxcblx0ICogYW5kIGRhdGEuXG5cdCAqIEBwcm9wZXJ0eSBfcHJlbG9hZEhhc2hcblx0ICogQHR5cGUge09iamVjdH1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9wcmVsb2FkSGFzaCA9IHt9O1xuXG5cdC8qKlxuXHQgKiBBbiBvYmplY3QgaGFzaCBzdG9yaW5nIHt7I2Nyb3NzTGluayBcIlBsYXlQcm9wc0NvbmZpZ1wifX17ey9jcm9zc0xpbmt9fSB2aWEgdGhlIHBhcnNlZCBzb3VyY2UgdGhhdCBpcyBwYXNzZWQgYXMgZGVmYXVsdFBsYXlQcm9wcyBpblxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQHByb3BlcnR5IF9kZWZhdWx0UGxheVByb3BzSGFzaFxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4xXG5cdCAqL1xuXHRzLl9kZWZhdWx0UGxheVByb3BzSGFzaCA9IHt9O1xuXG5cbi8vIEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzOlxuXHRzLmFkZEV2ZW50TGlzdGVuZXIgPSBudWxsO1xuXHRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBudWxsO1xuXHRzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gbnVsbDtcblx0cy5kaXNwYXRjaEV2ZW50ID0gbnVsbDtcblx0cy5oYXNFdmVudExpc3RlbmVyID0gbnVsbDtcblx0cy5fbGlzdGVuZXJzID0gbnVsbDtcblxuXHRjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShzKTsgLy8gaW5qZWN0IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzLlxuXG5cbi8vIEV2ZW50c1xuXHQvKipcblx0ICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGEgZmlsZSBmaW5pc2hlcyBsb2FkaW5nIGludGVybmFsbHkuIFRoaXMgZXZlbnQgaXMgZmlyZWQgZm9yIGVhY2ggbG9hZGVkIHNvdW5kLFxuXHQgKiBzbyBhbnkgaGFuZGxlciBtZXRob2RzIHNob3VsZCBsb29rIHVwIHRoZSA8Y29kZT5ldmVudC5zcmM8L2NvZGU+IHRvIGhhbmRsZSBhIHBhcnRpY3VsYXIgc291bmQuXG5cdCAqIEBldmVudCBmaWxlbG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBvZiB0aGUgc291bmQgdGhhdCB3YXMgbG9hZGVkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2lkXSBUaGUgaWQgcGFzc2VkIGluIHdoZW4gdGhlIHNvdW5kIHdhcyByZWdpc3RlcmVkLiBJZiBvbmUgd2FzIG5vdCBwcm92aWRlZCwgaXQgd2lsbCBiZSBudWxsLlxuXHQgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IFtkYXRhXSBBbnkgYWRkaXRpb25hbCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgaXRlbS4gSWYgbm90IHByb3ZpZGVkLCBpdCB3aWxsIGJlIHVuZGVmaW5lZC5cblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYSBmaWxlIGZhaWxzIGxvYWRpbmcgaW50ZXJuYWxseS4gVGhpcyBldmVudCBpcyBmaXJlZCBmb3IgZWFjaCBsb2FkZWQgc291bmQsXG5cdCAqIHNvIGFueSBoYW5kbGVyIG1ldGhvZHMgc2hvdWxkIGxvb2sgdXAgdGhlIDxjb2RlPmV2ZW50LnNyYzwvY29kZT4gdG8gaGFuZGxlIGEgcGFydGljdWxhciBzb3VuZC5cblx0ICogQGV2ZW50IGZpbGVlcnJvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBvZiB0aGUgc291bmQgdGhhdCB3YXMgbG9hZGVkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2lkXSBUaGUgaWQgcGFzc2VkIGluIHdoZW4gdGhlIHNvdW5kIHdhcyByZWdpc3RlcmVkLiBJZiBvbmUgd2FzIG5vdCBwcm92aWRlZCwgaXQgd2lsbCBiZSBudWxsLlxuXHQgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IFtkYXRhXSBBbnkgYWRkaXRpb25hbCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgaXRlbS4gSWYgbm90IHByb3ZpZGVkLCBpdCB3aWxsIGJlIHVuZGVmaW5lZC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cbi8vIENsYXNzIFB1YmxpYyBNZXRob2RzXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHByZWxvYWQgcnVsZXMgdG8gYWxsb3cgU291bmQgdG8gYmUgdXNlZCBhcyBhIHBsdWdpbiBieSA8YSBocmVmPVwiaHR0cDovL3ByZWxvYWRqcy5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIj5QcmVsb2FkSlM8L2E+LlxuXHQgKiBBbnkgbG9hZCBjYWxscyB0aGF0IGhhdmUgdGhlIG1hdGNoaW5nIHR5cGUgb3IgZXh0ZW5zaW9uIHdpbGwgZmlyZSB0aGUgY2FsbGJhY2sgbWV0aG9kLCBhbmQgdXNlIHRoZSByZXN1bHRpbmdcblx0ICogb2JqZWN0LCB3aGljaCBpcyBwb3RlbnRpYWxseSBtb2RpZmllZCBieSBTb3VuZC4gVGhpcyBoZWxwcyB3aGVuIGRldGVybWluaW5nIHRoZSBjb3JyZWN0IHBhdGgsIGFzIHdlbGwgYXNcblx0ICogcmVnaXN0ZXJpbmcgdGhlIGF1ZGlvIGluc3RhbmNlKHMpIHdpdGggU291bmQuIFRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgY2FsbGVkLCBleGNlcHQgYnkgUHJlbG9hZEpTLlxuXHQgKiBAbWV0aG9kIGdldFByZWxvYWRIYW5kbGVyc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nOlxuXHQgKiA8dWw+PGxpPmNhbGxiYWNrOiBBIHByZWxvYWQgY2FsbGJhY2sgdGhhdCBpcyBmaXJlZCB3aGVuIGEgZmlsZSBpcyBhZGRlZCB0byBQcmVsb2FkSlMsIHdoaWNoIHByb3ZpZGVzXG5cdCAqICAgICAgU291bmQgYSBtZWNoYW5pc20gdG8gbW9kaWZ5IHRoZSBsb2FkIHBhcmFtZXRlcnMsIHNlbGVjdCB0aGUgY29ycmVjdCBmaWxlIGZvcm1hdCwgcmVnaXN0ZXIgdGhlIHNvdW5kLCBldGMuPC9saT5cblx0ICogICAgICA8bGk+dHlwZXM6IEEgbGlzdCBvZiBmaWxlIHR5cGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBieSBTb3VuZCAoY3VycmVudGx5IHN1cHBvcnRzIFwic291bmRcIikuPC9saT5cblx0ICogICAgICA8bGk+ZXh0ZW5zaW9uczogQSBsaXN0IG9mIGZpbGUgZXh0ZW5zaW9ucyB0aGF0IGFyZSBzdXBwb3J0ZWQgYnkgU291bmQgKHNlZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9TVVBQT1JURURfRVhURU5TSU9OUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSkuPC9saT48L3VsPlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuZ2V0UHJlbG9hZEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRjYWxsYmFjazpjcmVhdGVqcy5wcm94eShzLmluaXRMb2FkLCBzKSxcblx0XHRcdHR5cGVzOltcInNvdW5kXCJdLFxuXHRcdFx0ZXh0ZW5zaW9uczpzLlNVUFBPUlRFRF9FWFRFTlNJT05TXG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogVXNlZCB0byBkaXNwYXRjaCBmaWxlbG9hZCBldmVudHMgZnJvbSBpbnRlcm5hbCBsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVMb2FkQ29tcGxldGVcblx0ICogQHBhcmFtIGV2ZW50IEEgbG9hZGVyIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLl9oYW5kbGVMb2FkQ29tcGxldGUgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBzcmMgPSBldmVudC50YXJnZXQuZ2V0SXRlbSgpLnNyYztcblx0XHRpZiAoIXMuX3ByZWxvYWRIYXNoW3NyY10pIHtyZXR1cm47fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzLl9wcmVsb2FkSGFzaFtzcmNdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzLl9wcmVsb2FkSGFzaFtzcmNdW2ldO1xuXHRcdFx0cy5fcHJlbG9hZEhhc2hbc3JjXVtpXSA9IHRydWU7XG5cblx0XHRcdGlmICghcy5oYXNFdmVudExpc3RlbmVyKFwiZmlsZWxvYWRcIikpIHsgY29udGludWU7IH1cblxuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZWxvYWRcIik7XG5cdFx0XHRldmVudC5zcmMgPSBpdGVtLnNyYztcblx0XHRcdGV2ZW50LmlkID0gaXRlbS5pZDtcblx0XHRcdGV2ZW50LmRhdGEgPSBpdGVtLmRhdGE7XG5cdFx0XHRldmVudC5zcHJpdGUgPSBpdGVtLnNwcml0ZTtcblxuXHRcdFx0cy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gZGlzcGF0Y2ggZXJyb3IgZXZlbnRzIGZyb20gaW50ZXJuYWwgcHJlbG9hZGluZy5cblx0ICogQHBhcmFtIGV2ZW50XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX2hhbmRsZUxvYWRFcnJvciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHNyYyA9IGV2ZW50LnRhcmdldC5nZXRJdGVtKCkuc3JjO1xuXHRcdGlmICghcy5fcHJlbG9hZEhhc2hbc3JjXSkge3JldHVybjt9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHMuX3ByZWxvYWRIYXNoW3NyY10ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHMuX3ByZWxvYWRIYXNoW3NyY11baV07XG5cdFx0XHRzLl9wcmVsb2FkSGFzaFtzcmNdW2ldID0gZmFsc2U7XG5cblx0XHRcdGlmICghcy5oYXNFdmVudExpc3RlbmVyKFwiZmlsZWVycm9yXCIpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVlcnJvclwiKTtcblx0XHRcdGV2ZW50LnNyYyA9IGl0ZW0uc3JjO1xuXHRcdFx0ZXZlbnQuaWQgPSBpdGVtLmlkO1xuXHRcdFx0ZXZlbnQuZGF0YSA9IGl0ZW0uZGF0YTtcblx0XHRcdGV2ZW50LnNwcml0ZSA9IGl0ZW0uc3ByaXRlO1xuXG5cdFx0XHRzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVXNlZCBieSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclBsdWdpbnNcIn19e3svY3Jvc3NMaW5rfX0gdG8gcmVnaXN0ZXIgYSBTb3VuZCBwbHVnaW4uXG5cdCAqXG5cdCAqIEBtZXRob2QgX3JlZ2lzdGVyUGx1Z2luXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gVGhlIHBsdWdpbiBjbGFzcyB0byBpbnN0YWxsLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBwbHVnaW4gd2FzIHN1Y2Nlc3NmdWxseSBpbml0aWFsaXplZC5cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cy5fcmVnaXN0ZXJQbHVnaW4gPSBmdW5jdGlvbiAocGx1Z2luKSB7XG5cdFx0Ly8gTm90ZTogRWFjaCBwbHVnaW4gaXMgcGFzc2VkIGluIGFzIGEgY2xhc3MgcmVmZXJlbmNlLCBidXQgd2Ugc3RvcmUgdGhlIGFjdGl2ZVBsdWdpbiBhcyBhbiBpbnN0YW5jZVxuXHRcdGlmIChwbHVnaW4uaXNTdXBwb3J0ZWQoKSkge1xuXHRcdFx0cy5hY3RpdmVQbHVnaW4gPSBuZXcgcGx1Z2luKCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhIGxpc3Qgb2YgU291bmQgcGx1Z2lucywgaW4gb3JkZXIgb2YgcHJlY2VkZW5jZS4gVG8gcmVnaXN0ZXIgYSBzaW5nbGUgcGx1Z2luLCBwYXNzIGEgc2luZ2xlIGVsZW1lbnQgaW4gdGhlIGFycmF5LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuRmxhc2hBdWRpb1BsdWdpbi5zd2ZQYXRoID0gXCIuLi9zcmMvc291bmRqcy9mbGFzaGF1ZGlvL1wiO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyUGx1Z2lucyhbY3JlYXRlanMuV2ViQXVkaW9QbHVnaW4sIGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbiwgY3JlYXRlanMuRmxhc2hBdWRpb1BsdWdpbl0pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHJlZ2lzdGVyUGx1Z2luc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBwbHVnaW5zIEFuIGFycmF5IG9mIHBsdWdpbnMgY2xhc3NlcyB0byBpbnN0YWxsLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGEgcGx1Z2luIHdhcyBzdWNjZXNzZnVsbHkgaW5pdGlhbGl6ZWQuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMucmVnaXN0ZXJQbHVnaW5zID0gZnVuY3Rpb24gKHBsdWdpbnMpIHtcblx0XHRzLl9wbHVnaW5zUmVnaXN0ZXJlZCA9IHRydWU7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwbHVnaW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKHMuX3JlZ2lzdGVyUGx1Z2luKHBsdWdpbnNbaV0pKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIGRlZmF1bHQgcGx1Z2lucy4gVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiBhbnkgYXVkaW8gaXMgcGxheWVkIG9yIHJlZ2lzdGVyZWQgYmVmb3JlXG5cdCAqIHRoZSB1c2VyIGhhcyBtYW51YWxseSByZWdpc3RlcmVkIHBsdWdpbnMsIGFuZCBlbmFibGVzIFNvdW5kIHRvIHdvcmsgd2l0aG91dCBtYW51YWwgcGx1Z2luIHNldHVwLiBDdXJyZW50bHksIHRoZVxuXHQgKiBkZWZhdWx0IHBsdWdpbnMgYXJlIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319IGZvbGxvd2VkIGJ5IHt7I2Nyb3NzTGluayBcIkhUTUxBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiBcdGlmICghY3JlYXRlanMuaW5pdGlhbGl6ZURlZmF1bHRQbHVnaW5zKCkpIHsgcmV0dXJuOyB9XG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZURlZmF1bHRQbHVnaW5zXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIGEgcGx1Z2luIHdhcyBpbml0aWFsaXplZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKiBAc2luY2UgMC40LjBcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pbml0aWFsaXplRGVmYXVsdFBsdWdpbnMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHMuYWN0aXZlUGx1Z2luICE9IG51bGwpIHtyZXR1cm4gdHJ1ZTt9XG5cdFx0aWYgKHMuX3BsdWdpbnNSZWdpc3RlcmVkKSB7cmV0dXJuIGZhbHNlO31cblx0XHRpZiAocy5yZWdpc3RlclBsdWdpbnMoW2NyZWF0ZWpzLldlYkF1ZGlvUGx1Z2luLCBjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW5dKSkge3JldHVybiB0cnVlO31cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgU291bmQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQsIGFuZCBhIHBsdWdpbiBoYXMgYmVlbiBhY3RpdmF0ZWQuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIHNldHMgdXAgYSBGbGFzaCBmYWxsYmFjaywgYnV0IG9ubHkgaWYgdGhlcmUgaXMgbm8gcGx1Z2luIHNwZWNpZmllZCB5ZXQuXG5cdCAqXG5cdCAqIFx0aWYgKCFjcmVhdGVqcy5Tb3VuZC5pc1JlYWR5KCkpIHtcblx0ICpcdFx0Y3JlYXRlanMuRmxhc2hBdWRpb1BsdWdpbi5zd2ZQYXRoID0gXCIuLi9zcmMvc291bmRqcy9mbGFzaGF1ZGlvL1wiO1xuXHQgKiBcdFx0Y3JlYXRlanMuU291bmQucmVnaXN0ZXJQbHVnaW5zKFtjcmVhdGVqcy5XZWJBdWRpb1BsdWdpbiwgY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLCBjcmVhdGVqcy5GbGFzaEF1ZGlvUGx1Z2luXSk7XG5cdCAqXHR9XG5cdCAqXG5cdCAqIEBtZXRob2QgaXNSZWFkeVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiBTb3VuZCBoYXMgaW5pdGlhbGl6ZWQgYSBwbHVnaW4uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNSZWFkeSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gKHMuYWN0aXZlUGx1Z2luICE9IG51bGwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXByZWNhdGVkLCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIlNvdW5kL2NhcGFiaWxpdGllczpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGdldENhcGFiaWxpdGllc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjYXBhYmlsaXRpZXMgb2YgdGhlIGFjdGl2ZSBwbHVnaW4uXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdHMuZ2V0Q2FwYWJpbGl0aWVzID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmIChzLmFjdGl2ZVBsdWdpbiA9PSBudWxsKSB7cmV0dXJuIG51bGw7fVxuXHRcdHJldHVybiBzLmFjdGl2ZVBsdWdpbi5fY2FwYWJpbGl0aWVzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXByZWNhdGVkLCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIlNvdW5kL2NhcGFiaWxpdGllczpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGdldENhcGFiaWxpdHlcblx0ICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgY2FwYWJpbGl0eSB0byByZXRyaWV2ZVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ8Qm9vbGVhbn0gVGhlIHZhbHVlIG9mIHRoZSBjYXBhYmlsaXR5LlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzZWUgZ2V0Q2FwYWJpbGl0aWVzXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHRzLmdldENhcGFiaWxpdHkgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0aWYgKHMuYWN0aXZlUGx1Z2luID09IG51bGwpIHtyZXR1cm4gbnVsbDt9XG5cdFx0cmV0dXJuIHMuYWN0aXZlUGx1Z2luLl9jYXBhYmlsaXRpZXNba2V5XTtcblx0fTtcblxuXHQvKipcblx0ICogUHJvY2VzcyBtYW5pZmVzdCBpdGVtcyBmcm9tIDxhIGhyZWY9XCJodHRwOi8vcHJlbG9hZGpzLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPlByZWxvYWRKUzwvYT4uIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkXG5cdCAqIGZvciB1c2FnZSBieSBhIHBsdWdpbiwgYW5kIG5vdCBmb3IgZGlyZWN0IGludGVyYWN0aW9uLlxuXHQgKiBAbWV0aG9kIGluaXRMb2FkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgVGhlIG9iamVjdCB0byBsb2FkLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R8QWJzdHJhY3RMb2FkZXJ9IEFuIGluc3RhbmNlIG9mIEFic3RyYWN0TG9hZGVyLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaW5pdExvYWQgPSBmdW5jdGlvbiAobG9hZEl0ZW0pIHtcblx0XHRyZXR1cm4gcy5fcmVnaXN0ZXJTb3VuZChsb2FkSXRlbSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIG1ldGhvZCBmb3IgbG9hZGluZyBzb3VuZHMuICBUaGlzIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LlxuXHQgKlxuXHQgKiBAbWV0aG9kIF9yZWdpc3RlclNvdW5kXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgVGhlIG9iamVjdCB0byBsb2FkLCBjb250YWluaW5nIHNyYyBwcm9wZXJ0eSBhbmQgb3B0aW9uYWxseSBjb250YWluaW5nIGlkIGFuZCBkYXRhLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBtb2RpZmllZCB2YWx1ZXMgdGhhdCB3ZXJlIHBhc3NlZCBpbiwgd2hpY2ggZGVmaW5lcyB0aGUgc291bmQuXG5cdCAqIFJldHVybnMgZmFsc2UgaWYgdGhlIHNvdXJjZSBjYW5ub3QgYmUgcGFyc2VkIG9yIG5vIHBsdWdpbnMgY2FuIGJlIGluaXRpYWxpemVkLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNvdXJjZSBpcyBhbHJlYWR5IGxvYWRlZC5cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0cy5fcmVnaXN0ZXJTb3VuZCA9IGZ1bmN0aW9uIChsb2FkSXRlbSkge1xuXHRcdGlmICghcy5pbml0aWFsaXplRGVmYXVsdFBsdWdpbnMoKSkge3JldHVybiBmYWxzZTt9XG5cblx0XHR2YXIgZGV0YWlscztcblx0XHRpZiAobG9hZEl0ZW0uc3JjIGluc3RhbmNlb2YgT2JqZWN0KSB7XG5cdFx0XHRkZXRhaWxzID0gcy5fcGFyc2VTcmMobG9hZEl0ZW0uc3JjKTtcblx0XHRcdGRldGFpbHMuc3JjID0gbG9hZEl0ZW0ucGF0aCArIGRldGFpbHMuc3JjO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXRhaWxzID0gcy5fcGFyc2VQYXRoKGxvYWRJdGVtLnNyYyk7XG5cdFx0fVxuXHRcdGlmIChkZXRhaWxzID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdGxvYWRJdGVtLnNyYyA9IGRldGFpbHMuc3JjO1xuXHRcdGxvYWRJdGVtLnR5cGUgPSBcInNvdW5kXCI7XG5cblx0XHR2YXIgZGF0YSA9IGxvYWRJdGVtLmRhdGE7XG5cdFx0dmFyIG51bUNoYW5uZWxzID0gbnVsbDtcblx0XHRpZiAoZGF0YSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoIWlzTmFOKGRhdGEuY2hhbm5lbHMpKSB7XG5cdFx0XHRcdG51bUNoYW5uZWxzID0gcGFyc2VJbnQoZGF0YS5jaGFubmVscyk7XG5cdFx0XHR9IGVsc2UgaWYgKCFpc05hTihkYXRhKSkge1xuXHRcdFx0XHRudW1DaGFubmVscyA9IHBhcnNlSW50KGRhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihkYXRhLmF1ZGlvU3ByaXRlKSB7XG5cdFx0XHRcdHZhciBzcDtcblx0XHRcdFx0Zm9yKHZhciBpID0gZGF0YS5hdWRpb1Nwcml0ZS5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdFx0c3AgPSBkYXRhLmF1ZGlvU3ByaXRlW2ldO1xuXHRcdFx0XHRcdHMuX2lkSGFzaFtzcC5pZF0gPSB7c3JjOiBsb2FkSXRlbS5zcmMsIHN0YXJ0VGltZTogcGFyc2VJbnQoc3Auc3RhcnRUaW1lKSwgZHVyYXRpb246IHBhcnNlSW50KHNwLmR1cmF0aW9uKX07XG5cblx0XHRcdFx0XHRpZiAoc3AuZGVmYXVsdFBsYXlQcm9wcykge1xuXHRcdFx0XHRcdFx0cy5fZGVmYXVsdFBsYXlQcm9wc0hhc2hbc3AuaWRdID0gY3JlYXRlanMuUGxheVByb3BzQ29uZmlnLmNyZWF0ZShzcC5kZWZhdWx0UGxheVByb3BzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGxvYWRJdGVtLmlkICE9IG51bGwpIHtzLl9pZEhhc2hbbG9hZEl0ZW0uaWRdID0ge3NyYzogbG9hZEl0ZW0uc3JjfX07XG5cdFx0dmFyIGxvYWRlciA9IHMuYWN0aXZlUGx1Z2luLnJlZ2lzdGVyKGxvYWRJdGVtKTtcblxuXHRcdFNvdW5kQ2hhbm5lbC5jcmVhdGUobG9hZEl0ZW0uc3JjLCBudW1DaGFubmVscyk7XG5cblx0XHQvLyByZXR1cm4gdGhlIG51bWJlciBvZiBpbnN0YW5jZXMgdG8gdGhlIHVzZXIuICBUaGlzIHdpbGwgYWxzbyBiZSByZXR1cm5lZCBpbiB0aGUgbG9hZCBldmVudC5cblx0XHRpZiAoZGF0YSA9PSBudWxsIHx8ICFpc05hTihkYXRhKSkge1xuXHRcdFx0bG9hZEl0ZW0uZGF0YSA9IG51bUNoYW5uZWxzIHx8IFNvdW5kQ2hhbm5lbC5tYXhQZXJDaGFubmVsKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvYWRJdGVtLmRhdGEuY2hhbm5lbHMgPSBudW1DaGFubmVscyB8fCBTb3VuZENoYW5uZWwubWF4UGVyQ2hhbm5lbCgpO1xuXHRcdH1cblxuXHRcdGlmIChsb2FkZXIudHlwZSkge2xvYWRJdGVtLnR5cGUgPSBsb2FkZXIudHlwZTt9XG5cblx0XHRpZiAobG9hZEl0ZW0uZGVmYXVsdFBsYXlQcm9wcykge1xuXHRcdFx0cy5fZGVmYXVsdFBsYXlQcm9wc0hhc2hbbG9hZEl0ZW0uc3JjXSA9IGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZy5jcmVhdGUobG9hZEl0ZW0uZGVmYXVsdFBsYXlQcm9wcyk7XG5cdFx0fVxuXHRcdHJldHVybiBsb2FkZXI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGFuIGF1ZGlvIGZpbGUgZm9yIGxvYWRpbmcgYW5kIGZ1dHVyZSBwbGF5YmFjayBpbiBTb3VuZC4gVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuIHVzaW5nXG5cdCAqIDxhIGhyZWY9XCJodHRwOi8vcHJlbG9hZGpzLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPlByZWxvYWRKUzwvYT4uICBJdCBpcyByZWNvbW1lbmRlZCB0byByZWdpc3RlciBhbGwgc291bmRzIHRoYXRcblx0ICogbmVlZCB0byBiZSBwbGF5ZWQgYmFjayBpbiBvcmRlciB0byBwcm9wZXJseSBwcmVwYXJlIGFuZCBwcmVsb2FkIHRoZW0uIFNvdW5kIGRvZXMgaW50ZXJuYWwgcHJlbG9hZGluZyB3aGVuIHJlcXVpcmVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuU291bmQuYWx0ZXJuYXRlRXh0ZW5zaW9ucyA9IFtcIm1wM1wiXTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5vbihcImZpbGVsb2FkXCIsIGhhbmRsZUxvYWQpOyAvLyBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHdoZW4gbG9hZCBpcyBjb21wbGV0ZWRcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kKFwibXlBdWRpb1BhdGgvbXlTb3VuZC5vZ2dcIiwgXCJteUlEXCIsIDMpO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyU291bmQoe29nZzpcInBhdGgxL215U291bmQub2dnXCIsIG1wMzpcInBhdGgyL215U291bmROb0V4dGVuc2lvblwifSwgXCJteUlEXCIsIDMpO1xuXHQgKlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlZ2lzdGVyU291bmRcblx0ICogQHBhcmFtIHtTdHJpbmcgfCBPYmplY3R9IHNyYyBUaGUgc291cmNlIG9yIGFuIE9iamVjdCB3aXRoIGEgXCJzcmNcIiBwcm9wZXJ0eSBvciBhbiBPYmplY3Qgd2l0aCBtdWx0aXBsZSBleHRlbnNpb24gbGFiZWxlZCBzcmMgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtpZF0gQW4gaWQgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIHRvIHBsYXkgdGhlIHNvdW5kIGxhdGVyLiAgTm90ZSBpZCBpcyByZXF1aXJlZCBmb3Igd2hlbiBzcmMgaXMgbXVsdGlwbGUgZXh0ZW5zaW9uIGxhYmVsZWQgc3JjIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyIHwgT2JqZWN0fSBbZGF0YV0gRGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGl0ZW0uIFNvdW5kIHVzZXMgdGhlIGRhdGEgcGFyYW1ldGVyIGFzIHRoZSBudW1iZXIgb2Zcblx0ICogY2hhbm5lbHMgZm9yIGFuIGF1ZGlvIGluc3RhbmNlLCBob3dldmVyIGEgXCJjaGFubmVsc1wiIHByb3BlcnR5IGNhbiBiZSBhcHBlbmRlZCB0byB0aGUgZGF0YSBvYmplY3QgaWYgaXQgaXMgdXNlZFxuXHQgKiBmb3Igb3RoZXIgaW5mb3JtYXRpb24uIFRoZSBhdWRpbyBjaGFubmVscyB3aWxsIHNldCBhIGRlZmF1bHQgYmFzZWQgb24gcGx1Z2luIGlmIG5vIHZhbHVlIGlzIGZvdW5kLlxuXHQgKiBTb3VuZCBhbHNvIHVzZXMgdGhlIGRhdGEgcHJvcGVydHkgdG8gaG9sZCBhbiB7eyNjcm9zc0xpbmsgXCJBdWRpb1Nwcml0ZVwifX17ey9jcm9zc0xpbmt9fSBhcnJheSBvZiBvYmplY3RzIGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0IHtpZCwgc3RhcnRUaW1lLCBkdXJhdGlvbn0uPGJyLz5cblx0ICogICBpZCB1c2VkIHRvIHBsYXkgdGhlIHNvdW5kIGxhdGVyLCBpbiB0aGUgc2FtZSBtYW5uZXIgYXMgYSBzb3VuZCBzcmMgd2l0aCBhbiBpZC48YnIvPlxuXHQgKiAgIHN0YXJ0VGltZSBpcyB0aGUgaW5pdGlhbCBvZmZzZXQgdG8gc3RhcnQgcGxheWJhY2sgYW5kIGxvb3AgZnJvbSwgaW4gbWlsbGlzZWNvbmRzLjxici8+XG5cdCAqICAgZHVyYXRpb24gaXMgdGhlIGFtb3VudCBvZiB0aW1lIHRvIHBsYXkgdGhlIGNsaXAgZm9yLCBpbiBtaWxsaXNlY29uZHMuPGJyLz5cblx0ICogVGhpcyBhbGxvd3MgU291bmQgdG8gc3VwcG9ydCBhdWRpbyBzcHJpdGVzIHRoYXQgYXJlIHBsYXllZCBiYWNrIGJ5IGlkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVBhdGggU2V0IGEgcGF0aCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIHNyYyBmb3IgbG9hZGluZy5cblx0ICogQHBhcmFtIHtPYmplY3QgfCBQbGF5UHJvcHNDb25maWd9IGRlZmF1bHRQbGF5UHJvcHMgT3B0aW9uYWwgUGxheWJhY2sgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgc2V0IGFzIHRoZSBkZWZhdWx0cyBvbiBhbnkgbmV3IEFic3RyYWN0U291bmRJbnN0YW5jZS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlBsYXlQcm9wc0NvbmZpZ1wifX17ey9jcm9zc0xpbmt9fSBmb3Igb3B0aW9ucy5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgbW9kaWZpZWQgdmFsdWVzIHRoYXQgd2VyZSBwYXNzZWQgaW4sIHdoaWNoIGRlZmluZXMgdGhlIHNvdW5kLlxuXHQgKiBSZXR1cm5zIGZhbHNlIGlmIHRoZSBzb3VyY2UgY2Fubm90IGJlIHBhcnNlZCBvciBubyBwbHVnaW5zIGNhbiBiZSBpbml0aWFsaXplZC5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBzb3VyY2UgaXMgYWxyZWFkeSBsb2FkZWQuXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqL1xuXHRzLnJlZ2lzdGVyU291bmQgPSBmdW5jdGlvbiAoc3JjLCBpZCwgZGF0YSwgYmFzZVBhdGgsIGRlZmF1bHRQbGF5UHJvcHMpIHtcblx0XHR2YXIgbG9hZEl0ZW0gPSB7c3JjOiBzcmMsIGlkOiBpZCwgZGF0YTpkYXRhLCBkZWZhdWx0UGxheVByb3BzOmRlZmF1bHRQbGF5UHJvcHN9O1xuXHRcdGlmIChzcmMgaW5zdGFuY2VvZiBPYmplY3QgJiYgc3JjLnNyYykge1xuXHRcdFx0YmFzZVBhdGggPSBpZDtcblx0XHRcdGxvYWRJdGVtID0gc3JjO1xuXHRcdH1cblx0XHRsb2FkSXRlbSA9IGNyZWF0ZWpzLkxvYWRJdGVtLmNyZWF0ZShsb2FkSXRlbSk7XG5cdFx0bG9hZEl0ZW0ucGF0aCA9IGJhc2VQYXRoO1xuXG5cdFx0aWYgKGJhc2VQYXRoICE9IG51bGwgJiYgIShsb2FkSXRlbS5zcmMgaW5zdGFuY2VvZiBPYmplY3QpKSB7bG9hZEl0ZW0uc3JjID0gYmFzZVBhdGggKyBzcmM7fVxuXG5cdFx0dmFyIGxvYWRlciA9IHMuX3JlZ2lzdGVyU291bmQobG9hZEl0ZW0pO1xuXHRcdGlmKCFsb2FkZXIpIHtyZXR1cm4gZmFsc2U7fVxuXG5cdFx0aWYgKCFzLl9wcmVsb2FkSGFzaFtsb2FkSXRlbS5zcmNdKSB7IHMuX3ByZWxvYWRIYXNoW2xvYWRJdGVtLnNyY10gPSBbXTt9XG5cdFx0cy5fcHJlbG9hZEhhc2hbbG9hZEl0ZW0uc3JjXS5wdXNoKGxvYWRJdGVtKTtcblx0XHRpZiAocy5fcHJlbG9hZEhhc2hbbG9hZEl0ZW0uc3JjXS5sZW5ndGggPT0gMSkge1xuXHRcdFx0Ly8gT0pSIG5vdGUgdGhpcyB3aWxsIGRpc2FsbG93IHJlbG9hZGluZyBhIHNvdW5kIGlmIGxvYWRpbmcgZmFpbHMgb3IgdGhlIHNvdXJjZSBjaGFuZ2VzXG5cdFx0XHRsb2FkZXIub24oXCJjb21wbGV0ZVwiLCBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVMb2FkQ29tcGxldGUsIHRoaXMpKTtcblx0XHRcdGxvYWRlci5vbihcImVycm9yXCIsIGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUxvYWRFcnJvciwgdGhpcykpO1xuXHRcdFx0cy5hY3RpdmVQbHVnaW4ucHJlbG9hZChsb2FkZXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAocy5fcHJlbG9hZEhhc2hbbG9hZEl0ZW0uc3JjXVswXSA9PSB0cnVlKSB7cmV0dXJuIHRydWU7fVxuXHRcdH1cblxuXHRcdHJldHVybiBsb2FkSXRlbTtcblx0fTtcblxuXHQvKipcblx0ICogUmVnaXN0ZXIgYW4gYXJyYXkgb2YgYXVkaW8gZmlsZXMgZm9yIGxvYWRpbmcgYW5kIGZ1dHVyZSBwbGF5YmFjayBpbiBTb3VuZC4gSXQgaXMgcmVjb21tZW5kZWQgdG8gcmVnaXN0ZXIgYWxsXG5cdCAqIHNvdW5kcyB0aGF0IG5lZWQgdG8gYmUgcGxheWVkIGJhY2sgaW4gb3JkZXIgdG8gcHJvcGVybHkgcHJlcGFyZSBhbmQgcHJlbG9hZCB0aGVtLiBTb3VuZCBkb2VzIGludGVybmFsIHByZWxvYWRpbmdcblx0ICogd2hlbiByZXF1aXJlZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiBcdFx0dmFyIGFzc2V0UGF0aCA9IFwiLi9teUF1ZGlvUGF0aC9cIjtcblx0ICogICAgICB2YXIgc291bmRzID0gW1xuXHQgKiAgICAgICAgICB7c3JjOlwiYXNzZXQwLm9nZ1wiLCBpZDpcImV4YW1wbGVcIn0sXG5cdCAqICAgICAgICAgIHtzcmM6XCJhc3NldDEub2dnXCIsIGlkOlwiMVwiLCBkYXRhOjZ9LFxuXHQgKiAgICAgICAgICB7c3JjOlwiYXNzZXQyLm1wM1wiLCBpZDpcIndvcmtzXCJ9XG5cdCAqICAgICAgICAgIHtzcmM6e21wMzpcInBhdGgxL2Fzc2V0My5tcDNcIiwgb2dnOlwicGF0aDIvYXNzZXQzTm9FeHRlbnNpb259LCBpZDpcImJldHRlclwifVxuXHQgKiAgICAgIF07XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQuYWx0ZXJuYXRlRXh0ZW5zaW9ucyA9IFtcIm1wM1wiXTtcdC8vIGlmIHRoZSBwYXNzZWQgZXh0ZW5zaW9uIGlzIG5vdCBzdXBwb3J0ZWQsIHRyeSB0aGlzIGV4dGVuc2lvblxuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLm9uKFwiZmlsZWxvYWRcIiwgaGFuZGxlTG9hZCk7IC8vIGNhbGwgaGFuZGxlTG9hZCB3aGVuIGVhY2ggc291bmQgbG9hZHNcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kcyhzb3VuZHMsIGFzc2V0UGF0aCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgcmVnaXN0ZXJTb3VuZHNcblx0ICogQHBhcmFtIHtBcnJheX0gc291bmRzIEFuIGFycmF5IG9mIG9iamVjdHMgdG8gbG9hZC4gT2JqZWN0cyBhcmUgZXhwZWN0ZWQgdG8gYmUgaW4gdGhlIGZvcm1hdCBuZWVkZWQgZm9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRcIn19e3svY3Jvc3NMaW5rfX06IDxjb2RlPntzcmM6c3JjVVJJLCBpZDpJRCwgZGF0YTpEYXRhfTwvY29kZT5cblx0ICogd2l0aCBcImlkXCIgYW5kIFwiZGF0YVwiIGJlaW5nIG9wdGlvbmFsLlxuXHQgKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBvYmplY3Qgd2l0aCBwYXRoIGFuZCBtYW5pZmVzdCBwcm9wZXJ0aWVzLCB3aGVyZSBwYXRoIGlzIGEgYmFzZVBhdGggYW5kIG1hbmlmZXN0IGlzIGFuIGFycmF5IG9mIG9iamVjdHMgdG8gbG9hZC5cblx0ICogTm90ZSBpZCBpcyByZXF1aXJlZCBpZiBzcmMgaXMgYW4gb2JqZWN0IHdpdGggZXh0ZW5zaW9uIGxhYmVsZWQgc3JjIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlUGF0aCBTZXQgYSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgdG8gZWFjaCBzcmMgd2hlbiBsb2FkaW5nLiAgV2hlbiBjcmVhdGluZywgcGxheWluZywgb3IgcmVtb3Zpbmdcblx0ICogYXVkaW8gdGhhdCB3YXMgbG9hZGVkIHdpdGggYSBiYXNlUGF0aCBieSBzcmMsIHRoZSBiYXNlUGF0aCBtdXN0IGJlIGluY2x1ZGVkLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCB0aGUgbW9kaWZpZWQgdmFsdWVzIHRoYXQgd2VyZSBwYXNzZWQgaW4sIHdoaWNoIGRlZmluZXMgZWFjaCBzb3VuZC5cblx0ICogTGlrZSByZWdpc3RlclNvdW5kLCBpdCB3aWxsIHJldHVybiBmYWxzZSBmb3IgYW55IHZhbHVlcyB3aGVuIHRoZSBzb3VyY2UgY2Fubm90IGJlIHBhcnNlZCBvciBpZiBubyBwbHVnaW5zIGNhbiBiZSBpbml0aWFsaXplZC5cblx0ICogQWxzbywgaXQgd2lsbCByZXR1cm4gdHJ1ZSBmb3IgYW55IHZhbHVlcyB3aGVuIHRoZSBzb3VyY2UgaXMgYWxyZWFkeSBsb2FkZWQuXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLnJlZ2lzdGVyU291bmRzID0gZnVuY3Rpb24gKHNvdW5kcywgYmFzZVBhdGgpIHtcblx0XHR2YXIgcmV0dXJuVmFsdWVzID0gW107XG5cdFx0aWYgKHNvdW5kcy5wYXRoKSB7XG5cdFx0XHRpZiAoIWJhc2VQYXRoKSB7XG5cdFx0XHRcdGJhc2VQYXRoID0gc291bmRzLnBhdGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRiYXNlUGF0aCA9IGJhc2VQYXRoICsgc291bmRzLnBhdGg7XG5cdFx0XHR9XG5cdFx0XHRzb3VuZHMgPSBzb3VuZHMubWFuaWZlc3Q7XG5cdFx0XHQvLyBUT0RPIGRvY3VtZW50IHRoaXMgZmVhdHVyZVxuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNvdW5kcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHJldHVyblZhbHVlc1tpXSA9IGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyU291bmQoc291bmRzW2ldLnNyYywgc291bmRzW2ldLmlkLCBzb3VuZHNbaV0uZGF0YSwgYmFzZVBhdGgsIHNvdW5kc1tpXS5kZWZhdWx0UGxheVByb3BzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldHVyblZhbHVlcztcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIGEgc291bmQgdGhhdCBoYXMgYmVlbiByZWdpc3RlcmVkIHdpdGgge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSBvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICogPGJyIC8+Tm90ZSB0aGlzIHdpbGwgc3RvcCBwbGF5YmFjayBvbiBhY3RpdmUgaW5zdGFuY2VzIHBsYXlpbmcgdGhpcyBzb3VuZCBiZWZvcmUgZGVsZXRpbmcgdGhlbS5cblx0ICogPGJyIC8+Tm90ZSBpZiB5b3UgcGFzc2VkIGluIGEgYmFzZVBhdGgsIHlvdSBuZWVkIHRvIHBhc3MgaXQgb3IgcHJlcGVuZCBpdCB0byB0aGUgc3JjIGhlcmUuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZW1vdmVTb3VuZChcIm15SURcIik7XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVtb3ZlU291bmQoXCJteUF1ZGlvQmFzZVBhdGgvbXlTb3VuZC5vZ2dcIik7XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVtb3ZlU291bmQoXCJteVBhdGgvbXlPdGhlclNvdW5kLm1wM1wiLCBcIm15QmFzZVBhdGgvXCIpO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlbW92ZVNvdW5kKHttcDM6XCJtdXNpY05vRXh0ZW5zaW9uXCIsIG9nZzpcIm11c2ljLm9nZ1wifSwgXCJteUJhc2VQYXRoL1wiKTtcblx0ICpcblx0ICogQG1ldGhvZCByZW1vdmVTb3VuZFxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE9iamVjdH0gc3JjIFRoZSBzcmMgb3IgSUQgb2YgdGhlIGF1ZGlvLCBvciBhbiBPYmplY3Qgd2l0aCBhIFwic3JjXCIgcHJvcGVydHksIG9yIGFuIE9iamVjdCB3aXRoIG11bHRpcGxlIGV4dGVuc2lvbiBsYWJlbGVkIHNyYyBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVBhdGggU2V0IGEgcGF0aCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggc3JjIHdoZW4gcmVtb3ZpbmcuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgc291bmQgaXMgc3VjY2Vzc2Z1bGx5IHJlbW92ZWQuXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXHRzLnJlbW92ZVNvdW5kID0gZnVuY3Rpb24oc3JjLCBiYXNlUGF0aCkge1xuXHRcdGlmIChzLmFjdGl2ZVBsdWdpbiA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblxuXHRcdGlmIChzcmMgaW5zdGFuY2VvZiBPYmplY3QgJiYgc3JjLnNyYykge3NyYyA9IHNyYy5zcmM7fVxuXG5cdFx0dmFyIGRldGFpbHM7XG5cdFx0aWYgKHNyYyBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0ZGV0YWlscyA9IHMuX3BhcnNlU3JjKHNyYyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNyYyA9IHMuX2dldFNyY0J5SWQoc3JjKS5zcmM7XG5cdFx0XHRkZXRhaWxzID0gcy5fcGFyc2VQYXRoKHNyYyk7XG5cdFx0fVxuXHRcdGlmIChkZXRhaWxzID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdHNyYyA9IGRldGFpbHMuc3JjO1xuXHRcdGlmIChiYXNlUGF0aCAhPSBudWxsKSB7c3JjID0gYmFzZVBhdGggKyBzcmM7fVxuXG5cdFx0Zm9yKHZhciBwcm9wIGluIHMuX2lkSGFzaCl7XG5cdFx0XHRpZihzLl9pZEhhc2hbcHJvcF0uc3JjID09IHNyYykge1xuXHRcdFx0XHRkZWxldGUocy5faWRIYXNoW3Byb3BdKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBjbGVhciBmcm9tIFNvdW5kQ2hhbm5lbCwgd2hpY2ggYWxzbyBzdG9wcyBhbmQgZGVsZXRlcyBhbGwgaW5zdGFuY2VzXG5cdFx0U291bmRDaGFubmVsLnJlbW92ZVNyYyhzcmMpO1xuXG5cdFx0ZGVsZXRlKHMuX3ByZWxvYWRIYXNoW3NyY10pO1xuXG5cdFx0cy5hY3RpdmVQbHVnaW4ucmVtb3ZlU291bmQoc3JjKTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYW4gYXJyYXkgb2YgYXVkaW8gZmlsZXMgdGhhdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB3aXRoIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIDxiciAvPk5vdGUgdGhpcyB3aWxsIHN0b3AgcGxheWJhY2sgb24gYWN0aXZlIGluc3RhbmNlcyBwbGF5aW5nIHRoaXMgYXVkaW8gYmVmb3JlIGRlbGV0aW5nIHRoZW0uXG5cdCAqIDxiciAvPk5vdGUgaWYgeW91IHBhc3NlZCBpbiBhIGJhc2VQYXRoLCB5b3UgbmVlZCB0byBwYXNzIGl0IG9yIHByZXBlbmQgaXQgdG8gdGhlIHNyYyBoZXJlLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqIFx0XHRhc3NldFBhdGggPSBcIi4vbXlQYXRoL1wiO1xuXHQgKiAgICAgIHZhciBzb3VuZHMgPSBbXG5cdCAqICAgICAgICAgIHtzcmM6XCJhc3NldDAub2dnXCIsIGlkOlwiZXhhbXBsZVwifSxcblx0ICogICAgICAgICAge3NyYzpcImFzc2V0MS5vZ2dcIiwgaWQ6XCIxXCIsIGRhdGE6Nn0sXG5cdCAqICAgICAgICAgIHtzcmM6XCJhc3NldDIubXAzXCIsIGlkOlwid29ya3NcIn1cblx0ICogICAgICBdO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlbW92ZVNvdW5kcyhzb3VuZHMsIGFzc2V0UGF0aCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgcmVtb3ZlU291bmRzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHNvdW5kcyBBbiBhcnJheSBvZiBvYmplY3RzIHRvIHJlbW92ZS4gT2JqZWN0cyBhcmUgZXhwZWN0ZWQgdG8gYmUgaW4gdGhlIGZvcm1hdCBuZWVkZWQgZm9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlbW92ZVNvdW5kXCJ9fXt7L2Nyb3NzTGlua319OiA8Y29kZT57c3JjT3JJRDpzcmNVUklvcklEfTwvY29kZT4uXG5cdCAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIG9iamVjdCB3aXRoIHBhdGggYW5kIG1hbmlmZXN0IHByb3BlcnRpZXMsIHdoZXJlIHBhdGggaXMgYSBiYXNlUGF0aCBhbmQgbWFuaWZlc3QgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB0byByZW1vdmUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlUGF0aCBTZXQgYSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgdG8gZWFjaCBzcmMgd2hlbiByZW1vdmluZy5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBhcnJheSBvZiBCb29sZWFuIHZhbHVlcyByZXByZXNlbnRpbmcgaWYgdGhlIHNvdW5kcyB3aXRoIHRoZSBzYW1lIGFycmF5IGluZGV4IHdlcmVcblx0ICogc3VjY2Vzc2Z1bGx5IHJlbW92ZWQuXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXHRzLnJlbW92ZVNvdW5kcyA9IGZ1bmN0aW9uIChzb3VuZHMsIGJhc2VQYXRoKSB7XG5cdFx0dmFyIHJldHVyblZhbHVlcyA9IFtdO1xuXHRcdGlmIChzb3VuZHMucGF0aCkge1xuXHRcdFx0aWYgKCFiYXNlUGF0aCkge1xuXHRcdFx0XHRiYXNlUGF0aCA9IHNvdW5kcy5wYXRoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YmFzZVBhdGggPSBiYXNlUGF0aCArIHNvdW5kcy5wYXRoO1xuXHRcdFx0fVxuXHRcdFx0c291bmRzID0gc291bmRzLm1hbmlmZXN0O1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNvdW5kcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHJldHVyblZhbHVlc1tpXSA9IGNyZWF0ZWpzLlNvdW5kLnJlbW92ZVNvdW5kKHNvdW5kc1tpXS5zcmMsIGJhc2VQYXRoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldHVyblZhbHVlcztcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIGFsbCBzb3VuZHMgdGhhdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB3aXRoIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIDxiciAvPk5vdGUgdGhpcyB3aWxsIHN0b3AgcGxheWJhY2sgb24gYWxsIGFjdGl2ZSBzb3VuZCBpbnN0YW5jZXMgYmVmb3JlIGRlbGV0aW5nIHRoZW0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgIGNyZWF0ZWpzLlNvdW5kLnJlbW92ZUFsbFNvdW5kcygpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbFNvdW5kc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cy5yZW1vdmVBbGxTb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHRzLl9pZEhhc2ggPSB7fTtcblx0XHRzLl9wcmVsb2FkSGFzaCA9IHt9O1xuXHRcdFNvdW5kQ2hhbm5lbC5yZW1vdmVBbGwoKTtcblx0XHRpZiAocy5hY3RpdmVQbHVnaW4pIHtzLmFjdGl2ZVBsdWdpbi5yZW1vdmVBbGxTb3VuZHMoKTt9XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGEgc291cmNlIGhhcyBiZWVuIGxvYWRlZCBieSBpbnRlcm5hbCBwcmVsb2FkZXJzLiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhhdCBzb3VuZHMgdGhhdCBhcmVcblx0ICogbm90IGNvbXBsZXRlZCBwcmVsb2FkaW5nIHdpbGwgbm90IGtpY2sgb2ZmIGEgbmV3IGludGVybmFsIHByZWxvYWQgaWYgdGhleSBhcmUgcGxheWVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICB2YXIgbXlTb3VuZCA9IFwiYXNzZXRQYXRoL2Fzc2V0MC5vZ2dcIjtcblx0ICogICAgIGlmKGNyZWF0ZWpzLlNvdW5kLmxvYWRDb21wbGV0ZShteVNvdW5kKSB7XG5cdCAqICAgICAgICAgY3JlYXRlanMuU291bmQucGxheShteVNvdW5kKTtcblx0ICogICAgIH1cblx0ICpcblx0ICogQG1ldGhvZCBsb2FkQ29tcGxldGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc3JjIG9yIGlkIHRoYXQgaXMgYmVpbmcgbG9hZGVkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgc3JjIGlzIGFscmVhZHkgbG9hZGVkLlxuXHQgKiBAc2luY2UgMC40LjBcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5sb2FkQ29tcGxldGUgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0aWYgKCFzLmlzUmVhZHkoKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR2YXIgZGV0YWlscyA9IHMuX3BhcnNlUGF0aChzcmMpO1xuXHRcdGlmIChkZXRhaWxzKSB7XG5cdFx0XHRzcmMgPSBzLl9nZXRTcmNCeUlkKGRldGFpbHMuc3JjKS5zcmM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNyYyA9IHMuX2dldFNyY0J5SWQoc3JjKS5zcmM7XG5cdFx0fVxuXHRcdGlmKHMuX3ByZWxvYWRIYXNoW3NyY10gPT0gdW5kZWZpbmVkKSB7cmV0dXJuIGZhbHNlO31cblx0XHRyZXR1cm4gKHMuX3ByZWxvYWRIYXNoW3NyY11bMF0gPT0gdHJ1ZSk7ICAvLyBzcmMgb25seSBsb2FkcyBvbmNlLCBzbyBpZiBpdCdzIHRydWUgZm9yIHRoZSBmaXJzdCBpdCdzIHRydWUgZm9yIGFsbFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSB0aGUgcGF0aCBvZiBhIHNvdW5kLiBBbHRlcm5hdGUgZXh0ZW5zaW9ucyB3aWxsIGJlIGF0dGVtcHRlZCBpbiBvcmRlciBpZiB0aGVcblx0ICogY3VycmVudCBleHRlbnNpb24gaXMgbm90IHN1cHBvcnRlZFxuXHQgKiBAbWV0aG9kIF9wYXJzZVBhdGhcblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBwYXRoIHRvIGFuIGF1ZGlvIHNvdXJjZS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBIGZvcm1hdHRlZCBvYmplY3QgdGhhdCBjYW4gYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9hY3RpdmVQbHVnaW46cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYW5kIHJldHVybmVkIHRvIGEgcHJlbG9hZGVyIGxpa2UgPGEgaHJlZj1cImh0dHA6Ly9wcmVsb2FkanMuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+UHJlbG9hZEpTPC9hPi5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9wYXJzZVBhdGggPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodHlwZW9mKHZhbHVlKSAhPSBcInN0cmluZ1wiKSB7dmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO31cblxuXHRcdHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKHMuRklMRV9QQVRURVJOKTtcblx0XHRpZiAobWF0Y2ggPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cblx0XHR2YXIgbmFtZSA9IG1hdGNoWzRdO1xuXHRcdHZhciBleHQgPSBtYXRjaFs1XTtcblx0XHR2YXIgYyA9IHMuY2FwYWJpbGl0aWVzO1xuXHRcdHZhciBpID0gMDtcblx0XHR3aGlsZSAoIWNbZXh0XSkge1xuXHRcdFx0ZXh0ID0gcy5hbHRlcm5hdGVFeHRlbnNpb25zW2krK107XG5cdFx0XHRpZiAoaSA+IHMuYWx0ZXJuYXRlRXh0ZW5zaW9ucy5sZW5ndGgpIHsgcmV0dXJuIG51bGw7fVx0Ly8gbm8gZXh0ZW5zaW9ucyBhcmUgc3VwcG9ydGVkXG5cdFx0fVxuXHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZShcIi5cIittYXRjaFs1XSwgXCIuXCIrZXh0KTtcblxuXHRcdHZhciByZXQgPSB7bmFtZTpuYW1lLCBzcmM6dmFsdWUsIGV4dGVuc2lvbjpleHR9O1xuXHRcdHJldHVybiByZXQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlIHRoZSBwYXRoIG9mIGEgc291bmQgYmFzZWQgb24gcHJvcGVydGllcyBvZiBzcmMgbWF0Y2hpbmcgd2l0aCBzdXBwb3J0ZWQgZXh0ZW5zaW9ucy5cblx0ICogUmV0dXJucyBmYWxzZSBpZiBub25lIG9mIHRoZSBwcm9wZXJ0aWVzIGFyZSBzdXBwb3J0ZWRcblx0ICogQG1ldGhvZCBfcGFyc2VTcmNcblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSBwYXRocyB0byBhbiBhdWRpbyBzb3VyY2UsIGluZGV4ZWQgYnkgZXh0ZW5zaW9uIHR5cGUuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQSBmb3JtYXR0ZWQgb2JqZWN0IHRoYXQgY2FuIGJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUge3sjY3Jvc3NMaW5rIFwiU291bmQvYWN0aXZlUGx1Z2luOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCByZXR1cm5lZCB0byBhIHByZWxvYWRlciBsaWtlIDxhIGhyZWY9XCJodHRwOi8vcHJlbG9hZGpzLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPlByZWxvYWRKUzwvYT4uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fcGFyc2VTcmMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR2YXIgcmV0ID0ge25hbWU6dW5kZWZpbmVkLCBzcmM6dW5kZWZpbmVkLCBleHRlbnNpb246dW5kZWZpbmVkfTtcblx0XHR2YXIgYyA9IHMuY2FwYWJpbGl0aWVzO1xuXG5cdFx0Zm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkge1xuXHRcdCAgaWYodmFsdWUuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgY1twcm9wXSkge1xuXHRcdFx0XHRyZXQuc3JjID0gdmFsdWVbcHJvcF07XG5cdFx0XHRcdHJldC5leHRlbnNpb24gPSBwcm9wO1xuXHRcdFx0XHRicmVhaztcblx0XHQgIH1cblx0XHR9XG5cdFx0aWYgKCFyZXQuc3JjKSB7cmV0dXJuIGZhbHNlO31cdC8vIG5vIG1hdGNoZXNcblxuXHRcdHZhciBpID0gcmV0LnNyYy5sYXN0SW5kZXhPZihcIi9cIik7XG5cdFx0aWYgKGkgIT0gLTEpIHtcblx0XHRcdHJldC5uYW1lID0gcmV0LnNyYy5zbGljZShpKzEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXQubmFtZSA9IHJldC5zcmM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fTtcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS1cblx0IFN0YXRpYyBBUEkuXG5cdCAtLS0tLS0tLS0tLS0tLS0gKi9cblx0LyoqXG5cdCAqIFBsYXkgYSBzb3VuZCBhbmQgZ2V0IGEge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IHRvIGNvbnRyb2wuIElmIHRoZSBzb3VuZCBmYWlscyB0byBwbGF5LCBhXG5cdCAqIEFic3RyYWN0U291bmRJbnN0YW5jZSB3aWxsIHN0aWxsIGJlIHJldHVybmVkLCBhbmQgaGF2ZSBhIHBsYXlTdGF0ZSBvZiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9QTEFZX0ZBSUxFRDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogTm90ZSB0aGF0IGV2ZW4gb24gc291bmRzIHdpdGggZmFpbGVkIHBsYXliYWNrLCB5b3UgbWF5IHN0aWxsIGJlIGFibGUgdG8gY2FsbCBBYnN0cmFjdFNvdW5kSW5zdGFuY2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3BsYXlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHNpbmNlIHRoZSBmYWlsdXJlIGNvdWxkIGJlIGR1ZSB0byBsYWNrIG9mIGF2YWlsYWJsZSBjaGFubmVscy4gSWYgdGhlIHNyYyBkb2VzIG5vdCBoYXZlIGEgc3VwcG9ydGVkIGV4dGVuc2lvbiBvclxuXHQgKiBpZiB0aGVyZSBpcyBubyBhdmFpbGFibGUgcGx1Z2luLCBhIGRlZmF1bHQgQWJzdHJhY3RTb3VuZEluc3RhbmNlIHdpbGwgYmUgcmV0dXJuZWQgd2hpY2ggd2lsbCBub3QgcGxheSBhbnkgYXVkaW8sIGJ1dCB3aWxsIG5vdCBnZW5lcmF0ZSBlcnJvcnMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5vbihcImZpbGVsb2FkXCIsIGhhbmRsZUxvYWQpO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyU291bmQoXCJteUF1ZGlvUGF0aC9teVNvdW5kLm1wM1wiLCBcIm15SURcIiwgMyk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlTG9hZChldmVudCkge1xuXHQgKiAgICAgIFx0Y3JlYXRlanMuU291bmQucGxheShcIm15SURcIik7XG5cdCAqICAgICAgXHQvLyBzdG9yZSBvZmYgQWJzdHJhY3RTb3VuZEluc3RhbmNlIGZvciBjb250cm9sbGluZ1xuXHQgKiAgICAgIFx0dmFyIG15SW5zdGFuY2UgPSBjcmVhdGVqcy5Tb3VuZC5wbGF5KFwibXlJRFwiLCB7aW50ZXJydXB0OiBjcmVhdGVqcy5Tb3VuZC5JTlRFUlJVUFRfQU5ZLCBsb29wOi0xfSk7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBOT1RFIHRvIGNyZWF0ZSBhbiBhdWRpbyBzcHJpdGUgdGhhdCBoYXMgbm90IGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLCBib3RoIHN0YXJ0VGltZSBhbmQgZHVyYXRpb24gbmVlZCB0byBiZSBzZXQuXG5cdCAqIFRoaXMgaXMgb25seSB3aGVuIGNyZWF0aW5nIGEgbmV3IGF1ZGlvIHNwcml0ZSwgbm90IHdoZW4gcGxheWluZyB1c2luZyB0aGUgaWQgb2YgYW4gYWxyZWFkeSByZWdpc3RlcmVkIGF1ZGlvIHNwcml0ZS5cblx0ICpcblx0ICogPGI+UGFyYW1ldGVycyBEZXByZWNhdGVkPC9iPjxiciAvPlxuXHQgKiBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBtZXRob2QgYXJlIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYSBzaW5nbGUgcGFyYW1ldGVyIHRoYXQgaXMgYW4gT2JqZWN0IG9yIHt7I2Nyb3NzTGluayBcIlBsYXlQcm9wc0NvbmZpZ1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogQG1ldGhvZCBwbGF5XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNyYyBvciBJRCBvZiB0aGUgYXVkaW8uXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgT2JqZWN0fSBbaW50ZXJydXB0PVwibm9uZVwifG9wdGlvbnNdIDxiPlRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgcmVuYW1lZCBwbGF5UHJvcHMgaW4gdGhlIG5leHQgcmVsZWFzZS48L2I+PGJyIC8+XG5cdCAqIFRoaXMgcGFyYW1ldGVyIGNhbiBiZSBhbiBpbnN0YW5jZSBvZiB7eyNjcm9zc0xpbmsgXCJQbGF5UHJvcHNDb25maWdcIn19e3svY3Jvc3NMaW5rfX0gb3IgYW4gT2JqZWN0IHRoYXQgY29udGFpbnMgYW55IG9yIGFsbCBvcHRpb25hbCBwcm9wZXJ0aWVzIGJ5IG5hbWUsXG5cdCAqIGluY2x1ZGluZzogaW50ZXJydXB0LCBkZWxheSwgb2Zmc2V0LCBsb29wLCB2b2x1bWUsIHBhbiwgc3RhcnRUaW1lLCBhbmQgZHVyYXRpb24gKHNlZSB0aGUgYWJvdmUgY29kZSBzYW1wbGUpLlxuXHQgKiA8YnIgLz48c3Ryb25nPk9SPC9zdHJvbmc+PGJyIC8+XG5cdCAqIDxiPkRlcHJlY2F0ZWQ8L2I+IEhvdyB0byBpbnRlcnJ1cHQgYW55IGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlcyBvZiBhdWRpbyB3aXRoIHRoZSBzYW1lIHNvdXJjZSxcblx0ICogaWYgdGhlIG1heGltdW0gbnVtYmVyIG9mIGluc3RhbmNlcyBvZiB0aGUgc291bmQgYXJlIGFscmVhZHkgcGxheWluZy4gVmFsdWVzIGFyZSBkZWZpbmVkIGFzIDxjb2RlPklOVEVSUlVQVF9UWVBFPC9jb2RlPlxuXHQgKiBjb25zdGFudHMgb24gdGhlIFNvdW5kIGNsYXNzLCB3aXRoIHRoZSBkZWZhdWx0IGRlZmluZWQgYnkge3sjY3Jvc3NMaW5rIFwiU291bmQvZGVmYXVsdEludGVycnVwdEJlaGF2aW9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2RlbGF5PTBdIDxiPkRlcHJlY2F0ZWQ8L2I+IFRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSB0aGUgc3RhcnQgb2YgYXVkaW8gcGxheWJhY2ssIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXQ9MF0gPGI+RGVwcmVjYXRlZDwvYj4gVGhlIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgYXVkaW8gdG8gYmVnaW4gcGxheWJhY2ssIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtsb29wPTBdIDxiPkRlcHJlY2F0ZWQ8L2I+IEhvdyBtYW55IHRpbWVzIHRoZSBhdWRpbyBsb29wcyB3aGVuIGl0IHJlYWNoZXMgdGhlIGVuZCBvZiBwbGF5YmFjay4gVGhlIGRlZmF1bHQgaXMgMCAobm9cblx0ICogbG9vcHMpLCBhbmQgLTEgY2FuIGJlIHVzZWQgZm9yIGluZmluaXRlIHBsYXliYWNrLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3ZvbHVtZT0xXSA8Yj5EZXByZWNhdGVkPC9iPiBUaGUgdm9sdW1lIG9mIHRoZSBzb3VuZCwgYmV0d2VlbiAwIGFuZCAxLiBOb3RlIHRoYXQgdGhlIG1hc3RlciB2b2x1bWUgaXMgYXBwbGllZFxuXHQgKiBhZ2FpbnN0IHRoZSBpbmRpdmlkdWFsIHZvbHVtZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwYW49MF0gPGI+RGVwcmVjYXRlZDwvYj4gVGhlIGxlZnQtcmlnaHQgcGFuIG9mIHRoZSBzb3VuZCAoaWYgc3VwcG9ydGVkKSwgYmV0d2VlbiAtMSAobGVmdCkgYW5kIDEgKHJpZ2h0KS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydFRpbWU9bnVsbF0gPGI+RGVwcmVjYXRlZDwvYj4gVG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSAod2l0aCBkdXJhdGlvbiksIHRoZSBpbml0aWFsIG9mZnNldCB0byBzdGFydCBwbGF5YmFjayBhbmQgbG9vcCBmcm9tLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZHVyYXRpb249bnVsbF0gPGI+RGVwcmVjYXRlZDwvYj4gVG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSAod2l0aCBzdGFydFRpbWUpLCB0aGUgYW1vdW50IG9mIHRpbWUgdG8gcGxheSB0aGUgY2xpcCBmb3IsIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBBIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGNhbiBiZSBjb250cm9sbGVkIGFmdGVyIGl0IGlzIGNyZWF0ZWQuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMucGxheSA9IGZ1bmN0aW9uIChzcmMsIGludGVycnVwdCwgZGVsYXksIG9mZnNldCwgbG9vcCwgdm9sdW1lLCBwYW4sIHN0YXJ0VGltZSwgZHVyYXRpb24pIHtcblx0XHR2YXIgcGxheVByb3BzO1xuXHRcdGlmIChpbnRlcnJ1cHQgaW5zdGFuY2VvZiBPYmplY3QgfHwgaW50ZXJydXB0IGluc3RhbmNlb2YgY3JlYXRlanMuUGxheVByb3BzQ29uZmlnKSB7XG5cdFx0XHRwbGF5UHJvcHMgPSBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcuY3JlYXRlKGludGVycnVwdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBsYXlQcm9wcyA9IGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZy5jcmVhdGUoe2ludGVycnVwdDppbnRlcnJ1cHQsIGRlbGF5OmRlbGF5LCBvZmZzZXQ6b2Zmc2V0LCBsb29wOmxvb3AsIHZvbHVtZTp2b2x1bWUsIHBhbjpwYW4sIHN0YXJ0VGltZTpzdGFydFRpbWUsIGR1cmF0aW9uOmR1cmF0aW9ufSk7XG5cdFx0fVxuXHRcdHZhciBpbnN0YW5jZSA9IHMuY3JlYXRlSW5zdGFuY2Uoc3JjLCBwbGF5UHJvcHMuc3RhcnRUaW1lLCBwbGF5UHJvcHMuZHVyYXRpb24pO1xuXHRcdHZhciBvayA9IHMuX3BsYXlJbnN0YW5jZShpbnN0YW5jZSwgcGxheVByb3BzKTtcblx0XHRpZiAoIW9rKSB7aW5zdGFuY2UuX3BsYXlGYWlsZWQoKTt9XG5cdFx0cmV0dXJuIGluc3RhbmNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IHVzaW5nIHRoZSBwYXNzZWQgaW4gc3JjLiBJZiB0aGUgc3JjIGRvZXMgbm90IGhhdmUgYVxuXHQgKiBzdXBwb3J0ZWQgZXh0ZW5zaW9uIG9yIGlmIHRoZXJlIGlzIG5vIGF2YWlsYWJsZSBwbHVnaW4sIGEgZGVmYXVsdCBBYnN0cmFjdFNvdW5kSW5zdGFuY2Ugd2lsbCBiZSByZXR1cm5lZCB0aGF0IGNhbiBiZVxuXHQgKiBjYWxsZWQgc2FmZWx5IGJ1dCBkb2VzIG5vdGhpbmcuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgbXlJbnN0YW5jZSA9IG51bGw7XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQub24oXCJmaWxlbG9hZFwiLCBoYW5kbGVMb2FkKTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kKFwibXlBdWRpb1BhdGgvbXlTb3VuZC5tcDNcIiwgXCJteUlEXCIsIDMpO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUxvYWQoZXZlbnQpIHtcblx0ICogICAgICBcdG15SW5zdGFuY2UgPSBjcmVhdGVqcy5Tb3VuZC5jcmVhdGVJbnN0YW5jZShcIm15SURcIik7XG5cdCAqICAgICAgXHQvLyBhbHRlcm5hdGVseSB3ZSBjb3VsZCBjYWxsIHRoZSBmb2xsb3dpbmdcblx0ICogICAgICBcdG15SW5zdGFuY2UgPSBjcmVhdGVqcy5Tb3VuZC5jcmVhdGVJbnN0YW5jZShcIm15QXVkaW9QYXRoL215U291bmQubXAzXCIpO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogTk9URSB0byBjcmVhdGUgYW4gYXVkaW8gc3ByaXRlIHRoYXQgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCwgYm90aCBzdGFydFRpbWUgYW5kIGR1cmF0aW9uIG5lZWQgdG8gYmUgc2V0LlxuXHQgKiBUaGlzIGlzIG9ubHkgd2hlbiBjcmVhdGluZyBhIG5ldyBhdWRpbyBzcHJpdGUsIG5vdCB3aGVuIHBsYXlpbmcgdXNpbmcgdGhlIGlkIG9mIGFuIGFscmVhZHkgcmVnaXN0ZXJlZCBhdWRpbyBzcHJpdGUuXG5cdCAqXG5cdCAqIEBtZXRob2QgY3JlYXRlSW5zdGFuY2Vcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc3JjIG9yIElEIG9mIHRoZSBhdWRpby5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydFRpbWU9bnVsbF0gVG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSAod2l0aCBkdXJhdGlvbiksIHRoZSBpbml0aWFsIG9mZnNldCB0byBzdGFydCBwbGF5YmFjayBhbmQgbG9vcCBmcm9tLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZHVyYXRpb249bnVsbF0gVG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSAod2l0aCBzdGFydFRpbWUpLCB0aGUgYW1vdW50IG9mIHRpbWUgdG8gcGxheSB0aGUgY2xpcCBmb3IsIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBBIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGNhbiBiZSBjb250cm9sbGVkIGFmdGVyIGl0IGlzIGNyZWF0ZWQuXG5cdCAqIFVuc3VwcG9ydGVkIGV4dGVuc2lvbnMgd2lsbCByZXR1cm4gdGhlIGRlZmF1bHQgQWJzdHJhY3RTb3VuZEluc3RhbmNlLlxuXHQgKiBAc2luY2UgMC40LjBcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uIChzcmMsIHN0YXJ0VGltZSwgZHVyYXRpb24pIHtcblx0XHRpZiAoIXMuaW5pdGlhbGl6ZURlZmF1bHRQbHVnaW5zKCkpIHtyZXR1cm4gbmV3IGNyZWF0ZWpzLkRlZmF1bHRTb3VuZEluc3RhbmNlKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbik7fVxuXG5cdFx0dmFyIGRlZmF1bHRQbGF5UHJvcHMgPSBzLl9kZWZhdWx0UGxheVByb3BzSGFzaFtzcmNdO1x0Ly8gZm9yIGF1ZGlvIHNwcml0ZXMsIHdoaWNoIGNyZWF0ZSBhbmQgc3RvcmUgZGVmYXVsdHMgYnkgaWRcblx0XHRzcmMgPSBzLl9nZXRTcmNCeUlkKHNyYyk7XG5cblx0XHR2YXIgZGV0YWlscyA9IHMuX3BhcnNlUGF0aChzcmMuc3JjKTtcblxuXHRcdHZhciBpbnN0YW5jZSA9IG51bGw7XG5cdFx0aWYgKGRldGFpbHMgIT0gbnVsbCAmJiBkZXRhaWxzLnNyYyAhPSBudWxsKSB7XG5cdFx0XHRTb3VuZENoYW5uZWwuY3JlYXRlKGRldGFpbHMuc3JjKTtcblx0XHRcdGlmIChzdGFydFRpbWUgPT0gbnVsbCkge3N0YXJ0VGltZSA9IHNyYy5zdGFydFRpbWU7fVxuXHRcdFx0aW5zdGFuY2UgPSBzLmFjdGl2ZVBsdWdpbi5jcmVhdGUoZGV0YWlscy5zcmMsIHN0YXJ0VGltZSwgZHVyYXRpb24gfHwgc3JjLmR1cmF0aW9uKTtcblxuXHRcdFx0ZGVmYXVsdFBsYXlQcm9wcyA9IGRlZmF1bHRQbGF5UHJvcHMgfHwgcy5fZGVmYXVsdFBsYXlQcm9wc0hhc2hbZGV0YWlscy5zcmNdO1xuXHRcdFx0aWYoZGVmYXVsdFBsYXlQcm9wcykge1xuXHRcdFx0XHRpbnN0YW5jZS5hcHBseVBsYXlQcm9wcyhkZWZhdWx0UGxheVByb3BzKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5zdGFuY2UgPSBuZXcgY3JlYXRlanMuRGVmYXVsdFNvdW5kSW5zdGFuY2Uoc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uKTtcblx0XHR9XG5cblx0XHRpbnN0YW5jZS51bmlxdWVJZCA9IHMuX2xhc3RJRCsrO1xuXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wIGFsbCBhdWRpbyAoZ2xvYmFsIHN0b3ApLiBTdG9wcGVkIGF1ZGlvIGlzIHJlc2V0LCBhbmQgbm90IHBhdXNlZC4gVG8gcGxheSBhdWRpbyB0aGF0IGhhcyBiZWVuIHN0b3BwZWQsXG5cdCAqIGNhbGwgQWJzdHJhY3RTb3VuZEluc3RhbmNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9wbGF5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICBjcmVhdGVqcy5Tb3VuZC5zdG9wKCk7XG5cdCAqXG5cdCAqIEBtZXRob2Qgc3RvcFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGluc3RhbmNlcyA9IHRoaXMuX2luc3RhbmNlcztcblx0XHRmb3IgKHZhciBpID0gaW5zdGFuY2VzLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdGluc3RhbmNlc1tpXS5zdG9wKCk7ICAvLyBOT1RFIHN0b3AgcmVtb3ZlcyBpbnN0YW5jZSBmcm9tIHRoaXMuX2luc3RhbmNlc1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC92b2x1bWU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICpcblx0ICogQG1ldGhvZCBzZXRWb2x1bWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBtYXN0ZXIgdm9sdW1lIHZhbHVlLiBUaGUgYWNjZXB0YWJsZSByYW5nZSBpcyAwLTEuXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdHMuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKE51bWJlcih2YWx1ZSkgPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cdFx0dmFsdWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB2YWx1ZSkpO1xuXHRcdHMuX21hc3RlclZvbHVtZSA9IHZhbHVlO1xuXHRcdGlmICghdGhpcy5hY3RpdmVQbHVnaW4gfHwgIXRoaXMuYWN0aXZlUGx1Z2luLnNldFZvbHVtZSB8fCAhdGhpcy5hY3RpdmVQbHVnaW4uc2V0Vm9sdW1lKHZhbHVlKSkge1xuXHRcdFx0dmFyIGluc3RhbmNlcyA9IHRoaXMuX2luc3RhbmNlcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaW5zdGFuY2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpbnN0YW5jZXNbaV0uc2V0TWFzdGVyVm9sdW1lKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERlcHJlY2F0ZWQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiU291bmQvdm9sdW1lOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0Vm9sdW1lXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1hc3RlciB2b2x1bWUsIGluIGEgcmFuZ2Ugb2YgMC0xLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHRzLmdldFZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFzdGVyVm9sdW1lO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXByZWNhdGVkLCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIlNvdW5kL211dGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0TXV0ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFdoZXRoZXIgdGhlIGF1ZGlvIHNob3VsZCBiZSBtdXRlZCBvciBub3QuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBtdXRlIHdhcyBzZXQuXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHRzLnNldE11dGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cblx0XHR0aGlzLl9tYXN0ZXJNdXRlID0gdmFsdWU7XG5cdFx0aWYgKCF0aGlzLmFjdGl2ZVBsdWdpbiB8fCAhdGhpcy5hY3RpdmVQbHVnaW4uc2V0TXV0ZSB8fCAhdGhpcy5hY3RpdmVQbHVnaW4uc2V0TXV0ZSh2YWx1ZSkpIHtcblx0XHRcdHZhciBpbnN0YW5jZXMgPSB0aGlzLl9pbnN0YW5jZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGluc3RhbmNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aW5zdGFuY2VzW2ldLnNldE1hc3Rlck11dGUodmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogRGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9tdXRlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGdldE11dGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIG11dGUgdmFsdWUgb2YgU291bmQuXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHRzLmdldE11dGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hc3Rlck11dGU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgZGVmYXVsdCBwbGF5YmFjayBwcm9wZXJ0aWVzIGZvciBhbGwgbmV3IFNvdW5kSW5zdGFuY2VzIG9mIHRoZSBwYXNzZWQgaW4gc3JjIG9yIElELlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiUGxheVByb3BzQ29uZmlnXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhdmFpbGFibGUgcHJvcGVydGllcy5cblx0ICpcblx0ICogQG1ldGhvZCBzZXREZWZhdWx0UGxheVByb3BzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNyYyBvciBJRCB1c2VkIHRvIHJlZ2lzdGVyIHRoZSBhdWRpby5cblx0ICogQHBhcmFtIHtPYmplY3QgfCBQbGF5UHJvcHNDb25maWd9IHBsYXlQcm9wcyBUaGUgcGxheWJhY2sgcHJvcGVydGllcyB5b3Ugd291bGQgbGlrZSB0byBzZXQuXG5cdCAqIEBzaW5jZSAwLjYuMVxuXHQgKi9cblx0cy5zZXREZWZhdWx0UGxheVByb3BzID0gZnVuY3Rpb24oc3JjLCBwbGF5UHJvcHMpIHtcblx0XHRzcmMgPSBzLl9nZXRTcmNCeUlkKHNyYyk7XG5cdFx0cy5fZGVmYXVsdFBsYXlQcm9wc0hhc2hbcy5fcGFyc2VQYXRoKHNyYy5zcmMpLnNyY10gPSBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcuY3JlYXRlKHBsYXlQcm9wcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgZGVmYXVsdCBwbGF5YmFjayBwcm9wZXJ0aWVzIGZvciB0aGUgcGFzc2VkIGluIHNyYyBvciBJRC4gIFRoZXNlIHByb3BlcnRpZXMgYXJlIGFwcGxpZWQgdG8gYWxsXG5cdCAqIG5ldyBTb3VuZEluc3RhbmNlcy4gIFJldHVybnMgbnVsbCBpZiBkZWZhdWx0IGRvZXMgbm90IGV4aXN0LlxuXHQgKlxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQbGF5UHJvcHNcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc3JjIG9yIElEIHVzZWQgdG8gcmVnaXN0ZXIgdGhlIGF1ZGlvLlxuXHQgKiBAcmV0dXJucyB7UGxheVByb3BzQ29uZmlnfSByZXR1cm5zIGFuIGV4aXN0aW5nIFBsYXlQcm9wc0NvbmZpZyBvciBudWxsIGlmIG9uZSBkb2VzIG5vdCBleGlzdFxuXHQgKiBAc2luY2UgMC42LjFcblx0ICovXG5cdHMuZ2V0RGVmYXVsdFBsYXlQcm9wcyA9IGZ1bmN0aW9uKHNyYykge1xuXHRcdHNyYyA9IHMuX2dldFNyY0J5SWQoc3JjKTtcblx0XHRyZXR1cm4gcy5fZGVmYXVsdFBsYXlQcm9wc0hhc2hbcy5fcGFyc2VQYXRoKHNyYy5zcmMpLnNyY107XG5cdH07XG5cblxuXHQvKiAtLS0tLS0tLS0tLS0tLS1cblx0IEludGVybmFsIG1ldGhvZHNcblx0IC0tLS0tLS0tLS0tLS0tLSAqL1xuXHQvKipcblx0ICogUGxheSBhbiBpbnN0YW5jZS4gVGhpcyBpcyBjYWxsZWQgYnkgdGhlIHN0YXRpYyBBUEksIGFzIHdlbGwgYXMgZnJvbSBwbHVnaW5zLiBUaGlzIGFsbG93cyB0aGUgY29yZSBjbGFzcyB0b1xuXHQgKiBjb250cm9sIGRlbGF5cy5cblx0ICogQG1ldGhvZCBfcGxheUluc3RhbmNlXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBpbnN0YW5jZSBUaGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IHRvIHN0YXJ0IHBsYXlpbmcuXG5cdCAqIEBwYXJhbSB7UGxheVByb3BzQ29uZmlnfSBwbGF5UHJvcHMgQSBQbGF5UHJvcHNDb25maWcgb2JqZWN0LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgc291bmQgY2FuIHN0YXJ0IHBsYXlpbmcuIFNvdW5kcyB0aGF0IGZhaWwgaW1tZWRpYXRlbHkgd2lsbCByZXR1cm4gZmFsc2UuIFNvdW5kcyB0aGF0XG5cdCAqIGhhdmUgYSBkZWxheSB3aWxsIHJldHVybiB0cnVlLCBidXQgbWF5IHN0aWxsIGZhaWwgdG8gcGxheS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9wbGF5SW5zdGFuY2UgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIHBsYXlQcm9wcykge1xuXHRcdHZhciBkZWZhdWx0UGxheVByb3BzID0gcy5fZGVmYXVsdFBsYXlQcm9wc0hhc2hbaW5zdGFuY2Uuc3JjXSB8fCB7fTtcblx0XHRpZiAocGxheVByb3BzLmludGVycnVwdCA9PSBudWxsKSB7cGxheVByb3BzLmludGVycnVwdCA9IGRlZmF1bHRQbGF5UHJvcHMuaW50ZXJydXB0IHx8IHMuZGVmYXVsdEludGVycnVwdEJlaGF2aW9yfTtcblx0XHRpZiAocGxheVByb3BzLmRlbGF5ID09IG51bGwpIHtwbGF5UHJvcHMuZGVsYXkgPSBkZWZhdWx0UGxheVByb3BzLmRlbGF5IHx8IDA7fVxuXHRcdGlmIChwbGF5UHJvcHMub2Zmc2V0ID09IG51bGwpIHtwbGF5UHJvcHMub2Zmc2V0ID0gaW5zdGFuY2UuZ2V0UG9zaXRpb24oKTt9XG5cdFx0aWYgKHBsYXlQcm9wcy5sb29wID09IG51bGwpIHtwbGF5UHJvcHMubG9vcCA9IGluc3RhbmNlLmxvb3A7fVxuXHRcdGlmIChwbGF5UHJvcHMudm9sdW1lID09IG51bGwpIHtwbGF5UHJvcHMudm9sdW1lID0gaW5zdGFuY2Uudm9sdW1lO31cblx0XHRpZiAocGxheVByb3BzLnBhbiA9PSBudWxsKSB7cGxheVByb3BzLnBhbiA9IGluc3RhbmNlLnBhbjt9XG5cblx0XHRpZiAocGxheVByb3BzLmRlbGF5ID09IDApIHtcblx0XHRcdHZhciBvayA9IHMuX2JlZ2luUGxheWluZyhpbnN0YW5jZSwgcGxheVByb3BzKTtcblx0XHRcdGlmICghb2spIHtyZXR1cm4gZmFsc2U7fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvL05vdGUgdGhhdCB3ZSBjYW4ndCBwYXNzIGFyZ3VtZW50cyB0byBwcm94eSBPUiBzZXRUaW1lb3V0IChJRSBvbmx5KSwgc28ganVzdCB3cmFwIHRoZSBmdW5jdGlvbiBjYWxsLlxuXHRcdFx0Ly8gT0pSIFdlYkF1ZGlvIG1heSB3YW50IHRvIGhhbmRsZSB0aGlzIGRpZmZlcmVudGx5LCBzbyBpdCBtaWdodCBtYWtlIHNlbnNlIHRvIG1vdmUgdGhpcyBmdW5jdGlvbmFsaXR5IGludG8gdGhlIHBsdWdpbnMgaW4gdGhlIGZ1dHVyZVxuXHRcdFx0dmFyIGRlbGF5VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHMuX2JlZ2luUGxheWluZyhpbnN0YW5jZSwgcGxheVByb3BzKTtcblx0XHRcdH0sIHBsYXlQcm9wcy5kZWxheSk7XG5cdFx0XHRpbnN0YW5jZS5kZWxheVRpbWVvdXRJZCA9IGRlbGF5VGltZW91dElkO1xuXHRcdH1cblxuXHRcdHRoaXMuX2luc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbiBwbGF5YmFjay4gVGhpcyBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgb3IgYWZ0ZXIgZGVsYXkgYnkge3sjY3Jvc3NMaW5rIFwiU291bmQvcGxheUluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIF9iZWdpblBsYXlpbmdcblx0ICogQHBhcmFtIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IGluc3RhbmNlIEEge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IHRvIGJlZ2luIHBsYXliYWNrLlxuXHQgKiBAcGFyYW0ge1BsYXlQcm9wc0NvbmZpZ30gcGxheVByb3BzIEEgUGxheVByb3BzQ29uZmlnIG9iamVjdC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHNvdW5kIGNhbiBzdGFydCBwbGF5aW5nLiBJZiB0aGVyZSBhcmUgbm8gYXZhaWxhYmxlIGNoYW5uZWxzLCBvciB0aGUgaW5zdGFuY2UgZmFpbHMgdG9cblx0ICogc3RhcnQsIHRoaXMgd2lsbCByZXR1cm4gZmFsc2UuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fYmVnaW5QbGF5aW5nID0gZnVuY3Rpb24gKGluc3RhbmNlLCBwbGF5UHJvcHMpIHtcblx0XHRpZiAoIVNvdW5kQ2hhbm5lbC5hZGQoaW5zdGFuY2UsIHBsYXlQcm9wcy5pbnRlcnJ1cHQpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHZhciByZXN1bHQgPSBpbnN0YW5jZS5fYmVnaW5QbGF5aW5nKHBsYXlQcm9wcyk7XG5cdFx0aWYgKCFyZXN1bHQpIHtcblx0XHRcdHZhciBpbmRleCA9IGNyZWF0ZWpzLmluZGV4T2YodGhpcy5faW5zdGFuY2VzLCBpbnN0YW5jZSk7XG5cdFx0XHRpZiAoaW5kZXggPiAtMSkge3RoaXMuX2luc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO31cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgc291cmNlIG9mIGEgc291bmQgdmlhIHRoZSBJRCBwYXNzZWQgaW4gd2l0aCBhIHJlZ2lzdGVyIGNhbGwuIElmIG5vIElEIGlzIGZvdW5kIHRoZSB2YWx1ZSBpcyByZXR1cm5lZFxuXHQgKiBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIF9nZXRTcmNCeUlkXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgSUQgdGhlIHNvdW5kIHdhcyByZWdpc3RlcmVkIHdpdGguXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHNvdXJjZSBvZiB0aGUgc291bmQgaWYgaXQgaGFzIGJlZW4gcmVnaXN0ZXJlZCB3aXRoIHRoaXMgSUQgb3IgdGhlIHZhbHVlIHRoYXQgd2FzIHBhc3NlZCBpbi5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9nZXRTcmNCeUlkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHMuX2lkSGFzaFt2YWx1ZV0gfHwge3NyYzogdmFsdWV9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIHNvdW5kIGhhcyBjb21wbGV0ZWQgcGxheWJhY2ssIGJlZW4gaW50ZXJydXB0ZWQsIGZhaWxlZCwgb3IgYmVlbiBzdG9wcGVkLiBUaGlzIG1ldGhvZCByZW1vdmVzIHRoZSBpbnN0YW5jZSBmcm9tXG5cdCAqIFNvdW5kIG1hbmFnZW1lbnQuIEl0IHdpbGwgYmUgYWRkZWQgYWdhaW4sIGlmIHRoZSBzb3VuZCByZS1wbGF5cy4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBmcm9tIHRoZVxuXHQgKiBpbnN0YW5jZXMgdGhlbXNlbHZlcy5cblx0ICogQG1ldGhvZCBfcGxheUZpbmlzaGVkXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBpbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBmaW5pc2hlZCBwbGF5YmFjay5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9wbGF5RmluaXNoZWQgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcblx0XHRTb3VuZENoYW5uZWwucmVtb3ZlKGluc3RhbmNlKTtcblx0XHR2YXIgaW5kZXggPSBjcmVhdGVqcy5pbmRleE9mKHRoaXMuX2luc3RhbmNlcywgaW5zdGFuY2UpO1xuXHRcdGlmIChpbmRleCA+IC0xKSB7dGhpcy5faW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7fVx0Ly8gT0pSIHRoaXMgd2lsbCBhbHdheXMgYmUgPiAtMSwgdGhlcmUgaXMgbm8gd2F5IGZvciBhbiBpbnN0YW5jZSB0byBleGlzdCB3aXRob3V0IGJlaW5nIGFkZGVkIHRvIHRoaXMuX2luc3RhbmNlc1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlNvdW5kID0gU291bmQ7XG5cblx0LyoqXG5cdCAqIEFuIGludGVybmFsIGNsYXNzIHRoYXQgbWFuYWdlcyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzIGZvclxuXHQgKiBlYWNoIHNvdW5kIHR5cGUuIFRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcy5cblx0ICpcblx0ICogVGhlIG51bWJlciBvZiBzb3VuZHMgaXMgYXJ0aWZpY2lhbGx5IGxpbWl0ZWQgYnkgU291bmQgaW4gb3JkZXIgdG8gcHJldmVudCBvdmVyLXNhdHVyYXRpb24gb2YgYVxuXHQgKiBzaW5nbGUgc291bmQsIGFzIHdlbGwgYXMgdG8gc3RheSB3aXRoaW4gaGFyZHdhcmUgbGltaXRhdGlvbnMsIGFsdGhvdWdoIHRoZSBsYXR0ZXIgbWF5IGRpc2FwcGVhciB3aXRoIGJldHRlclxuXHQgKiBicm93c2VyIHN1cHBvcnQuXG5cdCAqXG5cdCAqIFdoZW4gYSBzb3VuZCBpcyBwbGF5ZWQsIHRoaXMgY2xhc3MgZW5zdXJlcyB0aGF0IHRoZXJlIGlzIGFuIGF2YWlsYWJsZSBpbnN0YW5jZSwgb3IgaW50ZXJydXB0cyBhbiBhcHByb3ByaWF0ZVxuXHQgKiBzb3VuZCB0aGF0IGlzIGFscmVhZHkgcGxheWluZy5cblx0ICogI2NsYXNzIFNvdW5kQ2hhbm5lbFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2Ugb2YgdGhlIGluc3RhbmNlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW21heD0xXSBUaGUgbnVtYmVyIG9mIGluc3RhbmNlcyBhbGxvd2VkXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRmdW5jdGlvbiBTb3VuZENoYW5uZWwoc3JjLCBtYXgpIHtcblx0XHR0aGlzLmluaXQoc3JjLCBtYXgpO1xuXHR9XG5cblx0LyogLS0tLS0tLS0tLS0tXG5cdCBTdGF0aWMgQVBJXG5cdCAtLS0tLS0tLS0tLS0gKi9cblx0LyoqXG5cdCAqIEEgaGFzaCBvZiBjaGFubmVsIGluc3RhbmNlcyBpbmRleGVkIGJ5IHNvdXJjZS5cblx0ICogI3Byb3BlcnR5IGNoYW5uZWxzXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFNvdW5kQ2hhbm5lbC5jaGFubmVscyA9IHt9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBzb3VuZCBjaGFubmVsLiBOb3RlIHRoYXQgaWYgdGhlIHNvdW5kIGNoYW5uZWwgYWxyZWFkeSBleGlzdHMsIHRoaXMgd2lsbCBmYWlsLlxuXHQgKiAjbWV0aG9kIGNyZWF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2UgZm9yIHRoZSBjaGFubmVsXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtYXggVGhlIG1heGltdW0gYW1vdW50IHRoaXMgY2hhbm5lbCBob2xkcy4gVGhlIGRlZmF1bHQgaXMge3sjY3Jvc3NMaW5rIFwiU291bmRDaGFubmVsLm1heERlZmF1bHRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBjaGFubmVscyB3ZXJlIGNyZWF0ZWQuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFNvdW5kQ2hhbm5lbC5jcmVhdGUgPSBmdW5jdGlvbiAoc3JjLCBtYXgpIHtcblx0XHR2YXIgY2hhbm5lbCA9IFNvdW5kQ2hhbm5lbC5nZXQoc3JjKTtcblx0XHRpZiAoY2hhbm5lbCA9PSBudWxsKSB7XG5cdFx0XHRTb3VuZENoYW5uZWwuY2hhbm5lbHNbc3JjXSA9IG5ldyBTb3VuZENoYW5uZWwoc3JjLCBtYXgpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblx0LyoqXG5cdCAqIERlbGV0ZSBhIHNvdW5kIGNoYW5uZWwsIHN0b3AgYW5kIGRlbGV0ZSBhbGwgcmVsYXRlZCBpbnN0YW5jZXMuIE5vdGUgdGhhdCBpZiB0aGUgc291bmQgY2hhbm5lbCBkb2VzIG5vdCBleGlzdCwgdGhpcyB3aWxsIGZhaWwuXG5cdCAqICNtZXRob2QgcmVtb3ZlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBmb3IgdGhlIGNoYW5uZWxcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGNoYW5uZWxzIHdlcmUgZGVsZXRlZC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0U291bmRDaGFubmVsLnJlbW92ZVNyYyA9IGZ1bmN0aW9uIChzcmMpIHtcblx0XHR2YXIgY2hhbm5lbCA9IFNvdW5kQ2hhbm5lbC5nZXQoc3JjKTtcblx0XHRpZiAoY2hhbm5lbCA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblx0XHRjaGFubmVsLl9yZW1vdmVBbGwoKTtcdC8vIHRoaXMgc3RvcHMgYW5kIHJlbW92ZXMgYWxsIGFjdGl2ZSBpbnN0YW5jZXNcblx0XHRkZWxldGUoU291bmRDaGFubmVsLmNoYW5uZWxzW3NyY10pO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHQvKipcblx0ICogRGVsZXRlIGFsbCBzb3VuZCBjaGFubmVscywgc3RvcCBhbmQgZGVsZXRlIGFsbCByZWxhdGVkIGluc3RhbmNlcy5cblx0ICogI21ldGhvZCByZW1vdmVBbGxcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0U291bmRDaGFubmVsLnJlbW92ZUFsbCA9IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IodmFyIGNoYW5uZWwgaW4gU291bmRDaGFubmVsLmNoYW5uZWxzKSB7XG5cdFx0XHRTb3VuZENoYW5uZWwuY2hhbm5lbHNbY2hhbm5lbF0uX3JlbW92ZUFsbCgpO1x0Ly8gdGhpcyBzdG9wcyBhbmQgcmVtb3ZlcyBhbGwgYWN0aXZlIGluc3RhbmNlc1xuXHRcdH1cblx0XHRTb3VuZENoYW5uZWwuY2hhbm5lbHMgPSB7fTtcblx0fTtcblx0LyoqXG5cdCAqIEFkZCBhbiBpbnN0YW5jZSB0byBhIHNvdW5kIGNoYW5uZWwuXG5cdCAqICNtZXRob2QgYWRkXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBpbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gYWRkIHRvIHRoZSBjaGFubmVsXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnRlcnJ1cHQgVGhlIGludGVycnVwdCB2YWx1ZSB0byB1c2UuIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kL3BsYXlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMgb24gaW50ZXJydXB0IG1vZGVzLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUaGUgc3VjY2VzcyBvZiB0aGUgbWV0aG9kIGNhbGwuIElmIHRoZSBjaGFubmVsIGlzIGZ1bGwsIGl0IHdpbGwgcmV0dXJuIGZhbHNlLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRTb3VuZENoYW5uZWwuYWRkID0gZnVuY3Rpb24gKGluc3RhbmNlLCBpbnRlcnJ1cHQpIHtcblx0XHR2YXIgY2hhbm5lbCA9IFNvdW5kQ2hhbm5lbC5nZXQoaW5zdGFuY2Uuc3JjKTtcblx0XHRpZiAoY2hhbm5lbCA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblx0XHRyZXR1cm4gY2hhbm5lbC5fYWRkKGluc3RhbmNlLCBpbnRlcnJ1cHQpO1xuXHR9O1xuXHQvKipcblx0ICogUmVtb3ZlIGFuIGluc3RhbmNlIGZyb20gdGhlIGNoYW5uZWwuXG5cdCAqICNtZXRob2QgcmVtb3ZlXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBpbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gcmVtb3ZlIGZyb20gdGhlIGNoYW5uZWxcblx0ICogQHJldHVybiBUaGUgc3VjY2VzcyBvZiB0aGUgbWV0aG9kIGNhbGwuIElmIHRoZXJlIGlzIG5vIGNoYW5uZWwsIGl0IHdpbGwgcmV0dXJuIGZhbHNlLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRTb3VuZENoYW5uZWwucmVtb3ZlID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBTb3VuZENoYW5uZWwuZ2V0KGluc3RhbmNlLnNyYyk7XG5cdFx0aWYgKGNoYW5uZWwgPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cdFx0Y2hhbm5lbC5fcmVtb3ZlKGluc3RhbmNlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0LyoqXG5cdCAqIEdldCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc291bmRzIHlvdSBjYW4gaGF2ZSBpbiBhIGNoYW5uZWwuXG5cdCAqICNtZXRob2QgbWF4UGVyQ2hhbm5lbFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBtYXhpbXVtIG51bWJlciBvZiBzb3VuZHMgeW91IGNhbiBoYXZlIGluIGEgY2hhbm5lbC5cblx0ICovXG5cdFNvdW5kQ2hhbm5lbC5tYXhQZXJDaGFubmVsID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBwLm1heERlZmF1bHQ7XG5cdH07XG5cdC8qKlxuXHQgKiBHZXQgYSBjaGFubmVsIGluc3RhbmNlIGJ5IGl0cyBzcmMuXG5cdCAqICNtZXRob2QgZ2V0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNyYyB0byB1c2UgdG8gbG9vayB1cCB0aGUgY2hhbm5lbFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRTb3VuZENoYW5uZWwuZ2V0ID0gZnVuY3Rpb24gKHNyYykge1xuXHRcdHJldHVybiBTb3VuZENoYW5uZWwuY2hhbm5lbHNbc3JjXTtcblx0fTtcblxuXHR2YXIgcCA9IFNvdW5kQ2hhbm5lbC5wcm90b3R5cGU7XG5cdHAuY29uc3RydWN0b3IgPSBTb3VuZENoYW5uZWw7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cblx0LyoqXG5cdCAqIFRoZSBzb3VyY2Ugb2YgdGhlIGNoYW5uZWwuXG5cdCAqICNwcm9wZXJ0eSBzcmNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICovXG5cdHAuc3JjID0gbnVsbDtcblxuXHQvKipcblx0ICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGluc3RhbmNlcyBpbiB0aGlzIGNoYW5uZWwuICAtMSBpbmRpY2F0ZXMgbm8gbGltaXRcblx0ICogI3Byb3BlcnR5IG1heFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0cC5tYXggPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCB2YWx1ZSB0byBzZXQgZm9yIG1heCwgaWYgaXQgaXNuJ3QgcGFzc2VkIGluLiAgQWxzbyB1c2VkIGlmIC0xIGlzIHBhc3NlZC5cblx0ICogI3Byb3BlcnR5IG1heERlZmF1bHRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgMTAwXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKi9cblx0cC5tYXhEZWZhdWx0ID0gMTAwO1xuXG5cdC8qKlxuXHQgKiBUaGUgY3VycmVudCBudW1iZXIgb2YgYWN0aXZlIGluc3RhbmNlcy5cblx0ICogI3Byb3BlcnR5IGxlbmd0aFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0cC5sZW5ndGggPSAwO1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBjaGFubmVsLlxuXHQgKiAjbWV0aG9kIGluaXRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIG9mIHRoZSBjaGFubmVsXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtYXggVGhlIG1heGltdW0gbnVtYmVyIG9mIGluc3RhbmNlcyBpbiB0aGUgY2hhbm5lbFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLmluaXQgPSBmdW5jdGlvbiAoc3JjLCBtYXgpIHtcblx0XHR0aGlzLnNyYyA9IHNyYztcblx0XHR0aGlzLm1heCA9IG1heCB8fCB0aGlzLm1heERlZmF1bHQ7XG5cdFx0aWYgKHRoaXMubWF4ID09IC0xKSB7dGhpcy5tYXggPSB0aGlzLm1heERlZmF1bHQ7fVxuXHRcdHRoaXMuX2luc3RhbmNlcyA9IFtdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYW4gaW5zdGFuY2UgYnkgaW5kZXguXG5cdCAqICNtZXRob2QgZ2V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gcmV0dXJuLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IFRoZSBBYnN0cmFjdFNvdW5kSW5zdGFuY2UgYXQgYSBzcGVjaWZpYyBpbnN0YW5jZS5cblx0ICovXG5cdHAuX2dldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnN0YW5jZXNbaW5kZXhdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGQgYSBuZXcgaW5zdGFuY2UgdG8gdGhlIGNoYW5uZWwuXG5cdCAqICNtZXRob2QgYWRkXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBpbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gYWRkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUaGUgc3VjY2VzcyBvZiB0aGUgbWV0aG9kIGNhbGwuIElmIHRoZSBjaGFubmVsIGlzIGZ1bGwsIGl0IHdpbGwgcmV0dXJuIGZhbHNlLlxuXHQgKi9cblx0cC5fYWRkID0gZnVuY3Rpb24gKGluc3RhbmNlLCBpbnRlcnJ1cHQpIHtcblx0XHRpZiAoIXRoaXMuX2dldFNsb3QoaW50ZXJydXB0LCBpbnN0YW5jZSkpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdHRoaXMuX2luc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcblx0XHR0aGlzLmxlbmd0aCsrO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYW4gaW5zdGFuY2UgZnJvbSB0aGUgY2hhbm5lbCwgZWl0aGVyIHdoZW4gaXQgaGFzIGZpbmlzaGVkIHBsYXlpbmcsIG9yIGl0IGhhcyBiZWVuIGludGVycnVwdGVkLlxuXHQgKiAjbWV0aG9kIHJlbW92ZVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gaW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHJlbW92ZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUaGUgc3VjY2VzcyBvZiB0aGUgcmVtb3ZlIGNhbGwuIElmIHRoZSBpbnN0YW5jZSBpcyBub3QgZm91bmQgaW4gdGhpcyBjaGFubmVsLCBpdCB3aWxsXG5cdCAqIHJldHVybiBmYWxzZS5cblx0ICovXG5cdHAuX3JlbW92ZSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuXHRcdHZhciBpbmRleCA9IGNyZWF0ZWpzLmluZGV4T2YodGhpcy5faW5zdGFuY2VzLCBpbnN0YW5jZSk7XG5cdFx0aWYgKGluZGV4ID09IC0xKSB7cmV0dXJuIGZhbHNlO31cblx0XHR0aGlzLl9pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHR0aGlzLmxlbmd0aC0tO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wIHBsYXliYWNrIGFuZCByZW1vdmUgYWxsIGluc3RhbmNlcyBmcm9tIHRoZSBjaGFubmVsLiAgVXN1YWxseSBpbiByZXNwb25zZSB0byBhIGRlbGV0ZSBjYWxsLlxuXHQgKiAjbWV0aG9kIHJlbW92ZUFsbFxuXHQgKi9cblx0cC5fcmVtb3ZlQWxsID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIE5vdGUgdGhhdCBzdG9wKCkgcmVtb3ZlcyB0aGUgaXRlbSBmcm9tIHRoZSBsaXN0XG5cdFx0Zm9yICh2YXIgaT10aGlzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHRoaXMuX2luc3RhbmNlc1tpXS5zdG9wKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYW4gYXZhaWxhYmxlIHNsb3QgZGVwZW5kaW5nIG9uIGludGVycnVwdCB2YWx1ZSBhbmQgaWYgc2xvdHMgYXJlIGF2YWlsYWJsZS5cblx0ICogI21ldGhvZCBnZXRTbG90XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnRlcnJ1cHQgVGhlIGludGVycnVwdCB2YWx1ZSB0byB1c2UuXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBpbnN0YW5jZSBUaGUgc291bmQgaW5zdGFuY2UgdGhhdCB3aWxsIGdvIGluIHRoZSBjaGFubmVsIGlmIHN1Y2Nlc3NmdWwuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IERldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gYXZhaWxhYmxlIHNsb3QuIERlcGVuZGluZyBvbiB0aGUgaW50ZXJydXB0IG1vZGUsIGlmIHRoZXJlIGFyZSBubyBzbG90cyxcblx0ICogYW4gZXhpc3RpbmcgQWJzdHJhY3RTb3VuZEluc3RhbmNlIG1heSBiZSBpbnRlcnJ1cHRlZC4gSWYgdGhlcmUgYXJlIG5vIHNsb3RzLCB0aGlzIG1ldGhvZCByZXR1cm5zIGZhbHNlLlxuXHQgKi9cblx0cC5fZ2V0U2xvdCA9IGZ1bmN0aW9uIChpbnRlcnJ1cHQsIGluc3RhbmNlKSB7XG5cdFx0dmFyIHRhcmdldCwgcmVwbGFjZW1lbnQ7XG5cblx0XHRpZiAoaW50ZXJydXB0ICE9IFNvdW5kLklOVEVSUlVQVF9OT05FKSB7XG5cdFx0XHQvLyBGaXJzdCByZXBsYWNlbWVudCBjYW5kaWRhdGVcblx0XHRcdHJlcGxhY2VtZW50ID0gdGhpcy5fZ2V0KDApO1xuXHRcdFx0aWYgKHJlcGxhY2VtZW50ID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLm1heDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fZ2V0KGkpO1xuXG5cdFx0XHQvLyBBdmFpbGFibGUgU3BhY2Vcblx0XHRcdGlmICh0YXJnZXQgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXVkaW8gaXMgY29tcGxldGUgb3Igbm90IHBsYXlpbmdcblx0XHRcdGlmICh0YXJnZXQucGxheVN0YXRlID09IFNvdW5kLlBMQVlfRklOSVNIRUQgfHxcblx0XHRcdFx0dGFyZ2V0LnBsYXlTdGF0ZSA9PSBTb3VuZC5QTEFZX0lOVEVSUlVQVEVEIHx8XG5cdFx0XHRcdHRhcmdldC5wbGF5U3RhdGUgPT0gU291bmQuUExBWV9GQUlMRUQpIHtcblx0XHRcdFx0cmVwbGFjZW1lbnQgPSB0YXJnZXQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaW50ZXJydXB0ID09IFNvdW5kLklOVEVSUlVQVF9OT05FKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdWRpbyBpcyBhIGJldHRlciBjYW5kaWRhdGUgdGhhbiB0aGUgY3VycmVudCB0YXJnZXQsIGFjY29yZGluZyB0byBwbGF5aGVhZFxuXHRcdFx0aWYgKChpbnRlcnJ1cHQgPT0gU291bmQuSU5URVJSVVBUX0VBUkxZICYmIHRhcmdldC5nZXRQb3NpdGlvbigpIDwgcmVwbGFjZW1lbnQuZ2V0UG9zaXRpb24oKSkgfHxcblx0XHRcdFx0KGludGVycnVwdCA9PSBTb3VuZC5JTlRFUlJVUFRfTEFURSAmJiB0YXJnZXQuZ2V0UG9zaXRpb24oKSA+IHJlcGxhY2VtZW50LmdldFBvc2l0aW9uKCkpKSB7XG5cdFx0XHRcdFx0cmVwbGFjZW1lbnQgPSB0YXJnZXQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHJlcGxhY2VtZW50ICE9IG51bGwpIHtcblx0XHRcdHJlcGxhY2VtZW50Ll9pbnRlcnJ1cHQoKTtcblx0XHRcdHRoaXMuX3JlbW92ZShyZXBsYWNlbWVudCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW1NvdW5kIFNvdW5kQ2hhbm5lbF1cIjtcblx0fTtcblx0Ly8gZG8gbm90IGFkZCBTb3VuZENoYW5uZWwgdG8gbmFtZXNwYWNlXG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBBYnN0cmFjdFNvdW5kSW5zdGFuY2UuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8qKlxuICogQSBBYnN0cmFjdFNvdW5kSW5zdGFuY2UgaXMgY3JlYXRlZCB3aGVuIGFueSBjYWxscyB0byB0aGUgU291bmQgQVBJIG1ldGhvZCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9wbGF5XCJ9fXt7L2Nyb3NzTGlua319IG9yXG4gKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9jcmVhdGVJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSBhcmUgbWFkZS4gVGhlIEFic3RyYWN0U291bmRJbnN0YW5jZSBpcyByZXR1cm5lZCBieSB0aGUgYWN0aXZlIHBsdWdpblxuICogZm9yIGNvbnRyb2wgYnkgdGhlIHVzZXIuXG4gKlxuICogPGg0PkV4YW1wbGU8L2g0PlxuICpcbiAqICAgICAgdmFyIG15SW5zdGFuY2UgPSBjcmVhdGVqcy5Tb3VuZC5wbGF5KFwibXlBc3NldFBhdGgvbXlTcmNGaWxlLm1wM1wiKTtcbiAqXG4gKiBBIG51bWJlciBvZiBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgcHJvdmlkZSBhIHF1aWNrIHdheSB0byBkZXRlcm1pbmUgaG93IGEgc291bmQgaXMgcGxheWVkLiBQbGVhc2Ugc2VlIHRoZSBTb3VuZFxuICogQVBJIG1ldGhvZCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9wbGF5XCJ9fXt7L2Nyb3NzTGlua319IGZvciBhIGxpc3Qgb2YgYXJndW1lbnRzLlxuICpcbiAqIE9uY2UgYSBBYnN0cmFjdFNvdW5kSW5zdGFuY2UgaXMgY3JlYXRlZCwgYSByZWZlcmVuY2UgY2FuIGJlIHN0b3JlZCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIGF1ZGlvIGRpcmVjdGx5IHRocm91Z2hcbiAqIHRoZSBBYnN0cmFjdFNvdW5kSW5zdGFuY2UuIElmIHRoZSByZWZlcmVuY2UgaXMgbm90IHN0b3JlZCwgdGhlIEFic3RyYWN0U291bmRJbnN0YW5jZSB3aWxsIHBsYXkgb3V0IGl0cyBhdWRpbyAoYW5kIGFueSBsb29wcyksIGFuZFxuICogaXMgdGhlbiBkZS1yZWZlcmVuY2VkIGZyb20gdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIHNvIHRoYXQgaXQgY2FuIGJlIGNsZWFuZWQgdXAuIElmIGF1ZGlvXG4gKiBwbGF5YmFjayBoYXMgY29tcGxldGVkLCBhIHNpbXBsZSBjYWxsIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGxheVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZSBtZXRob2RcbiAqIHdpbGwgcmVidWlsZCB0aGUgcmVmZXJlbmNlcyB0aGUgU291bmQgY2xhc3MgbmVlZCB0byBjb250cm9sIGl0LlxuICpcbiAqICAgICAgdmFyIG15SW5zdGFuY2UgPSBjcmVhdGVqcy5Tb3VuZC5wbGF5KFwibXlBc3NldFBhdGgvbXlTcmNGaWxlLm1wM1wiLCB7bG9vcDoyfSk7XG4gKiAgICAgIG15SW5zdGFuY2Uub24oXCJsb29wXCIsIGhhbmRsZUxvb3ApO1xuICogICAgICBmdW5jdGlvbiBoYW5kbGVMb29wKGV2ZW50KSB7XG4gKiAgICAgICAgICBteUluc3RhbmNlLnZvbHVtZSA9IG15SW5zdGFuY2Uudm9sdW1lICogMC41O1xuICogICAgICB9XG4gKlxuICogRXZlbnRzIGFyZSBkaXNwYXRjaGVkIGZyb20gdGhlIGluc3RhbmNlIHRvIG5vdGlmeSB3aGVuIHRoZSBzb3VuZCBoYXMgY29tcGxldGVkLCBsb29wZWQsIG9yIHdoZW4gcGxheWJhY2sgZmFpbHNcbiAqXG4gKiAgICAgIHZhciBteUluc3RhbmNlID0gY3JlYXRlanMuU291bmQucGxheShcIm15QXNzZXRQYXRoL215U3JjRmlsZS5tcDNcIik7XG4gKiAgICAgIG15SW5zdGFuY2Uub24oXCJjb21wbGV0ZVwiLCBoYW5kbGVDb21wbGV0ZSk7XG4gKiAgICAgIG15SW5zdGFuY2Uub24oXCJsb29wXCIsIGhhbmRsZUxvb3ApO1xuICogICAgICBteUluc3RhbmNlLm9uKFwiZmFpbGVkXCIsIGhhbmRsZUZhaWxlZCk7XG4gKlxuICpcbiAqIEBjbGFzcyBBYnN0cmFjdFNvdW5kSW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHBhdGggdG8gYW5kIGZpbGUgbmFtZSBvZiB0aGUgc291bmQuXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRUaW1lIEF1ZGlvIHNwcml0ZSBwcm9wZXJ0eSB1c2VkIHRvIGFwcGx5IGFuIG9mZnNldCwgaW4gbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIEF1ZGlvIHNwcml0ZSBwcm9wZXJ0eSB1c2VkIHRvIHNldCB0aGUgdGltZSB0aGUgY2xpcCBwbGF5cyBmb3IsIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5YmFja1Jlc291cmNlIEFueSByZXNvdXJjZSBuZWVkZWQgYnkgcGx1Z2luIHRvIHN1cHBvcnQgYXVkaW8gcGxheWJhY2suXG4gKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIENvbnN0cnVjdG9yOlxuXHR2YXIgQWJzdHJhY3RTb3VuZEluc3RhbmNlID0gZnVuY3Rpb24gKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbiwgcGxheWJhY2tSZXNvdXJjZSkge1xuXHRcdHRoaXMuRXZlbnREaXNwYXRjaGVyX2NvbnN0cnVjdG9yKCk7XG5cblxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgc291cmNlIG9mIHRoZSBzb3VuZC5cblx0XHQgKiBAcHJvcGVydHkgc3JjXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5zcmMgPSBzcmM7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBpbnN0YW5jZS4gVGhpcyBpcyBzZXQgYnkge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IHVuaXF1ZUlkXG5cdFx0ICogQHR5cGUge1N0cmluZ30gfCBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAtMVxuXHRcdCAqL1xuXHRcdHRoaXMudW5pcXVlSWQgPSAtMTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBwbGF5IHN0YXRlIG9mIHRoZSBzb3VuZC4gUGxheSBzdGF0ZXMgYXJlIGRlZmluZWQgYXMgY29uc3RhbnRzIG9uIHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBwbGF5U3RhdGVcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnBsYXlTdGF0ZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBIFRpbWVvdXQgY3JlYXRlZCBieSB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSB3aGVuIHRoaXMgQWJzdHJhY3RTb3VuZEluc3RhbmNlIGlzIHBsYXllZCB3aXRoIGEgZGVsYXkuXG5cdFx0ICogVGhpcyBhbGxvd3MgQWJzdHJhY3RTb3VuZEluc3RhbmNlIHRvIHJlbW92ZSB0aGUgZGVsYXkgaWYgc3RvcCwgcGF1c2UsIG9yIGNsZWFudXAgYXJlIGNhbGxlZCBiZWZvcmUgcGxheWJhY2sgYmVnaW5zLlxuXHRcdCAqIEBwcm9wZXJ0eSBkZWxheVRpbWVvdXRJZFxuXHRcdCAqIEB0eXBlIHt0aW1lb3V0VmFyaWFibGV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKi9cblx0XHR0aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcblx0XHQvLyBUT0RPIGNvbnNpZGVyIG1vdmluZyBkZWxheSBpbnRvIEFic3RyYWN0U291bmRJbnN0YW5jZSBzbyBpdCBjYW4gYmUgaGFuZGxlZCBieSBwbHVnaW5zXG5cblxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXNcblx0Ly8gR2V0dGVyIC8gU2V0dGVyIFByb3BlcnRpZXNcblx0XHQvLyBPSlIgVE9ETyBmaW5kIG9yaWdpbmFsIHJlYXNvbiB0aGF0IHdlIGRpZG4ndCB1c2UgZGVmaW5lZCBmdW5jdGlvbnMuICBJIHRoaW5rIGl0IHdhcyBwZXJmb3JtYW5jZSByZWxhdGVkXG5cdFx0LyoqXG5cdFx0ICogVGhlIHZvbHVtZSBvZiB0aGUgc291bmQsIGJldHdlZW4gMCBhbmQgMS5cblx0XHQgKlxuXHRcdCAqIFRoZSBhY3R1YWwgb3V0cHV0IHZvbHVtZSBvZiBhIHNvdW5kIGNhbiBiZSBjYWxjdWxhdGVkIHVzaW5nOlxuXHRcdCAqIDxjb2RlPm15SW5zdGFuY2Uudm9sdW1lICogY3JlYXRlanMuU291bmQuZ2V0Vm9sdW1lKCk7PC9jb2RlPlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHZvbHVtZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMuX3ZvbHVtZSA9ICAxO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZvbHVtZVwiLCB7XG5cdFx0XHRnZXQ6IHRoaXMuZ2V0Vm9sdW1lLFxuXHRcdFx0c2V0OiB0aGlzLnNldFZvbHVtZVxuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHBhbiBvZiB0aGUgc291bmQsIGJldHdlZW4gLTEgKGxlZnQpIGFuZCAxIChyaWdodCkuIE5vdGUgdGhhdCBwYW4gaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MIEF1ZGlvLlxuXHRcdCAqXG5cdFx0ICogPGJyIC8+Tm90ZSBpbiBXZWJBdWRpb1BsdWdpbiB0aGlzIG9ubHkgZ2l2ZXMgdXMgdGhlIFwieFwiIHZhbHVlIG9mIHdoYXQgaXMgYWN0dWFsbHkgM0QgYXVkaW8uXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgcGFuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5fcGFuID0gIDA7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGFuXCIsIHtcblx0XHRcdGdldDogdGhpcy5nZXRQYW4sXG5cdFx0XHRzZXQ6IHRoaXMuc2V0UGFuXG5cdFx0fSk7XG5cblx0XHQvKipcblx0XHQgKiBBdWRpbyBzcHJpdGUgcHJvcGVydHkgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHN0YXJ0aW5nIG9mZnNldC5cblx0XHQgKiBAcHJvcGVydHkgc3RhcnRUaW1lXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHNpbmNlIDAuNi4xXG5cdFx0ICovXG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gTWF0aC5tYXgoMCwgc3RhcnRUaW1lIHx8IDApO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXJ0VGltZVwiLCB7XG5cdFx0XHRnZXQ6IHRoaXMuZ2V0U3RhcnRUaW1lLFxuXHRcdFx0c2V0OiB0aGlzLnNldFN0YXJ0VGltZVxuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogU2V0cyBvciBnZXRzIHRoZSBsZW5ndGggb2YgdGhlIGF1ZGlvIGNsaXAsIHZhbHVlIGlzIGluIG1pbGxpc2Vjb25kcy5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBkdXJhdGlvblxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gTWF0aC5tYXgoMCwgZHVyYXRpb24gfHwgMCk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZHVyYXRpb25cIiwge1xuXHRcdFx0Z2V0OiB0aGlzLmdldER1cmF0aW9uLFxuXHRcdFx0c2V0OiB0aGlzLnNldER1cmF0aW9uXG5cdFx0fSk7XG5cblx0XHQvKipcblx0XHQgKiBPYmplY3QgdGhhdCBob2xkcyBwbHVnaW4gc3BlY2lmaWMgcmVzb3VyY2UgbmVlZCBmb3IgYXVkaW8gcGxheWJhY2suXG5cdFx0ICogVGhpcyBpcyBzZXQgaW50ZXJuYWxseSBieSB0aGUgcGx1Z2luLiAgRm9yIGV4YW1wbGUsIFdlYkF1ZGlvUGx1Z2luIHdpbGwgc2V0IGFuIGFycmF5IGJ1ZmZlcixcblx0XHQgKiBIVE1MQXVkaW9QbHVnaW4gd2lsbCBzZXQgYSB0YWcsIEZsYXNoQXVkaW9QbHVnaW4gd2lsbCBzZXQgYSBmbGFzaCByZWZlcmVuY2UuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgcGxheWJhY2tSZXNvdXJjZVxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UgPSBudWxsO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBsYXliYWNrUmVzb3VyY2VcIiwge1xuXHRcdFx0Z2V0OiB0aGlzLmdldFBsYXliYWNrUmVzb3VyY2UsXG5cdFx0XHRzZXQ6IHRoaXMuc2V0UGxheWJhY2tSZXNvdXJjZVxuXHRcdH0pO1xuXHRcdGlmKHBsYXliYWNrUmVzb3VyY2UgIT09IGZhbHNlICYmIHBsYXliYWNrUmVzb3VyY2UgIT09IHRydWUpIHsgdGhpcy5zZXRQbGF5YmFja1Jlc291cmNlKHBsYXliYWNrUmVzb3VyY2UpOyB9XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcG9zaXRpb24gb2YgdGhlIHBsYXloZWFkIGluIG1pbGxpc2Vjb25kcy4gVGhpcyBjYW4gYmUgc2V0IHdoaWxlIGEgc291bmQgaXMgcGxheWluZywgcGF1c2VkLCBvciBzdG9wcGVkLlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHBvc2l0aW9uXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5fcG9zaXRpb24gPSAwO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBvc2l0aW9uXCIsIHtcblx0XHRcdGdldDogdGhpcy5nZXRQb3NpdGlvbixcblx0XHRcdHNldDogdGhpcy5zZXRQb3NpdGlvblxuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBwbGF5IGxvb3BzIHJlbWFpbmluZy4gTmVnYXRpdmUgdmFsdWVzIHdpbGwgbG9vcCBpbmZpbml0ZWx5LlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IGxvb3Bcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHVibGljXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9vcCA9IDA7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibG9vcFwiLCB7XG5cdFx0XHRnZXQ6IHRoaXMuZ2V0TG9vcCxcblx0XHRcdHNldDogdGhpcy5zZXRMb29wXG5cdFx0fSk7XG5cblx0XHQvKipcblx0XHQgKiBNdXRlcyBvciB1bm11dGVzIHRoZSBjdXJyZW50IGF1ZGlvIGluc3RhbmNlLlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IG11dGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAc2luY2UgMC42LjBcblx0XHQgKi9cblx0XHR0aGlzLl9tdXRlZCA9IGZhbHNlO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm11dGVkXCIsIHtcblx0XHRcdGdldDogdGhpcy5nZXRNdXRlZCxcblx0XHRcdHNldDogdGhpcy5zZXRNdXRlZFxuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogUGF1c2VzIG9yIHJlc3VtZXMgdGhlIGN1cnJlbnQgYXVkaW8gaW5zdGFuY2UuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgcGF1c2VkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGF1c2VkXCIsIHtcblx0XHRcdGdldDogdGhpcy5nZXRQYXVzZWQsXG5cdFx0XHRzZXQ6IHRoaXMuc2V0UGF1c2VkXG5cdFx0fSk7XG5cblxuXHQvLyBFdmVudHNcblx0XHQvKipcblx0XHQgKiBUaGUgZXZlbnQgdGhhdCBpcyBmaXJlZCB3aGVuIHBsYXliYWNrIGhhcyBzdGFydGVkIHN1Y2Nlc3NmdWxseS5cblx0XHQgKiBAZXZlbnQgc3VjY2VlZGVkXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdFx0ICogQHNpbmNlIDAuNC4wXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBUaGUgZXZlbnQgdGhhdCBpcyBmaXJlZCB3aGVuIHBsYXliYWNrIGlzIGludGVycnVwdGVkLiBUaGlzIGhhcHBlbnMgd2hlbiBhbm90aGVyIHNvdW5kIHdpdGggdGhlIHNhbWVcblx0XHQgKiBzcmMgcHJvcGVydHkgaXMgcGxheWVkIHVzaW5nIGFuIGludGVycnVwdCB2YWx1ZSB0aGF0IGNhdXNlcyB0aGlzIGluc3RhbmNlIHRvIHN0b3AgcGxheWluZy5cblx0XHQgKiBAZXZlbnQgaW50ZXJydXB0ZWRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBldmVudCB0aGF0IGlzIGZpcmVkIHdoZW4gcGxheWJhY2sgaGFzIGZhaWxlZC4gVGhpcyBoYXBwZW5zIHdoZW4gdGhlcmUgYXJlIHRvbyBtYW55IGNoYW5uZWxzIHdpdGggdGhlIHNhbWVcblx0XHQgKiBzcmMgcHJvcGVydHkgYWxyZWFkeSBwbGF5aW5nIChhbmQgdGhlIGludGVycnVwdCB2YWx1ZSBkb2Vzbid0IGNhdXNlIGFuIGludGVycnVwdCBvZiBhbm90aGVyIGluc3RhbmNlKSwgb3Jcblx0XHQgKiB0aGUgc291bmQgY291bGQgbm90IGJlIHBsYXllZCwgcGVyaGFwcyBkdWUgdG8gYSA0MDQgZXJyb3IuXG5cdFx0ICogQGV2ZW50IGZhaWxlZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGV2ZW50IHRoYXQgaXMgZmlyZWQgd2hlbiBhIHNvdW5kIGhhcyBjb21wbGV0ZWQgcGxheWluZyBidXQgaGFzIGxvb3BzIHJlbWFpbmluZy5cblx0XHQgKiBAZXZlbnQgbG9vcFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGV2ZW50IHRoYXQgaXMgZmlyZWQgd2hlbiBwbGF5YmFjayBjb21wbGV0ZXMuIFRoaXMgbWVhbnMgdGhhdCB0aGUgc291bmQgaGFzIGZpbmlzaGVkIHBsYXlpbmcgaW4gaXRzXG5cdFx0ICogZW50aXJldHksIGluY2x1ZGluZyBpdHMgbG9vcCBpdGVyYXRpb25zLlxuXHRcdCAqIEBldmVudCBjb21wbGV0ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqL1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEFic3RyYWN0U291bmRJbnN0YW5jZSwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBQdWJsaWMgTWV0aG9kczpcblx0LyoqXG5cdCAqIFBsYXkgYW4gaW5zdGFuY2UuIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCBvbiBTb3VuZEluc3RhbmNlcyB0aGF0IGFscmVhZHkgZXhpc3QgKGNyZWF0ZWRcblx0ICogd2l0aCB0aGUgU291bmQgQVBJIHt7I2Nyb3NzTGluayBcIlNvdW5kL2NyZWF0ZUluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIlNvdW5kL3BsYXlcIn19e3svY3Jvc3NMaW5rfX0pLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIG15SW5zdGFuY2UgPSBjcmVhdGVqcy5Tb3VuZC5jcmVhdGVJbnN0YW5jZShteVNyYyk7XG5cdCAqICAgICAgbXlJbnN0YW5jZS5wbGF5KHtpbnRlcnJ1cHQ6Y3JlYXRlanMuU291bmQuSU5URVJSVVBUX0FOWSwgbG9vcDoyLCBwYW46MC41fSk7XG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBpZiB0aGlzIHNvdW5kIGlzIGFscmVhZHkgcGxheWluZywgdGhpcyBjYWxsIHdpbGwgc3RpbGwgc2V0IHRoZSBwYXNzZWQgaW4gcGFyYW1ldGVycy5cblxuXHQgKiA8Yj5QYXJhbWV0ZXJzIERlcHJlY2F0ZWQ8L2I+PGJyIC8+XG5cdCAqIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG1ldGhvZCBhcmUgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBhIHNpbmdsZSBwYXJhbWV0ZXIgdGhhdCBpcyBhbiBPYmplY3Qgb3Ige3sjY3Jvc3NMaW5rIFwiUGxheVByb3BzQ29uZmlnXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBAbWV0aG9kIHBsYXlcblx0ICogQHBhcmFtIHtTdHJpbmcgfCBPYmplY3R9IFtpbnRlcnJ1cHQ9XCJub25lXCJ8b3B0aW9uc10gPGI+VGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSByZW5hbWVkIHBsYXlQcm9wcyBpbiB0aGUgbmV4dCByZWxlYXNlLjwvYj48YnIgLz5cblx0ICogVGhpcyBwYXJhbWV0ZXIgY2FuIGJlIGFuIGluc3RhbmNlIG9mIHt7I2Nyb3NzTGluayBcIlBsYXlQcm9wc0NvbmZpZ1wifX17ey9jcm9zc0xpbmt9fSBvciBhbiBPYmplY3QgdGhhdCBjb250YWlucyBhbnkgb3IgYWxsIG9wdGlvbmFsIHByb3BlcnRpZXMgYnkgbmFtZSxcblx0ICogaW5jbHVkaW5nOiBpbnRlcnJ1cHQsIGRlbGF5LCBvZmZzZXQsIGxvb3AsIHZvbHVtZSwgcGFuLCBzdGFydFRpbWUsIGFuZCBkdXJhdGlvbiAoc2VlIHRoZSBhYm92ZSBjb2RlIHNhbXBsZSkuXG5cdCAqIDxiciAvPjxzdHJvbmc+T1I8L3N0cm9uZz48YnIgLz5cblx0ICogPGI+RGVwcmVjYXRlZDwvYj4gSG93IHRvIGludGVycnVwdCBhbnkgY3VycmVudGx5IHBsYXlpbmcgaW5zdGFuY2VzIG9mIGF1ZGlvIHdpdGggdGhlIHNhbWUgc291cmNlLFxuXHQgKiBpZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgaW5zdGFuY2VzIG9mIHRoZSBzb3VuZCBhcmUgYWxyZWFkeSBwbGF5aW5nLiBWYWx1ZXMgYXJlIGRlZmluZWQgYXMgPGNvZGU+SU5URVJSVVBUX1RZUEU8L2NvZGU+XG5cdCAqIGNvbnN0YW50cyBvbiB0aGUgU291bmQgY2xhc3MsIHdpdGggdGhlIGRlZmF1bHQgZGVmaW5lZCBieSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9kZWZhdWx0SW50ZXJydXB0QmVoYXZpb3I6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsYXk9MF0gPGI+RGVwcmVjYXRlZDwvYj4gVGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IHRoZSBzdGFydCBvZiBhdWRpbyBwbGF5YmFjaywgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29mZnNldD0wXSA8Yj5EZXByZWNhdGVkPC9iPiBUaGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBhdWRpbyB0byBiZWdpbiBwbGF5YmFjaywgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2xvb3A9MF0gPGI+RGVwcmVjYXRlZDwvYj4gSG93IG1hbnkgdGltZXMgdGhlIGF1ZGlvIGxvb3BzIHdoZW4gaXQgcmVhY2hlcyB0aGUgZW5kIG9mIHBsYXliYWNrLiBUaGUgZGVmYXVsdCBpcyAwIChub1xuXHQgKiBsb29wcyksIGFuZCAtMSBjYW4gYmUgdXNlZCBmb3IgaW5maW5pdGUgcGxheWJhY2suXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdm9sdW1lPTFdIDxiPkRlcHJlY2F0ZWQ8L2I+IFRoZSB2b2x1bWUgb2YgdGhlIHNvdW5kLCBiZXR3ZWVuIDAgYW5kIDEuIE5vdGUgdGhhdCB0aGUgbWFzdGVyIHZvbHVtZSBpcyBhcHBsaWVkXG5cdCAqIGFnYWluc3QgdGhlIGluZGl2aWR1YWwgdm9sdW1lLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3Bhbj0wXSA8Yj5EZXByZWNhdGVkPC9iPiBUaGUgbGVmdC1yaWdodCBwYW4gb2YgdGhlIHNvdW5kIChpZiBzdXBwb3J0ZWQpLCBiZXR3ZWVuIC0xIChsZWZ0KSBhbmQgMSAocmlnaHQpLlxuXHQgKiBOb3RlIHRoYXQgcGFuIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIEhUTUwgQXVkaW8uXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gQSByZWZlcmVuY2UgdG8gaXRzZWxmLCBpbnRlbmRlZCBmb3IgY2hhaW5pbmcgY2FsbHMuXG5cdCAqL1xuXHRwLnBsYXkgPSBmdW5jdGlvbiAoaW50ZXJydXB0LCBkZWxheSwgb2Zmc2V0LCBsb29wLCB2b2x1bWUsIHBhbikge1xuXHRcdHZhciBwbGF5UHJvcHM7XG5cdFx0aWYgKGludGVycnVwdCBpbnN0YW5jZW9mIE9iamVjdCB8fCBpbnRlcnJ1cHQgaW5zdGFuY2VvZiBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcpIHtcblx0XHRcdHBsYXlQcm9wcyA9IGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZy5jcmVhdGUoaW50ZXJydXB0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGxheVByb3BzID0gY3JlYXRlanMuUGxheVByb3BzQ29uZmlnLmNyZWF0ZSh7aW50ZXJydXB0OmludGVycnVwdCwgZGVsYXk6ZGVsYXksIG9mZnNldDpvZmZzZXQsIGxvb3A6bG9vcCwgdm9sdW1lOnZvbHVtZSwgcGFuOnBhbn0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnBsYXlTdGF0ZSA9PSBjcmVhdGVqcy5Tb3VuZC5QTEFZX1NVQ0NFRURFRCkge1xuXHRcdFx0dGhpcy5hcHBseVBsYXlQcm9wcyhwbGF5UHJvcHMpO1xuXHRcdFx0aWYgKHRoaXMuX3BhdXNlZCkge1x0dGhpcy5zZXRQYXVzZWQoZmFsc2UpOyB9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX2NsZWFuVXAoKTtcblx0XHRjcmVhdGVqcy5Tb3VuZC5fcGxheUluc3RhbmNlKHRoaXMsIHBsYXlQcm9wcyk7XHQvLyBtYWtlIHRoaXMgYW4gZXZlbnQgZGlzcGF0Y2g/P1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wIHBsYXliYWNrIG9mIHRoZSBpbnN0YW5jZS4gU3RvcHBlZCBzb3VuZHMgd2lsbCByZXNldCB0aGVpciBwb3NpdGlvbiB0byAwLCBhbmQgY2FsbHMgdG8ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3Jlc3VtZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aWxsIGZhaWwuIFRvIHN0YXJ0IHBsYXliYWNrIGFnYWluLCBjYWxsIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9wbGF5XCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqXG4gICAgICogSWYgeW91IGRvbid0IHdhbnQgdG8gbG9zZSB5b3VyIHBvc2l0aW9uIHVzZSB5b3VyU291bmRJbnN0YW5jZS5wYXVzZWQgPSB0cnVlIGluc3RlYWQuIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9wYXVzZWRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgIG15SW5zdGFuY2Uuc3RvcCgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHN0b3Bcblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBBIHJlZmVyZW5jZSB0byBpdHNlbGYsIGludGVuZGVkIGZvciBjaGFpbmluZyBjYWxscy5cblx0ICovXG5cdHAuc3RvcCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wb3NpdGlvbiA9IDA7XG5cdFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5faGFuZGxlU3RvcCgpO1xuXHRcdHRoaXMuX2NsZWFuVXAoKTtcblx0XHR0aGlzLnBsYXlTdGF0ZSA9IGNyZWF0ZWpzLlNvdW5kLlBMQVlfRklOSVNIRUQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgZXh0ZXJuYWwgcmVmZXJlbmNlcyBhbmQgcmVzb3VyY2VzIGZyb20gQWJzdHJhY3RTb3VuZEluc3RhbmNlLiAgTm90ZSB0aGlzIGlzIGlycmV2ZXJzaWJsZSBhbmQgQWJzdHJhY3RTb3VuZEluc3RhbmNlIHdpbGwgbm8gbG9uZ2VyIHdvcmtcblx0ICogQG1ldGhvZCBkZXN0cm95XG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fY2xlYW5VcCgpO1xuXHRcdHRoaXMuc3JjID0gbnVsbDtcblx0XHR0aGlzLnBsYXliYWNrUmVzb3VyY2UgPSBudWxsO1xuXG5cdFx0dGhpcy5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUYWtlcyBhbiBQbGF5UHJvcHNDb25maWcgb3IgT2JqZWN0IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBhbmQgc2V0cyB0aGVtIG9uIHRoaXMgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgYXBwbHlQbGF5UHJvcHNcblx0ICogQHBhcmFtIHtQbGF5UHJvcHNDb25maWcgfCBPYmplY3R9IHBsYXlQcm9wcyBBIFBsYXlQcm9wc0NvbmZpZyBvciBvYmplY3QgY29udGFpbmluZyB0aGUgc2FtZSBwcm9wZXJ0aWVzLlxuXHQgKiBAc2luY2UgMC42LjFcblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBBIHJlZmVyZW5jZSB0byBpdHNlbGYsIGludGVuZGVkIGZvciBjaGFpbmluZyBjYWxscy5cblx0ICovXG5cdHAuYXBwbHlQbGF5UHJvcHMgPSBmdW5jdGlvbihwbGF5UHJvcHMpIHtcblx0XHRpZiAocGxheVByb3BzLm9mZnNldCAhPSBudWxsKSB7IHRoaXMuc2V0UG9zaXRpb24ocGxheVByb3BzLm9mZnNldCkgfVxuXHRcdGlmIChwbGF5UHJvcHMubG9vcCAhPSBudWxsKSB7IHRoaXMuc2V0TG9vcChwbGF5UHJvcHMubG9vcCk7IH1cblx0XHRpZiAocGxheVByb3BzLnZvbHVtZSAhPSBudWxsKSB7IHRoaXMuc2V0Vm9sdW1lKHBsYXlQcm9wcy52b2x1bWUpOyB9XG5cdFx0aWYgKHBsYXlQcm9wcy5wYW4gIT0gbnVsbCkgeyB0aGlzLnNldFBhbihwbGF5UHJvcHMucGFuKTsgfVxuXHRcdGlmIChwbGF5UHJvcHMuc3RhcnRUaW1lICE9IG51bGwpIHtcblx0XHRcdHRoaXMuc2V0U3RhcnRUaW1lKHBsYXlQcm9wcy5zdGFydFRpbWUpO1xuXHRcdFx0dGhpcy5zZXREdXJhdGlvbihwbGF5UHJvcHMuZHVyYXRpb24pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltBYnN0cmFjdFNvdW5kSW5zdGFuY2VdXCI7XG5cdH07XG5cbi8vIGdldC9zZXQgbWV0aG9kcyB0aGF0IGFsbG93IHN1cHBvcnQgZm9yIElFOFxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGF1c2VkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHksXG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2QgZ2V0UGF1c2VkXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBJZiB0aGUgaW5zdGFuY2UgaXMgY3VycmVudGx5IHBhdXNlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZ2V0UGF1c2VkID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdXNlZDtcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGF1c2VkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBzZXRQYXVzZWRcblx0ICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuXHQgKiBAc2luY2UgMC42LjBcblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBBIHJlZmVyZW5jZSB0byBpdHNlbGYsIGludGVuZGVkIGZvciBjaGFpbmluZyBjYWxscy5cblx0ICovXG5cdHAuc2V0UGF1c2VkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKCh2YWx1ZSAhPT0gdHJ1ZSAmJiB2YWx1ZSAhPT0gZmFsc2UpIHx8IHRoaXMuX3BhdXNlZCA9PSB2YWx1ZSkge3JldHVybjt9XG5cdFx0aWYgKHZhbHVlID09IHRydWUgJiYgdGhpcy5wbGF5U3RhdGUgIT0gY3JlYXRlanMuU291bmQuUExBWV9TVUNDRUVERUQpIHtyZXR1cm47fVxuXHRcdHRoaXMuX3BhdXNlZCA9IHZhbHVlO1xuXHRcdGlmKHZhbHVlKSB7XG5cdFx0XHR0aGlzLl9wYXVzZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXN1bWUoKTtcblx0XHR9XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lb3V0SWQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS92b2x1bWU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIHNldFZvbHVtZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIHZvbHVtZSB0byBzZXQsIGJldHdlZW4gMCBhbmQgMS5cblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBBIHJlZmVyZW5jZSB0byBpdHNlbGYsIGludGVuZGVkIGZvciBjaGFpbmluZyBjYWxscy5cblx0ICovXG5cdHAuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IHRoaXMuX3ZvbHVtZSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX3ZvbHVtZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHZhbHVlKSk7XG5cdFx0aWYgKCF0aGlzLl9tdXRlZCkge1xuXHRcdFx0dGhpcy5fdXBkYXRlVm9sdW1lKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS92b2x1bWU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIGdldFZvbHVtZVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgc291bmQgaW5zdGFuY2UuXG5cdCAqL1xuXHRwLmdldFZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdm9sdW1lO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9tdXRlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2Qgc2V0TXV0ZWRcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBJZiB0aGUgc291bmQgc2hvdWxkIGJlIG11dGVkLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IEEgcmVmZXJlbmNlIHRvIGl0c2VsZiwgaW50ZW5kZWQgZm9yIGNoYWluaW5nIGNhbGxzLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuc2V0TXV0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgIT09IHRydWUgJiYgdmFsdWUgIT09IGZhbHNlKSB7cmV0dXJuO31cblx0XHR0aGlzLl9tdXRlZCA9IHZhbHVlO1xuXHRcdHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9tdXRlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2QgZ2V0TXV0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHNvdW5kIGlzIG11dGVkLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZ2V0TXV0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX211dGVkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9wYW46cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIHNldFBhblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIHBhbiB2YWx1ZSwgYmV0d2VlbiAtMSAobGVmdCkgYW5kIDEgKHJpZ2h0KS5cblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBSZXR1cm5zIHJlZmVyZW5jZSB0byBpdHNlbGYgZm9yIGNoYWluaW5nIGNhbGxzXG5cdCAqL1xuXHRwLnNldFBhbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmKHZhbHVlID09IHRoaXMuX3BhbikgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX3BhbiA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCB2YWx1ZSkpO1xuXHRcdHRoaXMuX3VwZGF0ZVBhbigpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9wYW46cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIGdldFBhblxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB2YWx1ZSBvZiB0aGUgcGFuLCBiZXR3ZWVuIC0xIChsZWZ0KSBhbmQgMSAocmlnaHQpLlxuXHQgKi9cblx0cC5nZXRQYW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Bhbjtcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcG9zaXRpb246cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIGdldFBvc2l0aW9uXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIHBvc2l0aW9uIG9mIHRoZSBwbGF5aGVhZCBpbiB0aGUgc291bmQsIGluIG1pbGxpc2Vjb25kcy5cblx0ICovXG5cdHAuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5wbGF5U3RhdGUgPT0gY3JlYXRlanMuU291bmQuUExBWV9TVUNDRUVERUQpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudFBvc2l0aW9uKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9wb3NpdGlvbjtcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcG9zaXRpb246cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIHNldFBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgcG9zaXRpb24gdG8gcGxhY2UgdGhlIHBsYXloZWFkLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gUmV0dXJucyByZWZlcmVuY2UgdG8gaXRzZWxmIGZvciBjaGFpbmluZyBjYWxsc1xuXHQgKi9cblx0cC5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gTWF0aC5tYXgoMCwgdmFsdWUpO1xuXHRcdGlmICh0aGlzLnBsYXlTdGF0ZSA9PSBjcmVhdGVqcy5Tb3VuZC5QTEFZX1NVQ0NFRURFRCkge1xuXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3N0YXJ0VGltZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2QgZ2V0U3RhcnRUaW1lXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIHN0YXJ0VGltZSBvZiB0aGUgc291bmQgaW5zdGFuY2UgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKi9cblx0cC5nZXRTdGFydFRpbWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0YXJ0VGltZTtcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2Uvc3RhcnRUaW1lOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBzZXRTdGFydFRpbWVcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBuZXcgc3RhcnRUaW1lIHRpbWUgaW4gbWlsbGkgc2Vjb25kcy5cblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBSZXR1cm5zIHJlZmVyZW5jZSB0byBpdHNlbGYgZm9yIGNoYWluaW5nIGNhbGxzXG5cdCAqL1xuXHRwLnNldFN0YXJ0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSB0aGlzLl9zdGFydFRpbWUpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9zdGFydFRpbWUgPSBNYXRoLm1heCgwLCB2YWx1ZSB8fCAwKTtcblx0XHR0aGlzLl91cGRhdGVTdGFydFRpbWUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvZHVyYXRpb246cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIGdldER1cmF0aW9uXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGR1cmF0aW9uIG9mIHRoZSBzb3VuZCBpbnN0YW5jZSBpbiBtaWxsaXNlY29uZHMuXG5cdCAqL1xuXHRwLmdldER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kdXJhdGlvbjtcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvZHVyYXRpb246cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIHNldER1cmF0aW9uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbmV3IGR1cmF0aW9uIHRpbWUgaW4gbWlsbGkgc2Vjb25kcy5cblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBSZXR1cm5zIHJlZmVyZW5jZSB0byBpdHNlbGYgZm9yIGNoYWluaW5nIGNhbGxzXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5zZXREdXJhdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSB0aGlzLl9kdXJhdGlvbikgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX2R1cmF0aW9uID0gTWF0aC5tYXgoMCwgdmFsdWUgfHwgMCk7XG5cdFx0dGhpcy5fdXBkYXRlRHVyYXRpb24oKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGxheWJhY2tSZXNvdXJjZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2Qgc2V0UGxheWJhY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSBuZXcgcGxheWJhY2sgcmVzb3VyY2UuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gUmV0dXJucyByZWZlcmVuY2UgdG8gaXRzZWxmIGZvciBjaGFpbmluZyBjYWxsc1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICoqL1xuXHRwLnNldFBsYXliYWNrUmVzb3VyY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlID0gdmFsdWU7XG5cdFx0aWYgKHRoaXMuX2R1cmF0aW9uID09IDApIHsgdGhpcy5fc2V0RHVyYXRpb25Gcm9tU291cmNlKCk7IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGxheWJhY2tSZXNvdXJjZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2Qgc2V0UGxheWJhY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSBuZXcgcGxheWJhY2sgcmVzb3VyY2UuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gcGxheWJhY2sgcmVzb3VyY2UgdXNlZCBmb3IgcGxheWluZyBhdWRpb1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICoqL1xuXHRwLmdldFBsYXliYWNrUmVzb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BsYXliYWNrUmVzb3VyY2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL2xvb3A6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIGdldExvb3Bcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAc2luY2UgMC42LjBcblx0ICoqL1xuXHRwLmdldExvb3AgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvb3A7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL2xvb3A6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eSxcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBzZXRMb29wXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGxvb3AgYWZ0ZXIgcGxheS5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLnNldExvb3AgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZih0aGlzLl9wbGF5YmFja1Jlc291cmNlICE9IG51bGwpIHtcblx0XHRcdC8vIHJlbW92ZSBsb29waW5nXG5cdFx0XHRpZiAodGhpcy5fbG9vcCAhPSAwICYmIHZhbHVlID09IDApIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlTG9vcGluZyh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBhZGQgbG9vcGluZ1xuXHRcdFx0ZWxzZSBpZiAodGhpcy5fbG9vcCA9PSAwICYmIHZhbHVlICE9IDApIHtcblx0XHRcdFx0dGhpcy5fYWRkTG9vcGluZyh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2xvb3AgPSB2YWx1ZTtcblx0fTtcblxuXG4vLyBQcml2YXRlIE1ldGhvZHM6XG5cdC8qKlxuXHQgKiBBIGhlbHBlciBtZXRob2QgdGhhdCBkaXNwYXRjaGVzIGFsbCBldmVudHMgZm9yIEFic3RyYWN0U291bmRJbnN0YW5jZS5cblx0ICogQG1ldGhvZCBfc2VuZEV2ZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRFdmVudCA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KHR5cGUpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFuIHVwIHRoZSBpbnN0YW5jZS4gUmVtb3ZlIHJlZmVyZW5jZXMgYW5kIGNsZWFuIHVwIGFueSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgc3VjaCBhcyB0aW1lcnMuXG5cdCAqIEBtZXRob2QgX2NsZWFuVXBcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fY2xlYW5VcCA9IGZ1bmN0aW9uICgpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVvdXRJZCk7IC8vIGNsZWFyIHRpbWVvdXQgdGhhdCBwbGF5cyBkZWxheWVkIHNvdW5kXG5cdFx0dGhpcy5faGFuZGxlQ2xlYW5VcCgpO1xuXHRcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG5cdFx0Y3JlYXRlanMuU291bmQuX3BsYXlGaW5pc2hlZCh0aGlzKTtcdC8vIFRPRE8gY2hhbmdlIHRvIGFuIGV2ZW50XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBzb3VuZCBoYXMgYmVlbiBpbnRlcnJ1cHRlZC5cblx0ICogQG1ldGhvZCBfaW50ZXJydXB0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2ludGVycnVwdCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jbGVhblVwKCk7XG5cdFx0dGhpcy5wbGF5U3RhdGUgPSBjcmVhdGVqcy5Tb3VuZC5QTEFZX0lOVEVSUlVQVEVEO1xuXHRcdHRoaXMuX3NlbmRFdmVudChcImludGVycnVwdGVkXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgYnkgdGhlIFNvdW5kIGNsYXNzIHdoZW4gdGhlIGF1ZGlvIGlzIHJlYWR5IHRvIHBsYXkgKGRlbGF5IGhhcyBjb21wbGV0ZWQpLiBTdGFydHMgc291bmQgcGxheWluZyBpZiB0aGVcblx0ICogc3JjIGlzIGxvYWRlZCwgb3RoZXJ3aXNlIHBsYXliYWNrIHdpbGwgZmFpbC5cblx0ICogQG1ldGhvZCBfYmVnaW5QbGF5aW5nXG5cdCAqIEBwYXJhbSB7UGxheVByb3BzQ29uZmlnfSBwbGF5UHJvcHMgQSBQbGF5UHJvcHNDb25maWcgb2JqZWN0LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiBwbGF5YmFjayBzdWNjZWVkZWQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdC8vIE9KUiBGbGFzaEF1ZGlvU291bmRJbnN0YW5jZSBvdmVyd3JpdGVzXG5cdHAuX2JlZ2luUGxheWluZyA9IGZ1bmN0aW9uIChwbGF5UHJvcHMpIHtcblx0XHR0aGlzLnNldFBvc2l0aW9uKHBsYXlQcm9wcy5vZmZzZXQpO1xuXHRcdHRoaXMuc2V0TG9vcChwbGF5UHJvcHMubG9vcCk7XG5cdFx0dGhpcy5zZXRWb2x1bWUocGxheVByb3BzLnZvbHVtZSk7XG5cdFx0dGhpcy5zZXRQYW4ocGxheVByb3BzLnBhbik7XG5cdFx0aWYgKHBsYXlQcm9wcy5zdGFydFRpbWUgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5zZXRTdGFydFRpbWUocGxheVByb3BzLnN0YXJ0VGltZSk7XG5cdFx0XHR0aGlzLnNldER1cmF0aW9uKHBsYXlQcm9wcy5kdXJhdGlvbik7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3BsYXliYWNrUmVzb3VyY2UgIT0gbnVsbCAmJiB0aGlzLl9wb3NpdGlvbiA8IHRoaXMuX2R1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2hhbmRsZVNvdW5kUmVhZHkoKTtcblx0XHRcdHRoaXMucGxheVN0YXRlID0gY3JlYXRlanMuU291bmQuUExBWV9TVUNDRUVERUQ7XG5cdFx0XHR0aGlzLl9zZW5kRXZlbnQoXCJzdWNjZWVkZWRcIik7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcGxheUZhaWxlZCgpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUGxheSBoYXMgZmFpbGVkLCB3aGljaCBjYW4gaGFwcGVuIGZvciBhIHZhcmlldHkgb2YgcmVhc29ucy5cblx0ICogQ2xlYW5zIHVwIGluc3RhbmNlIGFuZCBkaXNwYXRjaGVzIGZhaWxlZCBldmVudFxuXHQgKiBAbWV0aG9kIF9wbGF5RmFpbGVkXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9wbGF5RmFpbGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NsZWFuVXAoKTtcblx0XHR0aGlzLnBsYXlTdGF0ZSA9IGNyZWF0ZWpzLlNvdW5kLlBMQVlfRkFJTEVEO1xuXHRcdHRoaXMuX3NlbmRFdmVudChcImZhaWxlZFwiKTtcblx0fTtcblxuXHQvKipcblx0ICogQXVkaW8gaGFzIGZpbmlzaGVkIHBsYXlpbmcuIE1hbnVhbGx5IGxvb3AgaXQgaWYgcmVxdWlyZWQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVNvdW5kQ29tcGxldGVcblx0ICogQHBhcmFtIGV2ZW50XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2hhbmRsZVNvdW5kQ29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9wb3NpdGlvbiA9IDA7ICAvLyBoYXZlIHRvIHNldCB0aGlzIGFzIGl0IGNhbiBiZSBzZXQgYnkgcGF1c2UgZHVyaW5nIHBsYXliYWNrXG5cblx0XHRpZiAodGhpcy5fbG9vcCAhPSAwKSB7XG5cdFx0XHR0aGlzLl9sb29wLS07ICAvLyBOT1RFIHRoaXMgaW50cm9kdWNlcyBhIHRoZW9yZXRpY2FsIGxpbWl0IG9uIGxvb3BzID0gZmxvYXQgbWF4IHNpemUgeCAyIC0gMVxuXHRcdFx0dGhpcy5faGFuZGxlTG9vcCgpO1xuXHRcdFx0dGhpcy5fc2VuZEV2ZW50KFwibG9vcFwiKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9jbGVhblVwKCk7XG5cdFx0dGhpcy5wbGF5U3RhdGUgPSBjcmVhdGVqcy5Tb3VuZC5QTEFZX0ZJTklTSEVEO1xuXHRcdHRoaXMuX3NlbmRFdmVudChcImNvbXBsZXRlXCIpO1xuXHR9O1xuXG4vLyBQbHVnaW4gc3BlY2lmaWMgY29kZVxuXHQvKipcblx0ICogSGFuZGxlcyBzdGFydGluZyBwbGF5YmFjayB3aGVuIHRoZSBzb3VuZCBpcyByZWFkeSBmb3IgcGxheWluZy5cblx0ICogQG1ldGhvZCBfaGFuZGxlU291bmRSZWFkeVxuXHQgKiBAcHJvdGVjdGVkXG4gXHQgKi9cblx0cC5faGFuZGxlU291bmRSZWFkeSA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiB1c2VkIHRvIHVwZGF0ZSB0aGUgdm9sdW1lIGJhc2VkIG9uIHRoZSBpbnN0YW5jZSB2b2x1bWUsIG1hc3RlciB2b2x1bWUsIGluc3RhbmNlIG11dGUgdmFsdWUsXG5cdCAqIGFuZCBtYXN0ZXIgbXV0ZSB2YWx1ZS5cblx0ICogQG1ldGhvZCBfdXBkYXRlVm9sdW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3VwZGF0ZVZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiB1c2VkIHRvIHVwZGF0ZSB0aGUgcGFuXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVBhblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fdXBkYXRlUGFuID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gdXBkYXRlIHRoZSBzdGFydFRpbWUgb2YgdGhlIGF1ZGlvLlxuXHQgKiBAbWV0aG9kIF91cGRhdGVTdGFydFRpbWVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjFcblx0ICovXG5cdHAuX3VwZGF0ZVN0YXJ0VGltZSA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiB1c2VkIHRvIHVwZGF0ZSB0aGUgZHVyYXRpb24gb2YgdGhlIGF1ZGlvLlxuXHQgKiBAbWV0aG9kIF91cGRhdGVEdXJhdGlvblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fdXBkYXRlRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byBnZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBhdWRpbyBmcm9tIHRoZSBzb3VyY2Ugd2UnbGwgYmUgcGxheWluZy5cblx0ICogQG1ldGhvZCBfdXBkYXRlRHVyYXRpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX3NldER1cmF0aW9uRnJvbVNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IGNhbGN1bGF0ZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBsYXloZWFkIGFuZCBzZXRzIHRoaXMuX3Bvc2l0aW9uIHRvIHRoYXQgdmFsdWVcblx0ICogQG1ldGhvZCBfY2FsY3VsYXRlQ3VycmVudFBvc2l0aW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9jYWxjdWxhdGVDdXJyZW50UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGUgdGhhdCBzZXRzIHRoaXMucG9zaXRpb25cblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byB1cGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBwbGF5aGVhZC5cblx0ICogQG1ldGhvZCBfdXBkYXRlUG9zaXRpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX3VwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIGxvb3BpbmcgaXMgcmVtb3ZlZCBkdXJpbmcgcGxheWJhY2suXG5cdCAqIEBtZXRob2QgX3JlbW92ZUxvb3Bpbmdcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gbG9vcCBhZnRlciBwbGF5LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fcmVtb3ZlTG9vcGluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIGxvb3BpbmcgaXMgYWRkZWQgZHVyaW5nIHBsYXliYWNrLlxuXHQgKiBAbWV0aG9kIF9hZGRMb29waW5nXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGxvb3AgYWZ0ZXIgcGxheS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX2FkZExvb3BpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsZWQgd2hlbiBwYXVzaW5nIHBsYXliYWNrXG5cdCAqIEBtZXRob2QgX3BhdXNlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9wYXVzZSA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsZWQgd2hlbiByZXN1bWluZyBwbGF5YmFja1xuXHQgKiBAbWV0aG9kIF9yZXN1bWVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX3Jlc3VtZSA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsZWQgd2hlbiBzdG9wcGluZyBwbGF5YmFja1xuXHQgKiBAbWV0aG9kIF9oYW5kbGVTdG9wXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9oYW5kbGVTdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gY2FsbGVkIHdoZW4gQWJzdHJhY3RTb3VuZEluc3RhbmNlIGlzIGJlaW5nIGNsZWFuZWQgdXBcblx0ICogQG1ldGhvZCBfaGFuZGxlQ2xlYW5VcFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5faGFuZGxlQ2xlYW5VcCA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIEFic3RyYWN0U291bmRJbnN0YW5jZSBoYXMgcGxheWVkIHRvIGVuZCBhbmQgaXMgbG9vcGluZ1xuXHQgKiBAbWV0aG9kIF9oYW5kbGVMb29wXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9oYW5kbGVMb29wID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0Y3JlYXRlanMuQWJzdHJhY3RTb3VuZEluc3RhbmNlID0gY3JlYXRlanMucHJvbW90ZShBYnN0cmFjdFNvdW5kSW5zdGFuY2UsIFwiRXZlbnREaXNwYXRjaGVyXCIpO1xuXHRjcmVhdGVqcy5EZWZhdWx0U291bmRJbnN0YW5jZSA9IGNyZWF0ZWpzLkFic3RyYWN0U291bmRJbnN0YW5jZTtcdC8vIHVzZWQgd2hlbiBubyBwbHVnaW4gaXMgc3VwcG9ydGVkXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWJzdHJhY3RQbHVnaW4uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuIFx0LyoqXG5cdCAqIEEgZGVmYXVsdCBwbHVnaW4gY2xhc3MgdXNlZCBhcyBhIGJhc2UgZm9yIGFsbCBvdGhlciBwbHVnaW5zLlxuXHQgKiBAY2xhc3MgQWJzdHJhY3RQbHVnaW5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHR2YXIgQWJzdHJhY3RQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBwbHVnaW4uXG5cdFx0ICogbWV0aG9kIGFuZCBpcyB1c2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByb3BlcnR5IF9jYXBhYmlsaXRpZXNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHN0YXRpY1xuXHRcdCAqL1xuXHRcdHRoaXMuX2NhcGFiaWxpdGllcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBPYmplY3QgaGFzaCBpbmRleGVkIGJ5IHRoZSBzb3VyY2UgVVJJIG9mIGFsbCBjcmVhdGVkIGxvYWRlcnMsIHVzZWQgdG8gcHJvcGVybHkgZGVzdHJveSB0aGVtIGlmIHNvdXJjZXMgYXJlIHJlbW92ZWQuXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZGVycyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogT2JqZWN0IGhhc2ggaW5kZXhlZCBieSB0aGUgc291cmNlIFVSSSBvZiBlYWNoIGZpbGUgdG8gaW5kaWNhdGUgaWYgYW4gYXVkaW8gc291cmNlIGhhcyBiZWd1biBsb2FkaW5nLFxuXHRcdCAqIGlzIGN1cnJlbnRseSBsb2FkaW5nLCBvciBoYXMgY29tcGxldGVkIGxvYWRpbmcuICBDYW4gYmUgdXNlZCB0byBzdG9yZSBub24gYm9vbGVhbiBkYXRhIGFmdGVyIGxvYWRpbmdcblx0XHQgKiBpcyBjb21wbGV0ZSAoZm9yIGV4YW1wbGUgYXJyYXlCdWZmZXJzIGZvciB3ZWIgYXVkaW8pLlxuXHRcdCAqIEBwcm9wZXJ0eSBfYXVkaW9Tb3VyY2VzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fYXVkaW9Tb3VyY2VzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBPYmplY3QgaGFzaCBpbmRleGVkIGJ5IHRoZSBzb3VyY2UgVVJJIG9mIGFsbCBjcmVhdGVkIFNvdW5kSW5zdGFuY2VzLCB1cGRhdGVzIHRoZSBwbGF5YmFja1Jlc291cmNlIGlmIGl0IGxvYWRzIGFmdGVyIHRoZXkgYXJlIGNyZWF0ZWQsXG5cdFx0ICogYW5kIHByb3Blcmx5IGRlc3Ryb3kgdGhlbSBpZiBzb3VyY2VzIGFyZSByZW1vdmVkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fc291bmRJbnN0YW5jZXMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbnRlcm5hbCBtYXN0ZXIgdm9sdW1lIHZhbHVlIG9mIHRoZSBwbHVnaW4uXG5cdFx0ICogQHByb3BlcnR5IF92b2x1bWVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fdm9sdW1lID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgcmVmZXJlbmNlIHRvIGEgbG9hZGVyIGNsYXNzIHVzZWQgYnkgYSBwbHVnaW4gdGhhdCBtdXN0IGJlIHNldC5cblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZXJDbGFzcztcblxuXHRcdC8qKlxuXHRcdCAqIEEgcmVmZXJlbmNlIHRvIGFuIEFic3RyYWN0U291bmRJbnN0YW5jZSBjbGFzcyB1c2VkIGJ5IGEgcGx1Z2luIHRoYXQgbXVzdCBiZSBzZXQuXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkO1xuXHRcdCAqL1xuXHRcdHRoaXMuX3NvdW5kSW5zdGFuY2VDbGFzcztcblx0fTtcblx0dmFyIHAgPSBBYnN0cmFjdFBsdWdpbi5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIFN0YXRpYyBQcm9wZXJ0aWVzOlxuLy8gTk9URSBUSEVTRSBQUk9QRVJUSUVTIE5FRUQgVE8gQkUgQURERUQgVE8gRUFDSCBQTFVHSU5cblx0LyoqXG5cdCAqIFRoZSBjYXBhYmlsaXRpZXMgb2YgdGhlIHBsdWdpbi4gVGhpcyBpcyBnZW5lcmF0ZWQgdmlhIHRoZSBfZ2VuZXJhdGVDYXBhYmlsaXRpZXMgbWV0aG9kIGFuZCBpcyB1c2VkIGludGVybmFsbHkuXG5cdCAqIEBwcm9wZXJ0eSBfY2FwYWJpbGl0aWVzXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBkZWZhdWx0IG51bGxcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRBYnN0cmFjdFBsdWdpbi5fY2FwYWJpbGl0aWVzID0gbnVsbDtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIHRoZSBwbHVnaW4gY2FuIGJlIHVzZWQgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci9PUy5cblx0ICogQG1ldGhvZCBpc1N1cHBvcnRlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgcGx1Z2luIGNhbiBiZSBpbml0aWFsaXplZC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0QWJzdHJhY3RQbHVnaW4uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBQcmUtcmVnaXN0ZXIgYSBzb3VuZCBmb3IgcHJlbG9hZGluZyBhbmQgc2V0dXAuIFRoaXMgaXMgY2FsbGVkIGJ5IHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBOb3RlIGFsbCBwbHVnaW5zIHByb3ZpZGUgYSA8Y29kZT5Mb2FkZXI8L2NvZGU+IGluc3RhbmNlLCB3aGljaCA8YSBocmVmPVwiaHR0cDovL3ByZWxvYWRqcy5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIj5QcmVsb2FkSlM8L2E+XG5cdCAqIGNhbiB1c2UgdG8gYXNzaXN0IHdpdGggcHJlbG9hZGluZy5cblx0ICogQG1ldGhvZCByZWdpc3RlclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbG9hZEl0ZW0gQW4gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNvdXJjZSBvZiB0aGUgYXVkaW9cblx0ICogTm90ZSB0aGF0IG5vdCBldmVyeSBwbHVnaW4gd2lsbCBtYW5hZ2UgdGhpcyB2YWx1ZS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBIHJlc3VsdCBvYmplY3QsIGNvbnRhaW5pbmcgYSBcInRhZ1wiIGZvciBwcmVsb2FkaW5nIHB1cnBvc2VzLlxuXHQgKi9cblx0cC5yZWdpc3RlciA9IGZ1bmN0aW9uIChsb2FkSXRlbSkge1xuXHRcdHZhciBsb2FkZXIgPSB0aGlzLl9sb2FkZXJzW2xvYWRJdGVtLnNyY107XG5cdFx0aWYobG9hZGVyICYmICFsb2FkZXIuY2FuY2VsZWQpIHtyZXR1cm4gdGhpcy5fbG9hZGVyc1tsb2FkSXRlbS5zcmNdO31cdC8vIGFscmVhZHkgbG9hZGluZy9sb2FkZWQgdGhpcywgc28gZG9uJ3QgbG9hZCB0d2ljZVxuXHRcdC8vIE9KUiBwb3RlbnRpYWwgaXNzdWUgdGhhdCB3ZSB3b24ndCBiZSBmaXJpbmcgbG9hZGVkIGV2ZW50LCBtaWdodCBuZWVkIHRvIHRyaWdnZXIgaWYgdGhpcyBpcyBhbHJlYWR5IGxvYWRlZD9cblx0XHR0aGlzLl9hdWRpb1NvdXJjZXNbbG9hZEl0ZW0uc3JjXSA9IHRydWU7XG5cdFx0dGhpcy5fc291bmRJbnN0YW5jZXNbbG9hZEl0ZW0uc3JjXSA9IFtdO1xuXHRcdGxvYWRlciA9IG5ldyB0aGlzLl9sb2FkZXJDbGFzcyhsb2FkSXRlbSk7XG5cdFx0bG9hZGVyLm9uKFwiY29tcGxldGVcIiwgdGhpcy5faGFuZGxlUHJlbG9hZENvbXBsZXRlLCB0aGlzKTtcblx0XHR0aGlzLl9sb2FkZXJzW2xvYWRJdGVtLnNyY10gPSBsb2FkZXI7XG5cdFx0cmV0dXJuIGxvYWRlcjtcblx0fTtcblxuXHQvLyBub3RlIHNvdW5kIGNhbGxzIHJlZ2lzdGVyIGJlZm9yZSBjYWxsaW5nIHByZWxvYWRcblx0LyoqXG5cdCAqIEludGVybmFsbHkgcHJlbG9hZCBhIHNvdW5kLlxuXHQgKiBAbWV0aG9kIHByZWxvYWRcblx0ICogQHBhcmFtIHtMb2FkZXJ9IGxvYWRlciBUaGUgc291bmQgVVJJIHRvIGxvYWQuXG5cdCAqL1xuXHRwLnByZWxvYWQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0bG9hZGVyLm9uKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlUHJlbG9hZEVycm9yLCB0aGlzKTtcblx0XHRsb2FkZXIubG9hZCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgcHJlbG9hZGluZyBoYXMgc3RhcnRlZCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UuIElmIHRoZSBzb3VyY2UgaXMgZm91bmQsIHdlIGNhbiBhc3N1bWUgaXQgaXMgbG9hZGluZyxcblx0ICogb3IgaGFzIGFscmVhZHkgZmluaXNoZWQgbG9hZGluZy5cblx0ICogQG1ldGhvZCBpc1ByZWxvYWRTdGFydGVkXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdW5kIFVSSSB0byBjaGVjay5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdHAuaXNQcmVsb2FkU3RhcnRlZCA9IGZ1bmN0aW9uIChzcmMpIHtcblx0XHRyZXR1cm4gKHRoaXMuX2F1ZGlvU291cmNlc1tzcmNdICE9IG51bGwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgcHJlbG9hZGluZyBoYXMgZmluaXNoZWQgZm9yIGEgc3BlY2lmaWMgc291cmNlLlxuXHQgKiBAbWV0aG9kIGlzUHJlbG9hZENvbXBsZXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdW5kIFVSSSB0byBsb2FkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0cC5pc1ByZWxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIChzcmMpIHtcblx0XHRyZXR1cm4gKCEodGhpcy5fYXVkaW9Tb3VyY2VzW3NyY10gPT0gbnVsbCB8fCB0aGlzLl9hdWRpb1NvdXJjZXNbc3JjXSA9PSB0cnVlKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIHNvdW5kIGFkZGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luL3JlZ2lzdGVyXCJ9fXt7L2Nyb3NzTGlua319LiBOb3RlIHRoaXMgZG9lcyBub3QgY2FuY2VsIGEgcHJlbG9hZC5cblx0ICogQG1ldGhvZCByZW1vdmVTb3VuZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VuZCBVUkkgdG8gdW5sb2FkLlxuXHQgKi9cblx0cC5yZW1vdmVTb3VuZCA9IGZ1bmN0aW9uIChzcmMpIHtcblx0XHRpZiAoIXRoaXMuX3NvdW5kSW5zdGFuY2VzW3NyY10pIHsgcmV0dXJuOyB9XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMuX3NvdW5kSW5zdGFuY2VzW3NyY10ubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzLl9zb3VuZEluc3RhbmNlc1tzcmNdW2ldO1xuXHRcdFx0aXRlbS5kZXN0cm95KCk7XG5cdFx0fVxuXHRcdGRlbGV0ZSh0aGlzLl9zb3VuZEluc3RhbmNlc1tzcmNdKTtcblx0XHRkZWxldGUodGhpcy5fYXVkaW9Tb3VyY2VzW3NyY10pO1xuXHRcdGlmKHRoaXMuX2xvYWRlcnNbc3JjXSkgeyB0aGlzLl9sb2FkZXJzW3NyY10uZGVzdHJveSgpOyB9XG5cdFx0ZGVsZXRlKHRoaXMuX2xvYWRlcnNbc3JjXSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgc291bmRzIGFkZGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luL3JlZ2lzdGVyXCJ9fXt7L2Nyb3NzTGlua319LiBOb3RlIHRoaXMgZG9lcyBub3QgY2FuY2VsIGEgcHJlbG9hZC5cblx0ICogQG1ldGhvZCByZW1vdmVBbGxTb3VuZHNcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291bmQgVVJJIHRvIHVubG9hZC5cblx0ICovXG5cdHAucmVtb3ZlQWxsU291bmRzID0gZnVuY3Rpb24gKCkge1xuXHRcdGZvcih2YXIga2V5IGluIHRoaXMuX2F1ZGlvU291cmNlcykge1xuXHRcdFx0dGhpcy5yZW1vdmVTb3VuZChrZXkpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgc291bmQgaW5zdGFuY2UuIElmIHRoZSBzb3VuZCBoYXMgbm90IGJlZW4gcHJlbG9hZGVkLCBpdCBpcyBpbnRlcm5hbGx5IHByZWxvYWRlZCBoZXJlLlxuXHQgKiBAbWV0aG9kIGNyZWF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VuZCBzb3VyY2UgdG8gdXNlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRUaW1lIEF1ZGlvIHNwcml0ZSBwcm9wZXJ0eSB1c2VkIHRvIGFwcGx5IGFuIG9mZnNldCwgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gQXVkaW8gc3ByaXRlIHByb3BlcnR5IHVzZWQgdG8gc2V0IHRoZSB0aW1lIHRoZSBjbGlwIHBsYXlzIGZvciwgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IEEgc291bmQgaW5zdGFuY2UgZm9yIHBsYXliYWNrIGFuZCBjb250cm9sLlxuXHQgKi9cblx0cC5jcmVhdGUgPSBmdW5jdGlvbiAoc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uKSB7XG5cdFx0aWYgKCF0aGlzLmlzUHJlbG9hZFN0YXJ0ZWQoc3JjKSkge1xuXHRcdFx0dGhpcy5wcmVsb2FkKHRoaXMucmVnaXN0ZXIoc3JjKSk7XG5cdFx0fVxuXHRcdHZhciBzaSA9IG5ldyB0aGlzLl9zb3VuZEluc3RhbmNlQ2xhc3Moc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uLCB0aGlzLl9hdWRpb1NvdXJjZXNbc3JjXSk7XG5cdFx0dGhpcy5fc291bmRJbnN0YW5jZXNbc3JjXS5wdXNoKHNpKTtcblx0XHRyZXR1cm4gc2k7XG5cdH07XG5cblx0Ly8gaWYgYSBwbHVnaW4gZG9lcyBub3Qgc3VwcG9ydCB2b2x1bWUgYW5kIG11dGUsIGl0IHNob3VsZCBzZXQgdGhlc2UgdG8gbnVsbFxuXHQvKipcblx0ICogU2V0IHRoZSBtYXN0ZXIgdm9sdW1lIG9mIHRoZSBwbHVnaW4sIHdoaWNoIGFmZmVjdHMgYWxsIFNvdW5kSW5zdGFuY2VzLlxuXHQgKiBAbWV0aG9kIHNldFZvbHVtZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIHZvbHVtZSB0byBzZXQsIGJldHdlZW4gMCBhbmQgMS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHBsdWdpbiBwcm9jZXNzZXMgdGhlIHNldFZvbHVtZSBjYWxsICh0cnVlKS4gVGhlIFNvdW5kIGNsYXNzIHdpbGwgYWZmZWN0IGFsbCB0aGVcblx0ICogaW5zdGFuY2VzIG1hbnVhbGx5IG90aGVyd2lzZS5cblx0ICovXG5cdHAuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5fdm9sdW1lID0gdmFsdWU7XG5cdFx0dGhpcy5fdXBkYXRlVm9sdW1lKCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgbWFzdGVyIHZvbHVtZSBvZiB0aGUgcGx1Z2luLCB3aGljaCBhZmZlY3RzIGFsbCBTb3VuZEluc3RhbmNlcy5cblx0ICogQG1ldGhvZCBnZXRWb2x1bWVcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgdm9sdW1lIGxldmVsLCBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqL1xuXHRwLmdldFZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdm9sdW1lO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNdXRlIGFsbCBzb3VuZHMgdmlhIHRoZSBwbHVnaW4uXG5cdCAqIEBtZXRob2Qgc2V0TXV0ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIElmIGFsbCBzb3VuZCBzaG91bGQgYmUgbXV0ZWQgb3Igbm90LiBOb3RlIHRoYXQgcGx1Z2luLWxldmVsIG11dGluZyBqdXN0IGxvb2tzIHVwXG5cdCAqIHRoZSBtdXRlIHZhbHVlIG9mIFNvdW5kIHt7I2Nyb3NzTGluayBcIlNvdW5kL2dldE11dGVcIn19e3svY3Jvc3NMaW5rfX0sIHNvIHRoaXMgcHJvcGVydHkgaXMgbm90IHVzZWQgaGVyZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIG11dGUgY2FsbCBzdWNjZWVkcy5cblx0ICovXG5cdHAuc2V0TXV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8vIHBsdWdpbnMgc2hvdWxkIG92ZXJ3cml0ZSB0aGlzIG1ldGhvZFxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltBYnN0cmFjdFBsdWdpbl1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBIYW5kbGVzIGludGVybmFsIHByZWxvYWQgY29tcGxldGlvbi5cblx0ICogQG1ldGhvZCBfaGFuZGxlUHJlbG9hZENvbXBsZXRlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2hhbmRsZVByZWxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBzcmMgPSBldmVudC50YXJnZXQuZ2V0SXRlbSgpLnNyYztcblx0XHR0aGlzLl9hdWRpb1NvdXJjZXNbc3JjXSA9IGV2ZW50LnJlc3VsdDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3NvdW5kSW5zdGFuY2VzW3NyY10ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuX3NvdW5kSW5zdGFuY2VzW3NyY11baV07XG5cdFx0XHRpdGVtLnNldFBsYXliYWNrUmVzb3VyY2UodGhpcy5fYXVkaW9Tb3VyY2VzW3NyY10pO1xuXHRcdFx0Ly8gVG9EbyBjb25zaWRlciBhZGRpbmcgcGxheSBjYWxsIGhlcmUgaWYgcGxheXN0YXRlID09IHBsYXlmYWlsZWRcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgaW50ZXJuYWwgcHJlbG9hZCBlcnJvc1xuXHQgKiBAbWV0aG9kIF9oYW5kbGVQcmVsb2FkRXJyb3Jcblx0ICogQHBhcmFtIGV2ZW50XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2hhbmRsZVByZWxvYWRFcnJvciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Ly9kZWxldGUodGhpcy5fYXVkaW9Tb3VyY2VzW3NyY10pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGdhaW4gdmFsdWUgZm9yIG1hc3RlciBhdWRpby4gU2hvdWxkIG5vdCBiZSBjYWxsZWQgZXh0ZXJuYWxseS5cblx0ICogQG1ldGhvZCBfdXBkYXRlVm9sdW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3VwZGF0ZVZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBQbHVnaW4gU3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdGNyZWF0ZWpzLkFic3RyYWN0UGx1Z2luID0gQWJzdHJhY3RQbHVnaW47XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gV2ViQXVkaW9Mb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBMb2FkZXIgcHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gcHJlbG9hZCBXZWIgQXVkaW8gY29udGVudCB2aWEgUHJlbG9hZEpTIG9yIGludGVybmFsbHkuIEluc3RhbmNlcyBhcmUgcmV0dXJuZWQgdG9cblx0ICogdGhlIHByZWxvYWRlciwgYW5kIHRoZSBsb2FkIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgYXNzZXQgbmVlZHMgdG8gYmUgcmVxdWVzdGVkLlxuXHQgKlxuXHQgKiBAY2xhc3MgV2ViQXVkaW9Mb2FkZXJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxvYWRJdGVtIFRoZSBpdGVtIHRvIGJlIGxvYWRlZFxuXHQgKiBAZXh0ZW5kcyBYSFJSZXF1ZXN0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGZ1bmN0aW9uIExvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNPVU5EKTtcblxuXHR9O1xuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG5cdC8qKlxuXHQgKiB3ZWIgYXVkaW8gY29udGV4dCByZXF1aXJlZCBmb3IgZGVjb2RpbmcgYXVkaW9cblx0ICogQHByb3BlcnR5IGNvbnRleHRcblx0ICogQHR5cGUge0F1ZGlvQ29udGV4dH1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0TG9hZGVyLmNvbnRleHQgPSBudWxsO1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW1dlYkF1ZGlvTG9hZGVyXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kc1xuXHRwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5YSFJSZXF1ZXN0KHRoaXMuX2l0ZW0sIGZhbHNlKTtcblx0XHR0aGlzLl9yZXF1ZXN0LnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xuXHR9O1xuXG5cdHAuX3NlbmRDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdC8vIE9KUiB3ZSBsZWF2ZSB0aGlzIHdyYXBwZWQgaW4gTG9hZGVyIGJlY2F1c2Ugd2UgbmVlZCB0byByZWZlcmVuY2Ugc3JjIGFuZCB0aGUgaGFuZGxlciBvbmx5IHJlY2VpdmVzIGEgc2luZ2xlIGFyZ3VtZW50LCB0aGUgZGVjb2RlZEF1ZGlvXG5cdFx0TG9hZGVyLmNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKHRoaXMuX3Jhd1Jlc3VsdCxcblx0ICAgICAgICAgY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlQXVkaW9EZWNvZGVkLCB0aGlzKSxcblx0ICAgICAgICAgY3JlYXRlanMucHJveHkodGhpcy5fc2VuZEVycm9yLCB0aGlzKSk7XG5cdH07XG5cblxuXHQvKipcblx0KiBUaGUgYXVkaW8gaGFzIGJlZW4gZGVjb2RlZC5cblx0KiBAbWV0aG9kIGhhbmRsZUF1ZGlvRGVjb2RlZFxuXHQqIEBwYXJhbSBkZWNvZGVkXG5cdCogQHByb3RlY3RlZFxuXHQqL1xuXHRwLl9oYW5kbGVBdWRpb0RlY29kZWQgPSBmdW5jdGlvbiAoZGVjb2RlZEF1ZGlvKSB7XG5cdFx0dGhpcy5fcmVzdWx0ID0gZGVjb2RlZEF1ZGlvO1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfX3NlbmRDb21wbGV0ZSgpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLldlYkF1ZGlvTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gV2ViQXVkaW9Tb3VuZEluc3RhbmNlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKipcbiAqIFdlYkF1ZGlvU291bmRJbnN0YW5jZSBleHRlbmRzIHRoZSBiYXNlIGFwaSBvZiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gYW5kIGlzIHVzZWQgYnlcbiAqIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LlxuICpcbiAqIFdlYkF1ZGlvU291bmRJbnN0YW5jZSBleHBvc2VzIGF1ZGlvTm9kZXMgZm9yIGFkdmFuY2VkIHVzZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHBhdGggdG8gYW5kIGZpbGUgbmFtZSBvZiB0aGUgc291bmQuXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRUaW1lIEF1ZGlvIHNwcml0ZSBwcm9wZXJ0eSB1c2VkIHRvIGFwcGx5IGFuIG9mZnNldCwgaW4gbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIEF1ZGlvIHNwcml0ZSBwcm9wZXJ0eSB1c2VkIHRvIHNldCB0aGUgdGltZSB0aGUgY2xpcCBwbGF5cyBmb3IsIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5YmFja1Jlc291cmNlIEFueSByZXNvdXJjZSBuZWVkZWQgYnkgcGx1Z2luIHRvIHN1cHBvcnQgYXVkaW8gcGxheWJhY2suXG4gKiBAY2xhc3MgV2ViQXVkaW9Tb3VuZEluc3RhbmNlXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFNvdW5kSW5zdGFuY2VcbiAqIEBjb25zdHJ1Y3RvclxuICovXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRmdW5jdGlvbiBXZWJBdWRpb1NvdW5kSW5zdGFuY2Uoc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uLCBwbGF5YmFja1Jlc291cmNlKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFNvdW5kSW5zdGFuY2VfY29uc3RydWN0b3Ioc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uLCBwbGF5YmFja1Jlc291cmNlKTtcblxuXG4vLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIE5PVEUgdGhpcyBpcyBvbmx5IGludGVuZGVkIGZvciB1c2UgYnkgYWR2YW5jZWQgdXNlcnMuXG5cdFx0ICogPGJyIC8+R2Fpbk5vZGUgZm9yIGNvbnRyb2xsaW5nIDxjb2RlPldlYkF1ZGlvU291bmRJbnN0YW5jZTwvY29kZT4gdm9sdW1lLiBDb25uZWN0ZWQgdG8gdGhlIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvU291bmRJbnN0YW5jZS9kZXN0aW5hdGlvbk5vZGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IGdhaW5Ob2RlXG5cdFx0ICogQHR5cGUge0F1ZGlvR2Fpbk5vZGV9XG5cdFx0ICogQHNpbmNlIDAuNC4wXG5cdFx0ICpcblx0XHQgKi9cblx0XHR0aGlzLmdhaW5Ob2RlID0gcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblxuXHRcdC8qKlxuXHRcdCAqIE5PVEUgdGhpcyBpcyBvbmx5IGludGVuZGVkIGZvciB1c2UgYnkgYWR2YW5jZWQgdXNlcnMuXG5cdFx0ICogPGJyIC8+QSBwYW5Ob2RlIGFsbG93aW5nIGxlZnQgYW5kIHJpZ2h0IGF1ZGlvIGNoYW5uZWwgcGFubmluZyBvbmx5LiBDb25uZWN0ZWQgdG8gV2ViQXVkaW9Tb3VuZEluc3RhbmNlIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvU291bmRJbnN0YW5jZS9nYWluTm9kZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgcGFuTm9kZVxuXHRcdCAqIEB0eXBlIHtBdWRpb1Bhbm5lck5vZGV9XG5cdFx0ICogQHNpbmNlIDAuNC4wXG5cdFx0ICovXG5cdFx0dGhpcy5wYW5Ob2RlID0gcy5jb250ZXh0LmNyZWF0ZVBhbm5lcigpO1xuXHRcdHRoaXMucGFuTm9kZS5wYW5uaW5nTW9kZWwgPSBzLl9wYW5uaW5nTW9kZWw7XG5cdFx0dGhpcy5wYW5Ob2RlLmNvbm5lY3QodGhpcy5nYWluTm9kZSk7XG5cdFx0dGhpcy5fdXBkYXRlUGFuKCk7XG5cblx0XHQvKipcblx0XHQgKiBOT1RFIHRoaXMgaXMgb25seSBpbnRlbmRlZCBmb3IgdXNlIGJ5IGFkdmFuY2VkIHVzZXJzLlxuXHRcdCAqIDxiciAvPnNvdXJjZU5vZGUgaXMgdGhlIGF1ZGlvIHNvdXJjZS4gQ29ubmVjdGVkIHRvIFdlYkF1ZGlvU291bmRJbnN0YW5jZSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1NvdW5kSW5zdGFuY2UvcGFuTm9kZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgc291cmNlTm9kZVxuXHRcdCAqIEB0eXBlIHtBdWRpb05vZGV9XG5cdFx0ICogQHNpbmNlIDAuNC4wXG5cdFx0ICpcblx0XHQgKi9cblx0XHR0aGlzLnNvdXJjZU5vZGUgPSBudWxsO1xuXG5cbi8vIHByaXZhdGUgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIFRpbWVvdXQgdGhhdCBpcyBjcmVhdGVkIGludGVybmFsbHkgdG8gaGFuZGxlIHNvdW5kIHBsYXlpbmcgdG8gY29tcGxldGlvbi5cblx0XHQgKiBTdG9yZWQgc28gd2UgY2FuIHJlbW92ZSBpdCB3aGVuIHN0b3AsIHBhdXNlLCBvciBjbGVhbnVwIGFyZSBjYWxsZWRcblx0XHQgKiBAcHJvcGVydHkgX3NvdW5kQ29tcGxldGVUaW1lb3V0XG5cdFx0ICogQHR5cGUge3RpbWVvdXRWYXJpYWJsZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqL1xuXHRcdHRoaXMuX3NvdW5kQ29tcGxldGVUaW1lb3V0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIE5PVEUgdGhpcyBpcyBvbmx5IGludGVuZGVkIGZvciB1c2UgYnkgdmVyeSBhZHZhbmNlZCB1c2Vycy5cblx0XHQgKiBfc291cmNlTm9kZU5leHQgaXMgdGhlIGF1ZGlvIHNvdXJjZSBmb3IgdGhlIG5leHQgbG9vcCwgaW5zZXJ0ZWQgaW4gYSBsb29rIGFoZWFkIGFwcHJvYWNoIHRvIGFsbG93IGZvciBzbW9vdGhcblx0XHQgKiBsb29waW5nLiBDb25uZWN0ZWQgdG8ge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9Tb3VuZEluc3RhbmNlL2dhaW5Ob2RlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfc291cmNlTm9kZU5leHRcblx0XHQgKiBAdHlwZSB7QXVkaW9Ob2RlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHNpbmNlIDAuNC4xXG5cdFx0ICpcblx0XHQgKi9cblx0XHR0aGlzLl9zb3VyY2VOb2RlTmV4dCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaW1lIGF1ZGlvIHN0YXJ0ZWQgcGxheWJhY2ssIGluIHNlY29uZHMuIFVzZWQgdG8gaGFuZGxlIHNldCBwb3NpdGlvbiwgZ2V0IHBvc2l0aW9uLCBhbmQgcmVzdW1pbmcgZnJvbSBwYXVzZWQuXG5cdFx0ICogQHByb3BlcnR5IF9wbGF5YmFja1N0YXJ0VGltZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKi9cblx0XHR0aGlzLl9wbGF5YmFja1N0YXJ0VGltZSA9IDA7XG5cblx0XHQvLyBQcm94aWVzLCBtYWtlIHJlbW92aW5nIGxpc3RlbmVycyBlYXNpZXIuXG5cdFx0dGhpcy5fZW5kZWRIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlU291bmRDb21wbGV0ZSwgdGhpcyk7XG5cdH07XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFdlYkF1ZGlvU291bmRJbnN0YW5jZSwgY3JlYXRlanMuQWJzdHJhY3RTb3VuZEluc3RhbmNlKTtcblx0dmFyIHMgPSBXZWJBdWRpb1NvdW5kSW5zdGFuY2U7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuXHQvKipcblx0ICogTm90ZSB0aGlzIGlzIG9ubHkgaW50ZW5kZWQgZm9yIHVzZSBieSBhZHZhbmNlZCB1c2Vycy5cblx0ICogPGJyIC8+QXVkaW8gY29udGV4dCB1c2VkIHRvIGNyZWF0ZSBub2Rlcy4gIFRoaXMgaXMgYW5kIG5lZWRzIHRvIGJlIHRoZSBzYW1lIGNvbnRleHQgdXNlZCBieSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cbiAgXHQgKiBAcHJvcGVydHkgY29udGV4dFxuXHQgKiBAdHlwZSB7QXVkaW9Db250ZXh0fVxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5jb250ZXh0ID0gbnVsbDtcblxuXHQvKipcblx0ICogTm90ZSB0aGlzIGlzIG9ubHkgaW50ZW5kZWQgZm9yIHVzZSBieSBhZHZhbmNlZCB1c2Vycy5cblx0ICogPGJyIC8+VGhlIHNjcmF0Y2ggYnVmZmVyIHRoYXQgd2lsbCBiZSBhc3NpZ25lZCB0byB0aGUgYnVmZmVyIHByb3BlcnR5IG9mIGEgc291cmNlIG5vZGUgb24gY2xvc2UuICBcblx0ICogVGhpcyBpcyBhbmQgc2hvdWxkIGJlIHRoZSBzYW1lIHNjcmF0Y2ggYnVmZmVyIHJlZmVyZW5jZWQgYnkge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG4gIFx0ICogQHByb3BlcnR5IF9zY3JhdGNoQnVmZmVyXG5cdCAqIEB0eXBlIHtBdWRpb0J1ZmZlclNvdXJjZU5vZGV9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX3NjcmF0Y2hCdWZmZXIgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBOb3RlIHRoaXMgaXMgb25seSBpbnRlbmRlZCBmb3IgdXNlIGJ5IGFkdmFuY2VkIHVzZXJzLlxuXHQgKiA8YnIgLz4gQXVkaW8gbm9kZSBmcm9tIFdlYkF1ZGlvUGx1Z2luIHRoYXQgc2VxdWVuY2VzIHRvIDxjb2RlPmNvbnRleHQuZGVzdGluYXRpb248L2NvZGU+XG5cdCAqIEBwcm9wZXJ0eSBkZXN0aW5hdGlvbk5vZGVcblx0ICogQHR5cGUge0F1ZGlvTm9kZX1cblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuZGVzdGluYXRpb25Ob2RlID0gbnVsbDtcblxuXHQvKipcblx0ICogVmFsdWUgdG8gc2V0IHBhbm5pbmcgbW9kZWwgdG8gZXF1YWwgcG93ZXIgZm9yIFdlYkF1ZGlvU291bmRJbnN0YW5jZS4gIENhbiBiZSBcImVxdWFscG93ZXJcIiBvciAwIGRlcGVuZGluZyBvbiBicm93c2VyIGltcGxlbWVudGF0aW9uLlxuXHQgKiBAcHJvcGVydHkgX3Bhbm5pbmdNb2RlbFxuXHQgKiBAdHlwZSB7TnVtYmVyIC8gU3RyaW5nfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLl9wYW5uaW5nTW9kZWwgPSBcImVxdWFscG93ZXJcIjtcblxuXG4vLyBQdWJsaWMgbWV0aG9kc1xuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLkFic3RyYWN0U291bmRJbnN0YW5jZV9kZXN0cm95KCk7XG5cblx0XHR0aGlzLnBhbk5vZGUuZGlzY29ubmVjdCgwKTtcblx0XHR0aGlzLnBhbk5vZGUgPSBudWxsO1xuXHRcdHRoaXMuZ2Fpbk5vZGUuZGlzY29ubmVjdCgwKTtcblx0XHR0aGlzLmdhaW5Ob2RlID0gbnVsbDtcblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltXZWJBdWRpb1NvdW5kSW5zdGFuY2VdXCI7XG5cdH07XG5cblxuLy8gUHJpdmF0ZSBNZXRob2RzXG5cdHAuX3VwZGF0ZVBhbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucGFuTm9kZS5zZXRQb3NpdGlvbih0aGlzLl9wYW4sIDAsIC0wLjUpO1xuXHRcdC8vIHogbmVlZCB0byBiZSAtMC41IG90aGVyd2lzZSB0aGUgc291bmQgb25seSBwbGF5cyBpbiBsZWZ0LCByaWdodCwgb3IgY2VudGVyXG5cdH07XG5cblx0cC5fcmVtb3ZlTG9vcGluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpcy5fc291cmNlTm9kZU5leHQgPSB0aGlzLl9jbGVhblVwQXVkaW9Ob2RlKHRoaXMuX3NvdXJjZU5vZGVOZXh0KTtcblx0fTtcblxuXHRwLl9hZGRMb29waW5nID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodGhpcy5wbGF5U3RhdGUgIT0gY3JlYXRlanMuU291bmQuUExBWV9TVUNDRUVERUQpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5fc291cmNlTm9kZU5leHQgPSB0aGlzLl9jcmVhdGVBbmRQbGF5QXVkaW9Ob2RlKHRoaXMuX3BsYXliYWNrU3RhcnRUaW1lLCAwKTtcblx0fTtcblxuXHRwLl9zZXREdXJhdGlvbkZyb21Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZHVyYXRpb24gPSB0aGlzLnBsYXliYWNrUmVzb3VyY2UuZHVyYXRpb24gKiAxMDAwO1xuXHR9O1xuXG5cdHAuX2hhbmRsZUNsZWFuVXAgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuc291cmNlTm9kZSAmJiB0aGlzLnBsYXlTdGF0ZSA9PSBjcmVhdGVqcy5Tb3VuZC5QTEFZX1NVQ0NFRURFRCkge1xuXHRcdFx0dGhpcy5zb3VyY2VOb2RlID0gdGhpcy5fY2xlYW5VcEF1ZGlvTm9kZSh0aGlzLnNvdXJjZU5vZGUpO1xuXHRcdFx0dGhpcy5fc291cmNlTm9kZU5leHQgPSB0aGlzLl9jbGVhblVwQXVkaW9Ob2RlKHRoaXMuX3NvdXJjZU5vZGVOZXh0KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5nYWluTm9kZS5udW1iZXJPZk91dHB1dHMgIT0gMCkge3RoaXMuZ2Fpbk5vZGUuZGlzY29ubmVjdCgwKTt9XG5cdFx0Ly8gT0pSIHRoZXJlIGFwcGVhcnMgdG8gYmUgYSBidWcgdGhhdCB0aGlzIGRvZXNuJ3QgYWx3YXlzIHdvcmsgaW4gd2Via2l0IChDaHJvbWUgYW5kIFNhZmFyaSkuIEFjY29yZGluZyB0byB0aGUgZG9jdW1lbnRhdGlvbiwgdGhpcyBzaG91bGQgd29yay5cblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9zb3VuZENvbXBsZXRlVGltZW91dCk7XG5cblx0XHR0aGlzLl9wbGF5YmFja1N0YXJ0VGltZSA9IDA7XHQvLyBUaGlzIGlzIHVzZWQgYnkgZ2V0UG9zaXRpb25cblx0fTtcblxuXHQvKipcblx0ICogVHVybiBvZmYgYW5kIGRpc2Nvbm5lY3QgYW4gYXVkaW9Ob2RlLCB0aGVuIHNldCByZWZlcmVuY2UgdG8gbnVsbCB0byByZWxlYXNlIGl0IGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cblx0ICogQG1ldGhvZCBfY2xlYW5VcEF1ZGlvTm9kZVxuXHQgKiBAcGFyYW0gYXVkaW9Ob2RlXG5cdCAqIEByZXR1cm4ge2F1ZGlvTm9kZX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC40LjFcblx0ICovXG5cdHAuX2NsZWFuVXBBdWRpb05vZGUgPSBmdW5jdGlvbihhdWRpb05vZGUpIHtcblx0XHRpZihhdWRpb05vZGUpIHtcblx0XHRcdGF1ZGlvTm9kZS5zdG9wKDApO1xuXHRcdFx0YXVkaW9Ob2RlLmRpc2Nvbm5lY3QoMCk7XG5cdFx0XHQvLyBuZWNlc3NhcnkgdG8gcHJldmVudCBsZWFrIG9uIGlPUyBTYWZhcmkgNy05LiB3aWxsIHRocm93IGluIGFsbW9zdCBhbGwgb3RoZXJcblx0XHRcdC8vIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zLlxuXHRcdFx0dHJ5IHsgYXVkaW9Ob2RlLmJ1ZmZlciA9IHMuX3NjcmF0Y2hCdWZmZXI7IH0gY2F0Y2goZSkge31cblx0XHRcdGF1ZGlvTm9kZSA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBhdWRpb05vZGU7XG5cdH07XG5cblx0cC5faGFuZGxlU291bmRSZWFkeSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuZ2Fpbk5vZGUuY29ubmVjdChzLmRlc3RpbmF0aW9uTm9kZSk7ICAvLyB0aGlzIGxpbmUgY2FuIGNhdXNlIGEgbWVtb3J5IGxlYWsuICBOb2RlcyBuZWVkIHRvIGJlIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBhdWRpb0Rlc3RpbmF0aW9uIG9yIGFueSBzZXF1ZW5jZSB0aGF0IGxlYWRzIHRvIGl0LlxuXG5cdFx0dmFyIGR1ciA9IHRoaXMuX2R1cmF0aW9uICogMC4wMDE7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3Bvc2l0aW9uICogMC4wMDE7XG5cdFx0aWYgKHBvcyA+IGR1cikge3BvcyA9IGR1cjt9XG5cdFx0dGhpcy5zb3VyY2VOb2RlID0gdGhpcy5fY3JlYXRlQW5kUGxheUF1ZGlvTm9kZSgocy5jb250ZXh0LmN1cnJlbnRUaW1lIC0gZHVyKSwgcG9zKTtcblx0XHR0aGlzLl9wbGF5YmFja1N0YXJ0VGltZSA9IHRoaXMuc291cmNlTm9kZS5zdGFydFRpbWUgLSBwb3M7XG5cblx0XHR0aGlzLl9zb3VuZENvbXBsZXRlVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5fZW5kZWRIYW5kbGVyLCAoZHVyIC0gcG9zKSAqIDEwMDApO1xuXG5cdFx0aWYodGhpcy5fbG9vcCAhPSAwKSB7XG5cdFx0XHR0aGlzLl9zb3VyY2VOb2RlTmV4dCA9IHRoaXMuX2NyZWF0ZUFuZFBsYXlBdWRpb05vZGUodGhpcy5fcGxheWJhY2tTdGFydFRpbWUsIDApO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhdWRpbyBub2RlIHVzaW5nIHRoZSBjdXJyZW50IHNyYyBhbmQgY29udGV4dCwgY29ubmVjdHMgaXQgdG8gdGhlIGdhaW4gbm9kZSwgYW5kIHN0YXJ0cyBwbGF5YmFjay5cblx0ICogQG1ldGhvZCBfY3JlYXRlQW5kUGxheUF1ZGlvTm9kZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRUaW1lIFRoZSB0aW1lIHRvIGFkZCB0aGlzIHRvIHRoZSB3ZWIgYXVkaW8gY29udGV4dCwgaW4gc2Vjb25kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBUaGUgYW1vdW50IG9mIHRpbWUgaW50byB0aGUgc3JjIGF1ZGlvIHRvIHN0YXJ0IHBsYXliYWNrLCBpbiBzZWNvbmRzLlxuXHQgKiBAcmV0dXJuIHthdWRpb05vZGV9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXHRwLl9jcmVhdGVBbmRQbGF5QXVkaW9Ob2RlID0gZnVuY3Rpb24oc3RhcnRUaW1lLCBvZmZzZXQpIHtcblx0XHR2YXIgYXVkaW9Ob2RlID0gcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXHRcdGF1ZGlvTm9kZS5idWZmZXIgPSB0aGlzLnBsYXliYWNrUmVzb3VyY2U7XG5cdFx0YXVkaW9Ob2RlLmNvbm5lY3QodGhpcy5wYW5Ob2RlKTtcblx0XHR2YXIgZHVyID0gdGhpcy5fZHVyYXRpb24gKiAwLjAwMTtcblx0XHRhdWRpb05vZGUuc3RhcnRUaW1lID0gc3RhcnRUaW1lICsgZHVyO1xuXHRcdGF1ZGlvTm9kZS5zdGFydChhdWRpb05vZGUuc3RhcnRUaW1lLCBvZmZzZXQrKHRoaXMuX3N0YXJ0VGltZSowLjAwMSksIGR1ciAtIG9mZnNldCk7XG5cdFx0cmV0dXJuIGF1ZGlvTm9kZTtcblx0fTtcblxuXHRwLl9wYXVzZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wb3NpdGlvbiA9IChzLmNvbnRleHQuY3VycmVudFRpbWUgLSB0aGlzLl9wbGF5YmFja1N0YXJ0VGltZSkgKiAxMDAwOyAgLy8gKiAxMDAwIHRvIGdpdmUgbWlsbGlzZWNvbmRzLCBsZXRzIHVzIHJlc3RhcnQgYXQgc2FtZSBwb2ludFxuXHRcdHRoaXMuc291cmNlTm9kZSA9IHRoaXMuX2NsZWFuVXBBdWRpb05vZGUodGhpcy5zb3VyY2VOb2RlKTtcblx0XHR0aGlzLl9zb3VyY2VOb2RlTmV4dCA9IHRoaXMuX2NsZWFuVXBBdWRpb05vZGUodGhpcy5fc291cmNlTm9kZU5leHQpO1xuXG5cdFx0aWYgKHRoaXMuZ2Fpbk5vZGUubnVtYmVyT2ZPdXRwdXRzICE9IDApIHt0aGlzLmdhaW5Ob2RlLmRpc2Nvbm5lY3QoMCk7fVxuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NvdW5kQ29tcGxldGVUaW1lb3V0KTtcblx0fTtcblxuXHRwLl9yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faGFuZGxlU291bmRSZWFkeSgpO1xuXHR9O1xuXG5cdC8qXG5cdHAuX2hhbmRsZVN0b3AgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gd2ViIGF1ZGlvIGRvZXMgbm90IG5lZWQgdG8gZG8gYW55dGhpbmcgZXh0cmFcblx0fTtcblx0Ki9cblxuXHRwLl91cGRhdGVWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG5ld1ZvbHVtZSA9IHRoaXMuX211dGVkID8gMCA6IHRoaXMuX3ZvbHVtZTtcblx0ICBcdGlmIChuZXdWb2x1bWUgIT0gdGhpcy5nYWluTm9kZS5nYWluLnZhbHVlKSB7XG5cdFx0ICB0aGlzLmdhaW5Ob2RlLmdhaW4udmFsdWUgPSBuZXdWb2x1bWU7XG4gIFx0XHR9XG5cdH07XG5cblx0cC5fY2FsY3VsYXRlQ3VycmVudFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAoKHMuY29udGV4dC5jdXJyZW50VGltZSAtIHRoaXMuX3BsYXliYWNrU3RhcnRUaW1lKSAqIDEwMDApOyAvLyBwb3MgaW4gc2Vjb25kcyAqIDEwMDAgdG8gZ2l2ZSBtaWxsaXNlY29uZHNcblx0fTtcblxuXHRwLl91cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNvdXJjZU5vZGUgPSB0aGlzLl9jbGVhblVwQXVkaW9Ob2RlKHRoaXMuc291cmNlTm9kZSk7XG5cdFx0dGhpcy5fc291cmNlTm9kZU5leHQgPSB0aGlzLl9jbGVhblVwQXVkaW9Ob2RlKHRoaXMuX3NvdXJjZU5vZGVOZXh0KTtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fc291bmRDb21wbGV0ZVRpbWVvdXQpO1xuXG5cdFx0aWYgKCF0aGlzLl9wYXVzZWQpIHt0aGlzLl9oYW5kbGVTb3VuZFJlYWR5KCk7fVxuXHR9O1xuXG5cdC8vIE9KUiB3ZSBhcmUgdXNpbmcgYSBsb29rIGFoZWFkIGFwcHJvYWNoIHRvIGVuc3VyZSBzbW9vdGggbG9vcGluZy5cblx0Ly8gV2UgYWRkIF9zb3VyY2VOb2RlTmV4dCB0byB0aGUgYXVkaW8gY29udGV4dCBzbyB0aGF0IGl0IHN0YXJ0cyBwbGF5aW5nIGV2ZW4gaWYgdGhpcyBjYWxsYmFjayBpcyBkZWxheWVkLlxuXHQvLyBUaGlzIHRlY2huaXF1ZSBpcyBkZXNjcmliZWQgaGVyZTogIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2F1ZGlvL3NjaGVkdWxpbmcvXG5cdC8vIE5PVEUgdGhlIGNvc3Qgb2YgdGhpcyBpcyB0aGF0IG91ciBhdWRpbyBsb29wIG1heSBub3QgYWx3YXlzIG1hdGNoIHRoZSBsb29wIGV2ZW50IHRpbWluZyBwcmVjaXNlbHkuXG5cdHAuX2hhbmRsZUxvb3AgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY2xlYW5VcEF1ZGlvTm9kZSh0aGlzLnNvdXJjZU5vZGUpO1xuXHRcdHRoaXMuc291cmNlTm9kZSA9IHRoaXMuX3NvdXJjZU5vZGVOZXh0O1xuXHRcdHRoaXMuX3BsYXliYWNrU3RhcnRUaW1lID0gdGhpcy5zb3VyY2VOb2RlLnN0YXJ0VGltZTtcblx0XHR0aGlzLl9zb3VyY2VOb2RlTmV4dCA9IHRoaXMuX2NyZWF0ZUFuZFBsYXlBdWRpb05vZGUodGhpcy5fcGxheWJhY2tTdGFydFRpbWUsIDApO1xuXHRcdHRoaXMuX3NvdW5kQ29tcGxldGVUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9lbmRlZEhhbmRsZXIsIHRoaXMuX2R1cmF0aW9uKTtcblx0fTtcblxuXHRwLl91cGRhdGVEdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZih0aGlzLnBsYXlTdGF0ZSA9PSBjcmVhdGVqcy5Tb3VuZC5QTEFZX1NVQ0NFRURFRCkge1xuXHRcdFx0dGhpcy5fcGF1c2UoKTtcblx0XHRcdHRoaXMuX3Jlc3VtZSgpO1xuXHRcdH1cblx0fTtcblxuXHRjcmVhdGVqcy5XZWJBdWRpb1NvdW5kSW5zdGFuY2UgPSBjcmVhdGVqcy5wcm9tb3RlKFdlYkF1ZGlvU291bmRJbnN0YW5jZSwgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gV2ViQXVkaW9QbHVnaW4uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFBsYXkgc291bmRzIHVzaW5nIFdlYiBBdWRpbyBpbiB0aGUgYnJvd3Nlci4gVGhlIFdlYkF1ZGlvUGx1Z2luIGlzIGN1cnJlbnRseSB0aGUgZGVmYXVsdCBwbHVnaW4sIGFuZCB3aWxsIGJlIHVzZWRcblx0ICogYW55d2hlcmUgdGhhdCBpdCBpcyBzdXBwb3J0ZWQuIFRvIGNoYW5nZSBwbHVnaW4gcHJpb3JpdHksIGNoZWNrIG91dCB0aGUgU291bmQgQVBJXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyUGx1Z2luc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cblx0ICogPGg0Pktub3duIEJyb3dzZXIgYW5kIE9TIGlzc3VlcyBmb3IgV2ViIEF1ZGlvPC9oND5cblx0ICogPGI+RmlyZWZveCAyNTwvYj5cblx0ICogPGxpPlxuXHQgKiAgICAgbXAzIGF1ZGlvIGZpbGVzIGRvIG5vdCBsb2FkIHByb3Blcmx5IG9uIGFsbCB3aW5kb3dzIG1hY2hpbmVzLCByZXBvcnRlZCA8YSBocmVmPVwiaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTI5OTY5XCIgdGFyZ2V0PVwiX2JsYW5rXCI+aGVyZTwvYT4uXG5cdCAqICAgICA8YnIgLz5Gb3IgdGhpcyByZWFzb24gaXQgaXMgcmVjb21tZW5kZWQgdG8gcGFzcyBhbm90aGVyIEZpcmVGb3gtc3VwcG9ydGVkIHR5cGUgKGkuZS4gb2dnKSBhcyB0aGUgZGVmYXVsdFxuXHQgKiAgICAgZXh0ZW5zaW9uLCB1bnRpbCB0aGlzIGJ1ZyBpcyByZXNvbHZlZFxuXHQgKiA8L2xpPlxuXHQgKlxuXHQgKiA8Yj5XZWJraXQgKENocm9tZSBhbmQgU2FmYXJpKTwvYj5cblx0ICogPGxpPlxuXHQgKiAgICAgQXVkaW9Ob2RlLmRpc2Nvbm5lY3QgZG9lcyBub3QgYWx3YXlzIHNlZW0gdG8gd29yay4gIFRoaXMgY2FuIGNhdXNlIHRoZSBmaWxlIHNpemUgdG8gZ3JvdyBvdmVyIHRpbWUgaWYgeW91XG5cdCAqIFx0ICAgYXJlIHBsYXlpbmcgYSBsb3Qgb2YgYXVkaW8gZmlsZXMuXG5cdCAqIDwvbGk+XG5cdCAqXG5cdCAqIDxiPmlPUyA2IGxpbWl0YXRpb25zPC9iPlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+XG5cdCAqICAgICAgICAgU291bmQgaXMgaW5pdGlhbGx5IG11dGVkIGFuZCB3aWxsIG9ubHkgdW5tdXRlIHRocm91Z2ggcGxheSBiZWluZyBjYWxsZWQgaW5zaWRlIGEgdXNlciBpbml0aWF0ZWQgZXZlbnRcblx0ICogICAgICAgICAodG91Y2gvY2xpY2spLiBQbGVhc2UgcmVhZCB0aGUgbW9iaWxlIHBsYXliYWNrIG5vdGVzIGluIHRoZSB0aGUge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogICAgICAgICBjbGFzcyBmb3IgYSBmdWxsIG92ZXJ2aWV3IG9mIHRoZSBsaW1pdGF0aW9ucywgYW5kIGhvdyB0byBnZXQgYXJvdW5kIHRoZW0uXG5cdCAqICAgICA8L2xpPlxuXHQgKlx0ICAgPGxpPlxuXHQgKlx0ICAgICAgIEEgYnVnIGV4aXN0cyB0aGF0IHdpbGwgZGlzdG9ydCB1bi1jYWNoZWQgYXVkaW8gd2hlbiBhIHZpZGVvIGVsZW1lbnQgaXMgcHJlc2VudCBpbiB0aGUgRE9NLiBZb3UgY2FuIGF2b2lkXG5cdCAqXHQgICAgICAgdGhpcyBidWcgYnkgZW5zdXJpbmcgdGhlIGF1ZGlvIGFuZCB2aWRlbyBhdWRpbyBzaGFyZSB0aGUgc2FtZSBzYW1wbGUgcmF0ZS5cblx0ICpcdCAgIDwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIEBjbGFzcyBXZWJBdWRpb1BsdWdpblxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqL1xuXHRmdW5jdGlvbiBXZWJBdWRpb1BsdWdpbigpIHtcblx0XHR0aGlzLkFic3RyYWN0UGx1Z2luX2NvbnN0cnVjdG9yKCk7XG5cblxuLy8gUHJpdmF0ZSBQcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogVmFsdWUgdG8gc2V0IHBhbm5pbmcgbW9kZWwgdG8gZXF1YWwgcG93ZXIgZm9yIFdlYkF1ZGlvU291bmRJbnN0YW5jZS4gIENhbiBiZSBcImVxdWFscG93ZXJcIiBvciAwIGRlcGVuZGluZyBvbiBicm93c2VyIGltcGxlbWVudGF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGFubmluZ01vZGVsXG5cdFx0ICogQHR5cGUge051bWJlciAvIFN0cmluZ31cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcGFubmluZ01vZGVsID0gcy5fcGFubmluZ01vZGVsOztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB3ZWIgYXVkaW8gY29udGV4dCwgd2hpY2ggV2ViQXVkaW8gdXNlcyB0byBwbGF5IGF1ZGlvLiBBbGwgbm9kZXMgdGhhdCBpbnRlcmFjdCB3aXRoIHRoZSBXZWJBdWRpb1BsdWdpblxuXHRcdCAqIG5lZWQgdG8gYmUgY3JlYXRlZCB3aXRoaW4gdGhpcyBjb250ZXh0LlxuXHRcdCAqIEBwcm9wZXJ0eSBjb250ZXh0XG5cdFx0ICogQHR5cGUge0F1ZGlvQ29udGV4dH1cblx0XHQgKi9cblx0XHR0aGlzLmNvbnRleHQgPSBzLmNvbnRleHQ7XG5cblx0XHQvKipcblx0XHQgKiBBIER5bmFtaWNzQ29tcHJlc3Nvck5vZGUsIHdoaWNoIGlzIHVzZWQgdG8gaW1wcm92ZSBzb3VuZCBxdWFsaXR5IGFuZCBwcmV2ZW50IGF1ZGlvIGRpc3RvcnRpb24uXG5cdFx0ICogSXQgaXMgY29ubmVjdGVkIHRvIDxjb2RlPmNvbnRleHQuZGVzdGluYXRpb248L2NvZGU+LlxuXHRcdCAqXG5cdFx0ICogQ2FuIGJlIGFjY2Vzc2VkIGJ5IGFkdmFuY2VkIHVzZXJzIHRocm91Z2ggY3JlYXRlanMuU291bmQuYWN0aXZlUGx1Z2luLmR5bmFtaWNzQ29tcHJlc3Nvck5vZGUuXG5cdFx0ICogQHByb3BlcnR5IGR5bmFtaWNzQ29tcHJlc3Nvck5vZGVcblx0XHQgKiBAdHlwZSB7QXVkaW9Ob2RlfVxuXHRcdCAqL1xuXHRcdHRoaXMuZHluYW1pY3NDb21wcmVzc29yTm9kZSA9IHRoaXMuY29udGV4dC5jcmVhdGVEeW5hbWljc0NvbXByZXNzb3IoKTtcblx0XHR0aGlzLmR5bmFtaWNzQ29tcHJlc3Nvck5vZGUuY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBHYWluTm9kZSBmb3IgY29udHJvbGxpbmcgbWFzdGVyIHZvbHVtZS4gSXQgaXMgY29ubmVjdGVkIHRvIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luL2R5bmFtaWNzQ29tcHJlc3Nvck5vZGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICpcblx0XHQgKiBDYW4gYmUgYWNjZXNzZWQgYnkgYWR2YW5jZWQgdXNlcnMgdGhyb3VnaCBjcmVhdGVqcy5Tb3VuZC5hY3RpdmVQbHVnaW4uZ2Fpbk5vZGUuXG5cdFx0ICogQHByb3BlcnR5IGdhaW5Ob2RlXG5cdFx0ICogQHR5cGUge0F1ZGlvR2Fpbk5vZGV9XG5cdFx0ICovXG5cdFx0dGhpcy5nYWluTm9kZSA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdFx0dGhpcy5nYWluTm9kZS5jb25uZWN0KHRoaXMuZHluYW1pY3NDb21wcmVzc29yTm9kZSk7XG5cdFx0Y3JlYXRlanMuV2ViQXVkaW9Tb3VuZEluc3RhbmNlLmRlc3RpbmF0aW9uTm9kZSA9IHRoaXMuZ2Fpbk5vZGU7XG5cblx0XHR0aGlzLl9jYXBhYmlsaXRpZXMgPSBzLl9jYXBhYmlsaXRpZXM7XG5cblx0XHR0aGlzLl9sb2FkZXJDbGFzcyA9IGNyZWF0ZWpzLldlYkF1ZGlvTG9hZGVyO1xuXHRcdHRoaXMuX3NvdW5kSW5zdGFuY2VDbGFzcyA9IGNyZWF0ZWpzLldlYkF1ZGlvU291bmRJbnN0YW5jZTtcblxuXHRcdHRoaXMuX2FkZFByb3BzVG9DbGFzc2VzKCk7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoV2ViQXVkaW9QbHVnaW4sIGNyZWF0ZWpzLkFic3RyYWN0UGx1Z2luKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBTdGF0aWMgUHJvcGVydGllc1xuXHR2YXIgcyA9IFdlYkF1ZGlvUGx1Z2luO1xuXHQvKipcblx0ICogVGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgcGx1Z2luLiBUaGlzIGlzIGdlbmVyYXRlZCB2aWEgdGhlIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luL19nZW5lcmF0ZUNhcGFiaWxpdGllczptZXRob2RcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kIGFuZCBpcyB1c2VkIGludGVybmFsbHkuXG5cdCAqIEBwcm9wZXJ0eSBfY2FwYWJpbGl0aWVzXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBkZWZhdWx0IG51bGxcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9jYXBhYmlsaXRpZXMgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBWYWx1ZSB0byBzZXQgcGFubmluZyBtb2RlbCB0byBlcXVhbCBwb3dlciBmb3IgV2ViQXVkaW9Tb3VuZEluc3RhbmNlLiAgQ2FuIGJlIFwiZXF1YWxwb3dlclwiIG9yIDAgZGVwZW5kaW5nIG9uIGJyb3dzZXIgaW1wbGVtZW50YXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBfcGFubmluZ01vZGVsXG5cdCAqIEB0eXBlIHtOdW1iZXIgLyBTdHJpbmd9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fcGFubmluZ01vZGVsID0gXCJlcXVhbHBvd2VyXCI7XG5cblx0LyoqXG5cdCAqIFRoZSB3ZWIgYXVkaW8gY29udGV4dCwgd2hpY2ggV2ViQXVkaW8gdXNlcyB0byBwbGF5IGF1ZGlvLiBBbGwgbm9kZXMgdGhhdCBpbnRlcmFjdCB3aXRoIHRoZSBXZWJBdWRpb1BsdWdpblxuXHQgKiBuZWVkIHRvIGJlIGNyZWF0ZWQgd2l0aGluIHRoaXMgY29udGV4dC5cblx0ICpcblx0ICogQWR2YW5jZWQgdXNlcnMgY2FuIHNldCB0aGlzIHRvIGFuIGV4aXN0aW5nIGNvbnRleHQsIGJ1dCA8Yj5tdXN0PC9iPiBkbyBzbyBiZWZvcmUgdGhleSBjYWxsXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyUGx1Z2luc1wifX17ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJTb3VuZC9pbml0aWFsaXplRGVmYXVsdFBsdWdpbnNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBjb250ZXh0XG5cdCAqIEB0eXBlIHtBdWRpb0NvbnRleHR9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY29udGV4dCA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFRoZSBzY3JhdGNoIGJ1ZmZlciB0aGF0IHdpbGwgYmUgYXNzaWduZWQgdG8gdGhlIGJ1ZmZlciBwcm9wZXJ0eSBvZiBhIHNvdXJjZSBub2RlIG9uIGNsb3NlLlxuXHQgKiBXb3JrcyBhcm91bmQgYW4gaU9TIFNhZmFyaSBidWc6IGh0dHBzOi8vZ2l0aHViLmNvbS9DcmVhdGVKUy9Tb3VuZEpTL2lzc3Vlcy8xMDJcblx0ICpcblx0ICogQWR2YW5jZWQgdXNlcnMgY2FuIHNldCB0aGlzIHRvIGFuIGV4aXN0aW5nIHNvdXJjZSBub2RlLCBidXQgPGI+bXVzdDwvYj4gZG8gc28gYmVmb3JlIHRoZXkgY2FsbFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclBsdWdpbnNcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiU291bmQvaW5pdGlhbGl6ZURlZmF1bHRQbHVnaW5zXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgX3NjcmF0Y2hCdWZmZXJcblx0ICogQHR5cGUge0F1ZGlvQnVmZmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdCBzLl9zY3JhdGNoQnVmZmVyID0gbnVsbDtcblxuXHQvKipcblx0ICogSW5kaWNhdGVkIHdoZXRoZXIgYXVkaW8gb24gaU9TIGhhcyBiZWVuIHVubG9ja2VkLCB3aGljaCByZXF1aXJlcyBhIHRvdWNoZW5kL21vdXNlZG93biBldmVudCB0aGF0IHBsYXlzIGFuXG5cdCAqIGVtcHR5IHNvdW5kLlxuXHQgKiBAcHJvcGVydHkgX3VubG9ja2VkXG5cdCAqIEB0eXBlIHtib29sZWFufVxuXHQgKiBAc2luY2UgMC42LjJcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHMuX3VubG9ja2VkID0gZmFsc2U7XG5cblxuLy8gU3RhdGljIFB1YmxpYyBNZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgdGhlIHBsdWdpbiBjYW4gYmUgdXNlZCBpbiB0aGUgY3VycmVudCBicm93c2VyL09TLlxuXHQgKiBAbWV0aG9kIGlzU3VwcG9ydGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBwbHVnaW4gY2FuIGJlIGluaXRpYWxpemVkLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIGNoZWNrIGlmIHRoaXMgaXMgc29tZSBraW5kIG9mIG1vYmlsZSBkZXZpY2UsIFdlYiBBdWRpbyB3b3JrcyB3aXRoIGxvY2FsIHByb3RvY29sIHVuZGVyIFBob25lR2FwIGFuZCBpdCBpcyB1bmxpa2VseSBzb21lb25lIGlzIHRyeWluZyB0byBydW4gYSBsb2NhbCBmaWxlXG5cdFx0dmFyIGlzTW9iaWxlUGhvbmVHYXAgPSBjcmVhdGVqcy5Ccm93c2VyRGV0ZWN0LmlzSU9TIHx8IGNyZWF0ZWpzLkJyb3dzZXJEZXRlY3QuaXNBbmRyb2lkIHx8IGNyZWF0ZWpzLkJyb3dzZXJEZXRlY3QuaXNCbGFja2JlcnJ5O1xuXHRcdC8vIE9KUiBpc01vYmlsZSBtYXkgYmUgcmVkdW5kYW50IHdpdGggX2lzRmlsZVhIUlN1cHBvcnRlZCBhdmFpbGFibGUuICBDb25zaWRlciByZW1vdmluZy5cblx0XHRpZiAobG9jYXRpb24ucHJvdG9jb2wgPT0gXCJmaWxlOlwiICYmICFpc01vYmlsZVBob25lR2FwICYmICF0aGlzLl9pc0ZpbGVYSFJTdXBwb3J0ZWQoKSkgeyByZXR1cm4gZmFsc2U7IH0gIC8vIFdlYiBBdWRpbyByZXF1aXJlcyBYSFIsIHdoaWNoIGlzIG5vdCB1c3VhbGx5IGF2YWlsYWJsZSBsb2NhbGx5XG5cdFx0cy5fZ2VuZXJhdGVDYXBhYmlsaXRpZXMoKTtcblx0XHRpZiAocy5jb250ZXh0ID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQbGF5cyBhbiBlbXB0eSBzb3VuZCBpbiB0aGUgd2ViIGF1ZGlvIGNvbnRleHQuICBUaGlzIGlzIHVzZWQgdG8gZW5hYmxlIHdlYiBhdWRpbyBvbiBpT1MgZGV2aWNlcywgYXMgdGhleVxuXHQgKiByZXF1aXJlIHRoZSBmaXJzdCBzb3VuZCB0byBiZSBwbGF5ZWQgaW5zaWRlIG9mIGEgdXNlciBpbml0aWF0ZWQgZXZlbnQgKHRvdWNoL2NsaWNrKS4gIFRoaXMgaXMgY2FsbGVkIHdoZW5cblx0ICoge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0gaXMgaW5pdGlhbGl6ZWQgKGJ5IFNvdW5kIHt7I2Nyb3NzTGluayBcIlNvdW5kL2luaXRpYWxpemVEZWZhdWx0UGx1Z2luc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZXhhbXBsZSkuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoKGV2ZW50KSB7XG5cdCAqICAgICAgICAgY3JlYXRlanMuV2ViQXVkaW9QbHVnaW4ucGxheUVtcHR5U291bmQoKTtcblx0ICogICAgIH1cblx0ICpcblx0ICogQG1ldGhvZCBwbGF5RW1wdHlTb3VuZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cy5wbGF5RW1wdHlTb3VuZCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChzLmNvbnRleHQgPT0gbnVsbCkge3JldHVybjt9XG5cdFx0dmFyIHNvdXJjZSA9IHMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblx0XHRzb3VyY2UuYnVmZmVyID0gcy5fc2NyYXRjaEJ1ZmZlcjtcblx0XHRzb3VyY2UuY29ubmVjdChzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuXHRcdHNvdXJjZS5zdGFydCgwLCAwLCAwKTtcblx0fTtcblxuXG4vLyBTdGF0aWMgUHJpdmF0ZSBNZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgWEhSIGlzIHN1cHBvcnRlZCwgd2hpY2ggaXMgbmVjZXNzYXJ5IGZvciB3ZWIgYXVkaW8uXG5cdCAqIEBtZXRob2QgX2lzRmlsZVhIUlN1cHBvcnRlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiBYSFIgaXMgc3VwcG9ydGVkLlxuXHQgKiBAc2luY2UgMC40LjJcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9pc0ZpbGVYSFJTdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBpdCdzIG11Y2ggZWFzaWVyIHRvIGRldGVjdCB3aGVuIHNvbWV0aGluZyBnb2VzIHdyb25nLCBzbyBsZXQncyBzdGFydCBvcHRpbWlzdGljYWxseVxuXHRcdHZhciBzdXBwb3J0ZWQgPSB0cnVlO1xuXG5cdFx0dmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdHRyeSB7XG5cdFx0XHR4aHIub3BlbihcIkdFVFwiLCBcIldlYkF1ZGlvUGx1Z2luVGVzdC5mYWlsXCIsIGZhbHNlKTsgLy8gbG9hZGluZyBub24tZXhpc3RhbnQgZmlsZSB0cmlnZ2VycyA0MDQgb25seSBpZiBpdCBjb3VsZCBsb2FkIChzeW5jaHJvbm91cyBjYWxsKVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHQvLyBjYXRjaCBlcnJvcnMgaW4gY2FzZXMgd2hlcmUgdGhlIG9uZXJyb3IgaXMgcGFzc2VkIGJ5XG5cdFx0XHRzdXBwb3J0ZWQgPSBmYWxzZTtcblx0XHRcdHJldHVybiBzdXBwb3J0ZWQ7XG5cdFx0fVxuXHRcdHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7IHN1cHBvcnRlZCA9IGZhbHNlOyB9OyAvLyBjYXVzZSBpcnJlbGV2YW50XG5cdFx0Ly8gd2l0aCBzZWN1cml0eSB0dXJuZWQgb2ZmLCB3ZSBjYW4gZ2V0IGVtcHR5IHN1Y2Nlc3MgcmVzdWx0cywgd2hpY2ggaXMgYWN0dWFsbHkgYSBmYWlsZWQgcmVhZCAoc3RhdHVzIGNvZGUgMD8pXG5cdFx0eGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyBzdXBwb3J0ZWQgPSB0aGlzLnN0YXR1cyA9PSA0MDQgfHwgKHRoaXMuc3RhdHVzID09IDIwMCB8fCAodGhpcy5zdGF0dXMgPT0gMCAmJiB0aGlzLnJlc3BvbnNlICE9IFwiXCIpKTsgfTtcblx0XHR0cnkge1xuXHRcdFx0eGhyLnNlbmQoKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Ly8gY2F0Y2ggZXJyb3JzIGluIGNhc2VzIHdoZXJlIHRoZSBvbmVycm9yIGlzIHBhc3NlZCBieVxuXHRcdFx0c3VwcG9ydGVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN1cHBvcnRlZDtcblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHRoZSBjYXBhYmlsaXRpZXMgb2YgdGhlIHBsdWdpbi4gVXNlZCBpbnRlcm5hbGx5LiBQbGVhc2Ugc2VlIHRoZSBTb3VuZCBBUEkge3sjY3Jvc3NMaW5rIFwiU291bmQvZ2V0Q2FwYWJpbGl0aWVzXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCBmb3IgYW4gb3ZlcnZpZXcgb2YgcGx1Z2luIGNhcGFiaWxpdGllcy5cblx0ICogQG1ldGhvZCBfZ2VuZXJhdGVDYXBhYmlsaXRpZXNcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLl9nZW5lcmF0ZUNhcGFiaWxpdGllcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAocy5fY2FwYWJpbGl0aWVzICE9IG51bGwpIHtyZXR1cm47fVxuXHRcdC8vIFdlYiBBdWRpbyBjYW4gYmUgaW4gYW55IGZvcm1hdHMgc3VwcG9ydGVkIGJ5IHRoZSBhdWRpbyBlbGVtZW50LCBmcm9tIGh0dHA6Ly93d3cudzMub3JnL1RSL3dlYmF1ZGlvLyNBdWRpb0NvbnRleHQtc2VjdGlvblxuXHRcdHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImF1ZGlvXCIpO1xuXHRcdGlmICh0LmNhblBsYXlUeXBlID09IG51bGwpIHtyZXR1cm4gbnVsbDt9XG5cblx0XHRpZiAocy5jb250ZXh0ID09IG51bGwpIHtcblx0XHRcdGlmICh3aW5kb3cuQXVkaW9Db250ZXh0KSB7XG5cdFx0XHRcdHMuY29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcblx0XHRcdH0gZWxzZSBpZiAod2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkge1xuXHRcdFx0XHRzLmNvbnRleHQgPSBuZXcgd2Via2l0QXVkaW9Db250ZXh0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHMuX3NjcmF0Y2hCdWZmZXIgPT0gbnVsbCkge1xuXHRcdFx0cy5fc2NyYXRjaEJ1ZmZlciA9IHMuY29udGV4dC5jcmVhdGVCdWZmZXIoMSwgMSwgMjIwNTApO1xuXHRcdH1cblxuXHRcdHMuX2NvbXBhdGliaWxpdHlTZXRVcCgpO1xuXG5cdFx0Ly8gTGlzdGVuIGZvciBkb2N1bWVudCBsZXZlbCBjbGlja3MgdG8gdW5sb2NrIFdlYkF1ZGlvIG9uIGlPUy4gU2VlIHRoZSBfdW5sb2NrIG1ldGhvZC5cblx0XHRpZiAoXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3cgJiYgcy5jb250ZXh0LnN0YXRlICE9IFwicnVubmluZ1wiKSB7XG5cdFx0XHRzLl91bmxvY2soKTsgLy8gV2hlbiBwbGF5ZWQgaW5zaWRlIG9mIGEgdG91Y2ggZXZlbnQsIHRoaXMgd2lsbCBlbmFibGUgYXVkaW8gb24gaU9TIGltbWVkaWF0ZWx5LlxuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBzLl91bmxvY2ssIHRydWUpO1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHMuX3VubG9jaywgdHJ1ZSk7XG5cdFx0fVxuXG5cblx0XHRzLl9jYXBhYmlsaXRpZXMgPSB7XG5cdFx0XHRwYW5uaW5nOnRydWUsXG5cdFx0XHR2b2x1bWU6dHJ1ZSxcblx0XHRcdHRyYWNrczotMVxuXHRcdH07XG5cblx0XHQvLyBkZXRlcm1pbmUgd2hpY2ggZXh0ZW5zaW9ucyBvdXIgYnJvd3NlciBzdXBwb3J0cyBmb3IgdGhpcyBwbHVnaW4gYnkgaXRlcmF0aW5nIHRocm91Z2ggU291bmQuU1VQUE9SVEVEX0VYVEVOU0lPTlNcblx0XHR2YXIgc3VwcG9ydGVkRXh0ZW5zaW9ucyA9IGNyZWF0ZWpzLlNvdW5kLlNVUFBPUlRFRF9FWFRFTlNJT05TO1xuXHRcdHZhciBleHRlbnNpb25NYXAgPSBjcmVhdGVqcy5Tb3VuZC5FWFRFTlNJT05fTUFQO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3VwcG9ydGVkRXh0ZW5zaW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBleHQgPSBzdXBwb3J0ZWRFeHRlbnNpb25zW2ldO1xuXHRcdFx0dmFyIHBsYXlUeXBlID0gZXh0ZW5zaW9uTWFwW2V4dF0gfHwgZXh0O1xuXHRcdFx0cy5fY2FwYWJpbGl0aWVzW2V4dF0gPSAodC5jYW5QbGF5VHlwZShcImF1ZGlvL1wiICsgZXh0KSAhPSBcIm5vXCIgJiYgdC5jYW5QbGF5VHlwZShcImF1ZGlvL1wiICsgZXh0KSAhPSBcIlwiKSB8fCAodC5jYW5QbGF5VHlwZShcImF1ZGlvL1wiICsgcGxheVR5cGUpICE9IFwibm9cIiAmJiB0LmNhblBsYXlUeXBlKFwiYXVkaW8vXCIgKyBwbGF5VHlwZSkgIT0gXCJcIik7XG5cdFx0fSAgLy8gT0pSIGFub3RoZXIgd2F5IHRvIGRvIHRoaXMgbWlnaHQgYmUgY2FuUGxheVR5cGU6XCJtNGFcIiwgY29kZXg6IG1wNFxuXG5cdFx0Ly8gMD1ubyBvdXRwdXQsIDE9bW9ubywgMj1zdGVyZW8sIDQ9c3Vycm91bmQsIDY9NS4xIHN1cnJvdW5kLlxuXHRcdC8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi93ZWJhdWRpby8jQXVkaW9DaGFubmVsU3BsaXR0ZXIgZm9yIG1vcmUgZGV0YWlscyBvbiBjaGFubmVscy5cblx0XHRpZiAocy5jb250ZXh0LmRlc3RpbmF0aW9uLm51bWJlck9mQ2hhbm5lbHMgPCAyKSB7XG5cdFx0XHRzLl9jYXBhYmlsaXRpZXMucGFubmluZyA9IGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogU2V0IHVwIGNvbXBhdGliaWxpdHkgaWYgb25seSBkZXByZWNhdGVkIHdlYiBhdWRpbyBjYWxscyBhcmUgc3VwcG9ydGVkLlxuXHQgKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvd2ViYXVkaW8vI0RlcHJlY2F0aW9uTm90ZXNcblx0ICogTmVlZGVkIHNvIHdlIGNhbiBzdXBwb3J0IG5ldyBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgZGVwcmVjYXRlZCBjYWxscyAoRmlyZWZveCkgYXMgd2VsbCBhcyBvbGQgYnJvd3NlcnMgdGhhdFxuXHQgKiBkb24ndCBzdXBwb3J0IG5ldyBjYWxscy5cblx0ICpcblx0ICogQG1ldGhvZCBfY29tcGF0aWJpbGl0eVNldFVwXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC40LjJcblx0ICovXG5cdHMuX2NvbXBhdGliaWxpdHlTZXRVcCA9IGZ1bmN0aW9uKCkge1xuXHRcdHMuX3Bhbm5pbmdNb2RlbCA9IFwiZXF1YWxwb3dlclwiO1xuXHRcdC8vYXNzdW1lIHRoYXQgaWYgb25lIG5ldyBjYWxsIGlzIHN1cHBvcnRlZCwgdGhleSBhbGwgYXJlXG5cdFx0aWYgKHMuY29udGV4dC5jcmVhdGVHYWluKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gc2ltcGxlIG5hbWUgY2hhbmdlLCBmdW5jdGlvbmFsaXR5IHRoZSBzYW1lXG5cdFx0cy5jb250ZXh0LmNyZWF0ZUdhaW4gPSBzLmNvbnRleHQuY3JlYXRlR2Fpbk5vZGU7XG5cblx0XHQvLyBzb3VyY2Ugbm9kZSwgYWRkIHRvIHByb3RvdHlwZVxuXHRcdHZhciBhdWRpb05vZGUgPSBzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cdFx0YXVkaW9Ob2RlLl9fcHJvdG9fXy5zdGFydCA9IGF1ZGlvTm9kZS5fX3Byb3RvX18ubm90ZUdyYWluT247XHQvLyBub3RlIHRoYXQgbm90ZUdyYWluT24gcmVxdWlyZXMgYWxsIDMgcGFyYW1ldGVyc1xuXHRcdGF1ZGlvTm9kZS5fX3Byb3RvX18uc3RvcCA9IGF1ZGlvTm9kZS5fX3Byb3RvX18ubm90ZU9mZjtcblxuXHRcdC8vIHBhbm5pbmdNb2RlbFxuXHRcdHMuX3Bhbm5pbmdNb2RlbCA9IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRyeSB0byB1bmxvY2sgYXVkaW8gb24gaU9TLiBUaGlzIGlzIHRyaWdnZXJlZCBmcm9tIGVpdGhlciBXZWJBdWRpbyBwbHVnaW4gc2V0dXAgKHdoaWNoIHdpbGwgd29yayBpZiBpbnNpZGUgb2Zcblx0ICogYSBgbW91c2Vkb3duYCBvciBgdG91Y2hlbmRgIGV2ZW50IHN0YWNrKSwgb3IgdGhlIGZpcnN0IGRvY3VtZW50IHRvdWNoZW5kL21vdXNlZG93biBldmVudC4gSWYgaXQgZmFpbHMgKHRvdWNoZW5kXG5cdCAqIHdpbGwgZmFpbCBpZiB0aGUgdXNlciBwcmVzc2VzIGZvciB0b28gbG9uZywgaW5kaWNhdGluZyBhIHNjcm9sbCBldmVudCBpbnN0ZWFkIG9mIGEgY2xpY2sgZXZlbnQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBlYXJsaWVyIHZlcnNpb25zIG9mIGlPUyBzdXBwb3J0ZWQgYHRvdWNoc3RhcnRgIGZvciB0aGlzLCBidXQgaU9TOSByZW1vdmVkIHRoaXMgZnVuY3Rpb25hbGl0eS4gQWRkaW5nXG5cdCAqIGEgYHRvdWNoc3RhcnRgIGV2ZW50IHRvIHN1cHBvcnQgb2xkZXIgcGxhdGZvcm1zIG1heSBwcmVjbHVkZSBhIGBtb3VzZWRvd25gIGV2ZW4gZnJvbSBnZXR0aW5nIGZpcmVkIG9uIGlPUzksIHNvIHdlXG5cdCAqIHN0aWNrIHdpdGggYG1vdXNlZG93bmAgYW5kIGB0b3VjaGVuZGAuXG5cdCAqIEBtZXRob2QgX3VubG9ja1xuXHQgKiBAc2luY2UgMC42LjJcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHMuX3VubG9jayA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChzLl91bmxvY2tlZCkgeyByZXR1cm47IH1cblx0XHRzLnBsYXlFbXB0eVNvdW5kKCk7XG5cdFx0aWYgKHMuY29udGV4dC5zdGF0ZSA9PSBcInJ1bm5pbmdcIikge1xuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBzLl91bmxvY2ssIHRydWUpO1xuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHMuX3VubG9jaywgdHJ1ZSk7XG5cdFx0XHRzLl91bmxvY2tlZCA9IHRydWU7XG5cdFx0fVxuXHR9O1xuXG5cbi8vIFB1YmxpYyBNZXRob2RzXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW1dlYkF1ZGlvUGx1Z2luXVwiO1xuXHR9O1xuXG5cbi8vIFByaXZhdGUgTWV0aG9kc1xuXHQvKipcblx0ICogU2V0IHVwIG5lZWRlZCBwcm9wZXJ0aWVzIG9uIHN1cHBvcnRlZCBjbGFzc2VzIFdlYkF1ZGlvU291bmRJbnN0YW5jZSBhbmQgV2ViQXVkaW9Mb2FkZXIuXG5cdCAqIEBtZXRob2QgX2FkZFByb3BzVG9DbGFzc2VzXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX2FkZFByb3BzVG9DbGFzc2VzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGMgPSB0aGlzLl9zb3VuZEluc3RhbmNlQ2xhc3M7XG5cdFx0Yy5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXHRcdGMuX3NjcmF0Y2hCdWZmZXIgPSBzLl9zY3JhdGNoQnVmZmVyO1xuXHRcdGMuZGVzdGluYXRpb25Ob2RlID0gdGhpcy5nYWluTm9kZTtcblx0XHRjLl9wYW5uaW5nTW9kZWwgPSB0aGlzLl9wYW5uaW5nTW9kZWw7XG5cblx0XHR0aGlzLl9sb2FkZXJDbGFzcy5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgZ2FpbiB2YWx1ZSBmb3IgbWFzdGVyIGF1ZGlvLiBTaG91bGQgbm90IGJlIGNhbGxlZCBleHRlcm5hbGx5LlxuXHQgKiBAbWV0aG9kIF91cGRhdGVWb2x1bWVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fdXBkYXRlVm9sdW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBuZXdWb2x1bWUgPSBjcmVhdGVqcy5Tb3VuZC5fbWFzdGVyTXV0ZSA/IDAgOiB0aGlzLl92b2x1bWU7XG5cdFx0aWYgKG5ld1ZvbHVtZSAhPSB0aGlzLmdhaW5Ob2RlLmdhaW4udmFsdWUpIHtcblx0XHRcdHRoaXMuZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSA9IG5ld1ZvbHVtZTtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuV2ViQXVkaW9QbHVnaW4gPSBjcmVhdGVqcy5wcm9tb3RlKFdlYkF1ZGlvUGx1Z2luLCBcIkFic3RyYWN0UGx1Z2luXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEhUTUxBdWRpb1RhZ1Bvb2wuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBIVE1MQXVkaW9UYWdQb29sIGlzIGFuIG9iamVjdCBwb29sIGZvciBIVE1MQXVkaW8gdGFnIGluc3RhbmNlcy5cblx0ICogQGNsYXNzIEhUTUxBdWRpb1RhZ1Bvb2xcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIG9mIHRoZSBjaGFubmVsLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRmdW5jdGlvbiBIVE1MQXVkaW9UYWdQb29sKCkge1xuXHRcdFx0dGhyb3cgXCJIVE1MQXVkaW9UYWdQb29sIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWRcIjtcblx0fVxuXG5cdHZhciBzID0gSFRNTEF1ZGlvVGFnUG9vbDtcblxuLy8gU3RhdGljIFByb3BlcnRpZXNcblx0LyoqXG5cdCAqIEEgaGFzaCBsb29rdXAgb2YgZWFjaCBiYXNlIGF1ZGlvIHRhZywgaW5kZXhlZCBieSB0aGUgYXVkaW8gc291cmNlLlxuXHQgKiBAcHJvcGVydHkgX3RhZ3Ncblx0ICogQHR5cGUge3t9fVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuX3RhZ3MgPSB7fTtcblxuXHQvKipcblx0ICogQW4gb2JqZWN0IHBvb2wgZm9yIGh0bWwgYXVkaW8gdGFnc1xuXHQgKiBAcHJvcGVydHkgX3RhZ1Bvb2xcblx0ICogQHR5cGUge1RhZ1Bvb2x9XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5fdGFnUG9vbCA9IG5ldyBUYWdQb29sKCk7XG5cblx0LyoqXG5cdCAqIEEgaGFzaCBsb29rdXAgb2YgaWYgYSBiYXNlIGF1ZGlvIHRhZyBpcyBhdmFpbGFibGUsIGluZGV4ZWQgYnkgdGhlIGF1ZGlvIHNvdXJjZVxuXHQgKiBAcHJvcGVydHkgX3RhZ3NVc2VkXG5cdCAqIEB0eXBlIHt7fX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl90YWdVc2VkID0ge307XG5cbi8vIFN0YXRpYyBNZXRob2RzXG5cdC8qKlxuXHQgICogR2V0IGFuIGF1ZGlvIHRhZyB3aXRoIHRoZSBnaXZlbiBzb3VyY2UuXG5cdCAgKiBAbWV0aG9kIGdldFxuXHQgICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIGZpbGUgdXNlZCBieSB0aGUgYXVkaW8gdGFnLlxuXHQgICogQHN0YXRpY1xuXHQgICovXG5cdCBzLmdldCA9IGZ1bmN0aW9uIChzcmMpIHtcblx0XHR2YXIgdCA9IHMuX3RhZ3Nbc3JjXTtcblx0XHRpZiAodCA9PSBudWxsKSB7XG5cdFx0XHQvLyBjcmVhdGUgbmV3IGJhc2UgdGFnXG5cdFx0XHR0ID0gcy5fdGFnc1tzcmNdID0gcy5fdGFnUG9vbC5nZXQoKTtcblx0XHRcdHQuc3JjID0gc3JjO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBnZXQgYmFzZSBvciBwb29sXG5cdFx0XHRpZiAocy5fdGFnVXNlZFtzcmNdKSB7XG5cdFx0XHRcdHQgPSBzLl90YWdQb29sLmdldCgpO1xuXHRcdFx0XHR0LnNyYyA9IHNyYztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHMuX3RhZ1VzZWRbc3JjXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0O1xuXHQgfTtcblxuXHQgLyoqXG5cdCAgKiBSZXR1cm4gYW4gYXVkaW8gdGFnIHRvIHRoZSBwb29sLlxuXHQgICogQG1ldGhvZCBzZXRcblx0ICAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBmaWxlIHVzZWQgYnkgdGhlIGF1ZGlvIHRhZy5cblx0ICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZyBBdWRpbyB0YWcgdG8gc2V0LlxuXHQgICogQHN0YXRpY1xuXHQgICovXG5cdCBzLnNldCA9IGZ1bmN0aW9uIChzcmMsIHRhZykge1xuXHRcdCAvLyBjaGVjayBpZiB0aGlzIGlzIGJhc2UsIGlmIHllcyBzZXQgYm9vbGVhbiBpZiBub3QgcmV0dXJuIHRvIHBvb2xcblx0XHQgaWYodGFnID09IHMuX3RhZ3Nbc3JjXSkge1xuXHRcdFx0IHMuX3RhZ1VzZWRbc3JjXSA9IGZhbHNlO1xuXHRcdCB9IGVsc2Uge1xuXHRcdFx0IHMuX3RhZ1Bvb2wuc2V0KHRhZyk7XG5cdFx0IH1cblx0IH07XG5cblx0LyoqXG5cdCAqIERlbGV0ZSBzdG9yZWQgdGFnIHJlZmVyZW5jZSBhbmQgcmV0dXJuIHRoZW0gdG8gcG9vbC4gTm90ZSB0aGF0IGlmIHRoZSB0YWcgcmVmZXJlbmNlIGRvZXMgbm90IGV4aXN0LCB0aGlzIHdpbGwgZmFpbC5cblx0ICogQG1ldGhvZCByZW1vdmVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIGZvciB0aGUgdGFnXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBUYWdQb29sIHdhcyBkZWxldGVkLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLnJlbW92ZSA9IGZ1bmN0aW9uIChzcmMpIHtcblx0XHR2YXIgdGFnID0gcy5fdGFnc1tzcmNdO1xuXHRcdGlmICh0YWcgPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cdFx0cy5fdGFnUG9vbC5zZXQodGFnKTtcblx0XHRkZWxldGUocy5fdGFnc1tzcmNdKTtcblx0XHRkZWxldGUocy5fdGFnVXNlZFtzcmNdKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgZHVyYXRpb24gb2YgdGhlIHNyYyBhdWRpbyBpbiBtaWxsaXNlY29uZHNcblx0ICogQG1ldGhvZCBnZXREdXJhdGlvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2UgZmlsZSB1c2VkIGJ5IHRoZSBhdWRpbyB0YWcuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gRHVyYXRpb24gb2Ygc3JjIGluIG1pbGxpc2Vjb25kc1xuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmdldER1cmF0aW9uPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0dmFyIHQgPSBzLl90YWdzW3NyY107XG5cdFx0aWYgKHQgPT0gbnVsbCB8fCAhdC5kdXJhdGlvbikge3JldHVybiAwO31cdC8vIE9KUiBkdXJhdGlvbiBpcyBOYU4gaWYgbG9hZGluZyBoYXMgbm90IGNvbXBsZXRlZFxuXHRcdHJldHVybiB0LmR1cmF0aW9uICogMTAwMDtcblx0fTtcblxuXHRjcmVhdGVqcy5IVE1MQXVkaW9UYWdQb29sID0gSFRNTEF1ZGlvVGFnUG9vbDtcblxuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0LyoqXG5cdCAqIFRoZSBUYWdQb29sIGlzIGFuIG9iamVjdCBwb29sIGZvciBIVE1MQXVkaW8gdGFnIGluc3RhbmNlcy5cblx0ICogI2NsYXNzIFRhZ1Bvb2xcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIG9mIHRoZSBjaGFubmVsLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRmdW5jdGlvbiBUYWdQb29sKHNyYykge1xuXG4vLyBQdWJsaWMgUHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEEgbGlzdCBvZiBhbGwgYXZhaWxhYmxlIHRhZ3MgaW4gdGhlIHBvb2wuXG5cdFx0ICogI3Byb3BlcnR5IHRhZ3Ncblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3RhZ3MgPSBbXTtcblx0fTtcblxuXHR2YXIgcCA9IFRhZ1Bvb2wucHJvdG90eXBlO1xuXHRwLmNvbnN0cnVjdG9yID0gVGFnUG9vbDtcblxuXG4vLyBQdWJsaWMgTWV0aG9kc1xuXHQvKipcblx0ICogR2V0IGFuIEhUTUxBdWRpb0VsZW1lbnQgZm9yIGltbWVkaWF0ZSBwbGF5YmFjay4gVGhpcyB0YWtlcyBpdCBvdXQgb2YgdGhlIHBvb2wuXG5cdCAqICNtZXRob2QgZ2V0XG5cdCAqIEByZXR1cm4ge0hUTUxBdWRpb0VsZW1lbnR9IEFuIEhUTUwgYXVkaW8gdGFnLlxuXHQgKi9cblx0cC5nZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRhZztcblx0XHRpZiAodGhpcy5fdGFncy5sZW5ndGggPT0gMCkge1xuXHRcdFx0dGFnID0gdGhpcy5fY3JlYXRlVGFnKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhZyA9IHRoaXMuX3RhZ3MucG9wKCk7XG5cdFx0fVxuXHRcdGlmICh0YWcucGFyZW50Tm9kZSA9PSBudWxsKSB7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0YWcpO31cblx0XHRyZXR1cm4gdGFnO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQdXQgYW4gSFRNTEF1ZGlvRWxlbWVudCBiYWNrIGluIHRoZSBwb29sIGZvciB1c2UuXG5cdCAqICNtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7SFRNTEF1ZGlvRWxlbWVudH0gdGFnIEhUTUwgYXVkaW8gdGFnXG5cdCAqL1xuXHRwLnNldCA9IGZ1bmN0aW9uICh0YWcpIHtcblx0XHQvLyBPSlIgdGhpcyBmaXJzdCBzdGVwIHNlZW1zIHVubmVjZXNzYXJ5XG5cdFx0dmFyIGluZGV4ID0gY3JlYXRlanMuaW5kZXhPZih0aGlzLl90YWdzLCB0YWcpO1xuXHRcdGlmIChpbmRleCA9PSAtMSkge1xuXHRcdFx0dGhpcy5fdGFncy5zcmMgPSBudWxsO1xuXHRcdFx0dGhpcy5fdGFncy5wdXNoKHRhZyk7XG5cdFx0fVxuXHR9O1xuXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW1RhZ1Bvb2xdXCI7XG5cdH07XG5cblxuLy8gUHJpdmF0ZSBNZXRob2RzXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gSFRNTCBhdWRpbyB0YWcuXG5cdCAqICNtZXRob2QgX2NyZWF0ZVRhZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2UgZmlsZSB0byBzZXQgZm9yIHRoZSBhdWRpbyB0YWcuXG5cdCAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBSZXR1cm5zIGFuIEhUTUwgYXVkaW8gdGFnLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9jcmVhdGVUYWcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhdWRpb1wiKTtcblx0XHR0YWcuYXV0b3BsYXkgPSBmYWxzZTtcblx0XHR0YWcucHJlbG9hZCA9IFwibm9uZVwiO1xuXHRcdC8vTE06IEZpcmVmb3ggZmFpbHMgd2hlbiB0aGlzIHRoZSBwcmVsb2FkPVwibm9uZVwiIGZvciBvdGhlciB0YWdzLCBidXQgaXQgbmVlZHMgdG8gYmUgXCJub25lXCIgdG8gZW5zdXJlIFByZWxvYWRKUyB3b3Jrcy5cblx0XHRyZXR1cm4gdGFnO1xuXHR9O1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSFRNTEF1ZGlvU291bmRJbnN0YW5jZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEhUTUxBdWRpb1NvdW5kSW5zdGFuY2UgZXh0ZW5kcyB0aGUgYmFzZSBhcGkgb2Yge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IGFuZCBpcyB1c2VkIGJ5XG5cdCAqIHt7I2Nyb3NzTGluayBcIkhUTUxBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgcGF0aCB0byBhbmQgZmlsZSBuYW1lIG9mIHRoZSBzb3VuZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0VGltZSBBdWRpbyBzcHJpdGUgcHJvcGVydHkgdXNlZCB0byBhcHBseSBhbiBvZmZzZXQsIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIEF1ZGlvIHNwcml0ZSBwcm9wZXJ0eSB1c2VkIHRvIHNldCB0aGUgdGltZSB0aGUgY2xpcCBwbGF5cyBmb3IsIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IHBsYXliYWNrUmVzb3VyY2UgQW55IHJlc291cmNlIG5lZWRlZCBieSBwbHVnaW4gdG8gc3VwcG9ydCBhdWRpbyBwbGF5YmFjay5cblx0ICogQGNsYXNzIEhUTUxBdWRpb1NvdW5kSW5zdGFuY2Vcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RTb3VuZEluc3RhbmNlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gSFRNTEF1ZGlvU291bmRJbnN0YW5jZShzcmMsIHN0YXJ0VGltZSwgZHVyYXRpb24sIHBsYXliYWNrUmVzb3VyY2UpIHtcblx0XHR0aGlzLkFic3RyYWN0U291bmRJbnN0YW5jZV9jb25zdHJ1Y3RvcihzcmMsIHN0YXJ0VGltZSwgZHVyYXRpb24sIHBsYXliYWNrUmVzb3VyY2UpO1xuXG5cbi8vIFByaXZhdGUgUHJvcGVydGllc1xuXHRcdHRoaXMuX2F1ZGlvU3ByaXRlU3RvcFRpbWUgPSBudWxsO1xuXHRcdHRoaXMuX2RlbGF5VGltZW91dElkID0gbnVsbDtcblxuXHRcdC8vIFByb3hpZXMsIG1ha2UgcmVtb3ZpbmcgbGlzdGVuZXJzIGVhc2llci5cblx0XHR0aGlzLl9lbmRlZEhhbmRsZXIgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVTb3VuZENvbXBsZXRlLCB0aGlzKTtcblx0XHR0aGlzLl9yZWFkeUhhbmRsZXIgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUYWdSZWFkeSwgdGhpcyk7XG5cdFx0dGhpcy5fc3RhbGxlZEhhbmRsZXIgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9wbGF5RmFpbGVkLCB0aGlzKTtcblx0XHR0aGlzLl9hdWRpb1Nwcml0ZUVuZEhhbmRsZXIgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVBdWRpb1Nwcml0ZUxvb3AsIHRoaXMpO1xuXHRcdHRoaXMuX2xvb3BIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlU291bmRDb21wbGV0ZSwgdGhpcyk7XG5cblx0XHRpZiAoZHVyYXRpb24pIHtcblx0XHRcdHRoaXMuX2F1ZGlvU3ByaXRlU3RvcFRpbWUgPSAoc3RhcnRUaW1lICsgZHVyYXRpb24pICogMC4wMDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2R1cmF0aW9uID0gY3JlYXRlanMuSFRNTEF1ZGlvVGFnUG9vbC5nZXREdXJhdGlvbih0aGlzLnNyYyk7XG5cdFx0fVxuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEhUTUxBdWRpb1NvdW5kSW5zdGFuY2UsIGNyZWF0ZWpzLkFic3RyYWN0U291bmRJbnN0YW5jZSk7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gUHVibGljIE1ldGhvZHNcblx0LyoqXG5cdCAqIENhbGxlZCBieSB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSB3aGVuIHBsdWdpbiBkb2VzIG5vdCBoYW5kbGUgbWFzdGVyIHZvbHVtZS5cblx0ICogdW5kb2MnZCBiZWNhdXNlIGl0IGlzIG5vdCBtZWFudCB0byBiZSB1c2VkIG91dHNpZGUgb2YgU291bmRcblx0ICogI21ldGhvZCBzZXRNYXN0ZXJWb2x1bWVcblx0ICogQHBhcmFtIHZhbHVlXG5cdCAqL1xuXHRwLnNldE1hc3RlclZvbHVtZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgYnkge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX0gd2hlbiBwbHVnaW4gZG9lcyBub3QgaGFuZGxlIG1hc3RlciBtdXRlLlxuXHQgKiB1bmRvYydkIGJlY2F1c2UgaXQgaXMgbm90IG1lYW50IHRvIGJlIHVzZWQgb3V0c2lkZSBvZiBTb3VuZFxuXHQgKiAjbWV0aG9kIHNldE1hc3Rlck11dGVcblx0ICogQHBhcmFtIHZhbHVlXG5cdCAqL1xuXHRwLnNldE1hc3Rlck11dGUgPSBmdW5jdGlvbiAoaXNNdXRlZCkge1xuXHRcdHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuXHR9O1xuXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW0hUTUxBdWRpb1NvdW5kSW5zdGFuY2VdXCI7XG5cdH07XG5cbi8vUHJpdmF0ZSBNZXRob2RzXG5cdHAuX3JlbW92ZUxvb3BpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRpZih0aGlzLl9wbGF5YmFja1Jlc291cmNlID09IG51bGwpIHtyZXR1cm47fVxuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UubG9vcCA9IGZhbHNlO1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NFRUtFRCwgdGhpcy5fbG9vcEhhbmRsZXIsIGZhbHNlKTtcblx0fTtcblxuXHRwLl9hZGRMb29waW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYodGhpcy5fcGxheWJhY2tSZXNvdXJjZSA9PSBudWxsICB8fCB0aGlzLl9hdWRpb1Nwcml0ZVN0b3BUaW1lKSB7cmV0dXJuO31cblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TRUVLRUQsIHRoaXMuX2xvb3BIYW5kbGVyLCBmYWxzZSk7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5sb29wID0gdHJ1ZTtcblx0fTtcblxuXHRwLl9oYW5kbGVDbGVhblVwID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0YWcgPSB0aGlzLl9wbGF5YmFja1Jlc291cmNlO1xuXHRcdGlmICh0YWcgIT0gbnVsbCkge1xuXHRcdFx0dGFnLnBhdXNlKCk7XG5cdFx0XHR0YWcubG9vcCA9IGZhbHNlO1xuXHRcdFx0dGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19FTkRFRCwgdGhpcy5fZW5kZWRIYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHR0YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1JFQURZLCB0aGlzLl9yZWFkeUhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdHRhZy5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fU1RBTExFRCwgdGhpcy5fc3RhbGxlZEhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdHRhZy5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fU0VFS0VELCB0aGlzLl9sb29wSGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0dGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9USU1FX1VQREFURSwgdGhpcy5fYXVkaW9TcHJpdGVFbmRIYW5kbGVyLCBmYWxzZSk7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRhZy5jdXJyZW50VGltZSA9IHRoaXMuX3N0YXJ0VGltZTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdH0gLy8gUmVzZXQgUG9zaXRpb25cblx0XHRcdGNyZWF0ZWpzLkhUTUxBdWRpb1RhZ1Bvb2wuc2V0KHRoaXMuc3JjLCB0YWcpO1xuXHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZSA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdHAuX2JlZ2luUGxheWluZyA9IGZ1bmN0aW9uIChwbGF5UHJvcHMpIHtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlID0gY3JlYXRlanMuSFRNTEF1ZGlvVGFnUG9vbC5nZXQodGhpcy5zcmMpO1xuXHRcdHJldHVybiB0aGlzLkFic3RyYWN0U291bmRJbnN0YW5jZV9fYmVnaW5QbGF5aW5nKHBsYXlQcm9wcyk7XG5cdH07XG5cblx0cC5faGFuZGxlU291bmRSZWFkeSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICh0aGlzLl9wbGF5YmFja1Jlc291cmNlLnJlYWR5U3RhdGUgIT09IDQpIHtcblx0XHRcdHZhciB0YWcgPSB0aGlzLl9wbGF5YmFja1Jlc291cmNlO1xuXHRcdFx0dGFnLmFkZEV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19SRUFEWSwgdGhpcy5fcmVhZHlIYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHR0YWcuYWRkRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NUQUxMRUQsIHRoaXMuX3N0YWxsZWRIYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHR0YWcucHJlbG9hZCA9IFwiYXV0b1wiOyAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgRmlyZWZveCwgYXMgaXQgd29uJ3QgZXZlciBcImxvYWRcIiB1bnRpbCB0aGlzIGlzIHNldC5cblx0XHRcdHRhZy5sb2FkKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlVm9sdW1lKCk7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5jdXJyZW50VGltZSA9ICh0aGlzLl9zdGFydFRpbWUgKyB0aGlzLl9wb3NpdGlvbikgKiAwLjAwMTtcblx0XHRpZiAodGhpcy5fYXVkaW9TcHJpdGVTdG9wVGltZSkge1xuXHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fVElNRV9VUERBVEUsIHRoaXMuX2F1ZGlvU3ByaXRlRW5kSGFuZGxlciwgZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19FTkRFRCwgdGhpcy5fZW5kZWRIYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHRpZih0aGlzLl9sb29wICE9IDApIHtcblx0XHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fU0VFS0VELCB0aGlzLl9sb29wSGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmxvb3AgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucGxheSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIGhhbmRsZSB3aGVuIGEgdGFnIGlzIG5vdCByZWFkeSBmb3IgaW1tZWRpYXRlIHBsYXliYWNrIHdoZW4gaXQgaXMgcmV0dXJuZWQgZnJvbSB0aGUgSFRNTEF1ZGlvVGFnUG9vbC5cblx0ICogQG1ldGhvZCBfaGFuZGxlVGFnUmVhZHlcblx0ICogQHBhcmFtIGV2ZW50XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2hhbmRsZVRhZ1JlYWR5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fUkVBRFksIHRoaXMuX3JlYWR5SGFuZGxlciwgZmFsc2UpO1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NUQUxMRUQsIHRoaXMuX3N0YWxsZWRIYW5kbGVyLCBmYWxzZSk7XG5cblx0XHR0aGlzLl9oYW5kbGVTb3VuZFJlYWR5KCk7XG5cdH07XG5cblx0cC5fcGF1c2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5wYXVzZSgpO1xuXHR9O1xuXG5cdHAuX3Jlc3VtZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnBsYXkoKTtcblx0fTtcblxuXHRwLl91cGRhdGVWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3BsYXliYWNrUmVzb3VyY2UgIT0gbnVsbCkge1xuXHRcdFx0dmFyIG5ld1ZvbHVtZSA9ICh0aGlzLl9tdXRlZCB8fCBjcmVhdGVqcy5Tb3VuZC5fbWFzdGVyTXV0ZSkgPyAwIDogdGhpcy5fdm9sdW1lICogY3JlYXRlanMuU291bmQuX21hc3RlclZvbHVtZTtcblx0XHRcdGlmIChuZXdWb2x1bWUgIT0gdGhpcy5fcGxheWJhY2tSZXNvdXJjZS52b2x1bWUpIHt0aGlzLl9wbGF5YmFja1Jlc291cmNlLnZvbHVtZSA9IG5ld1ZvbHVtZTt9XG5cdFx0fVxuXHR9O1xuXG5cdHAuX2NhbGN1bGF0ZUN1cnJlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5fcGxheWJhY2tSZXNvdXJjZS5jdXJyZW50VGltZSAqIDEwMDApIC0gdGhpcy5fc3RhcnRUaW1lO1xuXHR9O1xuXG5cdHAuX3VwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fU0VFS0VELCB0aGlzLl9sb29wSGFuZGxlciwgZmFsc2UpO1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NFRUtFRCwgdGhpcy5faGFuZGxlU2V0UG9zaXRpb25TZWVrLCBmYWxzZSk7XG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuY3VycmVudFRpbWUgPSAodGhpcy5fcG9zaXRpb24gKyB0aGlzLl9zdGFydFRpbWUpICogMC4wMDE7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHsgLy8gT3V0IG9mIHJhbmdlXG5cdFx0XHR0aGlzLl9oYW5kbGVTZXRQb3NpdGlvblNlZWsobnVsbCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIGVuYWJsZSBzZXR0aW5nIHBvc2l0aW9uLCBhcyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoYXQgc2VlayB0byBiZSBkb25lIGJlZm9yZSB3ZSBhZGQgYmFjayBvdXIgbG9vcCBoYW5kbGluZyBzZWVrIGxpc3RlbmVyXG5cdCAqIEBtZXRob2QgX2hhbmRsZVNldFBvc2l0aW9uU2Vla1xuXHQgKiBAcGFyYW0gZXZlbnRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5faGFuZGxlU2V0UG9zaXRpb25TZWVrID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRpZiAodGhpcy5fcGxheWJhY2tSZXNvdXJjZSA9PSBudWxsKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NFRUtFRCwgdGhpcy5faGFuZGxlU2V0UG9zaXRpb25TZWVrLCBmYWxzZSk7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fU0VFS0VELCB0aGlzLl9sb29wSGFuZGxlciwgZmFsc2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaW1lciB1c2VkIHRvIGxvb3AgYXVkaW8gc3ByaXRlcy5cblx0ICogTk9URSBiZWNhdXNlIG9mIHRoZSBpbmFjY3VyYWNpZXMgaW4gdGhlIHRpbWV1cGRhdGUgZXZlbnQgKDE1IC0gMjUwbXMpIGFuZCBpbiBzZXR0aW5nIHRoZSB0YWcgdG8gdGhlIGRlc2lyZWQgdGltZWRcblx0ICogKHVwIHRvIDMwMG1zKSwgaXQgaXMgc3Ryb25nbHkgcmVjb21tZW5kZWQgbm90IHRvIGxvb3AgYXVkaW8gc3ByaXRlcyB3aXRoIEhUTUwgQXVkaW8gaWYgc21vb3RoIGxvb3BpbmcgaXMgZGVzaXJlZFxuXHQgKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVBdWRpb1Nwcml0ZUxvb3Bcblx0ICogQHBhcmFtIGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVBdWRpb1Nwcml0ZUxvb3AgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZih0aGlzLl9wbGF5YmFja1Jlc291cmNlLmN1cnJlbnRUaW1lIDw9IHRoaXMuX2F1ZGlvU3ByaXRlU3RvcFRpbWUpIHtyZXR1cm47fVxuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucGF1c2UoKTtcblx0XHRpZih0aGlzLl9sb29wID09IDApIHtcblx0XHRcdHRoaXMuX2hhbmRsZVNvdW5kQ29tcGxldGUobnVsbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9uID0gMDtcblx0XHRcdHRoaXMuX2xvb3AtLTtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuY3VycmVudFRpbWUgPSB0aGlzLl9zdGFydFRpbWUgKiAwLjAwMTtcblx0XHRcdGlmKCF0aGlzLl9wYXVzZWQpIHt0aGlzLl9wbGF5YmFja1Jlc291cmNlLnBsYXkoKTt9XG5cdFx0XHR0aGlzLl9zZW5kRXZlbnQoXCJsb29wXCIpO1xuXHRcdH1cblx0fTtcblxuXHQvLyBOT1RFIHdpdGggdGhpcyBhcHByb2FjaCBhdWRpbyB3aWxsIGxvb3AgYXMgcmVsaWFibHkgYXMgdGhlIGJyb3dzZXIgYWxsb3dzXG5cdC8vIGJ1dCB3ZSBjb3VsZCBlbmQgdXAgc2VuZGluZyB0aGUgbG9vcCBldmVudCBhZnRlciBuZXh0IGxvb3AgcGxheWJhY2sgYmVnaW5zXG5cdHAuX2hhbmRsZUxvb3AgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZih0aGlzLl9sb29wID09IDApIHtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UubG9vcCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fU0VFS0VELCB0aGlzLl9sb29wSGFuZGxlciwgZmFsc2UpO1xuXHRcdH1cblx0fTtcblxuXHRwLl91cGRhdGVTdGFydFRpbWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fYXVkaW9TcHJpdGVTdG9wVGltZSA9ICh0aGlzLl9zdGFydFRpbWUgKyB0aGlzLl9kdXJhdGlvbikgKiAwLjAwMTtcblxuXHRcdGlmKHRoaXMucGxheVN0YXRlID09IGNyZWF0ZWpzLlNvdW5kLlBMQVlfU1VDQ0VFREVEKSB7XG5cdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19FTkRFRCwgdGhpcy5fZW5kZWRIYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9USU1FX1VQREFURSwgdGhpcy5fYXVkaW9TcHJpdGVFbmRIYW5kbGVyLCBmYWxzZSk7XG5cdFx0fVxuXHR9O1xuXG5cdHAuX3VwZGF0ZUR1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2F1ZGlvU3ByaXRlU3RvcFRpbWUgPSAodGhpcy5fc3RhcnRUaW1lICsgdGhpcy5fZHVyYXRpb24pICogMC4wMDE7XG5cblx0XHRpZih0aGlzLnBsYXlTdGF0ZSA9PSBjcmVhdGVqcy5Tb3VuZC5QTEFZX1NVQ0NFRURFRCkge1xuXHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fRU5ERUQsIHRoaXMuX2VuZGVkSGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fVElNRV9VUERBVEUsIHRoaXMuX2F1ZGlvU3ByaXRlRW5kSGFuZGxlciwgZmFsc2UpO1xuXHRcdH1cblx0fTtcblxuXHRwLl9zZXREdXJhdGlvbkZyb21Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZHVyYXRpb24gPSBjcmVhdGVqcy5IVE1MQXVkaW9UYWdQb29sLmdldER1cmF0aW9uKHRoaXMuc3JjKTtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlID0gbnVsbDtcblx0fTtcblxuXHRjcmVhdGVqcy5IVE1MQXVkaW9Tb3VuZEluc3RhbmNlID0gY3JlYXRlanMucHJvbW90ZShIVE1MQXVkaW9Tb3VuZEluc3RhbmNlLCBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBIVE1MQXVkaW9QbHVnaW4uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFBsYXkgc291bmRzIHVzaW5nIEhUTUwgJmx0O2F1ZGlvJmd0OyB0YWdzIGluIHRoZSBicm93c2VyLiBUaGlzIHBsdWdpbiBpcyB0aGUgc2Vjb25kIHByaW9yaXR5IHBsdWdpbiBpbnN0YWxsZWRcblx0ICogYnkgZGVmYXVsdCwgYWZ0ZXIgdGhlIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LiAgRm9yIG9sZGVyIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgaHRtbFxuXHQgKiBhdWRpbywgaW5jbHVkZSBhbmQgaW5zdGFsbCB0aGUge3sjY3Jvc3NMaW5rIFwiRmxhc2hBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0Pktub3duIEJyb3dzZXIgYW5kIE9TIGlzc3VlcyBmb3IgSFRNTCBBdWRpbzwvaDQ+XG5cdCAqIDxiPkFsbCBicm93c2VyczwvYj48YnIgLz5cblx0ICogVGVzdGluZyBoYXMgc2hvd24gaW4gYWxsIGJyb3dzZXJzIHRoZXJlIGlzIGEgbGltaXQgdG8gaG93IG1hbnkgYXVkaW8gdGFnIGluc3RhbmNlcyB5b3UgYXJlIGFsbG93ZWQuICBJZiB5b3UgZXhjZWVkXG5cdCAqIHRoaXMgbGltaXQsIHlvdSBjYW4gZXhwZWN0IHRvIHNlZSB1bnByZWRpY3RhYmxlIHJlc3VsdHMuIFBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiU291bmQuTUFYX0lOU1RBTkNFU1wifX17ey9jcm9zc0xpbmt9fSBhc1xuXHQgKiBhIGd1aWRlIHRvIGhvdyBtYW55IHRvdGFsIGF1ZGlvIHRhZ3MgeW91IGNhbiBzYWZlbHkgdXNlIGluIGFsbCBicm93c2Vycy4gIFRoaXMgaXNzdWUgaXMgcHJpbWFyaWx5IGxpbWl0ZWQgdG8gSUU5LlxuXHQgKlxuICAgICAqIDxiPklFIGh0bWwgbGltaXRhdGlvbnM8L2I+PGJyIC8+XG4gICAgICogPHVsPjxsaT5UaGVyZSBpcyBhIGRlbGF5IGluIGFwcGx5aW5nIHZvbHVtZSBjaGFuZ2VzIHRvIHRhZ3MgdGhhdCBvY2N1cnMgb25jZSBwbGF5YmFjayBpcyBzdGFydGVkLiBTbyBpZiB5b3UgaGF2ZVxuICAgICAqIG11dGVkIGFsbCBzb3VuZHMsIHRoZXkgd2lsbCBhbGwgcGxheSBkdXJpbmcgdGhpcyBkZWxheSB1bnRpbCB0aGUgbXV0ZSBhcHBsaWVzIGludGVybmFsbHkuIFRoaXMgaGFwcGVucyByZWdhcmRsZXNzIG9mXG4gICAgICogd2hlbiBvciBob3cgeW91IGFwcGx5IHRoZSB2b2x1bWUgY2hhbmdlLCBhcyB0aGUgdGFnIHNlZW1zIHRvIG5lZWQgdG8gcGxheSB0byBhcHBseSBpdC48L2xpPlxuICAgICAqIDxsaT5NUDMgZW5jb2Rpbmcgd2lsbCBub3QgYWx3YXlzIHdvcmsgZm9yIGF1ZGlvIHRhZ3MgaWYgaXQncyBub3QgZGVmYXVsdC4gIFdlJ3ZlIGZvdW5kIGRlZmF1bHQgZW5jb2Rpbmcgd2l0aFxuICAgICAqIDY0a2JwcyB3b3Jrcy48L2xpPlxuXHQgKiA8bGk+T2NjYXNpb25hbGx5IHZlcnkgc2hvcnQgc2FtcGxlcyB3aWxsIGdldCBjdXQgb2ZmLjwvbGk+XG5cdCAqIDxsaT5UaGVyZSBpcyBhIGxpbWl0IHRvIGhvdyBtYW55IGF1ZGlvIHRhZ3MgeW91IGNhbiBsb2FkIG9yIHBsYXkgYXQgb25jZSwgd2hpY2ggYXBwZWFycyB0byBiZSBkZXRlcm1pbmVkIGJ5XG5cdCAqIGhhcmR3YXJlIGFuZCBicm93c2VyIHNldHRpbmdzLiAgU2VlIHt7I2Nyb3NzTGluayBcIkhUTUxBdWRpb1BsdWdpbi5NQVhfSU5TVEFOQ0VTXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhIHNhZmUgZXN0aW1hdGUuXG5cdCAqIE5vdGUgdGhhdCBhdWRpbyBzcHJpdGVzIGNhbiBiZSB1c2VkIGFzIGEgc29sdXRpb24gdG8gdGhpcyBpc3N1ZS48L2xpPjwvdWw+XG5cdCAqXG5cdCAqIDxiPlNhZmFyaSBsaW1pdGF0aW9uczwvYj48YnIgLz5cblx0ICogPHVsPjxsaT5TYWZhcmkgcmVxdWlyZXMgUXVpY2t0aW1lIHRvIGJlIGluc3RhbGxlZCBmb3IgYXVkaW8gcGxheWJhY2suPC9saT48L3VsPlxuXHQgKlxuXHQgKiA8Yj5pT1MgNiBsaW1pdGF0aW9uczwvYj48YnIgLz5cblx0ICogPHVsPjxsaT5jYW4gb25seSBoYXZlIG9uZSAmbHQ7YXVkaW8mZ3Q7IHRhZzwvbGk+XG5cdCAqIFx0XHQ8bGk+Y2FuIG5vdCBwcmVsb2FkIG9yIGF1dG9wbGF5IHRoZSBhdWRpbzwvbGk+XG5cdCAqIFx0XHQ8bGk+Y2FuIG5vdCBjYWNoZSB0aGUgYXVkaW88L2xpPlxuXHQgKiBcdFx0PGxpPmNhbiBub3QgcGxheSB0aGUgYXVkaW8gZXhjZXB0IGluc2lkZSBhIHVzZXIgaW5pdGlhdGVkIGV2ZW50LjwvbGk+XG5cdCAqXHRcdDxsaT5Ob3RlIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fSBmb3IgaU9TICg2Kyk8L2xpPlxuXHQgKiBcdFx0PGxpPmF1ZGlvIHNwcml0ZXMgY2FuIGJlIHVzZWQgdG8gbWl0aWdhdGUgc29tZSBvZiB0aGVzZSBpc3N1ZXMgYW5kIGFyZSBzdHJvbmdseSByZWNvbW1lbmRlZCBvbiBpT1M8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiA8Yj5BbmRyb2lkIE5hdGl2ZSBCcm93c2VyIGxpbWl0YXRpb25zPC9iPjxiciAvPlxuXHQgKiA8dWw+PGxpPldlIGhhdmUgbm8gY29udHJvbCBvdmVyIGF1ZGlvIHZvbHVtZS4gT25seSB0aGUgdXNlciBjYW4gc2V0IHZvbHVtZSBvbiB0aGVpciBkZXZpY2UuPC9saT5cblx0ICogICAgICA8bGk+V2UgY2FuIG9ubHkgcGxheSBhdWRpbyBpbnNpZGUgYSB1c2VyIGV2ZW50ICh0b3VjaC9jbGljaykuICBUaGlzIGN1cnJlbnRseSBtZWFucyB5b3UgY2Fubm90IGxvb3Agc291bmQgb3IgdXNlIGEgZGVsYXkuPC9saT48L3VsPlxuXHQgKiA8Yj4gQW5kcm9pZCBDaHJvbWUgMjYuMC4xNDEwLjU4IHNwZWNpZmljIGxpbWl0YXRpb25zPC9iPjxiciAvPlxuXHQgKiA8dWw+IDxsaT5DYW4gb25seSBwbGF5IDEgc291bmQgYXQgYSB0aW1lLjwvbGk+XG5cdCAqICAgICAgPGxpPlNvdW5kIGlzIG5vdCBjYWNoZWQuPC9saT5cblx0ICogICAgICA8bGk+U291bmQgY2FuIG9ubHkgYmUgbG9hZGVkIGluIGEgdXNlciBpbml0aWF0ZWQgdG91Y2gvY2xpY2sgZXZlbnQuPC9saT5cblx0ICogICAgICA8bGk+VGhlcmUgaXMgYSBkZWxheSBiZWZvcmUgYSBzb3VuZCBpcyBwbGF5ZWQsIHByZXN1bWFibHkgd2hpbGUgdGhlIHNyYyBpcyBsb2FkZWQuPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBnZW5lcmFsIG5vdGVzIG9uIGtub3duIGlzc3Vlcy5cblx0ICpcblx0ICogQGNsYXNzIEhUTUxBdWRpb1BsdWdpblxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEhUTUxBdWRpb1BsdWdpbigpIHtcblx0XHR0aGlzLkFic3RyYWN0UGx1Z2luX2NvbnN0cnVjdG9yKCk7XG5cblxuXHQvLyBQdWJsaWMgUHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIFRoaXMgaXMgbm8gbG9uZ2VyIG5lZWRlZCBhcyB3ZSBhcmUgbm93IHVzaW5nIG9iamVjdCBwb29saW5nIGZvciB0YWdzLlxuXHRcdCAqXG5cdFx0ICogPGI+Tk9URSB0aGlzIHByb3BlcnR5IG9ubHkgZXhpc3RzIGFzIGEgbGltaXRhdGlvbiBvZiBIVE1MIGF1ZGlvLjwvYj5cblx0XHQgKiBAcHJvcGVydHkgZGVmYXVsdE51bUNoYW5uZWxzXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAyXG5cdFx0ICogQHNpbmNlIDAuNC4wXG5cdFx0ICogQGRlcHJlY2F0ZWRcblx0XHQgKi9cblx0XHR0aGlzLmRlZmF1bHROdW1DaGFubmVscyA9IDI7XG5cblx0XHR0aGlzLl9jYXBhYmlsaXRpZXMgPSBzLl9jYXBhYmlsaXRpZXM7XG5cblx0XHR0aGlzLl9sb2FkZXJDbGFzcyA9IGNyZWF0ZWpzLlNvdW5kTG9hZGVyO1xuXHRcdHRoaXMuX3NvdW5kSW5zdGFuY2VDbGFzcyA9IGNyZWF0ZWpzLkhUTUxBdWRpb1NvdW5kSW5zdGFuY2U7XG5cdH1cblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChIVE1MQXVkaW9QbHVnaW4sIGNyZWF0ZWpzLkFic3RyYWN0UGx1Z2luKTtcblx0dmFyIHMgPSBIVE1MQXVkaW9QbHVnaW47XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gU3RhdGljIFByb3BlcnRpZXNcblx0LyoqXG5cdCAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgdGhhdCBjYW4gYmUgbG9hZGVkIG9yIHBsYXllZC4gVGhpcyBpcyBhIGJyb3dzZXIgbGltaXRhdGlvbiwgcHJpbWFyaWx5IGxpbWl0ZWQgdG8gSUU5LlxuXHQgKiBUaGUgYWN0dWFsIG51bWJlciB2YXJpZXMgZnJvbSBicm93c2VyIHRvIGJyb3dzZXIgKGFuZCBpcyBsYXJnZWx5IGhhcmR3YXJlIGRlcGVuZGFudCksIGJ1dCB0aGlzIGlzIGEgc2FmZSBlc3RpbWF0ZS5cblx0ICogQXVkaW8gc3ByaXRlcyB3b3JrIGFyb3VuZCB0aGlzIGxpbWl0YXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBNQVhfSU5TVEFOQ0VTXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDMwXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuTUFYX0lOU1RBTkNFUyA9IDMwO1xuXG5cdC8qKlxuXHQgKiBFdmVudCBjb25zdGFudCBmb3IgdGhlIFwiY2FuUGxheVRocm91Z2hcIiBldmVudCBmb3IgY2xlYW5lciBjb2RlLlxuXHQgKiBAcHJvcGVydHkgX0FVRElPX1JFQURZXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGNhbnBsYXl0aHJvdWdoXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5fQVVESU9fUkVBRFkgPSBcImNhbnBsYXl0aHJvdWdoXCI7XG5cblx0LyoqXG5cdCAqIEV2ZW50IGNvbnN0YW50IGZvciB0aGUgXCJlbmRlZFwiIGV2ZW50IGZvciBjbGVhbmVyIGNvZGUuXG5cdCAqIEBwcm9wZXJ0eSBfQVVESU9fRU5ERURcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgZW5kZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLl9BVURJT19FTkRFRCA9IFwiZW5kZWRcIjtcblxuXHQvKipcblx0ICogRXZlbnQgY29uc3RhbnQgZm9yIHRoZSBcInNlZWtlZFwiIGV2ZW50IGZvciBjbGVhbmVyIGNvZGUuICBXZSB1dGlsaXplIHRoaXMgZXZlbnQgZm9yIG1haW50YWluaW5nIGxvb3AgZXZlbnRzLlxuXHQgKiBAcHJvcGVydHkgX0FVRElPX1NFRUtFRFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBzZWVrZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLl9BVURJT19TRUVLRUQgPSBcInNlZWtlZFwiO1xuXG5cdC8qKlxuXHQgKiBFdmVudCBjb25zdGFudCBmb3IgdGhlIFwic3RhbGxlZFwiIGV2ZW50IGZvciBjbGVhbmVyIGNvZGUuXG5cdCAqIEBwcm9wZXJ0eSBfQVVESU9fU1RBTExFRFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBzdGFsbGVkXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5fQVVESU9fU1RBTExFRCA9IFwic3RhbGxlZFwiO1xuXG5cdC8qKlxuXHQgKiBFdmVudCBjb25zdGFudCBmb3IgdGhlIFwidGltZXVwZGF0ZVwiIGV2ZW50IGZvciBjbGVhbmVyIGNvZGUuICBVdGlsaXplZCBmb3IgbG9vcGluZyBhdWRpbyBzcHJpdGVzLlxuXHQgKiBUaGlzIGV2ZW50IGNhbGxzYmFjayBldmVyIDE1IHRvIDI1MG1zIGFuZCBjYW4gYmUgZHJvcHBlZCBieSB0aGUgYnJvd3NlciBmb3IgcGVyZm9ybWFuY2UuXG5cdCAqIEBwcm9wZXJ0eSBfVElNRV9VUERBVEVcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgdGltZXVwZGF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuX1RJTUVfVVBEQVRFID0gXCJ0aW1ldXBkYXRlXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBjYXBhYmlsaXRpZXMgb2YgdGhlIHBsdWdpbi4gVGhpcyBpcyBnZW5lcmF0ZWQgdmlhIHRoZSB7eyNjcm9zc0xpbmsgXCJIVE1MQXVkaW9QbHVnaW4vX2dlbmVyYXRlQ2FwYWJpbGl0aWVzXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC4gUGxlYXNlIHNlZSB0aGUgU291bmQge3sjY3Jvc3NMaW5rIFwiU291bmQvZ2V0Q2FwYWJpbGl0aWVzXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBmb3IgYW4gb3ZlcnZpZXcgb2YgYWxsXG5cdCAqIG9mIHRoZSBhdmFpbGFibGUgcHJvcGVydGllcy5cblx0ICogQHByb3BlcnR5IF9jYXBhYmlsaXRpZXNcblx0ICogQHR5cGUge09iamVjdH1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9jYXBhYmlsaXRpZXMgPSBudWxsO1xuXG5cbi8vIFN0YXRpYyBNZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgdGhlIHBsdWdpbiBjYW4gYmUgdXNlZCBpbiB0aGUgY3VycmVudCBicm93c2VyL09TLiBOb3RlIHRoYXQgSFRNTCBhdWRpbyBpcyBhdmFpbGFibGUgaW4gbW9zdCBtb2Rlcm5cblx0ICogYnJvd3NlcnMsIGJ1dCBpcyBkaXNhYmxlZCBpbiBpT1MgYmVjYXVzZSBvZiBpdHMgbGltaXRhdGlvbnMuXG5cdCAqIEBtZXRob2QgaXNTdXBwb3J0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHBsdWdpbiBjYW4gYmUgaW5pdGlhbGl6ZWQuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cy5fZ2VuZXJhdGVDYXBhYmlsaXRpZXMoKTtcblx0XHRyZXR1cm4gKHMuX2NhcGFiaWxpdGllcyAhPSBudWxsKTtcblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHRoZSBjYXBhYmlsaXRpZXMgb2YgdGhlIHBsdWdpbi4gVXNlZCBpbnRlcm5hbGx5LiBQbGVhc2Ugc2VlIHRoZSBTb3VuZCBBUEkge3sjY3Jvc3NMaW5rIFwiU291bmQvZ2V0Q2FwYWJpbGl0aWVzXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCBmb3IgYW4gb3ZlcnZpZXcgb2YgcGx1Z2luIGNhcGFiaWxpdGllcy5cblx0ICogQG1ldGhvZCBfZ2VuZXJhdGVDYXBhYmlsaXRpZXNcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLl9nZW5lcmF0ZUNhcGFiaWxpdGllcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAocy5fY2FwYWJpbGl0aWVzICE9IG51bGwpIHtyZXR1cm47fVxuXHRcdHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImF1ZGlvXCIpO1xuXHRcdGlmICh0LmNhblBsYXlUeXBlID09IG51bGwpIHtyZXR1cm4gbnVsbDt9XG5cblx0XHRzLl9jYXBhYmlsaXRpZXMgPSB7XG5cdFx0XHRwYW5uaW5nOmZhbHNlLFxuXHRcdFx0dm9sdW1lOnRydWUsXG5cdFx0XHR0cmFja3M6LTFcblx0XHR9O1xuXG5cdFx0Ly8gZGV0ZXJtaW5lIHdoaWNoIGV4dGVuc2lvbnMgb3VyIGJyb3dzZXIgc3VwcG9ydHMgZm9yIHRoaXMgcGx1Z2luIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIFNvdW5kLlNVUFBPUlRFRF9FWFRFTlNJT05TXG5cdFx0dmFyIHN1cHBvcnRlZEV4dGVuc2lvbnMgPSBjcmVhdGVqcy5Tb3VuZC5TVVBQT1JURURfRVhURU5TSU9OUztcblx0XHR2YXIgZXh0ZW5zaW9uTWFwID0gY3JlYXRlanMuU291bmQuRVhURU5TSU9OX01BUDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN1cHBvcnRlZEV4dGVuc2lvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgZXh0ID0gc3VwcG9ydGVkRXh0ZW5zaW9uc1tpXTtcblx0XHRcdHZhciBwbGF5VHlwZSA9IGV4dGVuc2lvbk1hcFtleHRdIHx8IGV4dDtcblx0XHRcdHMuX2NhcGFiaWxpdGllc1tleHRdID0gKHQuY2FuUGxheVR5cGUoXCJhdWRpby9cIiArIGV4dCkgIT0gXCJub1wiICYmIHQuY2FuUGxheVR5cGUoXCJhdWRpby9cIiArIGV4dCkgIT0gXCJcIikgfHwgKHQuY2FuUGxheVR5cGUoXCJhdWRpby9cIiArIHBsYXlUeXBlKSAhPSBcIm5vXCIgJiYgdC5jYW5QbGF5VHlwZShcImF1ZGlvL1wiICsgcGxheVR5cGUpICE9IFwiXCIpO1xuXHRcdH0gIC8vIE9KUiBhbm90aGVyIHdheSB0byBkbyB0aGlzIG1pZ2h0IGJlIGNhblBsYXlUeXBlOlwibTRhXCIsIGNvZGV4OiBtcDRcblx0fTtcblxuXG4vLyBwdWJsaWMgbWV0aG9kc1xuXHRwLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGxvYWRJdGVtKSB7XG5cdFx0dmFyIHRhZyA9IGNyZWF0ZWpzLkhUTUxBdWRpb1RhZ1Bvb2wuZ2V0KGxvYWRJdGVtLnNyYyk7XG5cdFx0dmFyIGxvYWRlciA9IHRoaXMuQWJzdHJhY3RQbHVnaW5fcmVnaXN0ZXIobG9hZEl0ZW0pO1xuXHRcdGxvYWRlci5zZXRUYWcodGFnKTtcblxuXHRcdHJldHVybiBsb2FkZXI7XG5cdH07XG5cblx0cC5yZW1vdmVTb3VuZCA9IGZ1bmN0aW9uIChzcmMpIHtcblx0XHR0aGlzLkFic3RyYWN0UGx1Z2luX3JlbW92ZVNvdW5kKHNyYyk7XG5cdFx0Y3JlYXRlanMuSFRNTEF1ZGlvVGFnUG9vbC5yZW1vdmUoc3JjKTtcblx0fTtcblxuXHRwLmNyZWF0ZSA9IGZ1bmN0aW9uIChzcmMsIHN0YXJ0VGltZSwgZHVyYXRpb24pIHtcblx0XHR2YXIgc2kgPSB0aGlzLkFic3RyYWN0UGx1Z2luX2NyZWF0ZShzcmMsIHN0YXJ0VGltZSwgZHVyYXRpb24pO1xuXHRcdHNpLnNldFBsYXliYWNrUmVzb3VyY2UobnVsbCk7XG5cdFx0cmV0dXJuIHNpO1xuXHR9O1xuXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW0hUTUxBdWRpb1BsdWdpbl1cIjtcblx0fTtcblxuXHQvLyBwbHVnaW4gZG9lcyBub3Qgc3VwcG9ydCB0aGVzZVxuXHRwLnNldFZvbHVtZSA9IHAuZ2V0Vm9sdW1lID0gcC5zZXRNdXRlID0gbnVsbDtcblxuXG5cdGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbiA9IGNyZWF0ZWpzLnByb21vdGUoSFRNTEF1ZGlvUGx1Z2luLCBcIkFic3RyYWN0UGx1Z2luXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFR3ZWVuLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vLyBUT0RPOiBwb3NzaWJseSBhZGQgYSBFTkQgYWN0aW9uc01vZGUgKG9ubHkgcnVucyBhY3Rpb25zIHRoYXQgPT0gcG9zaXRpb24pP1xuLy8gVE9ETzogZXZhbHVhdGUgYSB3YXkgdG8gZGVjb3VwbGUgcGF1c2VkIGZyb20gdGljayByZWdpc3RyYXRpb24uXG5cblxuXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgVHdlZW4gaW5zdGFuY2UgdHdlZW5zIHByb3BlcnRpZXMgZm9yIGEgc2luZ2xlIHRhcmdldC4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmUgY2hhaW5lZCBmb3IgZWFzeSBjb25zdHJ1Y3Rpb24gYW5kIHNlcXVlbmNpbmc6XG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB0YXJnZXQuYWxwaGEgPSAxO1xuXHQgKlx0ICAgIGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpXG5cdCAqXHQgICAgICAgICAud2FpdCg1MDApXG5cdCAqXHQgICAgICAgICAudG8oe2FscGhhOjAsIHZpc2libGU6ZmFsc2V9LCAxMDAwKVxuXHQgKlx0ICAgICAgICAgLmNhbGwoaGFuZGxlQ29tcGxldGUpO1xuXHQgKlx0ICAgIGZ1bmN0aW9uIGhhbmRsZUNvbXBsZXRlKCkge1xuXHQgKlx0ICAgIFx0Ly9Ud2VlbiBjb21wbGV0ZVxuXHQgKlx0ICAgIH1cblx0ICpcblx0ICogTXVsdGlwbGUgdHdlZW5zIGNhbiBwb2ludCB0byB0aGUgc2FtZSBpbnN0YW5jZSwgaG93ZXZlciBpZiB0aGV5IGFmZmVjdCB0aGUgc2FtZSBwcm9wZXJ0aWVzIHRoZXJlIGNvdWxkIGJlIHVuZXhwZWN0ZWRcblx0ICogYmVoYXZpb3VyLiBUbyBzdG9wIGFsbCB0d2VlbnMgb24gYW4gb2JqZWN0LCB1c2Uge3sjY3Jvc3NMaW5rIFwiVHdlZW4vcmVtb3ZlVHdlZW5zXCJ9fXt7L2Nyb3NzTGlua319IG9yIHBhc3MgYG92ZXJyaWRlOnRydWVgXG5cdCAqIGluIHRoZSBwcm9wcyBhcmd1bWVudC5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0LCB7b3ZlcnJpZGU6dHJ1ZX0pLnRvKHt4OjEwMH0pO1xuXHQgKlxuXHQgKiBTdWJzY3JpYmUgdG8gdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2NoYW5nZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCB0byBnZXQgbm90aWZpZWQgd2hlbiBhIHByb3BlcnR5IG9mIHRoZVxuXHQgKiB0YXJnZXQgaXMgY2hhbmdlZC5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0LCB7b3ZlcnJpZGU6dHJ1ZX0pLnRvKHt4OjEwMH0pLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlQ2hhbmdlKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoZXZlbnQpIHtcblx0ICogICAgICAgICAgLy8gVGhlIHR3ZWVuIGNoYW5nZWQuXG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBTZWUgdGhlIFR3ZWVuIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2dldFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgZm9yIGFkZGl0aW9uYWwgcGFyYW0gZG9jdW1lbnRhdGlvbi5cblx0ICogQGNsYXNzIFR3ZWVuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdGhhdCB3aWxsIGhhdmUgaXRzIHByb3BlcnRpZXMgdHdlZW5lZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0byBhcHBseSB0byB0aGlzIHR3ZWVuIGluc3RhbmNlIChleC4gYHtsb29wOnRydWUsIHBhdXNlZDp0cnVlfWAuXG5cdCAqIEFsbCBwcm9wZXJ0aWVzIGRlZmF1bHQgdG8gZmFsc2UuIFN1cHBvcnRlZCBwcm9wcyBhcmU6PFVMPlxuXHQgKiAgICA8TEk+IGxvb3A6IHNldHMgdGhlIGxvb3AgcHJvcGVydHkgb24gdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IHVzZVRpY2tzOiB1c2VzIHRpY2tzIGZvciBhbGwgZHVyYXRpb25zIGluc3RlYWQgb2YgbWlsbGlzZWNvbmRzLjwvTEk+XG5cdCAqICAgIDxMST4gaWdub3JlR2xvYmFsUGF1c2U6IHNldHMgdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2lnbm9yZUdsb2JhbFBhdXNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IG9uIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiBvdmVycmlkZTogaWYgdHJ1ZSwgYFR3ZWVuLnJlbW92ZVR3ZWVucyh0YXJnZXQpYCB3aWxsIGJlIGNhbGxlZCB0byByZW1vdmUgYW55IG90aGVyIHR3ZWVucyB3aXRoIHRoZSBzYW1lIHRhcmdldC5cblx0ICogICAgPExJPiBwYXVzZWQ6IGluZGljYXRlcyB3aGV0aGVyIHRvIHN0YXJ0IHRoZSB0d2VlbiBwYXVzZWQuPC9MST5cblx0ICogICAgPExJPiBwb3NpdGlvbjogaW5kaWNhdGVzIHRoZSBpbml0aWFsIHBvc2l0aW9uIGZvciB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gb25DaGFuZ2U6IHNwZWNpZmllcyBhIGxpc3RlbmVyIGZvciB0aGUgXCJjaGFuZ2VcIiBldmVudC48L0xJPlxuXHQgKiA8L1VMPlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3BsdWdpbkRhdGFdIEFuIG9iamVjdCBjb250YWluaW5nIGRhdGEgZm9yIHVzZSBieSBpbnN0YWxsZWQgcGx1Z2lucy4gU2VlIGluZGl2aWR1YWxcblx0ICogcGx1Z2lucycgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy5cblx0ICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gVHdlZW4odGFyZ2V0LCBwcm9wcywgcGx1Z2luRGF0YSkge1xuXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIENhdXNlcyB0aGlzIHR3ZWVuIHRvIGNvbnRpbnVlIHBsYXlpbmcgd2hlbiBhIGdsb2JhbCBwYXVzZSBpcyBhY3RpdmUuIEZvciBleGFtcGxlLCBpZiBUd2VlbkpTIGlzIHVzaW5nIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fSxcblx0XHQgKiB0aGVuIHNldHRpbmcgdGhpcyB0byB0cnVlICh0aGUgZGVmYXVsdCkgd2lsbCBjYXVzZSB0aGlzIHR3ZWVuIHRvIGJlIHBhdXNlZCB3aGVuIDxjb2RlPlRpY2tlci5zZXRQYXVzZWQodHJ1ZSk8L2NvZGU+XG5cdFx0ICogaXMgY2FsbGVkLiBTZWUgdGhlIFR3ZWVuIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3RpY2tcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGZvciBtb3JlIGluZm8uIENhbiBiZSBzZXQgdmlhIHRoZSBwcm9wc1xuXHRcdCAqIHBhcmFtZXRlci5cblx0XHQgKiBAcHJvcGVydHkgaWdub3JlR2xvYmFsUGF1c2Vcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmlnbm9yZUdsb2JhbFBhdXNlID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIHRoZSB0d2VlbiB3aWxsIGxvb3Agd2hlbiBpdCByZWFjaGVzIHRoZSBlbmQuIENhbiBiZSBzZXQgdmlhIHRoZSBwcm9wcyBwYXJhbS5cblx0XHQgKiBAcHJvcGVydHkgbG9vcFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5sb29wID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNwZWNpZmllcyB0aGUgdG90YWwgZHVyYXRpb24gb2YgdGhpcyB0d2VlbiBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIHVzZVRpY2tzIGlzIHRydWUpLlxuXHRcdCAqIFRoaXMgdmFsdWUgaXMgYXV0b21hdGljYWxseSB1cGRhdGVkIGFzIHlvdSBtb2RpZnkgdGhlIHR3ZWVuLiBDaGFuZ2luZyBpdCBkaXJlY3RseSBjb3VsZCByZXN1bHQgaW4gdW5leHBlY3RlZFxuXHRcdCAqIGJlaGF2aW91ci5cblx0XHQgKiBAcHJvcGVydHkgZHVyYXRpb25cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmR1cmF0aW9uID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxsb3dzIHlvdSB0byBzcGVjaWZ5IGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQgYnkgaW5zdGFsbGVkIHBsdWdpbnMuIEVhY2ggcGx1Z2luIHVzZXMgdGhpcyBkaWZmZXJlbnRseSwgYnV0IGluIGdlbmVyYWxcblx0XHQgKiB5b3Ugc3BlY2lmeSBkYXRhIGJ5IHNldHRpbmcgaXQgdG8gYSBwcm9wZXJ0eSBvZiBwbHVnaW5EYXRhIHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgcGx1Z2luIGNsYXNzLlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICpcdG15VHdlZW4ucGx1Z2luRGF0YS5QbHVnaW5DbGFzc05hbWUgPSBkYXRhO1xuXHRcdCAqIDxici8+XG5cdFx0ICogQWxzbywgbW9zdCBwbHVnaW5zIHN1cHBvcnQgYSBwcm9wZXJ0eSB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGVtLiBUaGlzIGlzIHR5cGljYWxseSB0aGUgcGx1Z2luIGNsYXNzIG5hbWUgZm9sbG93ZWQgYnkgXCJfZW5hYmxlZFwiLjxici8+XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKlx0bXlUd2Vlbi5wbHVnaW5EYXRhLlBsdWdpbkNsYXNzTmFtZV9lbmFibGVkID0gZmFsc2U7PGJyLz5cblx0XHQgKiA8YnIvPlxuXHRcdCAqIFNvbWUgcGx1Z2lucyBhbHNvIHN0b3JlIGluc3RhbmNlIGRhdGEgaW4gdGhpcyBvYmplY3QsIHVzdWFsbHkgaW4gYSBwcm9wZXJ0eSBuYW1lZCBfUGx1Z2luQ2xhc3NOYW1lLlxuXHRcdCAqIFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgaW5kaXZpZHVhbCBwbHVnaW5zIGZvciBtb3JlIGRldGFpbHMuXG5cdFx0ICogQHByb3BlcnR5IHBsdWdpbkRhdGFcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMucGx1Z2luRGF0YSA9IHBsdWdpbkRhdGEgfHwge307XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0YXJnZXQgb2YgdGhpcyB0d2Vlbi4gVGhpcyBpcyB0aGUgb2JqZWN0IG9uIHdoaWNoIHRoZSB0d2VlbmVkIHByb3BlcnRpZXMgd2lsbCBiZSBjaGFuZ2VkLiBDaGFuZ2luZ1xuXHRcdCAqIHRoaXMgcHJvcGVydHkgYWZ0ZXIgdGhlIHR3ZWVuIGlzIGNyZWF0ZWQgd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSB0YXJnZXRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCBub3JtYWxpemVkIHBvc2l0aW9uIG9mIHRoZSB0d2Vlbi4gVGhpcyB3aWxsIGFsd2F5cyBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgZHVyYXRpb24uXG5cdFx0ICogQ2hhbmdpbmcgdGhpcyBwcm9wZXJ0eSBkaXJlY3RseSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5wb3NpdGlvbiA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGUgdHdlZW4ncyBjdXJyZW50IHBvc2l0aW9uIGlzIHdpdGhpbiBhIHBhc3NpdmUgd2FpdC5cblx0XHQgKiBAcHJvcGVydHkgcGFzc2l2ZVxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMucGFzc2l2ZSA9IGZhbHNlO1xuXHRcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wYXVzZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9jdXJRdWV1ZVByb3BzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fY3VyUXVldWVQcm9wcyA9IHt9O1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2luaXRRdWV1ZVByb3BzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5faW5pdFF1ZXVlUHJvcHMgPSB7fTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zdGVwc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fc3RlcHMgPSBbXTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9hY3Rpb25zXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9hY3Rpb25zID0gW107XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJhdyBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX3ByZXZQb3NpdGlvblxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgcG9zaXRpb24gd2l0aGluIHRoZSBjdXJyZW50IHN0ZXAuXG5cdFx0ICogQHByb3BlcnR5IF9zdGVwUG9zaXRpb25cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fc3RlcFBvc2l0aW9uID0gMDsgLy8gdGhpcyBpcyBuZWVkZWQgYnkgTW92aWVDbGlwLlxuXHRcblx0XHQvKipcblx0XHQgKiBOb3JtYWxpemVkIHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJldlBvc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcHJldlBvcyA9IC0xO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3RhcmdldFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF91c2VUaWNrc1xuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3VzZVRpY2tzID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW5pdGVkXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5faW5pdGVkID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHR3ZWVuIGlzIGN1cnJlbnRseSByZWdpc3RlcmVkIHdpdGggVHdlZW4uXG5cdFx0ICogQHByb3BlcnR5IF9yZWdpc3RlcmVkXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG5cblx0XHRpZiAocHJvcHMpIHtcblx0XHRcdHRoaXMuX3VzZVRpY2tzID0gcHJvcHMudXNlVGlja3M7XG5cdFx0XHR0aGlzLmlnbm9yZUdsb2JhbFBhdXNlID0gcHJvcHMuaWdub3JlR2xvYmFsUGF1c2U7XG5cdFx0XHR0aGlzLmxvb3AgPSBwcm9wcy5sb29wO1xuXHRcdFx0cHJvcHMub25DaGFuZ2UgJiYgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHByb3BzLm9uQ2hhbmdlKTtcblx0XHRcdGlmIChwcm9wcy5vdmVycmlkZSkgeyBUd2Vlbi5yZW1vdmVUd2VlbnModGFyZ2V0KTsgfVxuXHRcdH1cblx0XHRpZiAocHJvcHMmJnByb3BzLnBhdXNlZCkgeyB0aGlzLl9wYXVzZWQ9dHJ1ZTsgfVxuXHRcdGVsc2UgeyBjcmVhdGVqcy5Ud2Vlbi5fcmVnaXN0ZXIodGhpcyx0cnVlKTsgfVxuXHRcdGlmIChwcm9wcyYmcHJvcHMucG9zaXRpb24hPW51bGwpIHsgdGhpcy5zZXRQb3NpdGlvbihwcm9wcy5wb3NpdGlvbiwgVHdlZW4uTk9ORSk7IH1cblxuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFR3ZWVuLCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXHRcblxuLy8gc3RhdGljIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIENvbnN0YW50IGRlZmluaW5nIHRoZSBub25lIGFjdGlvbnNNb2RlIGZvciB1c2Ugd2l0aCBzZXRQb3NpdGlvbi5cblx0ICogQHByb3BlcnR5IE5PTkVcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBkZWZhdWx0IDBcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uTk9ORSA9IDA7XG5cblx0LyoqXG5cdCAqIENvbnN0YW50IGRlZmluaW5nIHRoZSBsb29wIGFjdGlvbnNNb2RlIGZvciB1c2Ugd2l0aCBzZXRQb3NpdGlvbi5cblx0ICogQHByb3BlcnR5IExPT1Bcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBkZWZhdWx0IDFcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uTE9PUCA9IDE7XG5cblx0LyoqXG5cdCAqIENvbnN0YW50IGRlZmluaW5nIHRoZSByZXZlcnNlIGFjdGlvbnNNb2RlIGZvciB1c2Ugd2l0aCBzZXRQb3NpdGlvbi5cblx0ICogQHByb3BlcnR5IFJFVkVSU0Vcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBkZWZhdWx0IDJcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uUkVWRVJTRSA9IDI7XG5cblx0LyoqXG5cdCAqIENvbnN0YW50IHJldHVybmVkIGJ5IHBsdWdpbnMgdG8gdGVsbCB0aGUgdHdlZW4gbm90IHRvIHVzZSBkZWZhdWx0IGFzc2lnbm1lbnQuXG5cdCAqIEBwcm9wZXJ0eSBJR05PUkVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLklHTk9SRSA9IHt9O1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2xpc3RlbmVyc1xuXHQgKiBAdHlwZSBBcnJheVtUd2Vlbl1cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRUd2Vlbi5fdHdlZW5zID0gW107XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfcGx1Z2luc1xuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRUd2Vlbi5fcGx1Z2lucyA9IHt9O1xuXG5cbi8vIHN0YXRpYyBtZXRob2RzXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgdHdlZW4gaW5zdGFuY2UuIFRoaXMgaXMgZnVuY3Rpb25hbGx5IGlkZW50aWNhbCB0byB1c2luZyBcIm5ldyBUd2VlbiguLi4pXCIsIGJ1dCBsb29rcyBjbGVhbmVyXG5cdCAqIHdpdGggdGhlIGNoYWluZWQgc3ludGF4IG9mIFR3ZWVuSlMuXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0dmFyIHR3ZWVuID0gY3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdGhhdCB3aWxsIGhhdmUgaXRzIHByb3BlcnRpZXMgdHdlZW5lZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0byBhcHBseSB0byB0aGlzIHR3ZWVuIGluc3RhbmNlIChleC4gYHtsb29wOnRydWUsIHBhdXNlZDp0cnVlfWApLlxuXHQgKiBBbGwgcHJvcGVydGllcyBkZWZhdWx0IHRvIGBmYWxzZWAuIFN1cHBvcnRlZCBwcm9wcyBhcmU6XG5cdCAqIDxVTD5cblx0ICogICAgPExJPiBsb29wOiBzZXRzIHRoZSBsb29wIHByb3BlcnR5IG9uIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiB1c2VUaWNrczogdXNlcyB0aWNrcyBmb3IgYWxsIGR1cmF0aW9ucyBpbnN0ZWFkIG9mIG1pbGxpc2Vjb25kcy48L0xJPlxuXHQgKiAgICA8TEk+IGlnbm9yZUdsb2JhbFBhdXNlOiBzZXRzIHRoZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9pZ25vcmVHbG9iYWxQYXVzZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBvblxuXHQgKiAgICB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gb3ZlcnJpZGU6IGlmIHRydWUsIGBjcmVhdGVqcy5Ud2Vlbi5yZW1vdmVUd2VlbnModGFyZ2V0KWAgd2lsbCBiZSBjYWxsZWQgdG8gcmVtb3ZlIGFueSBvdGhlciB0d2VlbnMgd2l0aFxuXHQgKiAgICB0aGUgc2FtZSB0YXJnZXQuXG5cdCAqICAgIDxMST4gcGF1c2VkOiBpbmRpY2F0ZXMgd2hldGhlciB0byBzdGFydCB0aGUgdHdlZW4gcGF1c2VkLjwvTEk+XG5cdCAqICAgIDxMST4gcG9zaXRpb246IGluZGljYXRlcyB0aGUgaW5pdGlhbCBwb3NpdGlvbiBmb3IgdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IG9uQ2hhbmdlOiBzcGVjaWZpZXMgYSBsaXN0ZW5lciBmb3IgdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2NoYW5nZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudC48L0xJPlxuXHQgKiA8L1VMPlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3BsdWdpbkRhdGFdIEFuIG9iamVjdCBjb250YWluaW5nIGRhdGEgZm9yIHVzZSBieSBpbnN0YWxsZWQgcGx1Z2lucy4gU2VlIGluZGl2aWR1YWwgcGx1Z2lucydcblx0ICogZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3ZlcnJpZGU9ZmFsc2VdIElmIHRydWUsIGFueSBwcmV2aW91cyB0d2VlbnMgb24gdGhlIHNhbWUgdGFyZ2V0IHdpbGwgYmUgcmVtb3ZlZC4gVGhpcyBpcyB0aGVcblx0ICogc2FtZSBhcyBjYWxsaW5nIGBUd2Vlbi5yZW1vdmVUd2VlbnModGFyZ2V0KWAuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBBIHJlZmVyZW5jZSB0byB0aGUgY3JlYXRlZCB0d2Vlbi4gQWRkaXRpb25hbCBjaGFpbmVkIHR3ZWVucywgbWV0aG9kIGNhbGxzLCBvciBjYWxsYmFja3MgY2FuIGJlXG5cdCAqIGFwcGxpZWQgdG8gdGhlIHJldHVybmVkIHR3ZWVuIGluc3RhbmNlLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5nZXQgPSBmdW5jdGlvbih0YXJnZXQsIHByb3BzLCBwbHVnaW5EYXRhLCBvdmVycmlkZSkge1xuXHRcdGlmIChvdmVycmlkZSkgeyBUd2Vlbi5yZW1vdmVUd2VlbnModGFyZ2V0KTsgfVxuXHRcdHJldHVybiBuZXcgVHdlZW4odGFyZ2V0LCBwcm9wcywgcGx1Z2luRGF0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIGFsbCB0d2VlbnMuIFRoaXMgdHlwaWNhbGx5IHVzZXMgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fSBjbGFzcywgYnV0IHlvdSBjYW4gY2FsbCBpdFxuXHQgKiBtYW51YWxseSBpZiB5b3UgcHJlZmVyIHRvIHVzZSB5b3VyIG93biBcImhlYXJ0YmVhdFwiIGltcGxlbWVudGF0aW9uLlxuXHQgKiBAbWV0aG9kIHRpY2tcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIFRoZSBjaGFuZ2UgaW4gdGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdGljay4gUmVxdWlyZWQgdW5sZXNzIGFsbCB0d2VlbnMgaGF2ZVxuXHQgKiBgdXNlVGlja3NgIHNldCB0byB0cnVlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhdXNlZCBJbmRpY2F0ZXMgd2hldGhlciBhIGdsb2JhbCBwYXVzZSBpcyBpbiBlZmZlY3QuIFR3ZWVucyB3aXRoIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2lnbm9yZUdsb2JhbFBhdXNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdpbGwgaWdub3JlIHRoaXMsIGJ1dCBhbGwgb3RoZXJzIHdpbGwgcGF1c2UgaWYgdGhpcyBpcyBgdHJ1ZWAuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLnRpY2sgPSBmdW5jdGlvbihkZWx0YSwgcGF1c2VkKSB7XG5cdFx0dmFyIHR3ZWVucyA9IFR3ZWVuLl90d2VlbnMuc2xpY2UoKTsgLy8gdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zLlxuXHRcdGZvciAodmFyIGk9dHdlZW5zLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciB0d2VlbiA9IHR3ZWVuc1tpXTtcblx0XHRcdGlmICgocGF1c2VkICYmICF0d2Vlbi5pZ25vcmVHbG9iYWxQYXVzZSkgfHwgdHdlZW4uX3BhdXNlZCkgeyBjb250aW51ZTsgfVxuXHRcdFx0dHdlZW4udGljayh0d2Vlbi5fdXNlVGlja3M/MTpkZWx0YSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGUgZXZlbnRzIHRoYXQgcmVzdWx0IGZyb20gVHdlZW4gYmVpbmcgdXNlZCBhcyBhbiBldmVudCBoYW5kbGVyLiBUaGlzIGlzIGluY2x1ZGVkIHRvIGFsbG93IFR3ZWVuIHRvIGhhbmRsZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudHMgZnJvbSB0aGUgY3JlYXRlanMge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBObyBvdGhlciBldmVudHMgYXJlIGhhbmRsZWQgaW4gVHdlZW4uXG5cdCAqIEBtZXRob2QgaGFuZGxlRXZlbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEFuIGV2ZW50IG9iamVjdCBwYXNzZWQgaW4gYnkgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlclwifX17ey9jcm9zc0xpbmt9fS4gV2lsbFxuXHQgKiB1c3VhbGx5IGJlIG9mIHR5cGUgXCJ0aWNrXCIuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4yXG5cdCAqL1xuXHRUd2Vlbi5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKGV2ZW50LnR5cGUgPT0gXCJ0aWNrXCIpIHtcblx0XHRcdHRoaXMudGljayhldmVudC5kZWx0YSwgZXZlbnQucGF1c2VkKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGV4aXN0aW5nIHR3ZWVucyBmb3IgYSB0YXJnZXQuIFRoaXMgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgbmV3IHR3ZWVucyBpZiB0aGUgYG92ZXJyaWRlYFxuXHQgKiBwcm9wZXJ0eSBpcyBgdHJ1ZWAuXG5cdCAqIEBtZXRob2QgcmVtb3ZlVHdlZW5zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdG8gcmVtb3ZlIGV4aXN0aW5nIHR3ZWVucyBmcm9tLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5yZW1vdmVUd2VlbnMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRpZiAoIXRhcmdldC50d2VlbmpzX2NvdW50KSB7IHJldHVybjsgfVxuXHRcdHZhciB0d2VlbnMgPSBUd2Vlbi5fdHdlZW5zO1xuXHRcdGZvciAodmFyIGk9dHdlZW5zLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciB0d2VlbiA9IHR3ZWVuc1tpXTtcblx0XHRcdGlmICh0d2Vlbi5fdGFyZ2V0ID09IHRhcmdldCkge1xuXHRcdFx0XHR0d2Vlbi5fcGF1c2VkID0gdHJ1ZTtcblx0XHRcdFx0dHdlZW5zLnNwbGljZShpLCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGFyZ2V0LnR3ZWVuanNfY291bnQgPSAwO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wIGFuZCByZW1vdmUgYWxsIGV4aXN0aW5nIHR3ZWVucy5cblx0ICogQG1ldGhvZCByZW1vdmVBbGxUd2VlbnNcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjFcblx0ICovXG5cdFR3ZWVuLnJlbW92ZUFsbFR3ZWVucyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0d2VlbnMgPSBUd2Vlbi5fdHdlZW5zO1xuXHRcdGZvciAodmFyIGk9IDAsIGw9dHdlZW5zLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciB0d2VlbiA9IHR3ZWVuc1tpXTtcblx0XHRcdHR3ZWVuLl9wYXVzZWQgPSB0cnVlO1xuXHRcdFx0dHdlZW4udGFyZ2V0JiYodHdlZW4udGFyZ2V0LnR3ZWVuanNfY291bnQgPSAwKTtcblx0XHR9XG5cdFx0dHdlZW5zLmxlbmd0aCA9IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgYWN0aXZlIHR3ZWVucyAoYW5kIGhvdyBtYW55KSBvbiB0aGUgdGFyZ2V0IG9iamVjdCAoaWYgc3BlY2lmaWVkKSBvciBpbiBnZW5lcmFsLlxuXHQgKiBAbWV0aG9kIGhhc0FjdGl2ZVR3ZWVuc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gW3RhcmdldF0gVGhlIHRhcmdldCB0byBjaGVjayBmb3IgYWN0aXZlIHR3ZWVucy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGluZGljYXRlXG5cdCAqIGlmIHRoZXJlIGFyZSBhbnkgYWN0aXZlIHR3ZWVucyBvbiBhbnkgdGFyZ2V0LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGVyZSBhcmUgYWN0aXZlIHR3ZWVucy5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uaGFzQWN0aXZlVHdlZW5zID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0aWYgKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0LnR3ZWVuanNfY291bnQgIT0gbnVsbCAmJiAhIXRhcmdldC50d2VlbmpzX2NvdW50OyB9XG5cdFx0cmV0dXJuIFR3ZWVuLl90d2VlbnMgJiYgISFUd2Vlbi5fdHdlZW5zLmxlbmd0aDtcblx0fTtcblxuXHQvKipcblx0ICogSW5zdGFsbHMgYSBwbHVnaW4sIHdoaWNoIGNhbiBtb2RpZnkgaG93IGNlcnRhaW4gcHJvcGVydGllcyBhcmUgaGFuZGxlZCB3aGVuIHR3ZWVuZWQuIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQ1NTUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBhbiBleGFtcGxlIG9mIGhvdyB0byB3cml0ZSBUd2VlbkpTIHBsdWdpbnMuXG5cdCAqIEBtZXRob2QgaW5zdGFsbFBsdWdpblxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gVGhlIHBsdWdpbiBjbGFzcyB0byBpbnN0YWxsXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHByb3BlcnRpZXMgQW4gYXJyYXkgb2YgcHJvcGVydGllcyB0aGF0IHRoZSBwbHVnaW4gd2lsbCBoYW5kbGUuXG5cdCAqL1xuXHRUd2Vlbi5pbnN0YWxsUGx1Z2luID0gZnVuY3Rpb24ocGx1Z2luLCBwcm9wZXJ0aWVzKSB7XG5cdFx0dmFyIHByaW9yaXR5ID0gcGx1Z2luLnByaW9yaXR5O1xuXHRcdGlmIChwcmlvcml0eSA9PSBudWxsKSB7IHBsdWdpbi5wcmlvcml0eSA9IHByaW9yaXR5ID0gMDsgfVxuXHRcdGZvciAodmFyIGk9MCxsPXByb3BlcnRpZXMubGVuZ3RoLHA9VHdlZW4uX3BsdWdpbnM7aTxsO2krKykge1xuXHRcdFx0dmFyIG4gPSBwcm9wZXJ0aWVzW2ldO1xuXHRcdFx0aWYgKCFwW25dKSB7IHBbbl0gPSBbcGx1Z2luXTsgfVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHZhciBhcnIgPSBwW25dO1xuXHRcdFx0XHRmb3IgKHZhciBqPTAsamw9YXJyLmxlbmd0aDtqPGpsO2orKykge1xuXHRcdFx0XHRcdGlmIChwcmlvcml0eSA8IGFycltqXS5wcmlvcml0eSkgeyBicmVhazsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHBbbl0uc3BsaWNlKGosMCxwbHVnaW4pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIG9yIHVucmVnaXN0ZXJzIGEgdHdlZW4gd2l0aCB0aGUgdGlja2luZyBzeXN0ZW0uXG5cdCAqIEBtZXRob2QgX3JlZ2lzdGVyXG5cdCAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuIFRoZSB0d2VlbiBpbnN0YW5jZSB0byByZWdpc3RlciBvciB1bnJlZ2lzdGVyLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIElmIGB0cnVlYCwgdGhlIHR3ZWVuIGlzIHJlZ2lzdGVyZWQuIElmIGBmYWxzZWAgdGhlIHR3ZWVuIGlzIHVucmVnaXN0ZXJlZC5cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRUd2Vlbi5fcmVnaXN0ZXIgPSBmdW5jdGlvbih0d2VlbiwgdmFsdWUpIHtcblx0XHR2YXIgdGFyZ2V0ID0gdHdlZW4uX3RhcmdldDtcblx0XHR2YXIgdHdlZW5zID0gVHdlZW4uX3R3ZWVucztcblx0XHRpZiAodmFsdWUgJiYgIXR3ZWVuLl9yZWdpc3RlcmVkKSB7XG5cdFx0XHQvLyBUT0RPOiB0aGlzIGFwcHJvYWNoIG1pZ2h0IGZhaWwgaWYgYSBkZXYgaXMgdXNpbmcgc2VhbGVkIG9iamVjdHMgaW4gRVM1XG5cdFx0XHRpZiAodGFyZ2V0KSB7IHRhcmdldC50d2VlbmpzX2NvdW50ID0gdGFyZ2V0LnR3ZWVuanNfY291bnQgPyB0YXJnZXQudHdlZW5qc19jb3VudCsxIDogMTsgfVxuXHRcdFx0dHdlZW5zLnB1c2godHdlZW4pO1xuXHRcdFx0aWYgKCFUd2Vlbi5faW5pdGVkICYmIGNyZWF0ZWpzLlRpY2tlcikgeyBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgVHdlZW4pOyBUd2Vlbi5faW5pdGVkID0gdHJ1ZTsgfVxuXHRcdH0gZWxzZSBpZiAoIXZhbHVlICYmIHR3ZWVuLl9yZWdpc3RlcmVkKSB7XG5cdFx0XHRpZiAodGFyZ2V0KSB7IHRhcmdldC50d2VlbmpzX2NvdW50LS07IH1cblx0XHRcdHZhciBpID0gdHdlZW5zLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0aWYgKHR3ZWVuc1tpXSA9PSB0d2Vlbikge1xuXHRcdFx0XHRcdHR3ZWVucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dHdlZW4uX3JlZ2lzdGVyZWQgPSB2YWx1ZTtcblx0fTtcblxuXG4vLyBldmVudHM6XG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIHR3ZWVuJ3MgcG9zaXRpb24gY2hhbmdlcy5cblx0ICogQGV2ZW50IGNoYW5nZVxuXHQgKiBAc2luY2UgMC40LjBcblx0ICoqL1xuXHRcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBRdWV1ZXMgYSB3YWl0IChlc3NlbnRpYWxseSBhbiBlbXB0eSB0d2VlbikuXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0Ly9UaGlzIHR3ZWVuIHdpbGwgd2FpdCAxcyBiZWZvcmUgYWxwaGEgaXMgZmFkZWQgdG8gMC5cblx0ICpcdFx0Y3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCkud2FpdCgxMDAwKS50byh7YWxwaGE6MH0sIDEwMDApO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHdhaXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgd2FpdCBpbiBtaWxsaXNlY29uZHMgKG9yIGluIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgdHJ1ZSkuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Bhc3NpdmVdIFR3ZWVuIHByb3BlcnRpZXMgd2lsbCBub3QgYmUgdXBkYXRlZCBkdXJpbmcgYSBwYXNzaXZlIHdhaXQuIFRoaXNcblx0ICogaXMgbW9zdGx5IHVzZWZ1bCBmb3IgdXNlIHdpdGgge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmVcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzIHRoYXQgY29udGFpbiBtdWx0aXBsZSB0d2VlbnNcblx0ICogYWZmZWN0aW5nIHRoZSBzYW1lIHRhcmdldCBhdCBkaWZmZXJlbnQgdGltZXMuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKiovXG5cdHAud2FpdCA9IGZ1bmN0aW9uKGR1cmF0aW9uLCBwYXNzaXZlKSB7XG5cdFx0aWYgKGR1cmF0aW9uID09IG51bGwgfHwgZHVyYXRpb24gPD0gMCkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHZhciBvID0gdGhpcy5fY2xvbmVQcm9wcyh0aGlzLl9jdXJRdWV1ZVByb3BzKTtcblx0XHRyZXR1cm4gdGhpcy5fYWRkU3RlcCh7ZDpkdXJhdGlvbiwgcDA6bywgZTp0aGlzLl9saW5lYXJFYXNlLCBwMTpvLCB2OnBhc3NpdmV9KTtcblx0fTtcblxuXHQvKipcblx0ICogUXVldWVzIGEgdHdlZW4gZnJvbSB0aGUgY3VycmVudCB2YWx1ZXMgdG8gdGhlIHRhcmdldCBwcm9wZXJ0aWVzLiBTZXQgZHVyYXRpb24gdG8gMCB0byBqdW1wIHRvIHRoZXNlIHZhbHVlLlxuXHQgKiBOdW1lcmljIHByb3BlcnRpZXMgd2lsbCBiZSB0d2VlbmVkIGZyb20gdGhlaXIgY3VycmVudCB2YWx1ZSBpbiB0aGUgdHdlZW4gdG8gdGhlIHRhcmdldCB2YWx1ZS4gTm9uLW51bWVyaWNcblx0ICogcHJvcGVydGllcyB3aWxsIGJlIHNldCBhdCB0aGUgZW5kIG9mIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0Y3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCkudG8oe2FscGhhOjB9LCAxMDAwKTtcblx0ICpcblx0ICogQG1ldGhvZCB0b1xuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQW4gb2JqZWN0IHNwZWNpZnlpbmcgcHJvcGVydHkgdGFyZ2V0IHZhbHVlcyBmb3IgdGhpcyB0d2VlbiAoRXguIGB7eDozMDB9YCB3b3VsZCB0d2VlbiB0aGUgeFxuXHQgKiBwcm9wZXJ0eSBvZiB0aGUgdGFyZ2V0IHRvIDMwMCkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZHVyYXRpb249MF0gVGhlIGR1cmF0aW9uIG9mIHRoZSB3YWl0IGluIG1pbGxpc2Vjb25kcyAob3IgaW4gdGlja3MgaWYgYHVzZVRpY2tzYCBpcyB0cnVlKS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vhc2U9XCJsaW5lYXJcIl0gVGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2UgZm9yIHRoaXMgdHdlZW4uIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiRWFzZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBjbGFzcyBmb3IgYSBsaXN0IG9mIGJ1aWx0LWluIGVhc2UgZnVuY3Rpb25zLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICovXG5cdHAudG8gPSBmdW5jdGlvbihwcm9wcywgZHVyYXRpb24sIGVhc2UpIHtcblx0XHRpZiAoaXNOYU4oZHVyYXRpb24pIHx8IGR1cmF0aW9uIDwgMCkgeyBkdXJhdGlvbiA9IDA7IH1cblx0XHRyZXR1cm4gdGhpcy5fYWRkU3RlcCh7ZDpkdXJhdGlvbnx8MCwgcDA6dGhpcy5fY2xvbmVQcm9wcyh0aGlzLl9jdXJRdWV1ZVByb3BzKSwgZTplYXNlLCBwMTp0aGlzLl9jbG9uZVByb3BzKHRoaXMuX2FwcGVuZFF1ZXVlUHJvcHMocHJvcHMpKX0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBRdWV1ZXMgYW4gYWN0aW9uIHRvIGNhbGwgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgIFx0Ly93b3VsZCBjYWxsIG15RnVuY3Rpb24oKSBhZnRlciAxIHNlY29uZC5cblx0ICogICBcdG15VHdlZW4ud2FpdCgxMDAwKS5jYWxsKG15RnVuY3Rpb24pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGNhbGxcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtwYXJhbXNdLiBUaGUgcGFyYW1ldGVycyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLiBJZiB0aGlzIGlzIG9taXR0ZWQsIHRoZW4gdGhlIGZ1bmN0aW9uXG5cdCAqICAgICAgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHNpbmdsZSBwYXJhbSBwb2ludGluZyB0byB0aGlzIHR3ZWVuLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXS4gVGhlIHNjb3BlIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIGluLiBJZiBvbWl0dGVkLCBpdCB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgdGFyZ2V0J3Ncblx0ICogICAgICBzY29wZS5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqL1xuXHRwLmNhbGwgPSBmdW5jdGlvbihjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuXHRcdHJldHVybiB0aGlzLl9hZGRBY3Rpb24oe2Y6Y2FsbGJhY2ssIHA6cGFyYW1zID8gcGFyYW1zIDogW3RoaXNdLCBvOnNjb3BlID8gc2NvcGUgOiB0aGlzLl90YXJnZXR9KTtcblx0fTtcblxuXHQvLyBUT0RPOiBhZGQgY2xhcmlmaWNhdGlvbiBiZXR3ZWVuIHRoaXMgYW5kIGEgMCBkdXJhdGlvbiAudG86XG5cdC8qKlxuXHQgKiBRdWV1ZXMgYW4gYWN0aW9uIHRvIHNldCB0aGUgc3BlY2lmaWVkIHByb3BzIG9uIHRoZSBzcGVjaWZpZWQgdGFyZ2V0LiBJZiB0YXJnZXQgaXMgbnVsbCwgaXQgd2lsbCB1c2UgdGhpcyB0d2VlbidzXG5cdCAqIHRhcmdldC5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0XHRteVR3ZWVuLndhaXQoMTAwMCkuc2V0KHt2aXNpYmxlOmZhbHNlfSxmb28pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgdG8gc2V0IChleC4gYHt2aXNpYmxlOmZhbHNlfWApLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3RhcmdldF0gVGhlIHRhcmdldCB0byBzZXQgdGhlIHByb3BlcnRpZXMgb24uIElmIG9taXR0ZWQsIHRoZXkgd2lsbCBiZSBzZXQgb24gdGhlIHR3ZWVuJ3MgdGFyZ2V0LlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICovXG5cdHAuc2V0ID0gZnVuY3Rpb24ocHJvcHMsIHRhcmdldCkge1xuXHRcdHJldHVybiB0aGlzLl9hZGRBY3Rpb24oe2Y6dGhpcy5fc2V0LCBvOnRoaXMsIHA6W3Byb3BzLCB0YXJnZXQgPyB0YXJnZXQgOiB0aGlzLl90YXJnZXRdfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFF1ZXVlcyBhbiBhY3Rpb24gdG8gcGxheSAodW5wYXVzZSkgdGhlIHNwZWNpZmllZCB0d2Vlbi4gVGhpcyBlbmFibGVzIHlvdSB0byBzZXF1ZW5jZSBtdWx0aXBsZSB0d2VlbnMuXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0bXlUd2Vlbi50byh7eDoxMDB9LDUwMCkucGxheShvdGhlclR3ZWVuKTtcblx0ICpcblx0ICogQG1ldGhvZCBwbGF5XG5cdCAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuIFRoZSB0d2VlbiB0byBwbGF5LlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICovXG5cdHAucGxheSA9IGZ1bmN0aW9uKHR3ZWVuKSB7XG5cdFx0aWYgKCF0d2VlbikgeyB0d2VlbiA9IHRoaXM7IH1cblx0XHRyZXR1cm4gdGhpcy5jYWxsKHR3ZWVuLnNldFBhdXNlZCwgW2ZhbHNlXSwgdHdlZW4pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBRdWV1ZXMgYW4gYWN0aW9uIHRvIHBhdXNlIHRoZSBzcGVjaWZpZWQgdHdlZW4uXG5cdCAqIEBtZXRob2QgcGF1c2Vcblx0ICogQHBhcmFtIHtUd2Vlbn0gdHdlZW4gVGhlIHR3ZWVuIHRvIHBhdXNlLiBJZiBudWxsLCBpdCBwYXVzZXMgdGhpcyB0d2Vlbi5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscylcblx0ICovXG5cdHAucGF1c2UgPSBmdW5jdGlvbih0d2Vlbikge1xuXHRcdGlmICghdHdlZW4pIHsgdHdlZW4gPSB0aGlzOyB9XG5cdFx0cmV0dXJuIHRoaXMuY2FsbCh0d2Vlbi5zZXRQYXVzZWQsIFt0cnVlXSwgdHdlZW4pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGUgdHdlZW4gdG8gYSBzcGVjaWZpZWQgcG9zaXRpb24uXG5cdCAqIEBtZXRob2Qgc2V0UG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBwb3NpdGlvbiB0byBzZWVrIHRvIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgdXNlVGlja3MgaXMgdHJ1ZSkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWN0aW9uc01vZGU9MV0gU3BlY2lmaWVzIGhvdyBhY3Rpb25zIGFyZSBoYW5kbGVkIChpZS4gY2FsbCwgc2V0LCBwbGF5LCBwYXVzZSk6XG5cdCAqIDx1bD5cblx0ICogICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHdlZW4vTk9ORTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSAoMCkgLSBydW4gbm8gYWN0aW9ucy48L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUd2Vlbi9MT09QOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319ICgxKSAtIGlmIG5ldyBwb3NpdGlvbiBpcyBsZXNzIHRoYW4gb2xkLCB0aGVuIHJ1biBhbGxcblx0ICogICAgICBhY3Rpb25zIGJldHdlZW4gb2xkIGFuZCBkdXJhdGlvbiwgdGhlbiBhbGwgYWN0aW9ucyBiZXR3ZWVuIDAgYW5kIG5ldy48L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUd2Vlbi9SRVZFUlNFOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319ICgyKSAtIGlmIG5ldyBwb3NpdGlvbiBpcyBsZXNzIHRoYW4gb2xkLCBydW4gYWxsXG5cdCAqICAgICAgYWN0aW9ucyBiZXR3ZWVuIHRoZW0gaW4gcmV2ZXJzZS48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHdlZW4gaXMgY29tcGxldGUgKGllLiB0aGUgZnVsbCB0d2VlbiBoYXMgcnVuICYge3sjY3Jvc3NMaW5rIFwiVHdlZW4vbG9vcDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpcyBgZmFsc2VgKS5cblx0ICovXG5cdHAuc2V0UG9zaXRpb24gPSBmdW5jdGlvbih2YWx1ZSwgYWN0aW9uc01vZGUpIHtcblx0XHRpZiAodmFsdWUgPCAwKSB7IHZhbHVlID0gMDsgfVxuXHRcdGlmIChhY3Rpb25zTW9kZSA9PSBudWxsKSB7IGFjdGlvbnNNb2RlID0gMTsgfVxuXG5cdFx0Ly8gbm9ybWFsaXplIHBvc2l0aW9uOlxuXHRcdHZhciB0ID0gdmFsdWU7XG5cdFx0dmFyIGVuZCA9IGZhbHNlO1xuXHRcdGlmICh0ID49IHRoaXMuZHVyYXRpb24pIHtcblx0XHRcdGlmICh0aGlzLmxvb3ApIHsgdCA9IHQldGhpcy5kdXJhdGlvbjsgfVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHQgPSB0aGlzLmR1cmF0aW9uO1xuXHRcdFx0XHRlbmQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodCA9PSB0aGlzLl9wcmV2UG9zKSB7IHJldHVybiBlbmQ7IH1cblxuXG5cdFx0dmFyIHByZXZQb3MgPSB0aGlzLl9wcmV2UG9zO1xuXHRcdHRoaXMucG9zaXRpb24gPSB0aGlzLl9wcmV2UG9zID0gdDsgLy8gc2V0IHRoaXMgaW4gYWR2YW5jZSBpbiBjYXNlIGFuIGFjdGlvbiBtb2RpZmllcyBwb3NpdGlvbi5cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSB2YWx1ZTtcblxuXHRcdC8vIGhhbmRsZSB0d2VlbnM6XG5cdFx0aWYgKHRoaXMuX3RhcmdldCkge1xuXHRcdFx0aWYgKGVuZCkge1xuXHRcdFx0XHQvLyBhZGRyZXNzZXMgcHJvYmxlbXMgd2l0aCBhbiBlbmRpbmcgemVybyBsZW5ndGggc3RlcC5cblx0XHRcdFx0dGhpcy5fdXBkYXRlVGFyZ2V0UHJvcHMobnVsbCwxKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fc3RlcHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvLyBmaW5kIG91ciBuZXcgdHdlZW4gaW5kZXg6XG5cdFx0XHRcdGZvciAodmFyIGk9MCwgbD10aGlzLl9zdGVwcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3N0ZXBzW2ldLnQgPiB0KSB7IGJyZWFrOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHN0ZXAgPSB0aGlzLl9zdGVwc1tpLTFdO1xuXHRcdFx0XHR0aGlzLl91cGRhdGVUYXJnZXRQcm9wcyhzdGVwLCh0aGlzLl9zdGVwUG9zaXRpb24gPSB0LXN0ZXAudCkvc3RlcC5kKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBydW4gYWN0aW9uczpcblx0XHRpZiAoYWN0aW9uc01vZGUgIT0gMCAmJiB0aGlzLl9hY3Rpb25zLmxlbmd0aCA+IDApIHtcblx0XHRcdGlmICh0aGlzLl91c2VUaWNrcykge1xuXHRcdFx0XHQvLyBvbmx5IHJ1biB0aGUgYWN0aW9ucyB3ZSBsYW5kZWQgb24uXG5cdFx0XHRcdHRoaXMuX3J1bkFjdGlvbnModCx0KTtcblx0XHRcdH0gZWxzZSBpZiAoYWN0aW9uc01vZGUgPT0gMSAmJiB0PHByZXZQb3MpIHtcblx0XHRcdFx0aWYgKHByZXZQb3MgIT0gdGhpcy5kdXJhdGlvbikgeyB0aGlzLl9ydW5BY3Rpb25zKHByZXZQb3MsIHRoaXMuZHVyYXRpb24pOyB9XG5cdFx0XHRcdHRoaXMuX3J1bkFjdGlvbnMoMCwgdCwgdHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9ydW5BY3Rpb25zKHByZXZQb3MsIHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChlbmQpIHsgdGhpcy5zZXRQYXVzZWQodHJ1ZSk7IH1cblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VcIik7XG5cdFx0cmV0dXJuIGVuZDtcblx0fTtcblxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhpcyB0d2VlbiBieSB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWZgdXNlVGlja3NgIGlzIGB0cnVlYCkuXG5cdCAqIFRoaXMgaXMgbm9ybWFsbHkgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIFR3ZWVuIGVuZ2luZSAodmlhIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3RpY2tcIn19e3svY3Jvc3NMaW5rfX0pLCBidXQgaXNcblx0ICogZXhwb3NlZCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCB0aWNrXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSBUaGUgdGltZSB0byBhZHZhbmNlIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApLlxuXHQgKi9cblx0cC50aWNrID0gZnVuY3Rpb24oZGVsdGEpIHtcblx0XHRpZiAodGhpcy5fcGF1c2VkKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuc2V0UG9zaXRpb24odGhpcy5fcHJldlBvc2l0aW9uK2RlbHRhKTtcblx0fTtcblxuXHQvKipcblx0ICogUGF1c2VzIG9yIHBsYXlzIHRoaXMgdHdlZW4uXG5cdCAqIEBtZXRob2Qgc2V0UGF1c2VkXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ZhbHVlPXRydWVdIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0d2VlbiBzaG91bGQgYmUgcGF1c2VkIChgdHJ1ZWApIG9yIHBsYXllZCAoYGZhbHNlYCkuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpXG5cdCAqL1xuXHRwLnNldFBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuX3BhdXNlZCA9PT0gISF2YWx1ZSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX3BhdXNlZCA9ICEhdmFsdWU7XG5cdFx0VHdlZW4uX3JlZ2lzdGVyKHRoaXMsICF2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0Ly8gdGlueSBhcGkgKHByaW1hcmlseSBmb3IgdG9vbCBvdXRwdXQpOlxuXHRwLncgPSBwLndhaXQ7XG5cdHAudCA9IHAudG87XG5cdHAuYyA9IHAuY2FsbDtcblx0cC5zID0gcC5zZXQ7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1R3ZWVuXVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlR3ZWVuIGNhbiBub3QgYmUgY2xvbmVkLlwiKVxuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF91cGRhdGVUYXJnZXRQcm9wc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gc3RlcFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmF0aW9cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fdXBkYXRlVGFyZ2V0UHJvcHMgPSBmdW5jdGlvbihzdGVwLCByYXRpbykge1xuXHRcdHZhciBwMCxwMSx2LHYwLHYxLGFycjtcblx0XHRpZiAoIXN0ZXAgJiYgcmF0aW8gPT0gMSkge1xuXHRcdFx0Ly8gR0RTOiB3aGVuIGRvZXMgdGhpcyBydW4/IEp1c3QgYXQgdGhlIHZlcnkgZW5kPyBTaG91bGRuJ3QuXG5cdFx0XHR0aGlzLnBhc3NpdmUgPSBmYWxzZTtcblx0XHRcdHAwID0gcDEgPSB0aGlzLl9jdXJRdWV1ZVByb3BzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBhc3NpdmUgPSAhIXN0ZXAudjtcblx0XHRcdGlmICh0aGlzLnBhc3NpdmUpIHsgcmV0dXJuOyB9IC8vIGRvbid0IHVwZGF0ZSBwcm9wcy5cblx0XHRcdC8vIGFwcGx5IGVhc2UgdG8gcmF0aW8uXG5cdFx0XHRpZiAoc3RlcC5lKSB7IHJhdGlvID0gc3RlcC5lKHJhdGlvLDAsMSwxKTsgfVxuXHRcdFx0cDAgPSBzdGVwLnAwO1xuXHRcdFx0cDEgPSBzdGVwLnAxO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIG4gaW4gdGhpcy5faW5pdFF1ZXVlUHJvcHMpIHtcblx0XHRcdGlmICgodjAgPSBwMFtuXSkgPT0gbnVsbCkgeyBwMFtuXSA9IHYwID0gdGhpcy5faW5pdFF1ZXVlUHJvcHNbbl07IH1cblx0XHRcdGlmICgodjEgPSBwMVtuXSkgPT0gbnVsbCkgeyBwMVtuXSA9IHYxID0gdjA7IH1cblx0XHRcdGlmICh2MCA9PSB2MSB8fCByYXRpbyA9PSAwIHx8IHJhdGlvID09IDEgfHwgKHR5cGVvZih2MCkgIT0gXCJudW1iZXJcIikpIHtcblx0XHRcdFx0Ly8gbm8gaW50ZXJwb2xhdGlvbiAtIGVpdGhlciBhdCBzdGFydCwgZW5kLCB2YWx1ZXMgZG9uJ3QgY2hhbmdlLCBvciB0aGUgdmFsdWUgaXMgbm9uLW51bWVyaWMuXG5cdFx0XHRcdHYgPSByYXRpbyA9PSAxID8gdjEgOiB2MDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHYgPSB2MCsodjEtdjApKnJhdGlvO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaWdub3JlID0gZmFsc2U7XG5cdFx0XHRpZiAoYXJyID0gVHdlZW4uX3BsdWdpbnNbbl0pIHtcblx0XHRcdFx0Zm9yICh2YXIgaT0wLGw9YXJyLmxlbmd0aDtpPGw7aSsrKSB7XG5cdFx0XHRcdFx0dmFyIHYyID0gYXJyW2ldLnR3ZWVuKHRoaXMsIG4sIHYsIHAwLCBwMSwgcmF0aW8sICEhc3RlcCYmcDA9PXAxLCAhc3RlcCk7XG5cdFx0XHRcdFx0aWYgKHYyID09IFR3ZWVuLklHTk9SRSkgeyBpZ25vcmUgPSB0cnVlOyB9XG5cdFx0XHRcdFx0ZWxzZSB7IHYgPSB2MjsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWlnbm9yZSkgeyB0aGlzLl90YXJnZXRbbl0gPSB2OyB9XG5cdFx0fVxuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3J1bkFjdGlvbnNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlbmRQb3Ncblx0ICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlU3RhcnRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fcnVuQWN0aW9ucyA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBlbmRQb3MsIGluY2x1ZGVTdGFydCkge1xuXHRcdHZhciBzUG9zID0gc3RhcnRQb3M7XG5cdFx0dmFyIGVQb3MgPSBlbmRQb3M7XG5cdFx0dmFyIGkgPSAtMTtcblx0XHR2YXIgaiA9IHRoaXMuX2FjdGlvbnMubGVuZ3RoO1xuXHRcdHZhciBrID0gMTtcblx0XHRpZiAoc3RhcnRQb3MgPiBlbmRQb3MpIHtcblx0XHRcdC8vIHJ1bm5pbmcgYmFja3dhcmRzLCBmbGlwIGV2ZXJ5dGhpbmc6XG5cdFx0XHRzUG9zID0gZW5kUG9zO1xuXHRcdFx0ZVBvcyA9IHN0YXJ0UG9zO1xuXHRcdFx0aSA9IGo7XG5cdFx0XHRqID0gayA9IC0xO1xuXHRcdH1cblx0XHR3aGlsZSAoKGkrPWspICE9IGopIHtcblx0XHRcdHZhciBhY3Rpb24gPSB0aGlzLl9hY3Rpb25zW2ldO1xuXHRcdFx0dmFyIHBvcyA9IGFjdGlvbi50O1xuXHRcdFx0aWYgKHBvcyA9PSBlUG9zIHx8IChwb3MgPiBzUG9zICYmIHBvcyA8IGVQb3MpIHx8IChpbmNsdWRlU3RhcnQgJiYgcG9zID09IHN0YXJ0UG9zKSApIHtcblx0XHRcdFx0YWN0aW9uLmYuYXBwbHkoYWN0aW9uLm8sIGFjdGlvbi5wKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2FwcGVuZFF1ZXVlUHJvcHNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fYXBwZW5kUXVldWVQcm9wcyA9IGZ1bmN0aW9uKG8pIHtcblx0XHR2YXIgYXJyLG9sZFZhbHVlLGksIGwsIGluamVjdFByb3BzO1xuXHRcdGZvciAodmFyIG4gaW4gbykge1xuXHRcdFx0aWYgKHRoaXMuX2luaXRRdWV1ZVByb3BzW25dID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0b2xkVmFsdWUgPSB0aGlzLl90YXJnZXRbbl07XG5cblx0XHRcdFx0Ly8gaW5pdCBwbHVnaW5zOlxuXHRcdFx0XHRpZiAoYXJyID0gVHdlZW4uX3BsdWdpbnNbbl0pIHtcblx0XHRcdFx0XHRmb3IgKGk9MCxsPWFyci5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0XHRcdFx0b2xkVmFsdWUgPSBhcnJbaV0uaW5pdCh0aGlzLCBuLCBvbGRWYWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2luaXRRdWV1ZVByb3BzW25dID0gdGhpcy5fY3VyUXVldWVQcm9wc1tuXSA9IChvbGRWYWx1ZT09PXVuZGVmaW5lZCkgPyBudWxsIDogb2xkVmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGRWYWx1ZSA9IHRoaXMuX2N1clF1ZXVlUHJvcHNbbl07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgbiBpbiBvKSB7XG5cdFx0XHRvbGRWYWx1ZSA9IHRoaXMuX2N1clF1ZXVlUHJvcHNbbl07XG5cdFx0XHRpZiAoYXJyID0gVHdlZW4uX3BsdWdpbnNbbl0pIHtcblx0XHRcdFx0aW5qZWN0UHJvcHMgPSBpbmplY3RQcm9wc3x8e307XG5cdFx0XHRcdGZvciAoaT0wLCBsPWFyci5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0XHRcdC8vIFRPRE86IHJlbW92ZSB0aGUgY2hlY2sgZm9yIC5zdGVwIGluIHRoZSBuZXh0IHZlcnNpb24uIEl0J3MgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cdFx0XHRcdFx0aWYgKGFycltpXS5zdGVwKSB7IGFycltpXS5zdGVwKHRoaXMsIG4sIG9sZFZhbHVlLCBvW25dLCBpbmplY3RQcm9wcyk7IH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY3VyUXVldWVQcm9wc1tuXSA9IG9bbl07XG5cdFx0fVxuXHRcdGlmIChpbmplY3RQcm9wcykgeyB0aGlzLl9hcHBlbmRRdWV1ZVByb3BzKGluamVjdFByb3BzKTsgfVxuXHRcdHJldHVybiB0aGlzLl9jdXJRdWV1ZVByb3BzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jbG9uZVByb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9jbG9uZVByb3BzID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHR2YXIgbyA9IHt9O1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHtcblx0XHRcdG9bbl0gPSBwcm9wc1tuXTtcblx0XHR9XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2FkZFN0ZXBcblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fYWRkU3RlcCA9IGZ1bmN0aW9uKG8pIHtcblx0XHRpZiAoby5kID4gMCkge1xuXHRcdFx0dGhpcy5fc3RlcHMucHVzaChvKTtcblx0XHRcdG8udCA9IHRoaXMuZHVyYXRpb247XG5cdFx0XHR0aGlzLmR1cmF0aW9uICs9IG8uZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2FkZEFjdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9hZGRBY3Rpb24gPSBmdW5jdGlvbihvKSB7XG5cdFx0by50ID0gdGhpcy5kdXJhdGlvbjtcblx0XHR0aGlzLl9hY3Rpb25zLnB1c2gobyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3NldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2V0ID0gZnVuY3Rpb24ocHJvcHMsIG8pIHtcblx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7XG5cdFx0XHRvW25dID0gcHJvcHNbbl07XG5cdFx0fVxuXHR9O1xuXG5cdGNyZWF0ZWpzLlR3ZWVuID0gY3JlYXRlanMucHJvbW90ZShUd2VlbiwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUaW1lbGluZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cbi8vIGNvbnN0cnVjdG9yXHRcblx0LyoqXG5cdCAqIFRoZSBUaW1lbGluZSBjbGFzcyBzeW5jaHJvbml6ZXMgbXVsdGlwbGUgdHdlZW5zIGFuZCBhbGxvd3MgdGhlbSB0byBiZSBjb250cm9sbGVkIGFzIGEgZ3JvdXAuIFBsZWFzZSBub3RlIHRoYXQgaWYgYVxuXHQgKiB0aW1lbGluZSBpcyBsb29waW5nLCB0aGUgdHdlZW5zIG9uIGl0IG1heSBhcHBlYXIgdG8gbG9vcCBldmVuIGlmIHRoZSBcImxvb3BcIiBwcm9wZXJ0eSBvZiB0aGUgdHdlZW4gaXMgZmFsc2UuXG5cdCAqIEBjbGFzcyBUaW1lbGluZVxuXHQgKiBAcGFyYW0ge0FycmF5fSB0d2VlbnMgQW4gYXJyYXkgb2YgVHdlZW5zIHRvIGFkZCB0byB0aGlzIHRpbWVsaW5lLiBTZWUge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvYWRkVHdlZW5cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIG1vcmUgaW5mby5cblx0ICogQHBhcmFtIHtPYmplY3R9IGxhYmVscyBBbiBvYmplY3QgZGVmaW5pbmcgbGFiZWxzIGZvciB1c2luZyB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fS97eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9nb3RvQW5kU3RvcFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL3NldExhYmVsc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdG8gYXBwbHkgdG8gdGhpcyB0d2VlbiBpbnN0YW5jZSAoZXguIGB7bG9vcDp0cnVlfWApLiBBbGwgcHJvcGVydGllc1xuXHQgKiBkZWZhdWx0IHRvIGZhbHNlLiBTdXBwb3J0ZWQgcHJvcHMgYXJlOjxVTD5cblx0ICogICAgPExJPiBsb29wOiBzZXRzIHRoZSBsb29wIHByb3BlcnR5IG9uIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiB1c2VUaWNrczogdXNlcyB0aWNrcyBmb3IgYWxsIGR1cmF0aW9ucyBpbnN0ZWFkIG9mIG1pbGxpc2Vjb25kcy48L0xJPlxuXHQgKiAgICA8TEk+IGlnbm9yZUdsb2JhbFBhdXNlOiBzZXRzIHRoZSBpZ25vcmVHbG9iYWxQYXVzZSBwcm9wZXJ0eSBvbiB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gcGF1c2VkOiBpbmRpY2F0ZXMgd2hldGhlciB0byBzdGFydCB0aGUgdHdlZW4gcGF1c2VkLjwvTEk+XG5cdCAqICAgIDxMST4gcG9zaXRpb246IGluZGljYXRlcyB0aGUgaW5pdGlhbCBwb3NpdGlvbiBmb3IgdGhpcyB0aW1lbGluZS48L0xJPlxuXHQgKiAgICA8TEk+IG9uQ2hhbmdlOiBzcGVjaWZpZXMgYSBsaXN0ZW5lciB0byBhZGQgZm9yIHRoZSB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9jaGFuZ2U6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQuPC9MST5cblx0ICogPC9VTD5cblx0ICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIFRpbWVsaW5lKHR3ZWVucywgbGFiZWxzLCBwcm9wcykge1xuXHRcdHRoaXMuRXZlbnREaXNwYXRjaGVyX2NvbnN0cnVjdG9yKCk7XG5cblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQ2F1c2VzIHRoaXMgdGltZWxpbmUgdG8gY29udGludWUgcGxheWluZyB3aGVuIGEgZ2xvYmFsIHBhdXNlIGlzIGFjdGl2ZS5cblx0XHQgKiBAcHJvcGVydHkgaWdub3JlR2xvYmFsUGF1c2Vcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICoqL1xuXHRcdHRoaXMuaWdub3JlR2xvYmFsUGF1c2UgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0b3RhbCBkdXJhdGlvbiBvZiB0aGlzIHRpbWVsaW5lIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzIGBpcyBgdHJ1ZWApLiBUaGlzIHZhbHVlIGlzIHVzdWFsbHlcblx0XHQgKiBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgYXMgeW91IG1vZGlmeSB0aGUgdGltZWxpbmUuIFNlZSB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS91cGRhdGVEdXJhdGlvblwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBkdXJhdGlvblxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5kdXJhdGlvbiA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBJZiB0cnVlLCB0aGUgdGltZWxpbmUgd2lsbCBsb29wIHdoZW4gaXQgcmVhY2hlcyB0aGUgZW5kLiBDYW4gYmUgc2V0IHZpYSB0aGUgcHJvcHMgcGFyYW0uXG5cdFx0ICogQHByb3BlcnR5IGxvb3Bcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICoqL1xuXHRcdHRoaXMubG9vcCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgbm9ybWFsaXplZCBwb3NpdGlvbiBvZiB0aGUgdGltZWxpbmUuIFRoaXMgd2lsbCBhbHdheXMgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZHVyYXRpb246cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQ2hhbmdpbmcgdGhpcyBwcm9wZXJ0eSBkaXJlY3RseSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLnBvc2l0aW9uID0gbnVsbDtcblxuXHRcdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3BhdXNlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF90d2VlbnNcblx0XHQgKiBAdHlwZSBBcnJheVtUd2Vlbl1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3R3ZWVucyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9sYWJlbHNcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2xhYmVscyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2xhYmVsTGlzdFxuXHRcdCAqIEB0eXBlIEFycmF5W09iamVjdF1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2xhYmVsTGlzdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3ByZXZQb3NpdGlvblxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3ByZXZQb3NpdGlvbiA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3ByZXZQb3Ncblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAtMVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fcHJldlBvcyA9IC0xO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF91c2VUaWNrc1xuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fdXNlVGlja3MgPSBmYWxzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGltZWxpbmUgaXMgY3VycmVudGx5IHJlZ2lzdGVyZWQgd2l0aCBUd2Vlbi5cblx0XHQgKiBAcHJvcGVydHkgX3JlZ2lzdGVyZWRcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9yZWdpc3RlcmVkID0gZmFsc2U7XG5cblxuXHRcdGlmIChwcm9wcykge1xuXHRcdFx0dGhpcy5fdXNlVGlja3MgPSBwcm9wcy51c2VUaWNrcztcblx0XHRcdHRoaXMubG9vcCA9IHByb3BzLmxvb3A7XG5cdFx0XHR0aGlzLmlnbm9yZUdsb2JhbFBhdXNlID0gcHJvcHMuaWdub3JlR2xvYmFsUGF1c2U7XG5cdFx0XHRwcm9wcy5vbkNoYW5nZSYmdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHByb3BzLm9uQ2hhbmdlKTtcblx0XHR9XG5cdFx0aWYgKHR3ZWVucykgeyB0aGlzLmFkZFR3ZWVuLmFwcGx5KHRoaXMsIHR3ZWVucyk7IH1cblx0XHR0aGlzLnNldExhYmVscyhsYWJlbHMpO1xuXHRcdGlmIChwcm9wcyYmcHJvcHMucGF1c2VkKSB7IHRoaXMuX3BhdXNlZD10cnVlOyB9XG5cdFx0ZWxzZSB7IGNyZWF0ZWpzLlR3ZWVuLl9yZWdpc3Rlcih0aGlzLHRydWUpOyB9XG5cdFx0aWYgKHByb3BzJiZwcm9wcy5wb3NpdGlvbiE9bnVsbCkgeyB0aGlzLnNldFBvc2l0aW9uKHByb3BzLnBvc2l0aW9uLCBjcmVhdGVqcy5Ud2Vlbi5OT05FKTsgfVxuXHRcdFxuXHR9O1xuXHRcblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoVGltZWxpbmUsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblx0XG4vLyBldmVudHM6XG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIHRpbWVsaW5lJ3MgcG9zaXRpb24gY2hhbmdlcy5cblx0ICogQGV2ZW50IGNoYW5nZVxuXHQgKiBAc2luY2UgMC41LjBcblx0ICoqL1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQWRkcyBvbmUgb3IgbW9yZSB0d2VlbnMgKG9yIHRpbWVsaW5lcykgdG8gdGhpcyB0aW1lbGluZS4gVGhlIHR3ZWVucyB3aWxsIGJlIHBhdXNlZCAodG8gcmVtb3ZlIHRoZW0gZnJvbSB0aGVcblx0ICogbm9ybWFsIHRpY2tpbmcgc3lzdGVtKSBhbmQgbWFuYWdlZCBieSB0aGlzIHRpbWVsaW5lLiBBZGRpbmcgYSB0d2VlbiB0byBtdWx0aXBsZSB0aW1lbGluZXMgd2lsbCByZXN1bHQgaW5cblx0ICogdW5leHBlY3RlZCBiZWhhdmlvdXIuXG5cdCAqIEBtZXRob2QgYWRkVHdlZW5cblx0ICogQHBhcmFtIHtUd2Vlbn0gLi4udHdlZW4gVGhlIHR3ZWVuKHMpIHRvIGFkZC4gQWNjZXB0cyBtdWx0aXBsZSBhcmd1bWVudHMuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGUgZmlyc3QgdHdlZW4gdGhhdCB3YXMgcGFzc2VkIGluLlxuXHQgKiovXG5cdHAuYWRkVHdlZW4gPSBmdW5jdGlvbih0d2Vlbikge1xuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZiAobCA+IDEpIHtcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHsgdGhpcy5hZGRUd2Vlbihhcmd1bWVudHNbaV0pOyB9XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzWzBdO1xuXHRcdH0gZWxzZSBpZiAobCA9PSAwKSB7IHJldHVybiBudWxsOyB9XG5cdFx0dGhpcy5yZW1vdmVUd2Vlbih0d2Vlbik7XG5cdFx0dGhpcy5fdHdlZW5zLnB1c2godHdlZW4pO1xuXHRcdHR3ZWVuLnNldFBhdXNlZCh0cnVlKTtcblx0XHR0d2Vlbi5fcGF1c2VkID0gZmFsc2U7XG5cdFx0dHdlZW4uX3VzZVRpY2tzID0gdGhpcy5fdXNlVGlja3M7XG5cdFx0aWYgKHR3ZWVuLmR1cmF0aW9uID4gdGhpcy5kdXJhdGlvbikgeyB0aGlzLmR1cmF0aW9uID0gdHdlZW4uZHVyYXRpb247IH1cblx0XHRpZiAodGhpcy5fcHJldlBvcyA+PSAwKSB7IHR3ZWVuLnNldFBvc2l0aW9uKHRoaXMuX3ByZXZQb3MsIGNyZWF0ZWpzLlR3ZWVuLk5PTkUpOyB9XG5cdFx0cmV0dXJuIHR3ZWVuO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIG9uZSBvciBtb3JlIHR3ZWVucyBmcm9tIHRoaXMgdGltZWxpbmUuXG5cdCAqIEBtZXRob2QgcmVtb3ZlVHdlZW5cblx0ICogQHBhcmFtIHtUd2Vlbn0gLi4udHdlZW4gVGhlIHR3ZWVuKHMpIHRvIHJlbW92ZS4gQWNjZXB0cyBtdWx0aXBsZSBhcmd1bWVudHMuXG5cdCAqIEByZXR1cm4gQm9vbGVhbiBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgb2YgdGhlIHR3ZWVucyB3ZXJlIHN1Y2Nlc3NmdWxseSByZW1vdmVkLlxuXHQgKiovXG5cdHAucmVtb3ZlVHdlZW4gPSBmdW5jdGlvbih0d2Vlbikge1xuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZiAobCA+IDEpIHtcblx0XHRcdHZhciBnb29kID0gdHJ1ZTtcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHsgZ29vZCA9IGdvb2QgJiYgdGhpcy5yZW1vdmVUd2Vlbihhcmd1bWVudHNbaV0pOyB9XG5cdFx0XHRyZXR1cm4gZ29vZDtcblx0XHR9IGVsc2UgaWYgKGwgPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdHZhciB0d2VlbnMgPSB0aGlzLl90d2VlbnM7XG5cdFx0dmFyIGkgPSB0d2VlbnMubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGlmICh0d2VlbnNbaV0gPT0gdHdlZW4pIHtcblx0XHRcdFx0dHdlZW5zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0aWYgKHR3ZWVuLmR1cmF0aW9uID49IHRoaXMuZHVyYXRpb24pIHsgdGhpcy51cGRhdGVEdXJhdGlvbigpOyB9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBsYWJlbCB0aGF0IGNhbiBiZSB1c2VkIHdpdGgge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0ve3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgYWRkTGFiZWxcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIFRoZSBsYWJlbCBuYW1lLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRoaXMgbGFiZWwgcmVwcmVzZW50cy5cblx0ICoqL1xuXHRwLmFkZExhYmVsID0gZnVuY3Rpb24obGFiZWwsIHBvc2l0aW9uKSB7XG5cdFx0dGhpcy5fbGFiZWxzW2xhYmVsXSA9IHBvc2l0aW9uO1xuXHRcdHZhciBsaXN0ID0gdGhpcy5fbGFiZWxMaXN0O1xuXHRcdGlmIChsaXN0KSB7XG5cdFx0XHRmb3IgKHZhciBpPSAwLGw9bGlzdC5sZW5ndGg7IGk8bDsgaSsrKSB7IGlmIChwb3NpdGlvbiA8IGxpc3RbaV0ucG9zaXRpb24pIHsgYnJlYWs7IH0gfVxuXHRcdFx0bGlzdC5zcGxpY2UoaSwgMCwge2xhYmVsOmxhYmVsLCBwb3NpdGlvbjpwb3NpdGlvbn0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGVmaW5lcyBsYWJlbHMgZm9yIHVzZSB3aXRoIGdvdG9BbmRQbGF5L1N0b3AuIE92ZXJ3cml0ZXMgYW55IHByZXZpb3VzbHkgc2V0IGxhYmVscy5cblx0ICogQG1ldGhvZCBzZXRMYWJlbHNcblx0ICogQHBhcmFtIHtPYmplY3R9IG8gQW4gb2JqZWN0IGRlZmluaW5nIGxhYmVscyBmb3IgdXNpbmcge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0ve3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaW4gdGhlIGZvcm0gYHtsYWJlbE5hbWU6dGltZX1gIHdoZXJlIHRpbWUgaXMgaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIGB0cnVlYCkuXG5cdCAqKi9cblx0cC5zZXRMYWJlbHMgPSBmdW5jdGlvbihvKSB7XG5cdFx0dGhpcy5fbGFiZWxzID0gbyA/ICBvIDoge307XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzb3J0ZWQgbGlzdCBvZiB0aGUgbGFiZWxzIGRlZmluZWQgb24gdGhpcyB0aW1lbGluZS5cblx0ICogQG1ldGhvZCBnZXRMYWJlbHNcblx0ICogQHJldHVybiB7QXJyYXlbT2JqZWN0XX0gQSBzb3J0ZWQgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGxhYmVsIGFuZCBwb3NpdGlvbiBwcm9wZXJ0aWVzLlxuXHQgKiovXG5cdHAuZ2V0TGFiZWxzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxpc3QgPSB0aGlzLl9sYWJlbExpc3Q7XG5cdFx0aWYgKCFsaXN0KSB7XG5cdFx0XHRsaXN0ID0gdGhpcy5fbGFiZWxMaXN0ID0gW107XG5cdFx0XHR2YXIgbGFiZWxzID0gdGhpcy5fbGFiZWxzO1xuXHRcdFx0Zm9yICh2YXIgbiBpbiBsYWJlbHMpIHtcblx0XHRcdFx0bGlzdC5wdXNoKHtsYWJlbDpuLCBwb3NpdGlvbjpsYWJlbHNbbl19KTtcblx0XHRcdH1cblx0XHRcdGxpc3Quc29ydChmdW5jdGlvbiAoYSxiKSB7IHJldHVybiBhLnBvc2l0aW9uLSBiLnBvc2l0aW9uOyB9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGxpc3Q7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGxhYmVsIG9uIG9yIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY3VycmVudCBwb3NpdGlvbi4gRm9yIGV4YW1wbGUsIGdpdmVuIGEgdGltZWxpbmUgd2l0aFxuXHQgKiB0d28gbGFiZWxzLCBcImZpcnN0XCIgb24gZnJhbWUgaW5kZXggNCwgYW5kIFwic2Vjb25kXCIgb24gZnJhbWUgOCwgZ2V0Q3VycmVudExhYmVsIHdvdWxkIHJldHVybjpcblx0ICogPFVMPlxuXHQgKiBcdFx0PExJPm51bGwgaWYgdGhlIGN1cnJlbnQgcG9zaXRpb24gaXMgMi48L0xJPlxuXHQgKiBcdFx0PExJPlwiZmlyc3RcIiBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyA0LjwvTEk+XG5cdCAqIFx0XHQ8TEk+XCJmaXJzdFwiIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9uIGlzIDcuPC9MST5cblx0ICogXHRcdDxMST5cInNlY29uZFwiIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9uIGlzIDE1LjwvTEk+XG5cdCAqIDwvVUw+XG5cdCAqIEBtZXRob2QgZ2V0Q3VycmVudExhYmVsXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgbGFiZWwgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBsYWJlbFxuXHQgKiovXG5cdHAuZ2V0Q3VycmVudExhYmVsID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG5cdFx0dmFyIHBvcyA9IHRoaXMucG9zaXRpb247XG5cdFx0dmFyIGwgPSBsYWJlbHMubGVuZ3RoO1xuXHRcdGlmIChsKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaTxsOyBpKyspIHsgaWYgKHBvcyA8IGxhYmVsc1tpXS5wb3NpdGlvbikgeyBicmVhazsgfSB9XG5cdFx0XHRyZXR1cm4gKGk9PTApID8gbnVsbCA6IGxhYmVsc1tpLTFdLmxhYmVsO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogVW5wYXVzZXMgdGhpcyB0aW1lbGluZSBhbmQganVtcHMgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBvciBsYWJlbC5cblx0ICogQG1ldGhvZCBnb3RvQW5kUGxheVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBUaGUgcG9zaXRpb24gaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIGB0cnVlYClcblx0ICogb3IgbGFiZWwgdG8ganVtcCB0by5cblx0ICoqL1xuXHRwLmdvdG9BbmRQbGF5ID0gZnVuY3Rpb24ocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0dGhpcy5zZXRQYXVzZWQoZmFsc2UpO1xuXHRcdHRoaXMuX2dvdG8ocG9zaXRpb25PckxhYmVsKTtcblx0fTtcblxuXHQvKipcblx0ICogUGF1c2VzIHRoaXMgdGltZWxpbmUgYW5kIGp1bXBzIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gb3IgbGFiZWwuXG5cdCAqIEBtZXRob2QgZ290b0FuZFN0b3Bcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwb3NpdGlvbk9yTGFiZWwgVGhlIHBvc2l0aW9uIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApIG9yIGxhYmVsXG5cdCAqIHRvIGp1bXAgdG8uXG5cdCAqKi9cblx0cC5nb3RvQW5kU3RvcCA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHRoaXMuc2V0UGF1c2VkKHRydWUpO1xuXHRcdHRoaXMuX2dvdG8ocG9zaXRpb25PckxhYmVsKTtcblx0fTtcblxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhlIHRpbWVsaW5lIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXG5cdCAqIEBtZXRob2Qgc2V0UG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBwb3NpdGlvbiB0byBzZWVrIHRvIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FjdGlvbnNNb2RlXSBwYXJhbWV0ZXIgc3BlY2lmeWluZyBob3cgYWN0aW9ucyBhcmUgaGFuZGxlZC4gU2VlIHRoZSBUd2VlbiB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9zZXRQb3NpdGlvblwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QgZm9yIG1vcmUgZGV0YWlscy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRpbWVsaW5lIGlzIGNvbXBsZXRlIChpZS4gdGhlIGZ1bGwgdGltZWxpbmUgaGFzIHJ1biAmIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2xvb3A6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaXMgYGZhbHNlYCkuXG5cdCAqKi9cblx0cC5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHZhbHVlLCBhY3Rpb25zTW9kZSkge1xuXHRcdHZhciB0ID0gdGhpcy5fY2FsY1Bvc2l0aW9uKHZhbHVlKTtcblx0XHR2YXIgZW5kID0gIXRoaXMubG9vcCAmJiB2YWx1ZSA+PSB0aGlzLmR1cmF0aW9uO1xuXHRcdGlmICh0ID09IHRoaXMuX3ByZXZQb3MpIHsgcmV0dXJuIGVuZDsgfVxuXHRcdHRoaXMuX3ByZXZQb3NpdGlvbiA9IHZhbHVlO1xuXHRcdHRoaXMucG9zaXRpb24gPSB0aGlzLl9wcmV2UG9zID0gdDsgLy8gaW4gY2FzZSBhbiBhY3Rpb24gY2hhbmdlcyB0aGUgY3VycmVudCBmcmFtZS5cblx0XHRmb3IgKHZhciBpPTAsIGw9dGhpcy5fdHdlZW5zLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHRoaXMuX3R3ZWVuc1tpXS5zZXRQb3NpdGlvbih0LCBhY3Rpb25zTW9kZSk7XG5cdFx0XHRpZiAodCAhPSB0aGlzLl9wcmV2UG9zKSB7IHJldHVybiBmYWxzZTsgfSAvLyBhbiBhY3Rpb24gY2hhbmdlZCB0aGlzIHRpbWVsaW5lJ3MgcG9zaXRpb24uXG5cdFx0fVxuXHRcdGlmIChlbmQpIHsgdGhpcy5zZXRQYXVzZWQodHJ1ZSk7IH1cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VcIik7XG5cdFx0cmV0dXJuIGVuZDtcblx0fTtcblxuXHQvKipcblx0ICogUGF1c2VzIG9yIHBsYXlzIHRoaXMgdGltZWxpbmUuXG5cdCAqIEBtZXRob2Qgc2V0UGF1c2VkXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHR3ZWVuIHNob3VsZCBiZSBwYXVzZWQgKGB0cnVlYCkgb3IgcGxheWVkIChgZmFsc2VgKS5cblx0ICoqL1xuXHRwLnNldFBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpcy5fcGF1c2VkID0gISF2YWx1ZTsgXG5cdFx0Y3JlYXRlanMuVHdlZW4uX3JlZ2lzdGVyKHRoaXMsICF2YWx1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlY2FsY3VsYXRlcyB0aGUgZHVyYXRpb24gb2YgdGhlIHRpbWVsaW5lLiBUaGUgZHVyYXRpb24gaXMgYXV0b21hdGljYWxseSB1cGRhdGVkIHdoZW4gdHdlZW5zIGFyZSBhZGRlZCBvciByZW1vdmVkLFxuXHQgKiBidXQgdGhpcyBtZXRob2QgaXMgdXNlZnVsIGlmIHlvdSBtb2RpZnkgYSB0d2VlbiBhZnRlciBpdCB3YXMgYWRkZWQgdG8gdGhlIHRpbWVsaW5lLlxuXHQgKiBAbWV0aG9kIHVwZGF0ZUR1cmF0aW9uXG5cdCAqKi9cblx0cC51cGRhdGVEdXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZHVyYXRpb24gPSAwO1xuXHRcdGZvciAodmFyIGk9MCxsPXRoaXMuX3R3ZWVucy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl90d2VlbnNbaV07XG5cdFx0XHRpZiAodHdlZW4uZHVyYXRpb24gPiB0aGlzLmR1cmF0aW9uKSB7IHRoaXMuZHVyYXRpb24gPSB0d2Vlbi5kdXJhdGlvbjsgfVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhpcyB0aW1lbGluZSBieSB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApLlxuXHQgKiBUaGlzIGlzIG5vcm1hbGx5IGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBUd2VlbiBlbmdpbmUgKHZpYSB0aGUge3sjY3Jvc3NMaW5rIFwiVHdlZW4vdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCksIGJ1dCBpcyBleHBvc2VkIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIHRpY2tcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIFRoZSB0aW1lIHRvIGFkdmFuY2UgaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiB1c2VUaWNrcyBpcyB0cnVlKS5cblx0ICoqL1xuXHRwLnRpY2sgPSBmdW5jdGlvbihkZWx0YSkge1xuXHRcdHRoaXMuc2V0UG9zaXRpb24odGhpcy5fcHJldlBvc2l0aW9uK2RlbHRhKTtcblx0fTtcblxuXHQvKipcblx0ICogSWYgYSBudW1lcmljIHBvc2l0aW9uIGlzIHBhc3NlZCwgaXQgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLiBJZiBhIHN0cmluZyBpcyBwYXNzZWQsIHRoZSBwb3NpdGlvbiBvZiB0aGVcblx0ICogY29ycmVzcG9uZGluZyBmcmFtZSBsYWJlbCB3aWxsIGJlIHJldHVybmVkLCBvciBgbnVsbGAgaWYgYSBtYXRjaGluZyBsYWJlbCBpcyBub3QgZGVmaW5lZC5cblx0ICogQG1ldGhvZCByZXNvbHZlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gcG9zaXRpb25PckxhYmVsIEEgbnVtZXJpYyBwb3NpdGlvbiB2YWx1ZSBvciBsYWJlbCBzdHJpbmcuXG5cdCAqKi9cblx0cC5yZXNvbHZlID0gZnVuY3Rpb24ocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0dmFyIHBvcyA9IE51bWJlcihwb3NpdGlvbk9yTGFiZWwpO1xuXHRcdGlmIChpc05hTihwb3MpKSB7IHBvcyA9IHRoaXMuX2xhYmVsc1twb3NpdGlvbk9yTGFiZWxdOyB9XG5cdFx0cmV0dXJuIHBvcztcblx0fTtcblxuXHQvKipcblx0KiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQqIEBtZXRob2QgdG9TdHJpbmdcblx0KiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0KiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbVGltZWxpbmVdXCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlRpbWVsaW5lIGNhbiBub3QgYmUgY2xvbmVkLlwiKVxuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nb3RvXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBwb3NpdGlvbk9yTGFiZWxcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dvdG8gPSBmdW5jdGlvbihwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5yZXNvbHZlKHBvc2l0aW9uT3JMYWJlbCk7XG5cdFx0aWYgKHBvcyAhPSBudWxsKSB7IHRoaXMuc2V0UG9zaXRpb24ocG9zKTsgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2NhbGNQb3NpdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fY2FsY1Bvc2l0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPCAwKSB7IHJldHVybiAwOyB9XG5cdFx0aWYgKHZhbHVlIDwgdGhpcy5kdXJhdGlvbikgeyByZXR1cm4gdmFsdWU7IH1cblx0XHRyZXR1cm4gdGhpcy5sb29wID8gdmFsdWUldGhpcy5kdXJhdGlvbiA6IHRoaXMuZHVyYXRpb247XG5cdH07XG5cblx0Y3JlYXRlanMuVGltZWxpbmUgPSBjcmVhdGVqcy5wcm9tb3RlKFRpbWVsaW5lLCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEVhc2UuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBFYXNlIGNsYXNzIHByb3ZpZGVzIGEgY29sbGVjdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zIGZvciB1c2Ugd2l0aCBUd2VlbkpTLiBJdCBkb2VzIG5vdCB1c2UgdGhlIHN0YW5kYXJkIDQgcGFyYW1cblx0ICogZWFzaW5nIHNpZ25hdHVyZS4gSW5zdGVhZCBpdCB1c2VzIGEgc2luZ2xlIHBhcmFtIHdoaWNoIGluZGljYXRlcyB0aGUgY3VycmVudCBsaW5lYXIgcmF0aW8gKDAgdG8gMSkgb2YgdGhlIHR3ZWVuLlxuXHQgKlxuXHQgKiBNb3N0IG1ldGhvZHMgb24gRWFzZSBjYW4gYmUgcGFzc2VkIGRpcmVjdGx5IGFzIGVhc2luZyBmdW5jdGlvbnM6XG5cdCAqXG5cdCAqICAgICAgVHdlZW4uZ2V0KHRhcmdldCkudG8oe3g6MTAwfSwgNTAwLCBFYXNlLmxpbmVhcik7XG5cdCAqXG5cdCAqIEhvd2V2ZXIsIG1ldGhvZHMgYmVnaW5uaW5nIHdpdGggXCJnZXRcIiB3aWxsIHJldHVybiBhbiBlYXNpbmcgZnVuY3Rpb24gYmFzZWQgb24gcGFyYW1ldGVyIHZhbHVlczpcblx0ICpcblx0ICogICAgICBUd2Vlbi5nZXQodGFyZ2V0KS50byh7eToyMDB9LCA1MDAsIEVhc2UuZ2V0UG93SW4oMi4yKSk7XG5cdCAqXG5cdCAqIFBsZWFzZSBzZWUgdGhlIDxhIGhyZWY9XCJodHRwOi8vd3d3LmNyZWF0ZWpzLmNvbS9EZW1vcy9Ud2VlbkpTL1R3ZWVuX1NwYXJrVGFibGVcIj5zcGFyayB0YWJsZSBkZW1vPC9hPiBmb3IgYW5cblx0ICogb3ZlcnZpZXcgb2YgdGhlIGRpZmZlcmVudCBlYXNlIHR5cGVzIG9uIDxhIGhyZWY9XCJodHRwOi8vdHdlZW5qcy5jb21cIj5Ud2VlbkpTLmNvbTwvYT4uXG5cdCAqXG5cdCAqIDxlbT5FcXVhdGlvbnMgZGVyaXZlZCBmcm9tIHdvcmsgYnkgUm9iZXJ0IFBlbm5lci48L2VtPlxuXHQgKiBAY2xhc3MgRWFzZVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0ZnVuY3Rpb24gRWFzZSgpIHtcblx0XHR0aHJvdyBcIkVhc2UgY2Fubm90IGJlIGluc3RhbnRpYXRlZC5cIjtcblx0fVxuXG5cbi8vIHN0YXRpYyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGxpbmVhclxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmxpbmVhciA9IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHQ7IH07XG5cblx0LyoqXG5cdCAqIElkZW50aWNhbCB0byBsaW5lYXIuXG5cdCAqIEBtZXRob2Qgbm9uZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLm5vbmUgPSBFYXNlLmxpbmVhcjtcblxuXHQvKipcblx0ICogTWltaWNzIHRoZSBzaW1wbGUgLTEwMCB0byAxMDAgZWFzaW5nIGluIEZsYXNoIFByby5cblx0ICogQG1ldGhvZCBnZXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBBIHZhbHVlIGZyb20gLTEgKGVhc2UgaW4pIHRvIDEgKGVhc2Ugb3V0KSBpbmRpY2F0aW5nIHRoZSBzdHJlbmd0aCBhbmQgZGlyZWN0aW9uIG9mIHRoZSBlYXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0ID0gZnVuY3Rpb24oYW1vdW50KSB7XG5cdFx0aWYgKGFtb3VudCA8IC0xKSB7IGFtb3VudCA9IC0xOyB9XG5cdFx0aWYgKGFtb3VudCA+IDEpIHsgYW1vdW50ID0gMTsgfVxuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAoYW1vdW50PT0wKSB7IHJldHVybiB0OyB9XG5cdFx0XHRpZiAoYW1vdW50PDApIHsgcmV0dXJuIHQqKHQqLWFtb3VudCsxK2Ftb3VudCk7IH1cblx0XHRcdHJldHVybiB0KigoMi10KSphbW91bnQrKDEtYW1vdW50KSk7XG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGV4cG9uZW50aWFsIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0UG93SW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvdyBUaGUgZXhwb25lbnQgdG8gdXNlIChleC4gMyB3b3VsZCByZXR1cm4gYSBjdWJpYyBlYXNlKS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldFBvd0luID0gZnVuY3Rpb24ocG93KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiBNYXRoLnBvdyh0LHBvdyk7XG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGV4cG9uZW50aWFsIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0UG93T3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3cgVGhlIGV4cG9uZW50IHRvIHVzZSAoZXguIDMgd291bGQgcmV0dXJuIGEgY3ViaWMgZWFzZSkuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRQb3dPdXQgPSBmdW5jdGlvbihwb3cpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuIDEtTWF0aC5wb3coMS10LHBvdyk7XG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGV4cG9uZW50aWFsIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0UG93SW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvdyBUaGUgZXhwb25lbnQgdG8gdXNlIChleC4gMyB3b3VsZCByZXR1cm4gYSBjdWJpYyBlYXNlKS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldFBvd0luT3V0ID0gZnVuY3Rpb24ocG93KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICgodCo9Mik8MSkgcmV0dXJuIDAuNSpNYXRoLnBvdyh0LHBvdyk7XG5cdFx0XHRyZXR1cm4gMS0wLjUqTWF0aC5hYnMoTWF0aC5wb3coMi10LHBvdykpO1xuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhZEluXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhZEluID0gRWFzZS5nZXRQb3dJbigyKTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhZE91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YWRPdXQgPSBFYXNlLmdldFBvd091dCgyKTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhZEluT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhZEluT3V0ID0gRWFzZS5nZXRQb3dJbk91dCgyKTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBjdWJpY0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY3ViaWNJbiA9IEVhc2UuZ2V0UG93SW4oMyk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGN1YmljT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY3ViaWNPdXQgPSBFYXNlLmdldFBvd091dCgzKTtcblx0LyoqXG5cdCAqIEBtZXRob2QgY3ViaWNJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmN1YmljSW5PdXQgPSBFYXNlLmdldFBvd0luT3V0KDMpO1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YXJ0SW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWFydEluID0gRWFzZS5nZXRQb3dJbig0KTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhcnRPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWFydE91dCA9IEVhc2UuZ2V0UG93T3V0KDQpO1xuXHQvKipcblx0ICogQG1ldGhvZCBxdWFydEluT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhcnRJbk91dCA9IEVhc2UuZ2V0UG93SW5PdXQoNCk7XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgcXVpbnRJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1aW50SW4gPSBFYXNlLmdldFBvd0luKDUpO1xuXHQvKipcblx0ICogQG1ldGhvZCBxdWludE91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1aW50T3V0ID0gRWFzZS5nZXRQb3dPdXQoNSk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1aW50SW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWludEluT3V0ID0gRWFzZS5nZXRQb3dJbk91dCg1KTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBzaW5lSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5zaW5lSW4gPSBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIDEtTWF0aC5jb3ModCpNYXRoLlBJLzIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHNpbmVPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5zaW5lT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiBNYXRoLnNpbih0Kk1hdGguUEkvMik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2Qgc2luZUluT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2Uuc2luZUluT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtMC41KihNYXRoLmNvcyhNYXRoLlBJKnQpIC0gMSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBcImJhY2sgaW5cIiBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldEJhY2tJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IFRoZSBzdHJlbmd0aCBvZiB0aGUgZWFzZS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEJhY2tJbiA9IGZ1bmN0aW9uKGFtb3VudCkge1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gdCp0KigoYW1vdW50KzEpKnQtYW1vdW50KTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBiYWNrSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5iYWNrSW4gPSBFYXNlLmdldEJhY2tJbigxLjcpO1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgXCJiYWNrIG91dFwiIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0QmFja091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IFRoZSBzdHJlbmd0aCBvZiB0aGUgZWFzZS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEJhY2tPdXQgPSBmdW5jdGlvbihhbW91bnQpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuICgtLXQqdCooKGFtb3VudCsxKSp0ICsgYW1vdW50KSArIDEpO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJhY2tPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5iYWNrT3V0ID0gRWFzZS5nZXRCYWNrT3V0KDEuNyk7XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBcImJhY2sgaW4gb3V0XCIgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRCYWNrSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBUaGUgc3RyZW5ndGggb2YgdGhlIGVhc2UuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRCYWNrSW5PdXQgPSBmdW5jdGlvbihhbW91bnQpIHtcblx0XHRhbW91bnQqPTEuNTI1O1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAoKHQqPTIpPDEpIHJldHVybiAwLjUqKHQqdCooKGFtb3VudCsxKSp0LWFtb3VudCkpO1xuXHRcdFx0cmV0dXJuIDAuNSooKHQtPTIpKnQqKChhbW91bnQrMSkqdCthbW91bnQpKzIpO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJhY2tJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJhY2tJbk91dCA9IEVhc2UuZ2V0QmFja0luT3V0KDEuNyk7XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY2lyY0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY2lyY0luID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtKE1hdGguc3FydCgxLXQqdCktIDEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNpcmNPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5jaXJjT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQoMS0oLS10KSp0KTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBjaXJjSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5jaXJjSW5PdXQgPSBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0Kj0yKSA8IDEpIHJldHVybiAtMC41KihNYXRoLnNxcnQoMS10KnQpLTEpO1xuXHRcdHJldHVybiAwLjUqKE1hdGguc3FydCgxLSh0LT0yKSp0KSsxKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBib3VuY2VJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJvdW5jZUluID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAxLUVhc2UuYm91bmNlT3V0KDEtdCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgYm91bmNlT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYm91bmNlT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdGlmICh0IDwgMS8yLjc1KSB7XG5cdFx0XHRyZXR1cm4gKDcuNTYyNSp0KnQpO1xuXHRcdH0gZWxzZSBpZiAodCA8IDIvMi43NSkge1xuXHRcdFx0cmV0dXJuICg3LjU2MjUqKHQtPTEuNS8yLjc1KSp0KzAuNzUpO1xuXHRcdH0gZWxzZSBpZiAodCA8IDIuNS8yLjc1KSB7XG5cdFx0XHRyZXR1cm4gKDcuNTYyNSoodC09Mi4yNS8yLjc1KSp0KzAuOTM3NSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAoNy41NjI1Kih0LT0yLjYyNS8yLjc1KSp0ICswLjk4NDM3NSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJvdW5jZUluT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYm91bmNlSW5PdXQgPSBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQ8MC41KSByZXR1cm4gRWFzZS5ib3VuY2VJbiAodCoyKSAqIC41O1xuXHRcdHJldHVybiBFYXNlLmJvdW5jZU91dCh0KjItMSkqMC41KzAuNTtcblx0fTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGVsYXN0aWMgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRFbGFzdGljSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtcGxpdHVkZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRFbGFzdGljSW4gPSBmdW5jdGlvbihhbXBsaXR1ZGUscGVyaW9kKSB7XG5cdFx0dmFyIHBpMiA9IE1hdGguUEkqMjtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKHQ9PTAgfHwgdD09MSkgcmV0dXJuIHQ7XG5cdFx0XHR2YXIgcyA9IHBlcmlvZC9waTIqTWF0aC5hc2luKDEvYW1wbGl0dWRlKTtcblx0XHRcdHJldHVybiAtKGFtcGxpdHVkZSpNYXRoLnBvdygyLDEwKih0LT0xKSkqTWF0aC5zaW4oKHQtcykqcGkyL3BlcmlvZCkpO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGVsYXN0aWNJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmVsYXN0aWNJbiA9IEVhc2UuZ2V0RWxhc3RpY0luKDEsMC4zKTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGVsYXN0aWMgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRFbGFzdGljT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbXBsaXR1ZGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBlcmlvZFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0RWxhc3RpY091dCA9IGZ1bmN0aW9uKGFtcGxpdHVkZSxwZXJpb2QpIHtcblx0XHR2YXIgcGkyID0gTWF0aC5QSSoyO1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAodD09MCB8fCB0PT0xKSByZXR1cm4gdDtcblx0XHRcdHZhciBzID0gcGVyaW9kL3BpMiAqIE1hdGguYXNpbigxL2FtcGxpdHVkZSk7XG5cdFx0XHRyZXR1cm4gKGFtcGxpdHVkZSpNYXRoLnBvdygyLC0xMCp0KSpNYXRoLnNpbigodC1zKSpwaTIvcGVyaW9kICkrMSk7XG5cdFx0fTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgZWxhc3RpY091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmVsYXN0aWNPdXQgPSBFYXNlLmdldEVsYXN0aWNPdXQoMSwwLjMpO1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgZWxhc3RpYyBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldEVsYXN0aWNJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1wbGl0dWRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2Rcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEVsYXN0aWNJbk91dCA9IGZ1bmN0aW9uKGFtcGxpdHVkZSxwZXJpb2QpIHtcblx0XHR2YXIgcGkyID0gTWF0aC5QSSoyO1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHR2YXIgcyA9IHBlcmlvZC9waTIgKiBNYXRoLmFzaW4oMS9hbXBsaXR1ZGUpO1xuXHRcdFx0aWYgKCh0Kj0yKTwxKSByZXR1cm4gLTAuNSooYW1wbGl0dWRlKk1hdGgucG93KDIsMTAqKHQtPTEpKSpNYXRoLnNpbiggKHQtcykqcGkyL3BlcmlvZCApKTtcblx0XHRcdHJldHVybiBhbXBsaXR1ZGUqTWF0aC5wb3coMiwtMTAqKHQtPTEpKSpNYXRoLnNpbigodC1zKSpwaTIvcGVyaW9kKSowLjUrMTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBlbGFzdGljSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5lbGFzdGljSW5PdXQgPSBFYXNlLmdldEVsYXN0aWNJbk91dCgxLDAuMyoxLjUpO1xuXG5cdGNyZWF0ZWpzLkVhc2UgPSBFYXNlO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTW90aW9uR3VpZGVQbHVnaW4uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEEgVHdlZW5KUyBwbHVnaW4gZm9yIHdvcmtpbmcgd2l0aCBtb3Rpb24gZ3VpZGVzLlxuXHQgKlxuXHQgKiBUbyB1c2UsIGluc3RhbGwgdGhlIHBsdWdpbiBhZnRlciBUd2VlbkpTIGhhcyBsb2FkZWQuIE5leHQgdHdlZW4gdGhlICdndWlkZScgcHJvcGVydHkgd2l0aCBhbiBvYmplY3QgYXMgZGV0YWlsZWQgYmVsb3cuXG5cdCAqXG5cdCAqICAgICAgIGNyZWF0ZWpzLk1vdGlvbkd1aWRlUGx1Z2luLmluc3RhbGwoKTtcblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIC8vIFVzaW5nIGEgTW90aW9uIEd1aWRlXG5cdCAqXHQgICAgY3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCkudG8oe2d1aWRlOnsgcGF0aDpbMCwwLCAwLDIwMCwyMDAsMjAwLCAyMDAsMCwwLDBdIH19LDcwMDApO1xuXHQgKlx0ICAgIC8vIFZpc3VhbGl6aW5nIHRoZSBsaW5lXG5cdCAqXHQgICAgZ3JhcGhpY3MubW92ZVRvKDAsMCkuY3VydmVUbygwLDIwMCwyMDAsMjAwKS5jdXJ2ZVRvKDIwMCwwLDAsMCk7XG5cdCAqXG5cdCAqIEVhY2ggcGF0aCBuZWVkcyBwcmUtY29tcHV0YXRpb24gdG8gZW5zdXJlIHRoZXJlJ3MgZmFzdCBwZXJmb3JtYW5jZS4gQmVjYXVzZSBvZiB0aGUgcHJlLWNvbXB1dGF0aW9uIHRoZXJlJ3Mgbm9cblx0ICogYnVpbHQgaW4gc3VwcG9ydCBmb3IgcGF0aCBjaGFuZ2VzIG1pZCB0d2Vlbi4gVGhlc2UgYXJlIHRoZSBHdWlkZSBPYmplY3QncyBwcm9wZXJ0aWVzOjxVTD5cblx0ICogICAgICA8TEk+IHBhdGg6IFJlcXVpcmVkLCBBcnJheSA6IFRoZSB4L3kgcG9pbnRzIHVzZWQgdG8gZHJhdyB0aGUgcGF0aCB3aXRoIGEgbW92ZVRvIGFuZCAxIHRvIG4gY3VydmVUbyBjYWxscy48L0xJPlxuXHQgKiAgICAgIDxMST4gc3RhcnQ6IE9wdGlvbmFsLCAwLTEgOiBJbml0aWFsIHBvc2l0aW9uLCBkZWZhdWx0IDAgZXhjZXB0IGZvciB3aGVuIGNvbnRpbnVpbmcgYWxvbmcgdGhlIHNhbWUgcGF0aC48L0xJPlxuXHQgKiAgICAgIDxMST4gZW5kOiBPcHRpb25hbCwgMC0xIDogRmluYWwgcG9zaXRpb24sIGRlZmF1bHQgMSBpZiBub3Qgc3BlY2lmaWVkLjwvTEk+XG5cdCAqICAgICAgPExJPiBvcmllbnQ6IE9wdGlvbmFsLCBzdHJpbmcgOiBcImZpeGVkXCIvXCJhdXRvXCIvXCJjd1wiL1wiY2N3XCI8VUw+XG5cdCAqXHRcdFx0XHQ8TEk+XCJmaXhlZFwiIGZvcmNlcyB0aGUgb2JqZWN0IHRvIGZhY2UgZG93biB0aGUgcGF0aCBhbGwgbW92ZW1lbnQgKHJlbGF0aXZlIHRvIHN0YXJ0IHJvdGF0aW9uKSw8L0xJPlxuXHQgKiAgICAgIFx0XHQ8TEk+XCJhdXRvXCIgcm90YXRlcyB0aGUgb2JqZWN0IGFsb25nIHRoZSBwYXRoIHJlbGF0aXZlIHRvIHRoZSBsaW5lLjwvTEk+XG5cdCAqICAgICAgXHRcdDxMST5cImN3XCIvXCJjY3dcIiBmb3JjZSBjbG9ja3dpc2Ugb3IgY291bnRlciBjbG9ja3dpc2Ugcm90YXRpb25zIGluY2x1ZGluZyBmbGFzaCBsaWtlIGJlaGF2aW91cjwvTEk+XG5cdCAqIFx0XHQ8L1VMPjwvTEk+XG5cdCAqIDwvVUw+XG5cdCAqIEd1aWRlIG9iamVjdHMgc2hvdWxkIG5vdCBiZSBzaGFyZWQgYmV0d2VlbiB0d2VlbnMgZXZlbiBpZiBhbGwgcHJvcGVydGllcyBhcmUgaWRlbnRpY2FsLCB0aGUgbGlicmFyeSBzdG9yZXNcblx0ICogaW5mb3JtYXRpb24gb24gdGhlc2Ugb2JqZWN0cyBpbiB0aGUgYmFja2dyb3VuZCBhbmQgc2hhcmluZyB0aGVtIGNhbiBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW91ci4gVmFsdWVzXG5cdCAqIG91dHNpZGUgMC0xIHJhbmdlIG9mIHR3ZWVucyB3aWxsIGJlIGEgXCJiZXN0IGd1ZXNzXCIgZnJvbSB0aGUgYXBwcm9wcmlhdGUgcGFydCBvZiB0aGUgZGVmaW5lZCBjdXJ2ZS5cblx0ICpcblx0ICogQGNsYXNzIE1vdGlvbkd1aWRlUGx1Z2luXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIE1vdGlvbkd1aWRlUGx1Z2luKCkge1xuXHRcdHRocm93KFwiTW90aW9uR3VpZGVQbHVnaW4gY2Fubm90IGJlIGluc3RhbnRpYXRlZC5cIilcblx0fTtcblxuXG4vLyBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBwcmlvcml0eVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi5wcmlvcml0eSA9IDA7IC8vIGhpZ2ggcHJpb3JpdHksIHNob3VsZCBydW4gc29vbmVyXG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB0ZW1wb3JhcnkgdmFyaWFibGUgc3RvcmFnZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi5fcm90T2ZmUztcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB0ZW1wb3JhcnkgdmFyaWFibGUgc3RvcmFnZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi5fcm90T2ZmRTtcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB0ZW1wb3JhcnkgdmFyaWFibGUgc3RvcmFnZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi5fcm90Tm9ybVM7XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgdGVtcG9yYXJ5IHZhcmlhYmxlIHN0b3JhZ2Vcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uX3JvdE5vcm1FO1xuXG5cbi8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBJbnN0YWxscyB0aGlzIHBsdWdpbiBmb3IgdXNlIHdpdGggVHdlZW5KUy4gQ2FsbCB0aGlzIG9uY2UgYWZ0ZXIgVHdlZW5KUyBpcyBsb2FkZWQgdG8gZW5hYmxlIHRoaXMgcGx1Z2luLlxuXHQgKiBAbWV0aG9kIGluc3RhbGxcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLmluc3RhbGwgPSBmdW5jdGlvbigpIHtcblx0XHRjcmVhdGVqcy5Ud2Vlbi5pbnN0YWxsUGx1Z2luKE1vdGlvbkd1aWRlUGx1Z2luLCBbXCJndWlkZVwiLCBcInhcIiwgXCJ5XCIsIFwicm90YXRpb25cIl0pO1xuXHRcdHJldHVybiBjcmVhdGVqcy5Ud2Vlbi5JR05PUkU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgaW5pdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi5pbml0ID0gZnVuY3Rpb24odHdlZW4sIHByb3AsIHZhbHVlKSB7XG5cdFx0dmFyIHRhcmdldCA9IHR3ZWVuLnRhcmdldDtcblx0XHRpZighdGFyZ2V0Lmhhc093blByb3BlcnR5KFwieFwiKSl7IHRhcmdldC54ID0gMDsgfVxuXHRcdGlmKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoXCJ5XCIpKXsgdGFyZ2V0LnkgPSAwOyB9XG5cdFx0aWYoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShcInJvdGF0aW9uXCIpKXsgdGFyZ2V0LnJvdGF0aW9uID0gMDsgfVxuXG5cdFx0aWYocHJvcD09XCJyb3RhdGlvblwiKXsgdHdlZW4uX19uZWVkc1JvdCA9IHRydWU7IH1cblx0XHRyZXR1cm4gcHJvcD09XCJndWlkZVwiP251bGw6dmFsdWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2Qgc3RlcFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi5zdGVwID0gZnVuY3Rpb24odHdlZW4sIHByb3AsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBpbmplY3RQcm9wcykge1xuXHRcdC8vIG90aGVyIHByb3BzXG5cdFx0aWYocHJvcCA9PSBcInJvdGF0aW9uXCIpe1xuXHRcdFx0dHdlZW4uX19yb3RHbG9iYWxTID0gc3RhcnRWYWx1ZTtcblx0XHRcdHR3ZWVuLl9fcm90R2xvYmFsRSA9IGVuZFZhbHVlO1xuXHRcdFx0TW90aW9uR3VpZGVQbHVnaW4udGVzdFJvdERhdGEodHdlZW4sIGluamVjdFByb3BzKTtcblx0XHR9XG5cdFx0aWYocHJvcCAhPSBcImd1aWRlXCIpeyByZXR1cm4gZW5kVmFsdWU7IH1cblxuXHRcdC8vIGd1aWRlIG9ubHkgaW5mb3JtYXRpb24gLSBTdGFydCAtXG5cdFx0dmFyIHRlbXAsIGRhdGEgPSBlbmRWYWx1ZTtcblx0XHRpZighZGF0YS5oYXNPd25Qcm9wZXJ0eShcInBhdGhcIikpeyBkYXRhLnBhdGggPSBbXTsgfVxuXHRcdHZhciBwYXRoID0gZGF0YS5wYXRoO1xuXHRcdGlmKCFkYXRhLmhhc093blByb3BlcnR5KFwiZW5kXCIpKXsgZGF0YS5lbmQgPSAxOyB9XG5cdFx0aWYoIWRhdGEuaGFzT3duUHJvcGVydHkoXCJzdGFydFwiKSl7XG5cdFx0XHRkYXRhLnN0YXJ0ID0gKHN0YXJ0VmFsdWUmJnN0YXJ0VmFsdWUuaGFzT3duUHJvcGVydHkoXCJlbmRcIikmJnN0YXJ0VmFsdWUucGF0aD09PXBhdGgpP3N0YXJ0VmFsdWUuZW5kOjA7XG5cdFx0fVxuXG5cdFx0Ly8gRmlndXJlIG91dCBzdWJsaW5lIGluZm9ybWF0aW9uXG5cdFx0aWYoZGF0YS5oYXNPd25Qcm9wZXJ0eShcIl9zZWdtZW50c1wiKSAmJiBkYXRhLl9sZW5ndGgpeyByZXR1cm4gZW5kVmFsdWU7IH1cblx0XHR2YXIgbCA9IHBhdGgubGVuZ3RoO1xuXHRcdHZhciBhY2N1cmFjeSA9IDEwO1x0XHQvLyBBZGp1c3QgdG8gaW1wcm92ZSBsaW5lIGZvbGxvd2luZyBwcmVjaXNpb24gYnV0IHNhY3JpZmljZSBwZXJmb3JtYW5jZSAoIyBvZiBzZWcpXG5cdFx0aWYobCA+PSA2ICYmIChsLTIpICUgNCA9PSAwKXtcdC8vIEVub3VnaCBwb2ludHMgJiYgY29udGFpbnMgY29ycmVjdCBudW1iZXIgcGVyIGVudHJ5IGlnbm9yaW5nIHN0YXJ0XG5cdFx0XHRkYXRhLl9zZWdtZW50cyA9IFtdO1xuXHRcdFx0ZGF0YS5fbGVuZ3RoID0gMDtcblx0XHRcdGZvcih2YXIgaT0yOyBpPGw7IGkrPTQpe1xuXHRcdFx0XHR2YXIgc3ggPSBwYXRoW2ktMl0sIHN5ID0gcGF0aFtpLTFdO1xuXHRcdFx0XHR2YXIgY3ggPSBwYXRoW2krMF0sIGN5ID0gcGF0aFtpKzFdO1xuXHRcdFx0XHR2YXIgZXggPSBwYXRoW2krMl0sIGV5ID0gcGF0aFtpKzNdO1xuXHRcdFx0XHR2YXIgb2xkWCA9IHN4LCBvbGRZID0gc3k7XG5cdFx0XHRcdHZhciB0ZW1wWCwgdGVtcFksIHRvdGFsID0gMDtcblx0XHRcdFx0dmFyIHN1YmxpbmVzID0gW107XG5cdFx0XHRcdGZvcih2YXIgaj0xOyBqPD1hY2N1cmFjeTsgaisrKXtcblx0XHRcdFx0XHR2YXIgdCA9IGovYWNjdXJhY3k7XG5cdFx0XHRcdFx0dmFyIGludiA9IDEgLSB0O1xuXHRcdFx0XHRcdHRlbXBYID0gaW52KmludiAqIHN4ICsgMiAqIGludiAqIHQgKiBjeCArIHQqdCAqIGV4O1xuXHRcdFx0XHRcdHRlbXBZID0gaW52KmludiAqIHN5ICsgMiAqIGludiAqIHQgKiBjeSArIHQqdCAqIGV5O1xuXHRcdFx0XHRcdHRvdGFsICs9IHN1YmxpbmVzW3N1YmxpbmVzLnB1c2goTWF0aC5zcXJ0KCh0ZW1wPXRlbXBYLW9sZFgpKnRlbXAgKyAodGVtcD10ZW1wWS1vbGRZKSp0ZW1wKSktMV07XG5cdFx0XHRcdFx0b2xkWCA9IHRlbXBYO1xuXHRcdFx0XHRcdG9sZFkgPSB0ZW1wWTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhLl9zZWdtZW50cy5wdXNoKHRvdGFsKTtcblx0XHRcdFx0ZGF0YS5fc2VnbWVudHMucHVzaChzdWJsaW5lcyk7XG5cdFx0XHRcdGRhdGEuX2xlbmd0aCArPSB0b3RhbDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3coXCJpbnZhbGlkICdwYXRoJyBkYXRhLCBwbGVhc2Ugc2VlIGRvY3VtZW50YXRpb24gZm9yIHZhbGlkIHBhdGhzXCIpO1xuXHRcdH1cblxuXHRcdC8vIFNldHVwIHgveSB0d2VlbnNcblx0XHR0ZW1wID0gZGF0YS5vcmllbnQ7XG5cdFx0ZGF0YS5vcmllbnQgPSB0cnVlO1xuXHRcdHZhciBvID0ge307XG5cdFx0TW90aW9uR3VpZGVQbHVnaW4uY2FsYyhkYXRhLCBkYXRhLnN0YXJ0LCBvKTtcblx0XHR0d2Vlbi5fX3JvdFBhdGhTID0gTnVtYmVyKG8ucm90YXRpb24udG9GaXhlZCg1KSk7XG5cdFx0TW90aW9uR3VpZGVQbHVnaW4uY2FsYyhkYXRhLCBkYXRhLmVuZCwgbyk7XG5cdFx0dHdlZW4uX19yb3RQYXRoRSA9IE51bWJlcihvLnJvdGF0aW9uLnRvRml4ZWQoNSkpO1xuXHRcdGRhdGEub3JpZW50ID0gZmFsc2U7XHQvL2hlcmUgYW5kIG5vdyB3ZSBkb24ndCBrbm93IGlmIHdlIG5lZWQgdG9cblx0XHRNb3Rpb25HdWlkZVBsdWdpbi5jYWxjKGRhdGEsIGRhdGEuZW5kLCBpbmplY3RQcm9wcyk7XG5cdFx0ZGF0YS5vcmllbnQgPSB0ZW1wO1xuXG5cdFx0Ly8gU2V0dXAgcm90YXRpb24gcHJvcGVydGllc1xuXHRcdGlmKCFkYXRhLm9yaWVudCl7IHJldHVybiBlbmRWYWx1ZTsgfVxuXHRcdHR3ZWVuLl9fZ3VpZGVEYXRhID0gZGF0YTtcblx0XHRNb3Rpb25HdWlkZVBsdWdpbi50ZXN0Um90RGF0YSh0d2VlbiwgaW5qZWN0UHJvcHMpO1xuXHRcdHJldHVybiBlbmRWYWx1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCB0ZXN0Um90RGF0YVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi50ZXN0Um90RGF0YSA9IGZ1bmN0aW9uKHR3ZWVuLCBpbmplY3RQcm9wcyl7XG5cblx0XHQvLyBubyByb3RhdGlvbiBpbmZvcm1hdD8gaWYgd2UgbmVlZCBpdCBjb21lIGJhY2ssIGlmIHdlIGRvbid0IHVzZSAwICYgZW5zdXJlIHdlIGhhdmUgZ3VpZGUgZGF0YVxuXHRcdGlmKHR3ZWVuLl9fcm90R2xvYmFsUyA9PT0gdW5kZWZpbmVkIHx8IHR3ZWVuLl9fcm90R2xvYmFsRSA9PT0gdW5kZWZpbmVkKXtcblx0XHRcdGlmKHR3ZWVuLl9fbmVlZHNSb3QpeyByZXR1cm47IH1cblx0XHRcdGlmKHR3ZWVuLl9jdXJRdWV1ZVByb3BzLnJvdGF0aW9uICE9PSB1bmRlZmluZWQpe1xuXHRcdFx0XHR0d2Vlbi5fX3JvdEdsb2JhbFMgPSB0d2Vlbi5fX3JvdEdsb2JhbEUgPSB0d2Vlbi5fY3VyUXVldWVQcm9wcy5yb3RhdGlvbjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLl9fcm90R2xvYmFsUyA9IHR3ZWVuLl9fcm90R2xvYmFsRSA9IGluamVjdFByb3BzLnJvdGF0aW9uID0gdHdlZW4udGFyZ2V0LnJvdGF0aW9uIHx8IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKHR3ZWVuLl9fZ3VpZGVEYXRhID09PSB1bmRlZmluZWQpeyByZXR1cm47IH1cblxuXHRcdC8vIFByb2Nlc3Mgcm90YXRpb24gcHJvcGVydGllc1xuXHRcdHZhciBkYXRhID0gdHdlZW4uX19ndWlkZURhdGE7XG5cdFx0dmFyIHJvdEdsb2JhbEQgPSB0d2Vlbi5fX3JvdEdsb2JhbEUgLSB0d2Vlbi5fX3JvdEdsb2JhbFM7XG5cdFx0dmFyIHJvdFBhdGhEID0gdHdlZW4uX19yb3RQYXRoRSAtIHR3ZWVuLl9fcm90UGF0aFM7XG5cdFx0dmFyIHJvdCA9IHJvdEdsb2JhbEQgLSByb3RQYXRoRDtcblxuXHRcdGlmKGRhdGEub3JpZW50ID09IFwiYXV0b1wiKXtcblx0XHRcdGlmKHJvdCA+IDE4MCl7XHRcdFx0cm90IC09IDM2MDsgfVxuXHRcdFx0ZWxzZSBpZihyb3QgPCAtMTgwKXtcdHJvdCArPSAzNjA7IH1cblxuXHRcdH0gZWxzZSBpZihkYXRhLm9yaWVudCA9PSBcImN3XCIpe1xuXHRcdFx0d2hpbGUocm90IDwgMCl7IHJvdCArPSAzNjA7IH1cblx0XHRcdGlmKHJvdCA9PSAwICYmIHJvdEdsb2JhbEQgPiAwICYmIHJvdEdsb2JhbEQgIT0gMTgwKXsgcm90ICs9IDM2MDsgfVxuXG5cdFx0fSBlbHNlIGlmKGRhdGEub3JpZW50ID09IFwiY2N3XCIpe1xuXHRcdFx0cm90ID0gcm90R2xvYmFsRCAtICgocm90UGF0aEQgPiAxODApPygzNjAtcm90UGF0aEQpOihyb3RQYXRoRCkpO1x0Ly8gc2lnbiBmbGlwcGluZyBvbiBwYXRoXG5cdFx0XHR3aGlsZShyb3QgPiAwKXsgcm90IC09IDM2MDsgfVxuXHRcdFx0aWYocm90ID09IDAgJiYgcm90R2xvYmFsRCA8IDAgJiYgcm90R2xvYmFsRCAhPSAtMTgwKXsgcm90IC09IDM2MDsgfVxuXHRcdH1cblxuXHRcdGRhdGEucm90RGVsdGEgPSByb3Q7XG5cdFx0ZGF0YS5yb3RPZmZTID0gdHdlZW4uX19yb3RHbG9iYWxTIC0gdHdlZW4uX19yb3RQYXRoUztcblxuXHRcdC8vIHJlc2V0XG5cdFx0dHdlZW4uX19yb3RHbG9iYWxTID0gdHdlZW4uX19yb3RHbG9iYWxFID0gdHdlZW4uX19ndWlkZURhdGEgPSB0d2Vlbi5fX25lZWRzUm90ID0gdW5kZWZpbmVkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHR3ZWVuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLnR3ZWVuID0gZnVuY3Rpb24odHdlZW4sIHByb3AsIHZhbHVlLCBzdGFydFZhbHVlcywgZW5kVmFsdWVzLCByYXRpbywgd2FpdCwgZW5kKSB7XG5cdFx0dmFyIGRhdGEgPSBlbmRWYWx1ZXMuZ3VpZGU7XG5cdFx0aWYoZGF0YSA9PSB1bmRlZmluZWQgfHwgZGF0YSA9PT0gc3RhcnRWYWx1ZXMuZ3VpZGUpeyByZXR1cm4gdmFsdWU7IH1cblx0XHRpZihkYXRhLmxhc3RSYXRpbyAhPSByYXRpbyl7XG5cdFx0XHQvLyBmaXJzdCB0aW1lIHRocm91Z2ggc28gY2FsY3VsYXRlIHdoYXQgSSBuZWVkIHRvXG5cdFx0XHR2YXIgdCA9ICgoZGF0YS5lbmQtZGF0YS5zdGFydCkqKHdhaXQ/ZGF0YS5lbmQ6cmF0aW8pK2RhdGEuc3RhcnQpO1xuXHRcdFx0TW90aW9uR3VpZGVQbHVnaW4uY2FsYyhkYXRhLCB0LCB0d2Vlbi50YXJnZXQpO1xuXHRcdFx0c3dpdGNoKGRhdGEub3JpZW50KXtcblx0XHRcdFx0Y2FzZSBcImN3XCI6XHRcdC8vIG1peCBpbiB0aGUgb3JpZ2luYWwgcm90YXRpb25cblx0XHRcdFx0Y2FzZSBcImNjd1wiOlxuXHRcdFx0XHRjYXNlIFwiYXV0b1wiOiB0d2Vlbi50YXJnZXQucm90YXRpb24gKz0gZGF0YS5yb3RPZmZTICsgZGF0YS5yb3REZWx0YSpyYXRpbzsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJmaXhlZFwiOlx0Ly8gZm9sbG93IGZpeGVkIGJlaGF2aW91ciB0byBzb2x2ZSBwb3RlbnRpYWwgaXNzdWVzXG5cdFx0XHRcdGRlZmF1bHQ6IHR3ZWVuLnRhcmdldC5yb3RhdGlvbiArPSBkYXRhLnJvdE9mZlM7IGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0ZGF0YS5sYXN0UmF0aW8gPSByYXRpbztcblx0XHR9XG5cdFx0aWYocHJvcCA9PSBcInJvdGF0aW9uXCIgJiYgKCghZGF0YS5vcmllbnQpIHx8IGRhdGEub3JpZW50ID09IFwiZmFsc2VcIikpeyByZXR1cm4gdmFsdWU7IH1cblx0XHRyZXR1cm4gdHdlZW4udGFyZ2V0W3Byb3BdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIHgveS9yb3RhdGlvbiBpbmZvcm1hdGlvbiBhYm91dCBhIHBhdGggZm9yIGEgZ2l2ZW4gcmF0aW8gYWxvbmcgdGhlIHBhdGguXG5cdCAqIEFzc3VtZXMgYSBwYXRoIG9iamVjdCB3aXRoIGFsbCBvcHRpb25hbCBwYXJhbWV0ZXJzIHNwZWNpZmllZC5cblx0ICogQHBhcmFtIGRhdGEgRGF0YSBvYmplY3QgeW91IHdvdWxkIHBhc3MgdG8gdGhlIFwiZ3VpZGU6XCIgcHJvcGVydHkgaW4gYSBUd2VlblxuXHQgKiBAcGFyYW0gcmF0aW8gMC0xIERpc3RhbmNlIGFsb25nIHBhdGgsIHZhbHVlcyBvdXRzaWRlIDAtMSBhcmUgXCJiZXN0IGd1ZXNzXCJcblx0ICogQHBhcmFtIHRhcmdldCBPYmplY3QgdG8gY29weSB0aGUgcmVzdWx0cyBvbnRvLCB3aWxsIHVzZSBhIG5ldyBvYmplY3QgaWYgbm90IHN1cHBsaWVkLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB0YXJnZXQgb2JqZWN0IG9yIGEgbmV3IG9iamVjdCB3LyB0aGUgdHdlZW5lZCBwcm9wZXJ0aWVzXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLmNhbGMgPSBmdW5jdGlvbihkYXRhLCByYXRpbywgdGFyZ2V0KSB7XG5cdFx0aWYoZGF0YS5fc2VnbWVudHMgPT0gdW5kZWZpbmVkKXsgdGhyb3coXCJNaXNzaW5nIGNyaXRpY2FsIHByZS1jYWxjdWxhdGVkIGluZm9ybWF0aW9uLCBwbGVhc2UgZmlsZSBhIGJ1Z1wiKTsgfVxuXHRcdGlmKHRhcmdldCA9PSB1bmRlZmluZWQpeyB0YXJnZXQgPSB7eDowLCB5OjAsIHJvdGF0aW9uOjB9OyB9XG5cdFx0dmFyIHNlZyA9IGRhdGEuX3NlZ21lbnRzO1xuXHRcdHZhciBwYXRoID0gZGF0YS5wYXRoO1xuXG5cdFx0Ly8gZmluZCBzZWdtZW50XG5cdFx0dmFyIHBvcyA9IGRhdGEuX2xlbmd0aCAqIHJhdGlvO1xuXHRcdHZhciBjYXAgPSBzZWcubGVuZ3RoIC0gMjtcblx0XHR2YXIgbiA9IDA7XG5cdFx0d2hpbGUocG9zID4gc2VnW25dICYmIG4gPCBjYXApe1xuXHRcdFx0cG9zIC09IHNlZ1tuXTtcblx0XHRcdG4rPTI7XG5cdFx0fVxuXG5cdFx0Ly8gZmluZCBzdWJsaW5lXG5cdFx0dmFyIHN1YmxpbmVzID0gc2VnW24rMV07XG5cdFx0dmFyIGkgPSAwO1xuXHRcdGNhcCA9IHN1YmxpbmVzLmxlbmd0aC0xO1xuXHRcdHdoaWxlKHBvcyA+IHN1YmxpbmVzW2ldICYmIGkgPCBjYXApe1xuXHRcdFx0cG9zIC09IHN1YmxpbmVzW2ldO1xuXHRcdFx0aSsrO1xuXHRcdH1cblx0XHR2YXIgdCA9IChpLysrY2FwKSsocG9zLyhjYXAqc3VibGluZXNbaV0pKTtcblxuXHRcdC8vIGZpbmQgeC95XG5cdFx0biA9IChuKjIpKzI7XG5cdFx0dmFyIGludiA9IDEgLSB0O1xuXHRcdHRhcmdldC54ID0gaW52KmludiAqIHBhdGhbbi0yXSArIDIgKiBpbnYgKiB0ICogcGF0aFtuKzBdICsgdCp0ICogcGF0aFtuKzJdO1xuXHRcdHRhcmdldC55ID0gaW52KmludiAqIHBhdGhbbi0xXSArIDIgKiBpbnYgKiB0ICogcGF0aFtuKzFdICsgdCp0ICogcGF0aFtuKzNdO1xuXG5cdFx0Ly8gb3JpZW50YXRpb25cblx0XHRpZihkYXRhLm9yaWVudCl7XG5cdFx0XHR0YXJnZXQucm90YXRpb24gPSA1Ny4yOTU3Nzk1ICogTWF0aC5hdGFuMihcblx0XHRcdFx0KHBhdGhbbisxXS1wYXRoW24tMV0pKmludiArIChwYXRoW24rM10tcGF0aFtuKzFdKSp0LFxuXHRcdFx0XHQocGF0aFtuKzBdLXBhdGhbbi0yXSkqaW52ICsgKHBhdGhbbisyXS1wYXRoW24rMF0pKnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG5cblx0Y3JlYXRlanMuTW90aW9uR3VpZGVQbHVnaW4gPSBNb3Rpb25HdWlkZVBsdWdpbjtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHZlcnNpb24uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFN0YXRpYyBjbGFzcyBob2xkaW5nIGxpYnJhcnkgc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgdmVyc2lvbiBhbmQgYnVpbGREYXRlIG9mXG5cdCAqIHRoZSBsaWJyYXJ5LlxuXHQgKiBAY2xhc3MgVHdlZW5KU1xuXHQgKiovXG5cdHZhciBzID0gY3JlYXRlanMuVHdlZW5KUyA9IGNyZWF0ZWpzLlR3ZWVuSlMgfHwge307XG5cblx0LyoqXG5cdCAqIFRoZSB2ZXJzaW9uIHN0cmluZyBmb3IgdGhpcyByZWxlYXNlLlxuXHQgKiBAcHJvcGVydHkgdmVyc2lvblxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdHMudmVyc2lvbiA9IC8qPXZlcnNpb24qL1wiMC42LjJcIjsgLy8gaW5qZWN0ZWQgYnkgYnVpbGQgcHJvY2Vzc1xuXG5cdC8qKlxuXHQgKiBUaGUgYnVpbGQgZGF0ZSBmb3IgdGhpcyByZWxlYXNlIGluIFVUQyBmb3JtYXQuXG5cdCAqIEBwcm9wZXJ0eSBidWlsZERhdGVcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLmJ1aWxkRGF0ZSA9IC8qPWRhdGUqL1wiVGh1LCAyNiBOb3YgMjAxNSAyMDo0NDozMSBHTVRcIjsgLy8gaW5qZWN0ZWQgYnkgYnVpbGQgcHJvY2Vzc1xuXG59KSgpO1xuaWYodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZS5leHBvcnRzID0gdGhpcy5jcmVhdGVqczsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/createjs-module/createjs.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2FtZC1vcHRpb25zLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzPzAwODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/amd-options.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL21vZHVsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanM/Y2VkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _views_App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./views/App */ \"./src/views/App.js\");\n\r\n\r\nvar app = new _views_App__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\napp.start();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQXBwIGZyb20gJy4vdmlld3MvQXBwJztcclxuXHJcbnZhciBhcHAgPSBuZXcgQXBwKCk7XHJcbmFwcC5zdGFydCgpO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/models/GameEvent.js":
/*!*********************************!*\
  !*** ./src/models/GameEvent.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar GameEvent = {\r\n    ACTIVATE_QUESTION: 'ACTIVATE_QUESTION',\r\n    CONTINUE: 'CONTINUE_GAME',\r\n    GAME_OVER: 'GAME_OVER',\r\n    CLEANUP_SCOREBOARD: 'CLEANUP_SCOREBOARD',\r\n    SHOW_TEAM_PERFORMANCE: 'SHOW_TEAM_PERFORMANCE',\r\n    REMOVE_TEAM_PERFORMANCE: 'REMOVE_TEAM_PERFORMANCE',\r\n    SHOW_QUESTION_FEEDBACK: 'SHOW_QUESTION_FEEDBACK',\r\n    CLEAR_QUESTION_FEEDBACK: 'CLEAR_QUESTION_FEEDBACK',\r\n    SOUND_COMPLETED:'SOUND_COMPLETED'\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (GameEvent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kZWxzL0dhbWVFdmVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2RlbHMvR2FtZUV2ZW50LmpzPzcxOGUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEdhbWVFdmVudCA9IHtcclxuICAgIEFDVElWQVRFX1FVRVNUSU9OOiAnQUNUSVZBVEVfUVVFU1RJT04nLFxyXG4gICAgQ09OVElOVUU6ICdDT05USU5VRV9HQU1FJyxcclxuICAgIEdBTUVfT1ZFUjogJ0dBTUVfT1ZFUicsXHJcbiAgICBDTEVBTlVQX1NDT1JFQk9BUkQ6ICdDTEVBTlVQX1NDT1JFQk9BUkQnLFxyXG4gICAgU0hPV19URUFNX1BFUkZPUk1BTkNFOiAnU0hPV19URUFNX1BFUkZPUk1BTkNFJyxcclxuICAgIFJFTU9WRV9URUFNX1BFUkZPUk1BTkNFOiAnUkVNT1ZFX1RFQU1fUEVSRk9STUFOQ0UnLFxyXG4gICAgU0hPV19RVUVTVElPTl9GRUVEQkFDSzogJ1NIT1dfUVVFU1RJT05fRkVFREJBQ0snLFxyXG4gICAgQ0xFQVJfUVVFU1RJT05fRkVFREJBQ0s6ICdDTEVBUl9RVUVTVElPTl9GRUVEQkFDSycsXHJcbiAgICBTT1VORF9DT01QTEVURUQ6J1NPVU5EX0NPTVBMRVRFRCdcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEdhbWVFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/models/GameEvent.js\n");

/***/ }),

/***/ "./src/models/Models.js":
/*!******************************!*\
  !*** ./src/models/Models.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\r\nvar GameModel = {\r\n    instance: {},\r\n    getInstance: function () {\r\n        return this.instance;\r\n    }\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (GameModel);\r\n\r\nwindow.gm = GameModel.getInstance()//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kZWxzL01vZGVscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2RlbHMvTW9kZWxzLmpzPzZjY2IiXSwic291cmNlc0NvbnRlbnQiOlsiXHJcbnZhciBHYW1lTW9kZWwgPSB7XHJcbiAgICBpbnN0YW5jZToge30sXHJcbiAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgR2FtZU1vZGVsXHJcblxyXG53aW5kb3cuZ20gPSBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/models/Models.js\n");

/***/ }),

/***/ "./src/models/Player.js":
/*!******************************!*\
  !*** ./src/models/Player.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Player {\r\n\r\n    constructor(id) {\r\n        this.id = id;\r\n\r\n        this.run = '';\r\n\r\n        this.states = {\r\n            \"INIT\": \"init\",\r\n            \"RUNNER\": \"runner\",\r\n            \"OUT\": \"out\",\r\n            \"STRIKE\": \"strike\",\r\n            \"DISABLE\": \"disable\"\r\n        }\r\n    }\r\n\r\n    scoreRun(run) {\r\n        this.run += run;\r\n    }\r\n\r\n    getPlayerScore() {\r\n        return this.run\r\n    }\r\n\r\n    setStatus(status) {\r\n        this.state = this.states[status];\r\n        if ((this.state === this.states[\"STRIKE\"]) || (this.state === this.states[\"RUNNER\"])) {\r\n            if (this.run === '') {\r\n                this.run = 0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Player);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kZWxzL1BsYXllci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2RlbHMvUGxheWVyLmpzP2FlOTAiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgUGxheWVyIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihpZCkge1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHJcbiAgICAgICAgdGhpcy5ydW4gPSAnJztcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB7XHJcbiAgICAgICAgICAgIFwiSU5JVFwiOiBcImluaXRcIixcclxuICAgICAgICAgICAgXCJSVU5ORVJcIjogXCJydW5uZXJcIixcclxuICAgICAgICAgICAgXCJPVVRcIjogXCJvdXRcIixcclxuICAgICAgICAgICAgXCJTVFJJS0VcIjogXCJzdHJpa2VcIixcclxuICAgICAgICAgICAgXCJESVNBQkxFXCI6IFwiZGlzYWJsZVwiXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNjb3JlUnVuKHJ1bikge1xyXG4gICAgICAgIHRoaXMucnVuICs9IHJ1bjtcclxuICAgIH1cclxuXHJcbiAgICBnZXRQbGF5ZXJTY29yZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ydW5cclxuICAgIH1cclxuXHJcbiAgICBzZXRTdGF0dXMoc3RhdHVzKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXR1c107XHJcbiAgICAgICAgaWYgKCh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlc1tcIlNUUklLRVwiXSkgfHwgKHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzW1wiUlVOTkVSXCJdKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ydW4gPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJ1biA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBsYXllciJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/models/Player.js\n");

/***/ }),

/***/ "./src/models/Team.js":
/*!****************************!*\
  !*** ./src/models/Team.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Player__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Player */ \"./src/models/Player.js\");\n\r\n\r\nclass Team {\r\n\r\n    constructor(id, name) {\r\n        this.id = id;\r\n        this.name = name;\r\n\r\n        this.innings = [];\r\n        this.runs = 0;\r\n        this.over = [];\r\n        this.wickets = 0;\r\n\r\n        this.players = [];\r\n        this.playerCounter = 0;\r\n        this.lastPlayerDown = -1;\r\n\r\n        this.ballVO = [\r\n            'a_ball1',\r\n            'a_ball2',\r\n            'a_ball3',\r\n            'a_ball4',\r\n            'a_ball5',\r\n            'a_ball6'\r\n        ]\r\n\r\n        this.createWickets();\r\n    }\r\n\r\n    setQuestions(q, t) {\r\n        this\r\n            .innings\r\n            .push({ 'questions': q, 'title': t, 'completed': false, 'runs': 0 });\r\n    }\r\n\r\n    getInningTitle() {\r\n        return this.innings[0].title\r\n    }\r\n\r\n    getInningsQuestions() {\r\n        return this.innings[0].questions\r\n    }\r\n\r\n    setInningCompleted() {\r\n        this.innings[0].completed = true;\r\n    }\r\n\r\n    isInningCompleted() {\r\n        return (this.innings[0].completed)\r\n            ? true\r\n            : false\r\n    }\r\n\r\n    createWickets() {\r\n        for (let i = 0; i < 11; i++) {\r\n            let player = new _Player__WEBPACK_IMPORTED_MODULE_0__[\"default\"](i);\r\n            player.setStatus(\"DISABLE\");\r\n            this\r\n                .players\r\n                .push(player);\r\n        }\r\n\r\n        this.setStriker(this.playerCounter);\r\n        this.playerCounter++;\r\n        this.setRunner(this.playerCounter);\r\n    }\r\n\r\n    getPlayerStates() {\r\n        return this.players\r\n    }\r\n\r\n    getTeamName() {\r\n        return this\r\n            .name\r\n            .toString();\r\n    }\r\n\r\n    getTeamId() {\r\n        return this.id;\r\n    }\r\n\r\n    addRun(run) {\r\n        this.runs += run;\r\n    }\r\n\r\n    getScore() {\r\n        return this.runs\r\n    }\r\n\r\n    wicketsDown() {\r\n        return this.wickets\r\n    }\r\n\r\n    remainingWickets() {\r\n        return (this.players.length - this.wickets)\r\n    }\r\n\r\n    message() {\r\n        return \"team message\"\r\n    }\r\n\r\n    countOver() {\r\n        return this.over\r\n    }\r\n\r\n    getBallCount() {\r\n        return this.over.length\r\n    }\r\n\r\n    getBallVO() {\r\n        return this.ballVO[this.over.length]\r\n    }\r\n\r\n    rotateStrike() {\r\n        let tmp = this.getStriker();\r\n        this.striker = this.runner;\r\n        this\r\n            .striker\r\n            .setStatus(\"STRIKE\");\r\n        this.runner = tmp;\r\n        this\r\n            .runner\r\n            .setStatus(\"RUNNER\");\r\n    }\r\n\r\n    setStriker(p) {\r\n        this.striker = this.players[p];\r\n        this\r\n            .striker\r\n            .setStatus(\"STRIKE\");\r\n    }\r\n    getStriker() {\r\n        return this.striker\r\n    }\r\n\r\n    setRunner(p) {\r\n        this.runner = this.players[p];\r\n        this\r\n            .runner\r\n            .setStatus(\"RUNNER\");\r\n\r\n    }\r\n    getRunner() {\r\n        return this.runner\r\n    }\r\n\r\n    getLastDownScore() {\r\n        return this\r\n            .players[this.lastPlayerDown]\r\n            .getPlayerScore()\r\n    }\r\n\r\n    strokePlayed(stroke) {\r\n\r\n        let ballValue;\r\n\r\n        if (stroke.value === -1) {\r\n            ballValue = \"W\";\r\n            this.wickets++;\r\n            (this.getStriker()).setStatus(\"OUT\");\r\n            this.lastPlayerDown = this\r\n                .getStriker()\r\n                .id;\r\n            this.playerCounter++;\r\n            this.setStriker(this.playerCounter);\r\n        } else {\r\n            ballValue = stroke.value;\r\n            this.addRun(ballValue);\r\n            this\r\n                .getStriker()\r\n                .scoreRun(ballValue);\r\n\r\n            if (ballValue === 1) {\r\n                this.rotateStrike();\r\n            }\r\n        }\r\n\r\n        this.over.push({ ballValue: ballValue, userselect: stroke.userselect });\r\n        //console.log(\"this.over \", this.over);\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Team);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kZWxzL1RlYW0uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWxzL1RlYW0uanM/MDNiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGxheWVyIGZyb20gXCIuL1BsYXllclwiO1xyXG5cclxuY2xhc3MgVGVhbSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoaWQsIG5hbWUpIHtcclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHJcbiAgICAgICAgdGhpcy5pbm5pbmdzID0gW107XHJcbiAgICAgICAgdGhpcy5ydW5zID0gMDtcclxuICAgICAgICB0aGlzLm92ZXIgPSBbXTtcclxuICAgICAgICB0aGlzLndpY2tldHMgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnBsYXllcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnBsYXllckNvdW50ZXIgPSAwO1xyXG4gICAgICAgIHRoaXMubGFzdFBsYXllckRvd24gPSAtMTtcclxuXHJcbiAgICAgICAgdGhpcy5iYWxsVk8gPSBbXHJcbiAgICAgICAgICAgICdhX2JhbGwxJyxcclxuICAgICAgICAgICAgJ2FfYmFsbDInLFxyXG4gICAgICAgICAgICAnYV9iYWxsMycsXHJcbiAgICAgICAgICAgICdhX2JhbGw0JyxcclxuICAgICAgICAgICAgJ2FfYmFsbDUnLFxyXG4gICAgICAgICAgICAnYV9iYWxsNidcclxuICAgICAgICBdXHJcblxyXG4gICAgICAgIHRoaXMuY3JlYXRlV2lja2V0cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFF1ZXN0aW9ucyhxLCB0KSB7XHJcbiAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAuaW5uaW5nc1xyXG4gICAgICAgICAgICAucHVzaCh7ICdxdWVzdGlvbnMnOiBxLCAndGl0bGUnOiB0LCAnY29tcGxldGVkJzogZmFsc2UsICdydW5zJzogMCB9KTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRJbm5pbmdUaXRsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbm5pbmdzWzBdLnRpdGxlXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SW5uaW5nc1F1ZXN0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbm5pbmdzWzBdLnF1ZXN0aW9uc1xyXG4gICAgfVxyXG5cclxuICAgIHNldElubmluZ0NvbXBsZXRlZCgpIHtcclxuICAgICAgICB0aGlzLmlubmluZ3NbMF0uY29tcGxldGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpc0lubmluZ0NvbXBsZXRlZCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuaW5uaW5nc1swXS5jb21wbGV0ZWQpXHJcbiAgICAgICAgICAgID8gdHJ1ZVxyXG4gICAgICAgICAgICA6IGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlV2lja2V0cygpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDExOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHBsYXllciA9IG5ldyBQbGF5ZXIoaSk7XHJcbiAgICAgICAgICAgIHBsYXllci5zZXRTdGF0dXMoXCJESVNBQkxFXCIpO1xyXG4gICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgICAgICAucGxheWVyc1xyXG4gICAgICAgICAgICAgICAgLnB1c2gocGxheWVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0U3RyaWtlcih0aGlzLnBsYXllckNvdW50ZXIpO1xyXG4gICAgICAgIHRoaXMucGxheWVyQ291bnRlcisrO1xyXG4gICAgICAgIHRoaXMuc2V0UnVubmVyKHRoaXMucGxheWVyQ291bnRlcik7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UGxheWVyU3RhdGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBsYXllcnNcclxuICAgIH1cclxuXHJcbiAgICBnZXRUZWFtTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICAubmFtZVxyXG4gICAgICAgICAgICAudG9TdHJpbmcoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRUZWFtSWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkUnVuKHJ1bikge1xyXG4gICAgICAgIHRoaXMucnVucyArPSBydW47XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U2NvcmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuc1xyXG4gICAgfVxyXG5cclxuICAgIHdpY2tldHNEb3duKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndpY2tldHNcclxuICAgIH1cclxuXHJcbiAgICByZW1haW5pbmdXaWNrZXRzKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5wbGF5ZXJzLmxlbmd0aCAtIHRoaXMud2lja2V0cylcclxuICAgIH1cclxuXHJcbiAgICBtZXNzYWdlKCkge1xyXG4gICAgICAgIHJldHVybiBcInRlYW0gbWVzc2FnZVwiXHJcbiAgICB9XHJcblxyXG4gICAgY291bnRPdmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm92ZXJcclxuICAgIH1cclxuXHJcbiAgICBnZXRCYWxsQ291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3Zlci5sZW5ndGhcclxuICAgIH1cclxuXHJcbiAgICBnZXRCYWxsVk8oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFsbFZPW3RoaXMub3Zlci5sZW5ndGhdXHJcbiAgICB9XHJcblxyXG4gICAgcm90YXRlU3RyaWtlKCkge1xyXG4gICAgICAgIGxldCB0bXAgPSB0aGlzLmdldFN0cmlrZXIoKTtcclxuICAgICAgICB0aGlzLnN0cmlrZXIgPSB0aGlzLnJ1bm5lcjtcclxuICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgIC5zdHJpa2VyXHJcbiAgICAgICAgICAgIC5zZXRTdGF0dXMoXCJTVFJJS0VcIik7XHJcbiAgICAgICAgdGhpcy5ydW5uZXIgPSB0bXA7XHJcbiAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAucnVubmVyXHJcbiAgICAgICAgICAgIC5zZXRTdGF0dXMoXCJSVU5ORVJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0U3RyaWtlcihwKSB7XHJcbiAgICAgICAgdGhpcy5zdHJpa2VyID0gdGhpcy5wbGF5ZXJzW3BdO1xyXG4gICAgICAgIHRoaXNcclxuICAgICAgICAgICAgLnN0cmlrZXJcclxuICAgICAgICAgICAgLnNldFN0YXR1cyhcIlNUUklLRVwiKTtcclxuICAgIH1cclxuICAgIGdldFN0cmlrZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaWtlclxyXG4gICAgfVxyXG5cclxuICAgIHNldFJ1bm5lcihwKSB7XHJcbiAgICAgICAgdGhpcy5ydW5uZXIgPSB0aGlzLnBsYXllcnNbcF07XHJcbiAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAucnVubmVyXHJcbiAgICAgICAgICAgIC5zZXRTdGF0dXMoXCJSVU5ORVJcIik7XHJcblxyXG4gICAgfVxyXG4gICAgZ2V0UnVubmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bm5lclxyXG4gICAgfVxyXG5cclxuICAgIGdldExhc3REb3duU2NvcmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgICAgLnBsYXllcnNbdGhpcy5sYXN0UGxheWVyRG93bl1cclxuICAgICAgICAgICAgLmdldFBsYXllclNjb3JlKClcclxuICAgIH1cclxuXHJcbiAgICBzdHJva2VQbGF5ZWQoc3Ryb2tlKSB7XHJcblxyXG4gICAgICAgIGxldCBiYWxsVmFsdWU7XHJcblxyXG4gICAgICAgIGlmIChzdHJva2UudmFsdWUgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGJhbGxWYWx1ZSA9IFwiV1wiO1xyXG4gICAgICAgICAgICB0aGlzLndpY2tldHMrKztcclxuICAgICAgICAgICAgKHRoaXMuZ2V0U3RyaWtlcigpKS5zZXRTdGF0dXMoXCJPVVRcIik7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFBsYXllckRvd24gPSB0aGlzXHJcbiAgICAgICAgICAgICAgICAuZ2V0U3RyaWtlcigpXHJcbiAgICAgICAgICAgICAgICAuaWQ7XHJcbiAgICAgICAgICAgIHRoaXMucGxheWVyQ291bnRlcisrO1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0cmlrZXIodGhpcy5wbGF5ZXJDb3VudGVyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBiYWxsVmFsdWUgPSBzdHJva2UudmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkUnVuKGJhbGxWYWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgICAgIC5nZXRTdHJpa2VyKClcclxuICAgICAgICAgICAgICAgIC5zY29yZVJ1bihiYWxsVmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGJhbGxWYWx1ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGVTdHJpa2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vdmVyLnB1c2goeyBiYWxsVmFsdWU6IGJhbGxWYWx1ZSwgdXNlcnNlbGVjdDogc3Ryb2tlLnVzZXJzZWxlY3QgfSk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInRoaXMub3ZlciBcIiwgdGhpcy5vdmVyKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRlYW0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/models/Team.js\n");

/***/ }),

/***/ "./src/models/TeamData.js":
/*!********************************!*\
  !*** ./src/models/TeamData.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass TeamData { }\r\n\r\n\r\nTeamData.randomize = false;\r\nTeamData.timeConfig = {\r\n    \"0\": [0, 0, 0, 0, 0],\r\n    \"20\": [20, 15, 10, 5, 0],\r\n    \"30\": [30, 23, 16, 9, 0],\r\n    \"40\": [40, 30, 20, 10, 0]\r\n};\r\n\r\nTeamData.timeDivision = [];\r\n\r\nTeamData.caught = [\"a_caught1\", \"a_caught2\", \"a_caught3\"];\r\nTeamData.bowled = [\"a_bowled1\", \"a_bowled2\"];\r\n\r\nTeamData.strikeName = [\r\n    {\r\n        \"vo\": [\r\n            \"a_six5\", \"a_six1\", \"a_six2\", \"a_six3\", \"a_six4\", \"a_six1\"\r\n        ],\r\n        \"cheers\": \"cheers6\",\r\n        \"txt\": \"Strike for Six\",\r\n        \"label\": \"sixer\",\r\n        \"value\": 6\r\n    }, {\r\n        \"vo\": [\r\n            \"a_six5\", \"a_six1\", \"a_six2\", \"a_six3\", \"a_six4\", \"a_six1\"\r\n        ],\r\n        \"cheers\": \"cheers6\",\r\n        \"txt\": \"Strike for Six\",\r\n        \"label\": \"sixer2\",\r\n        \"value\": 6\r\n    }, {\r\n        \"vo\": [\r\n            \"a_four5\", \"a_four1\", \"a_four2\", \"a_four3\", \"a_four4\", \"a_four4\"\r\n        ],\r\n        \"cheers\": \"cheers4\",\r\n        \"txt\": \"Strike for Four\",\r\n        \"label\": \"boundary\",\r\n        \"value\": 4\r\n    }, {\r\n        \"vo\": [\r\n            \"a_two4\", \"a_two1\", \"a_two2\", \"a_two2\", \"a_two2\", \"a_two3\"\r\n        ],\r\n        \"cheers\": \"cheers1\",\r\n        \"txt\": \"Strike for Two\",\r\n        \"label\": \"doubles\",\r\n        \"value\": 2\r\n    }, {\r\n        \"vo\": [\r\n            \"a_one1\", \"a_one1\", \"a_one2\", \"a_one3\", \"a_one4\", \"a_one4\"\r\n        ],\r\n        \"cheers\": \"cheers1\",\r\n        \"txt\": \"Strike for One\",\r\n        \"label\": \"singles\",\r\n        \"value\": 1\r\n    }, {\r\n        \"vo\": [\r\n            \"NoRun\", \"NoRun\", \"NoRun\", \"NoRun\", \"NoRun\", \"NoRun\"\r\n        ],\r\n        \"cheers\": \"stadium_noise\",\r\n        \"txt\": \"Strike for Zero\",\r\n        \"label\": \"dot\",\r\n        \"value\": 0\r\n    }\r\n];\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (TeamData);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kZWxzL1RlYW1EYXRhLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVscy9UZWFtRGF0YS5qcz8xNDYzIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFRlYW1EYXRhIHsgfVxyXG5cclxuXHJcblRlYW1EYXRhLnJhbmRvbWl6ZSA9IGZhbHNlO1xyXG5UZWFtRGF0YS50aW1lQ29uZmlnID0ge1xyXG4gICAgXCIwXCI6IFswLCAwLCAwLCAwLCAwXSxcclxuICAgIFwiMjBcIjogWzIwLCAxNSwgMTAsIDUsIDBdLFxyXG4gICAgXCIzMFwiOiBbMzAsIDIzLCAxNiwgOSwgMF0sXHJcbiAgICBcIjQwXCI6IFs0MCwgMzAsIDIwLCAxMCwgMF1cclxufTtcclxuXHJcblRlYW1EYXRhLnRpbWVEaXZpc2lvbiA9IFtdO1xyXG5cclxuVGVhbURhdGEuY2F1Z2h0ID0gW1wiYV9jYXVnaHQxXCIsIFwiYV9jYXVnaHQyXCIsIFwiYV9jYXVnaHQzXCJdO1xyXG5UZWFtRGF0YS5ib3dsZWQgPSBbXCJhX2Jvd2xlZDFcIiwgXCJhX2Jvd2xlZDJcIl07XHJcblxyXG5UZWFtRGF0YS5zdHJpa2VOYW1lID0gW1xyXG4gICAge1xyXG4gICAgICAgIFwidm9cIjogW1xyXG4gICAgICAgICAgICBcImFfc2l4NVwiLCBcImFfc2l4MVwiLCBcImFfc2l4MlwiLCBcImFfc2l4M1wiLCBcImFfc2l4NFwiLCBcImFfc2l4MVwiXHJcbiAgICAgICAgXSxcclxuICAgICAgICBcImNoZWVyc1wiOiBcImNoZWVyczZcIixcclxuICAgICAgICBcInR4dFwiOiBcIlN0cmlrZSBmb3IgU2l4XCIsXHJcbiAgICAgICAgXCJsYWJlbFwiOiBcInNpeGVyXCIsXHJcbiAgICAgICAgXCJ2YWx1ZVwiOiA2XHJcbiAgICB9LCB7XHJcbiAgICAgICAgXCJ2b1wiOiBbXHJcbiAgICAgICAgICAgIFwiYV9zaXg1XCIsIFwiYV9zaXgxXCIsIFwiYV9zaXgyXCIsIFwiYV9zaXgzXCIsIFwiYV9zaXg0XCIsIFwiYV9zaXgxXCJcclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiY2hlZXJzXCI6IFwiY2hlZXJzNlwiLFxyXG4gICAgICAgIFwidHh0XCI6IFwiU3RyaWtlIGZvciBTaXhcIixcclxuICAgICAgICBcImxhYmVsXCI6IFwic2l4ZXIyXCIsXHJcbiAgICAgICAgXCJ2YWx1ZVwiOiA2XHJcbiAgICB9LCB7XHJcbiAgICAgICAgXCJ2b1wiOiBbXHJcbiAgICAgICAgICAgIFwiYV9mb3VyNVwiLCBcImFfZm91cjFcIiwgXCJhX2ZvdXIyXCIsIFwiYV9mb3VyM1wiLCBcImFfZm91cjRcIiwgXCJhX2ZvdXI0XCJcclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiY2hlZXJzXCI6IFwiY2hlZXJzNFwiLFxyXG4gICAgICAgIFwidHh0XCI6IFwiU3RyaWtlIGZvciBGb3VyXCIsXHJcbiAgICAgICAgXCJsYWJlbFwiOiBcImJvdW5kYXJ5XCIsXHJcbiAgICAgICAgXCJ2YWx1ZVwiOiA0XHJcbiAgICB9LCB7XHJcbiAgICAgICAgXCJ2b1wiOiBbXHJcbiAgICAgICAgICAgIFwiYV90d280XCIsIFwiYV90d28xXCIsIFwiYV90d28yXCIsIFwiYV90d28yXCIsIFwiYV90d28yXCIsIFwiYV90d28zXCJcclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiY2hlZXJzXCI6IFwiY2hlZXJzMVwiLFxyXG4gICAgICAgIFwidHh0XCI6IFwiU3RyaWtlIGZvciBUd29cIixcclxuICAgICAgICBcImxhYmVsXCI6IFwiZG91Ymxlc1wiLFxyXG4gICAgICAgIFwidmFsdWVcIjogMlxyXG4gICAgfSwge1xyXG4gICAgICAgIFwidm9cIjogW1xyXG4gICAgICAgICAgICBcImFfb25lMVwiLCBcImFfb25lMVwiLCBcImFfb25lMlwiLCBcImFfb25lM1wiLCBcImFfb25lNFwiLCBcImFfb25lNFwiXHJcbiAgICAgICAgXSxcclxuICAgICAgICBcImNoZWVyc1wiOiBcImNoZWVyczFcIixcclxuICAgICAgICBcInR4dFwiOiBcIlN0cmlrZSBmb3IgT25lXCIsXHJcbiAgICAgICAgXCJsYWJlbFwiOiBcInNpbmdsZXNcIixcclxuICAgICAgICBcInZhbHVlXCI6IDFcclxuICAgIH0sIHtcclxuICAgICAgICBcInZvXCI6IFtcclxuICAgICAgICAgICAgXCJOb1J1blwiLCBcIk5vUnVuXCIsIFwiTm9SdW5cIiwgXCJOb1J1blwiLCBcIk5vUnVuXCIsIFwiTm9SdW5cIlxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJjaGVlcnNcIjogXCJzdGFkaXVtX25vaXNlXCIsXHJcbiAgICAgICAgXCJ0eHRcIjogXCJTdHJpa2UgZm9yIFplcm9cIixcclxuICAgICAgICBcImxhYmVsXCI6IFwiZG90XCIsXHJcbiAgICAgICAgXCJ2YWx1ZVwiOiAwXHJcbiAgICB9XHJcbl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUZWFtRGF0YSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/models/TeamData.js\n");

/***/ }),

/***/ "./src/models/Umpire.js":
/*!******************************!*\
  !*** ./src/models/Umpire.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Utils */ \"./src/utils/Utils.js\");\n/* harmony import */ var _Team__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Team */ \"./src/models/Team.js\");\n/* harmony import */ var _TeamData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TeamData */ \"./src/models/TeamData.js\");\n/* harmony import */ var _GameEvent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GameEvent */ \"./src/models/GameEvent.js\");\n\r\n\r\n\r\n\r\n\r\nclass Umpire {\r\n\r\n    whoWonToss() {\r\n        return this.teamWonToss\r\n    }\r\n\r\n    Toss() {\r\n        //.. decision for toss\r\n        this.teamWonToss = _utils_Utils__WEBPACK_IMPORTED_MODULE_0__[\"ArrayUtils\"].getRandomBool()\r\n            ? \"Red\"\r\n            : \"Blue\";\r\n\r\n        this.teamOrder = [];\r\n        this.teamOrderInc = 0;\r\n        this.setTeam();\r\n    }\r\n\r\n    getBattingTeam() {\r\n        return this.battingTeam\r\n    }\r\n\r\n    setTeam() {\r\n\r\n        this.teamA1 = new _Team__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"Red\", \"Team 2\");\r\n        this.teamB1 = new _Team__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"Blue\", \"Team 1\");\r\n        this.teamA2 = new _Team__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"Red\", \"Team 2\");\r\n        this.teamB2 = new _Team__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"Blue\", \"Team 1\");\r\n\r\n        if (this.teamWonToss === \"Red\") {\r\n            this.teamOrder = [this.teamA1, this.teamB1, this.teamA2, this.teamB2];\r\n        } else {\r\n            this.teamOrder = [this.teamB1, this.teamA1, this.teamB2, this.teamA2];\r\n        }\r\n        this.battingTeam = this.teamOrder[this.teamOrderInc];\r\n    }\r\n\r\n    startGame(xml, devMode) {\r\n\r\n        let q_arr = xml.GameContent.Gamedata.GameEdge.game.questions.question;\r\n\r\n        /* -- randomize questions and options -- */\r\n        //let toRandomize = xml.GameContent.metadata.gameRules._randamizeQmode; // taken from xml\r\n        let toRandomize = _TeamData__WEBPACK_IMPORTED_MODULE_2__[\"default\"].randomize; // from user config\r\n\r\n        if (toRandomize) {\r\n            q_arr.forEach((each, i) => {\r\n                q_arr[i].option = _utils_Utils__WEBPACK_IMPORTED_MODULE_0__[\"ArrayUtils\"].shuffleArray(each.option);\r\n            })\r\n            q_arr = _utils_Utils__WEBPACK_IMPORTED_MODULE_0__[\"ArrayUtils\"].shuffleArray(xml.GameContent.Gamedata.GameEdge.game.questions.question);\r\n        }\r\n\r\n        let _start = 0;\r\n        let _inc = devMode ? 2 : 6;\r\n        //let _inc = 2;\r\n        let _end = _start + _inc;\r\n        let slicingArrTitle = [\"First Innnings\", \"First Innnings\", \"Second Innings\", \"Second Innings\"];\r\n\r\n        this.teamOrder.forEach((team, id) => {\r\n\r\n            team.setQuestions(q_arr.slice(_start, _end), slicingArrTitle[id]);\r\n            //console.log(\"(\", _start, \", \", _end, \")\");\r\n            _start = _end;\r\n            _end = _start + _inc;\r\n\r\n        });\r\n\r\n        this.getInningsOver();\r\n    }\r\n\r\n    setInningTitle() {\r\n        this.inningsTitle = this\r\n            .getBattingTeam()\r\n            .getInningTitle();\r\n    }\r\n\r\n    getInningTitle() {\r\n        return this.inningsTitle\r\n    }\r\n\r\n    getMatchStat() {\r\n        return this.getStats()\r\n    }\r\n\r\n    getStats() {\r\n\r\n        this.gameStat = {\r\n            \"FirstBatted\": this\r\n                .teamOrder[0]\r\n                .getTeamId(),\r\n            \"SecondBatted\": this\r\n                .teamOrder[1]\r\n                .getTeamId(),\r\n            \"TeamBatting\": this.getBattingTeam(),\r\n            \"winner\": {},\r\n            \"inning\": this.teamOrderInc,\r\n            \"TeamRed\": 0,\r\n            \"TeamBlue\": 0,\r\n            \"runDiff\": 0,\r\n            \"r_msg\": '',\r\n            \"msg\": '',\r\n            \"s_msg\": '',\r\n            \"gameover\": false\r\n        }\r\n\r\n        this\r\n            .teamOrder\r\n            .forEach((each, i) => {\r\n                this.gameStat[\"Team\" + each.getTeamId()] += each.getScore();\r\n            })\r\n\r\n        this.gameStat.runDiff = this.gameStat[\"Team\" + this.gameStat.FirstBatted] - this.gameStat[\"Team\" + this.gameStat.SecondBatted];\r\n\r\n        let m = '';\r\n        let runsLiteral = (Math.abs(this.gameStat.runDiff) > 1) ? \" runs\" : \" run\";\r\n\r\n        switch (this.teamOrderInc) {\r\n            case 0:\r\n\r\n                this.gameStat.msg = this\r\n                    .teamOrder[0]\r\n                    .getTeamName() + \" scored \" + this.gameStat.runDiff + runsLiteral + \". You need to score many more runs to lead in the match.\";\r\n                this.gameStat.s_msg = \"\"; //\"Runs: \" + Math.abs(this.gameStat.runDiff);\r\n                break;\r\n\r\n            case 1:\r\n\r\n                this.gameStat.msg = this.teamOrder[0].getTeamName() + \" scored \" + this.gameStat[\"Team\" + this.gameStat.FirstBatted] + runsLiteral + \". \" +\r\n                    this.teamOrder[1].getTeamName() + \" scored \" + this.gameStat[\"Team\" + this.gameStat.SecondBatted] + runsLiteral + \".\";\r\n                /* this.gameStat.msg = this.gameStat.SecondBatted + \" is \" + ((this.gameStat.runDiff < 0)\r\n                    ? \" leading by \"\r\n                    : \" trailling by \") + Math.abs(this.gameStat.runDiff) + \" runs.\"; */\r\n                m = (this.gameStat.runDiff < 1)\r\n                    ? \"Lead: \"\r\n                    : \"Trail: \";\r\n\r\n                this.gameStat.s_msg = (m + Math.abs(this.gameStat.runDiff)) + runsLiteral;\r\n                break;\r\n\r\n            case 2:\r\n\r\n                if (this.teamOrder[2].isInningCompleted()) {\r\n                    if (this.gameStat[\"Team\" + this.gameStat.SecondBatted] > this.gameStat[\"Team\" + this.gameStat.FirstBatted]) {\r\n                        this.gameStat.msg = this.teamOrder[1].getTeamName() + \" won by \" + Math.abs(this.gameStat.runDiff) + runsLiteral + \".\";\r\n                        this.gameStat.gameover = true;\r\n                        this.gameStat.winner = this.gameStat.SecondBatted;\r\n                    } else {\r\n\r\n                        this.gameStat.msg = this\r\n                            .teamOrder[0]\r\n                            .getTeamName() + \" scored \" + this.gameStat[\"Team\" + this.gameStat.FirstBatted] + runsLiteral + \". You need to score \" + (Math.abs(this.gameStat.runDiff) + 1) + \" more runs to win the match.\";\r\n                    }\r\n                }\r\n\r\n                m = (this.gameStat.runDiff > -1)\r\n                    ? \"Lead: \"\r\n                    : \"Trail: \";\r\n\r\n                this.gameStat.s_msg = this.gameStat.gameover ? this.gameStat.msg : (m + Math.abs(this.gameStat.runDiff)) + runsLiteral;\r\n\r\n                break;\r\n\r\n            case 3:\r\n\r\n\r\n\r\n                if (this.gameStat[\"Team\" + this.gameStat.SecondBatted] > this.gameStat[\"Team\" + this.gameStat.FirstBatted]) {\r\n                    //this.gameStat.msg = this.teamOrder[3].getTeamName() + \" won by \" + this.teamOrder[3].remainingWickets() + \" wickets.\";\r\n                    this.gameStat.msg = this.teamOrder[3].getTeamName() + \" won by \" + Math.abs(this.gameStat.runDiff) + runsLiteral;\r\n                    this.gameStat.gameover = true;\r\n                    this.gameStat.winner = this.gameStat.SecondBatted;\r\n                }\r\n\r\n                if (this.teamOrder[this.teamOrderInc].isInningCompleted()) {\r\n                    //final check\r\n                    if (this.gameStat[\"Team\" + this.gameStat.FirstBatted] > this.gameStat[\"Team\" + this.gameStat.SecondBatted]) {\r\n                        this.gameStat.msg = this.teamOrder[0].getTeamName() + \" won by \" + Math.abs(this.gameStat.runDiff) + runsLiteral + \".\";\r\n                        this.gameStat.winner = this.teamOrder[0];\r\n                    } else if (this.gameStat[\"Team\" + this.gameStat.SecondBatted] > this.gameStat[\"Team\" + this.gameStat.FirstBatted]) {\r\n                        this.gameStat.msg = this.teamOrder[3].getTeamName() + \" won by \" + Math.abs(this.gameStat.runDiff) + runsLiteral + \".\";\r\n                        this.gameStat.winner = this.teamOrder[3];\r\n                    } else if (this.gameStat[\"Team\" + this.gameStat.SecondBatted] === this.gameStat[\"Team\" + this.gameStat.FirstBatted]) {\r\n                        this.gameStat.msg = \"Game drawn\";\r\n                        this.gameStat.winner = 'None';\r\n                    }\r\n                    this.gameStat.gameover = true;\r\n                }\r\n\r\n                let runsLiteral2 = ((Math.abs(this.gameStat.runDiff) + 1) > 1) ? \" runs\" : \" run\";\r\n\r\n                this.gameStat.s_msg = this.gameStat.gameover ? this.gameStat.msg : \"Target: \" + (this.gameStat.runDiff + 1) + runsLiteral2;\r\n\r\n                break;\r\n\r\n            default:\r\n        }\r\n        //console.log(this.teamOrderInc, this.gameStat);\r\n        return this.gameStat\r\n\r\n    }\r\n\r\n    getInningsOver() {\r\n        this.inningsQuestions = new _utils_Utils__WEBPACK_IMPORTED_MODULE_0__[\"Iterator\"](this.getBattingTeam().getInningsQuestions()).iterator();\r\n    }\r\n\r\n    continueNextInnings() {\r\n\r\n        //console.log(\"this innings: \", this.teamOrderInc, '   ', this.teamOrder.length, \"getBallCount: \", this.getBattingTeam().getBallCount())\r\n\r\n        //if (!this.gameStat.gameover) {\r\n        if (this.teamOrderInc === (this.teamOrder.length - 1)) {\r\n            window.eventManager.dispatch(_GameEvent__WEBPACK_IMPORTED_MODULE_3__[\"default\"].GAME_OVER, \"null\");\r\n        } else {\r\n            this.switchBatting();\r\n            this.setInningTitle();\r\n            this.getInningsOver();\r\n            this.continueInnings();\r\n        }\r\n    }\r\n\r\n    overUp() {\r\n        this.getBattingTeam().setInningCompleted();\r\n        //.. check if gameover\r\n        if (this.teamOrderInc === (this.teamOrder.length - 1)) {\r\n            window.eventManager.dispatch(_GameEvent__WEBPACK_IMPORTED_MODULE_3__[\"default\"].GAME_OVER, \"null\");\r\n        } else {\r\n            window.eventManager.dispatch(_GameEvent__WEBPACK_IMPORTED_MODULE_3__[\"default\"].SHOW_TEAM_PERFORMANCE, null);\r\n        }\r\n\r\n    }\r\n\r\n    gameOver(p) {\r\n        window.eventManager.dispatch(_GameEvent__WEBPACK_IMPORTED_MODULE_3__[\"default\"].SHOW_TEAM_PERFORMANCE, p);\r\n    }\r\n\r\n    nextBall() {\r\n        let thisBall = this.inningsQuestions.next();\r\n        /* if (thisBall.done) {\r\n            this.getBattingTeam().setInningCompleted();\r\n            this.getStats();\r\n        } */\r\n        return thisBall\r\n    }\r\n\r\n    switchBatting() {\r\n        this.teamOrderInc++;\r\n        this.battingTeam = this.teamOrder[this.teamOrderInc];\r\n    }\r\n\r\n    continueInnings() {\r\n        window.eventManager.dispatch(_GameEvent__WEBPACK_IMPORTED_MODULE_3__[\"default\"].CONTINUE, \"null\");\r\n    }\r\n\r\n    captureShot(s) {\r\n        this.getBattingTeam().strokePlayed(s);\r\n    }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Umpire);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kZWxzL1VtcGlyZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2RlbHMvVW1waXJlLmpzP2UxOGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXJyYXlVdGlscywgSXRlcmF0b3IgfSBmcm9tIFwiLi4vdXRpbHMvVXRpbHNcIjtcclxuaW1wb3J0IFRlYW0gZnJvbSBcIi4vVGVhbVwiO1xyXG5pbXBvcnQgVGVhbURhdGEgZnJvbSBcIi4vVGVhbURhdGFcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi9HYW1lRXZlbnRcIjtcclxuXHJcbmNsYXNzIFVtcGlyZSB7XHJcblxyXG4gICAgd2hvV29uVG9zcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50ZWFtV29uVG9zc1xyXG4gICAgfVxyXG5cclxuICAgIFRvc3MoKSB7XHJcbiAgICAgICAgLy8uLiBkZWNpc2lvbiBmb3IgdG9zc1xyXG4gICAgICAgIHRoaXMudGVhbVdvblRvc3MgPSBBcnJheVV0aWxzLmdldFJhbmRvbUJvb2woKVxyXG4gICAgICAgICAgICA/IFwiUmVkXCJcclxuICAgICAgICAgICAgOiBcIkJsdWVcIjtcclxuXHJcbiAgICAgICAgdGhpcy50ZWFtT3JkZXIgPSBbXTtcclxuICAgICAgICB0aGlzLnRlYW1PcmRlckluYyA9IDA7XHJcbiAgICAgICAgdGhpcy5zZXRUZWFtKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0QmF0dGluZ1RlYW0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0dGluZ1RlYW1cclxuICAgIH1cclxuXHJcbiAgICBzZXRUZWFtKCkge1xyXG5cclxuICAgICAgICB0aGlzLnRlYW1BMSA9IG5ldyBUZWFtKFwiUmVkXCIsIFwiVGVhbSAyXCIpO1xyXG4gICAgICAgIHRoaXMudGVhbUIxID0gbmV3IFRlYW0oXCJCbHVlXCIsIFwiVGVhbSAxXCIpO1xyXG4gICAgICAgIHRoaXMudGVhbUEyID0gbmV3IFRlYW0oXCJSZWRcIiwgXCJUZWFtIDJcIik7XHJcbiAgICAgICAgdGhpcy50ZWFtQjIgPSBuZXcgVGVhbShcIkJsdWVcIiwgXCJUZWFtIDFcIik7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnRlYW1Xb25Ub3NzID09PSBcIlJlZFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGVhbU9yZGVyID0gW3RoaXMudGVhbUExLCB0aGlzLnRlYW1CMSwgdGhpcy50ZWFtQTIsIHRoaXMudGVhbUIyXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRlYW1PcmRlciA9IFt0aGlzLnRlYW1CMSwgdGhpcy50ZWFtQTEsIHRoaXMudGVhbUIyLCB0aGlzLnRlYW1BMl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYmF0dGluZ1RlYW0gPSB0aGlzLnRlYW1PcmRlclt0aGlzLnRlYW1PcmRlckluY107XHJcbiAgICB9XHJcblxyXG4gICAgc3RhcnRHYW1lKHhtbCwgZGV2TW9kZSkge1xyXG5cclxuICAgICAgICBsZXQgcV9hcnIgPSB4bWwuR2FtZUNvbnRlbnQuR2FtZWRhdGEuR2FtZUVkZ2UuZ2FtZS5xdWVzdGlvbnMucXVlc3Rpb247XHJcblxyXG4gICAgICAgIC8qIC0tIHJhbmRvbWl6ZSBxdWVzdGlvbnMgYW5kIG9wdGlvbnMgLS0gKi9cclxuICAgICAgICAvL2xldCB0b1JhbmRvbWl6ZSA9IHhtbC5HYW1lQ29udGVudC5tZXRhZGF0YS5nYW1lUnVsZXMuX3JhbmRhbWl6ZVFtb2RlOyAvLyB0YWtlbiBmcm9tIHhtbFxyXG4gICAgICAgIGxldCB0b1JhbmRvbWl6ZSA9IFRlYW1EYXRhLnJhbmRvbWl6ZTsgLy8gZnJvbSB1c2VyIGNvbmZpZ1xyXG5cclxuICAgICAgICBpZiAodG9SYW5kb21pemUpIHtcclxuICAgICAgICAgICAgcV9hcnIuZm9yRWFjaCgoZWFjaCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcV9hcnJbaV0ub3B0aW9uID0gQXJyYXlVdGlscy5zaHVmZmxlQXJyYXkoZWFjaC5vcHRpb24pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBxX2FyciA9IEFycmF5VXRpbHMuc2h1ZmZsZUFycmF5KHhtbC5HYW1lQ29udGVudC5HYW1lZGF0YS5HYW1lRWRnZS5nYW1lLnF1ZXN0aW9ucy5xdWVzdGlvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgX3N0YXJ0ID0gMDtcclxuICAgICAgICBsZXQgX2luYyA9IGRldk1vZGUgPyAyIDogNjtcclxuICAgICAgICAvL2xldCBfaW5jID0gMjtcclxuICAgICAgICBsZXQgX2VuZCA9IF9zdGFydCArIF9pbmM7XHJcbiAgICAgICAgbGV0IHNsaWNpbmdBcnJUaXRsZSA9IFtcIkZpcnN0IElubm5pbmdzXCIsIFwiRmlyc3QgSW5ubmluZ3NcIiwgXCJTZWNvbmQgSW5uaW5nc1wiLCBcIlNlY29uZCBJbm5pbmdzXCJdO1xyXG5cclxuICAgICAgICB0aGlzLnRlYW1PcmRlci5mb3JFYWNoKCh0ZWFtLCBpZCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgdGVhbS5zZXRRdWVzdGlvbnMocV9hcnIuc2xpY2UoX3N0YXJ0LCBfZW5kKSwgc2xpY2luZ0FyclRpdGxlW2lkXSk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCIoXCIsIF9zdGFydCwgXCIsIFwiLCBfZW5kLCBcIilcIik7XHJcbiAgICAgICAgICAgIF9zdGFydCA9IF9lbmQ7XHJcbiAgICAgICAgICAgIF9lbmQgPSBfc3RhcnQgKyBfaW5jO1xyXG5cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5nZXRJbm5pbmdzT3ZlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldElubmluZ1RpdGxlKCkge1xyXG4gICAgICAgIHRoaXMuaW5uaW5nc1RpdGxlID0gdGhpc1xyXG4gICAgICAgICAgICAuZ2V0QmF0dGluZ1RlYW0oKVxyXG4gICAgICAgICAgICAuZ2V0SW5uaW5nVGl0bGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRJbm5pbmdUaXRsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbm5pbmdzVGl0bGVcclxuICAgIH1cclxuXHJcbiAgICBnZXRNYXRjaFN0YXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdHMoKVxyXG4gICAgfVxyXG5cclxuICAgIGdldFN0YXRzKCkge1xyXG5cclxuICAgICAgICB0aGlzLmdhbWVTdGF0ID0ge1xyXG4gICAgICAgICAgICBcIkZpcnN0QmF0dGVkXCI6IHRoaXNcclxuICAgICAgICAgICAgICAgIC50ZWFtT3JkZXJbMF1cclxuICAgICAgICAgICAgICAgIC5nZXRUZWFtSWQoKSxcclxuICAgICAgICAgICAgXCJTZWNvbmRCYXR0ZWRcIjogdGhpc1xyXG4gICAgICAgICAgICAgICAgLnRlYW1PcmRlclsxXVxyXG4gICAgICAgICAgICAgICAgLmdldFRlYW1JZCgpLFxyXG4gICAgICAgICAgICBcIlRlYW1CYXR0aW5nXCI6IHRoaXMuZ2V0QmF0dGluZ1RlYW0oKSxcclxuICAgICAgICAgICAgXCJ3aW5uZXJcIjoge30sXHJcbiAgICAgICAgICAgIFwiaW5uaW5nXCI6IHRoaXMudGVhbU9yZGVySW5jLFxyXG4gICAgICAgICAgICBcIlRlYW1SZWRcIjogMCxcclxuICAgICAgICAgICAgXCJUZWFtQmx1ZVwiOiAwLFxyXG4gICAgICAgICAgICBcInJ1bkRpZmZcIjogMCxcclxuICAgICAgICAgICAgXCJyX21zZ1wiOiAnJyxcclxuICAgICAgICAgICAgXCJtc2dcIjogJycsXHJcbiAgICAgICAgICAgIFwic19tc2dcIjogJycsXHJcbiAgICAgICAgICAgIFwiZ2FtZW92ZXJcIjogZmFsc2VcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXNcclxuICAgICAgICAgICAgLnRlYW1PcmRlclxyXG4gICAgICAgICAgICAuZm9yRWFjaCgoZWFjaCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lU3RhdFtcIlRlYW1cIiArIGVhY2guZ2V0VGVhbUlkKCldICs9IGVhY2guZ2V0U2NvcmUoKTtcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgdGhpcy5nYW1lU3RhdC5ydW5EaWZmID0gdGhpcy5nYW1lU3RhdFtcIlRlYW1cIiArIHRoaXMuZ2FtZVN0YXQuRmlyc3RCYXR0ZWRdIC0gdGhpcy5nYW1lU3RhdFtcIlRlYW1cIiArIHRoaXMuZ2FtZVN0YXQuU2Vjb25kQmF0dGVkXTtcclxuXHJcbiAgICAgICAgbGV0IG0gPSAnJztcclxuICAgICAgICBsZXQgcnVuc0xpdGVyYWwgPSAoTWF0aC5hYnModGhpcy5nYW1lU3RhdC5ydW5EaWZmKSA+IDEpID8gXCIgcnVuc1wiIDogXCIgcnVuXCI7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodGhpcy50ZWFtT3JkZXJJbmMpIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZVN0YXQubXNnID0gdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIC50ZWFtT3JkZXJbMF1cclxuICAgICAgICAgICAgICAgICAgICAuZ2V0VGVhbU5hbWUoKSArIFwiIHNjb3JlZCBcIiArIHRoaXMuZ2FtZVN0YXQucnVuRGlmZiArIHJ1bnNMaXRlcmFsICsgXCIuIFlvdSBuZWVkIHRvIHNjb3JlIG1hbnkgbW9yZSBydW5zIHRvIGxlYWQgaW4gdGhlIG1hdGNoLlwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lU3RhdC5zX21zZyA9IFwiXCI7IC8vXCJSdW5zOiBcIiArIE1hdGguYWJzKHRoaXMuZ2FtZVN0YXQucnVuRGlmZik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWVTdGF0Lm1zZyA9IHRoaXMudGVhbU9yZGVyWzBdLmdldFRlYW1OYW1lKCkgKyBcIiBzY29yZWQgXCIgKyB0aGlzLmdhbWVTdGF0W1wiVGVhbVwiICsgdGhpcy5nYW1lU3RhdC5GaXJzdEJhdHRlZF0gKyBydW5zTGl0ZXJhbCArIFwiLiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZWFtT3JkZXJbMV0uZ2V0VGVhbU5hbWUoKSArIFwiIHNjb3JlZCBcIiArIHRoaXMuZ2FtZVN0YXRbXCJUZWFtXCIgKyB0aGlzLmdhbWVTdGF0LlNlY29uZEJhdHRlZF0gKyBydW5zTGl0ZXJhbCArIFwiLlwiO1xyXG4gICAgICAgICAgICAgICAgLyogdGhpcy5nYW1lU3RhdC5tc2cgPSB0aGlzLmdhbWVTdGF0LlNlY29uZEJhdHRlZCArIFwiIGlzIFwiICsgKCh0aGlzLmdhbWVTdGF0LnJ1bkRpZmYgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgID8gXCIgbGVhZGluZyBieSBcIlxyXG4gICAgICAgICAgICAgICAgICAgIDogXCIgdHJhaWxsaW5nIGJ5IFwiKSArIE1hdGguYWJzKHRoaXMuZ2FtZVN0YXQucnVuRGlmZikgKyBcIiBydW5zLlwiOyAqL1xyXG4gICAgICAgICAgICAgICAgbSA9ICh0aGlzLmdhbWVTdGF0LnJ1bkRpZmYgPCAxKVxyXG4gICAgICAgICAgICAgICAgICAgID8gXCJMZWFkOiBcIlxyXG4gICAgICAgICAgICAgICAgICAgIDogXCJUcmFpbDogXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lU3RhdC5zX21zZyA9IChtICsgTWF0aC5hYnModGhpcy5nYW1lU3RhdC5ydW5EaWZmKSkgKyBydW5zTGl0ZXJhbDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAyOlxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRlYW1PcmRlclsyXS5pc0lubmluZ0NvbXBsZXRlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2FtZVN0YXRbXCJUZWFtXCIgKyB0aGlzLmdhbWVTdGF0LlNlY29uZEJhdHRlZF0gPiB0aGlzLmdhbWVTdGF0W1wiVGVhbVwiICsgdGhpcy5nYW1lU3RhdC5GaXJzdEJhdHRlZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lU3RhdC5tc2cgPSB0aGlzLnRlYW1PcmRlclsxXS5nZXRUZWFtTmFtZSgpICsgXCIgd29uIGJ5IFwiICsgTWF0aC5hYnModGhpcy5nYW1lU3RhdC5ydW5EaWZmKSArIHJ1bnNMaXRlcmFsICsgXCIuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZVN0YXQuZ2FtZW92ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVTdGF0Lndpbm5lciA9IHRoaXMuZ2FtZVN0YXQuU2Vjb25kQmF0dGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVTdGF0Lm1zZyA9IHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZWFtT3JkZXJbMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRUZWFtTmFtZSgpICsgXCIgc2NvcmVkIFwiICsgdGhpcy5nYW1lU3RhdFtcIlRlYW1cIiArIHRoaXMuZ2FtZVN0YXQuRmlyc3RCYXR0ZWRdICsgcnVuc0xpdGVyYWwgKyBcIi4gWW91IG5lZWQgdG8gc2NvcmUgXCIgKyAoTWF0aC5hYnModGhpcy5nYW1lU3RhdC5ydW5EaWZmKSArIDEpICsgXCIgbW9yZSBydW5zIHRvIHdpbiB0aGUgbWF0Y2guXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG0gPSAodGhpcy5nYW1lU3RhdC5ydW5EaWZmID4gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBcIkxlYWQ6IFwiXHJcbiAgICAgICAgICAgICAgICAgICAgOiBcIlRyYWlsOiBcIjtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWVTdGF0LnNfbXNnID0gdGhpcy5nYW1lU3RhdC5nYW1lb3ZlciA/IHRoaXMuZ2FtZVN0YXQubXNnIDogKG0gKyBNYXRoLmFicyh0aGlzLmdhbWVTdGF0LnJ1bkRpZmYpKSArIHJ1bnNMaXRlcmFsO1xyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAzOlxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2FtZVN0YXRbXCJUZWFtXCIgKyB0aGlzLmdhbWVTdGF0LlNlY29uZEJhdHRlZF0gPiB0aGlzLmdhbWVTdGF0W1wiVGVhbVwiICsgdGhpcy5nYW1lU3RhdC5GaXJzdEJhdHRlZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3RoaXMuZ2FtZVN0YXQubXNnID0gdGhpcy50ZWFtT3JkZXJbM10uZ2V0VGVhbU5hbWUoKSArIFwiIHdvbiBieSBcIiArIHRoaXMudGVhbU9yZGVyWzNdLnJlbWFpbmluZ1dpY2tldHMoKSArIFwiIHdpY2tldHMuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lU3RhdC5tc2cgPSB0aGlzLnRlYW1PcmRlclszXS5nZXRUZWFtTmFtZSgpICsgXCIgd29uIGJ5IFwiICsgTWF0aC5hYnModGhpcy5nYW1lU3RhdC5ydW5EaWZmKSArIHJ1bnNMaXRlcmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZVN0YXQuZ2FtZW92ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZVN0YXQud2lubmVyID0gdGhpcy5nYW1lU3RhdC5TZWNvbmRCYXR0ZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGVhbU9yZGVyW3RoaXMudGVhbU9yZGVySW5jXS5pc0lubmluZ0NvbXBsZXRlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9maW5hbCBjaGVja1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdhbWVTdGF0W1wiVGVhbVwiICsgdGhpcy5nYW1lU3RhdC5GaXJzdEJhdHRlZF0gPiB0aGlzLmdhbWVTdGF0W1wiVGVhbVwiICsgdGhpcy5nYW1lU3RhdC5TZWNvbmRCYXR0ZWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZVN0YXQubXNnID0gdGhpcy50ZWFtT3JkZXJbMF0uZ2V0VGVhbU5hbWUoKSArIFwiIHdvbiBieSBcIiArIE1hdGguYWJzKHRoaXMuZ2FtZVN0YXQucnVuRGlmZikgKyBydW5zTGl0ZXJhbCArIFwiLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVTdGF0Lndpbm5lciA9IHRoaXMudGVhbU9yZGVyWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5nYW1lU3RhdFtcIlRlYW1cIiArIHRoaXMuZ2FtZVN0YXQuU2Vjb25kQmF0dGVkXSA+IHRoaXMuZ2FtZVN0YXRbXCJUZWFtXCIgKyB0aGlzLmdhbWVTdGF0LkZpcnN0QmF0dGVkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVTdGF0Lm1zZyA9IHRoaXMudGVhbU9yZGVyWzNdLmdldFRlYW1OYW1lKCkgKyBcIiB3b24gYnkgXCIgKyBNYXRoLmFicyh0aGlzLmdhbWVTdGF0LnJ1bkRpZmYpICsgcnVuc0xpdGVyYWwgKyBcIi5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lU3RhdC53aW5uZXIgPSB0aGlzLnRlYW1PcmRlclszXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ2FtZVN0YXRbXCJUZWFtXCIgKyB0aGlzLmdhbWVTdGF0LlNlY29uZEJhdHRlZF0gPT09IHRoaXMuZ2FtZVN0YXRbXCJUZWFtXCIgKyB0aGlzLmdhbWVTdGF0LkZpcnN0QmF0dGVkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVTdGF0Lm1zZyA9IFwiR2FtZSBkcmF3blwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVTdGF0Lndpbm5lciA9ICdOb25lJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lU3RhdC5nYW1lb3ZlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHJ1bnNMaXRlcmFsMiA9ICgoTWF0aC5hYnModGhpcy5nYW1lU3RhdC5ydW5EaWZmKSArIDEpID4gMSkgPyBcIiBydW5zXCIgOiBcIiBydW5cIjtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWVTdGF0LnNfbXNnID0gdGhpcy5nYW1lU3RhdC5nYW1lb3ZlciA/IHRoaXMuZ2FtZVN0YXQubXNnIDogXCJUYXJnZXQ6IFwiICsgKHRoaXMuZ2FtZVN0YXQucnVuRGlmZiArIDEpICsgcnVuc0xpdGVyYWwyO1xyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLnRlYW1PcmRlckluYywgdGhpcy5nYW1lU3RhdCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FtZVN0YXRcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SW5uaW5nc092ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5pbm5pbmdzUXVlc3Rpb25zID0gbmV3IEl0ZXJhdG9yKHRoaXMuZ2V0QmF0dGluZ1RlYW0oKS5nZXRJbm5pbmdzUXVlc3Rpb25zKCkpLml0ZXJhdG9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29udGludWVOZXh0SW5uaW5ncygpIHtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInRoaXMgaW5uaW5nczogXCIsIHRoaXMudGVhbU9yZGVySW5jLCAnICAgJywgdGhpcy50ZWFtT3JkZXIubGVuZ3RoLCBcImdldEJhbGxDb3VudDogXCIsIHRoaXMuZ2V0QmF0dGluZ1RlYW0oKS5nZXRCYWxsQ291bnQoKSlcclxuXHJcbiAgICAgICAgLy9pZiAoIXRoaXMuZ2FtZVN0YXQuZ2FtZW92ZXIpIHtcclxuICAgICAgICBpZiAodGhpcy50ZWFtT3JkZXJJbmMgPT09ICh0aGlzLnRlYW1PcmRlci5sZW5ndGggLSAxKSkge1xyXG4gICAgICAgICAgICB3aW5kb3cuZXZlbnRNYW5hZ2VyLmRpc3BhdGNoKEdhbWVFdmVudC5HQU1FX09WRVIsIFwibnVsbFwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN3aXRjaEJhdHRpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRJbm5pbmdUaXRsZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmdldElubmluZ3NPdmVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGludWVJbm5pbmdzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG92ZXJVcCgpIHtcclxuICAgICAgICB0aGlzLmdldEJhdHRpbmdUZWFtKCkuc2V0SW5uaW5nQ29tcGxldGVkKCk7XHJcbiAgICAgICAgLy8uLiBjaGVjayBpZiBnYW1lb3ZlclxyXG4gICAgICAgIGlmICh0aGlzLnRlYW1PcmRlckluYyA9PT0gKHRoaXMudGVhbU9yZGVyLmxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5ldmVudE1hbmFnZXIuZGlzcGF0Y2goR2FtZUV2ZW50LkdBTUVfT1ZFUiwgXCJudWxsXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5ldmVudE1hbmFnZXIuZGlzcGF0Y2goR2FtZUV2ZW50LlNIT1dfVEVBTV9QRVJGT1JNQU5DRSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBnYW1lT3ZlcihwKSB7XHJcbiAgICAgICAgd2luZG93LmV2ZW50TWFuYWdlci5kaXNwYXRjaChHYW1lRXZlbnQuU0hPV19URUFNX1BFUkZPUk1BTkNFLCBwKTtcclxuICAgIH1cclxuXHJcbiAgICBuZXh0QmFsbCgpIHtcclxuICAgICAgICBsZXQgdGhpc0JhbGwgPSB0aGlzLmlubmluZ3NRdWVzdGlvbnMubmV4dCgpO1xyXG4gICAgICAgIC8qIGlmICh0aGlzQmFsbC5kb25lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0QmF0dGluZ1RlYW0oKS5zZXRJbm5pbmdDb21wbGV0ZWQoKTtcclxuICAgICAgICAgICAgdGhpcy5nZXRTdGF0cygpO1xyXG4gICAgICAgIH0gKi9cclxuICAgICAgICByZXR1cm4gdGhpc0JhbGxcclxuICAgIH1cclxuXHJcbiAgICBzd2l0Y2hCYXR0aW5nKCkge1xyXG4gICAgICAgIHRoaXMudGVhbU9yZGVySW5jKys7XHJcbiAgICAgICAgdGhpcy5iYXR0aW5nVGVhbSA9IHRoaXMudGVhbU9yZGVyW3RoaXMudGVhbU9yZGVySW5jXTtcclxuICAgIH1cclxuXHJcbiAgICBjb250aW51ZUlubmluZ3MoKSB7XHJcbiAgICAgICAgd2luZG93LmV2ZW50TWFuYWdlci5kaXNwYXRjaChHYW1lRXZlbnQuQ09OVElOVUUsIFwibnVsbFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjYXB0dXJlU2hvdChzKSB7XHJcbiAgICAgICAgdGhpcy5nZXRCYXR0aW5nVGVhbSgpLnN0cm9rZVBsYXllZChzKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVW1waXJlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/models/Umpire.js\n");

/***/ }),

/***/ "./src/utils/ButtonUtil.js":
/*!*********************************!*\
  !*** ./src/utils/ButtonUtil.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\r\nclass ButtonUtil {\r\n\r\n    static configure(btn) {\r\n        btn.on(\"mouseover\", () => {\r\n            btn.overState = true;\r\n            btn.gotoAndStop(\"_over\");\r\n        });\r\n        btn.on(\"mouseout\", () => {\r\n            btn.overState = false;\r\n            btn.gotoAndStop(\"_up\");\r\n        });\r\n        btn.on(\"mousedown\", () => {\r\n            btn.gotoAndStop(\"_down\");\r\n        });\r\n        //btn.on(\"click\", onBtnClick);\r\n        btn.cursor = \"pointer\";\r\n        btn.mouseChildren = false;\r\n    }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ButtonUtil);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvQnV0dG9uVXRpbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy91dGlscy9CdXR0b25VdGlsLmpzPzk1ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiXHJcbmNsYXNzIEJ1dHRvblV0aWwge1xyXG5cclxuICAgIHN0YXRpYyBjb25maWd1cmUoYnRuKSB7XHJcbiAgICAgICAgYnRuLm9uKFwibW91c2VvdmVyXCIsICgpID0+IHtcclxuICAgICAgICAgICAgYnRuLm92ZXJTdGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGJ0bi5nb3RvQW5kU3RvcChcIl9vdmVyXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGJ0bi5vbihcIm1vdXNlb3V0XCIsICgpID0+IHtcclxuICAgICAgICAgICAgYnRuLm92ZXJTdGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBidG4uZ290b0FuZFN0b3AoXCJfdXBcIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYnRuLm9uKFwibW91c2Vkb3duXCIsICgpID0+IHtcclxuICAgICAgICAgICAgYnRuLmdvdG9BbmRTdG9wKFwiX2Rvd25cIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy9idG4ub24oXCJjbGlja1wiLCBvbkJ0bkNsaWNrKTtcclxuICAgICAgICBidG4uY3Vyc29yID0gXCJwb2ludGVyXCI7XHJcbiAgICAgICAgYnRuLm1vdXNlQ2hpbGRyZW4gPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uVXRpbCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils/ButtonUtil.js\n");

/***/ }),

/***/ "./src/utils/SoundUtil.js":
/*!********************************!*\
  !*** ./src/utils/SoundUtil.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _models_GameEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/GameEvent */ \"./src/models/GameEvent.js\");\n\r\n\r\nclass SoundUtil {\r\n\r\n    static registerSound(src, id) {\r\n        window\r\n            .createjs\r\n            .Sound\r\n            .registerSound(src, id);\r\n    }\r\n\r\n    static playSound(id, vol, del, loop, evt = _models_GameEvent__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SOUND_COMPLETED) {\r\n        /*\r\n        interrupt - How to interrupt any currently playing instances of audio with the same source, if the maximum number of instances of the sound are already playing. Values are defined as INTERRUPT_TYPE constants on the Sound class, with the default defined by defaultInterruptBehavior.\r\n        delay - The amount of time to delay the start of audio playback, in milliseconds.\r\n        offset - The offset from the start of the audio to begin playback, in milliseconds.\r\n        loop - How many times the audio loops when it reaches the end of playback. The default is 0 (no loops), and -1 can be used for infinite playback.\r\n        volume - The volume of the sound, between 0 and 1. Note that the master volume is applied against the individual volume.\r\n        pan - The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\r\n        startTime - To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\r\n        duration - To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\r\n            */\r\n        let loopVal = (loop === undefined)\r\n            ? 0\r\n            : loop;\r\n        let volVal = (vol === undefined) ? 1 : vol;\r\n        let delVal = (del === undefined) ? 0 : del;\r\n\r\n        //console.log(\"sound: \", id, '   found:', SoundUtil._getSound(id), '  evt: ', evt);\r\n\r\n        if (SoundUtil._getSound(id) === undefined) {\r\n            let myInstance = window.createjs.Sound.createInstance(id);\r\n            myInstance.play({\r\n                interrupt: window.createjs.Sound.INTERRUPT_ANY,\r\n                loop: loopVal,\r\n                volume: volVal,\r\n                delay: delVal\r\n            }); //INTERRUPT_ANY, volume: 1, , pan: 0.5\r\n            myInstance.on(\"complete\", () => {\r\n                //console.log(\"snd instance completed playing on \", id, myInstance, evt);\r\n                window.eventManager.dispatch(evt, { id: myInstance });\r\n            }, false);\r\n            SoundUtil.sounds[id] = myInstance;\r\n        } else {\r\n            SoundUtil.resumeSound(id);\r\n        }\r\n\r\n    }\r\n\r\n    static pauseSound(id) {\r\n        let s = SoundUtil._getSound(id);\r\n        s.paused = true;\r\n    }\r\n\r\n    static resumeSound(id) {\r\n        let s = SoundUtil._getSound(id);\r\n        s.play();\r\n    }\r\n\r\n    static stopSound(id) {\r\n        let s = SoundUtil._getSound(id);\r\n        s.stop();\r\n    }\r\n\r\n    static _getSound(id) {\r\n        return SoundUtil.sounds[id];\r\n    }\r\n\r\n    static stopAllSounds() {\r\n        window.createjs.Sound.stop();\r\n    }\r\n}\r\n\r\nSoundUtil.sounds = [];\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (SoundUtil);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvU291bmRVdGlsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL1NvdW5kVXRpbC5qcz9jZjI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uL21vZGVscy9HYW1lRXZlbnRcIjtcclxuXHJcbmNsYXNzIFNvdW5kVXRpbCB7XHJcblxyXG4gICAgc3RhdGljIHJlZ2lzdGVyU291bmQoc3JjLCBpZCkge1xyXG4gICAgICAgIHdpbmRvd1xyXG4gICAgICAgICAgICAuY3JlYXRlanNcclxuICAgICAgICAgICAgLlNvdW5kXHJcbiAgICAgICAgICAgIC5yZWdpc3RlclNvdW5kKHNyYywgaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwbGF5U291bmQoaWQsIHZvbCwgZGVsLCBsb29wLCBldnQgPSBHYW1lRXZlbnQuU09VTkRfQ09NUExFVEVEKSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICBpbnRlcnJ1cHQgLSBIb3cgdG8gaW50ZXJydXB0IGFueSBjdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZXMgb2YgYXVkaW8gd2l0aCB0aGUgc2FtZSBzb3VyY2UsIGlmIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBhbHJlYWR5IHBsYXlpbmcuIFZhbHVlcyBhcmUgZGVmaW5lZCBhcyBJTlRFUlJVUFRfVFlQRSBjb25zdGFudHMgb24gdGhlIFNvdW5kIGNsYXNzLCB3aXRoIHRoZSBkZWZhdWx0IGRlZmluZWQgYnkgZGVmYXVsdEludGVycnVwdEJlaGF2aW9yLlxyXG4gICAgICAgIGRlbGF5IC0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IHRoZSBzdGFydCBvZiBhdWRpbyBwbGF5YmFjaywgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICAgIG9mZnNldCAtIFRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGF1ZGlvIHRvIGJlZ2luIHBsYXliYWNrLCBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgICAgbG9vcCAtIEhvdyBtYW55IHRpbWVzIHRoZSBhdWRpbyBsb29wcyB3aGVuIGl0IHJlYWNoZXMgdGhlIGVuZCBvZiBwbGF5YmFjay4gVGhlIGRlZmF1bHQgaXMgMCAobm8gbG9vcHMpLCBhbmQgLTEgY2FuIGJlIHVzZWQgZm9yIGluZmluaXRlIHBsYXliYWNrLlxyXG4gICAgICAgIHZvbHVtZSAtIFRoZSB2b2x1bWUgb2YgdGhlIHNvdW5kLCBiZXR3ZWVuIDAgYW5kIDEuIE5vdGUgdGhhdCB0aGUgbWFzdGVyIHZvbHVtZSBpcyBhcHBsaWVkIGFnYWluc3QgdGhlIGluZGl2aWR1YWwgdm9sdW1lLlxyXG4gICAgICAgIHBhbiAtIFRoZSBsZWZ0LXJpZ2h0IHBhbiBvZiB0aGUgc291bmQgKGlmIHN1cHBvcnRlZCksIGJldHdlZW4gLTEgKGxlZnQpIGFuZCAxIChyaWdodCkuXHJcbiAgICAgICAgc3RhcnRUaW1lIC0gVG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSAod2l0aCBkdXJhdGlvbiksIHRoZSBpbml0aWFsIG9mZnNldCB0byBzdGFydCBwbGF5YmFjayBhbmQgbG9vcCBmcm9tLCBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgICAgZHVyYXRpb24gLSBUbyBjcmVhdGUgYW4gYXVkaW8gc3ByaXRlICh3aXRoIHN0YXJ0VGltZSksIHRoZSBhbW91bnQgb2YgdGltZSB0byBwbGF5IHRoZSBjbGlwIGZvciwgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgIGxldCBsb29wVmFsID0gKGxvb3AgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgPyAwXHJcbiAgICAgICAgICAgIDogbG9vcDtcclxuICAgICAgICBsZXQgdm9sVmFsID0gKHZvbCA9PT0gdW5kZWZpbmVkKSA/IDEgOiB2b2w7XHJcbiAgICAgICAgbGV0IGRlbFZhbCA9IChkZWwgPT09IHVuZGVmaW5lZCkgPyAwIDogZGVsO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwic291bmQ6IFwiLCBpZCwgJyAgIGZvdW5kOicsIFNvdW5kVXRpbC5fZ2V0U291bmQoaWQpLCAnICBldnQ6ICcsIGV2dCk7XHJcblxyXG4gICAgICAgIGlmIChTb3VuZFV0aWwuX2dldFNvdW5kKGlkKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxldCBteUluc3RhbmNlID0gd2luZG93LmNyZWF0ZWpzLlNvdW5kLmNyZWF0ZUluc3RhbmNlKGlkKTtcclxuICAgICAgICAgICAgbXlJbnN0YW5jZS5wbGF5KHtcclxuICAgICAgICAgICAgICAgIGludGVycnVwdDogd2luZG93LmNyZWF0ZWpzLlNvdW5kLklOVEVSUlVQVF9BTlksXHJcbiAgICAgICAgICAgICAgICBsb29wOiBsb29wVmFsLFxyXG4gICAgICAgICAgICAgICAgdm9sdW1lOiB2b2xWYWwsXHJcbiAgICAgICAgICAgICAgICBkZWxheTogZGVsVmFsXHJcbiAgICAgICAgICAgIH0pOyAvL0lOVEVSUlVQVF9BTlksIHZvbHVtZTogMSwgLCBwYW46IDAuNVxyXG4gICAgICAgICAgICBteUluc3RhbmNlLm9uKFwiY29tcGxldGVcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInNuZCBpbnN0YW5jZSBjb21wbGV0ZWQgcGxheWluZyBvbiBcIiwgaWQsIG15SW5zdGFuY2UsIGV2dCk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuZXZlbnRNYW5hZ2VyLmRpc3BhdGNoKGV2dCwgeyBpZDogbXlJbnN0YW5jZSB9KTtcclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICBTb3VuZFV0aWwuc291bmRzW2lkXSA9IG15SW5zdGFuY2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgU291bmRVdGlsLnJlc3VtZVNvdW5kKGlkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwYXVzZVNvdW5kKGlkKSB7XHJcbiAgICAgICAgbGV0IHMgPSBTb3VuZFV0aWwuX2dldFNvdW5kKGlkKTtcclxuICAgICAgICBzLnBhdXNlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHJlc3VtZVNvdW5kKGlkKSB7XHJcbiAgICAgICAgbGV0IHMgPSBTb3VuZFV0aWwuX2dldFNvdW5kKGlkKTtcclxuICAgICAgICBzLnBsYXkoKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgc3RvcFNvdW5kKGlkKSB7XHJcbiAgICAgICAgbGV0IHMgPSBTb3VuZFV0aWwuX2dldFNvdW5kKGlkKTtcclxuICAgICAgICBzLnN0b3AoKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgX2dldFNvdW5kKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIFNvdW5kVXRpbC5zb3VuZHNbaWRdO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBzdG9wQWxsU291bmRzKCkge1xyXG4gICAgICAgIHdpbmRvdy5jcmVhdGVqcy5Tb3VuZC5zdG9wKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcblNvdW5kVXRpbC5zb3VuZHMgPSBbXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNvdW5kVXRpbFxyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utils/SoundUtil.js\n");

/***/ }),

/***/ "./src/utils/TextUtil.js":
/*!*******************************!*\
  !*** ./src/utils/TextUtil.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var createjs_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! createjs-module */ \"./node_modules/createjs-module/createjs.js\");\n/* harmony import */ var createjs_module__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(createjs_module__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nclass TextUtil {\r\n\r\n    static defaultStyle() {\r\n        return { \"style\": \"normal 18px Verdana\", \"color\": \"#FFF\", \"width\": 600 }\r\n    }\r\n\r\n    static embededFontStyle(fontName, size, color, width) {\r\n\r\n        let s = \"normal \" + size + \"px \" + fontName;\r\n        let c = color;\r\n        let w = width;\r\n\r\n        return { \"style\": s, \"color\": c, \"width\": w }\r\n    }\r\n\r\n    static getText({ x, y, t, f, lCanvas }) {\r\n        if (t.indexOf('<FONT FACE') >= 0) {\r\n            return TextUtil.formatText({ x, y, t, f, lCanvas });\r\n        } else {\r\n            let txt = new createjs_module__WEBPACK_IMPORTED_MODULE_0__[\"Text\"]();\r\n            txt.x = x;\r\n            txt.y = y;\r\n            txt.font = f.style;\r\n            txt.color = f.color;\r\n            txt.text = t;\r\n            txt.textAlign = \"left\";\r\n            txt.lineWidth = f.width;\r\n            lCanvas.addChild(txt)\r\n            return txt\r\n        }\r\n    }\r\n\r\n    static formatText({ x, y, t, f, lCanvas }) {\r\n        let txt = new createjs_module__WEBPACK_IMPORTED_MODULE_0__[\"Text\"]();\r\n        let tmpX = x;\r\n        if (t.indexOf('{') >= 0) {\r\n            t.replace('{', '$$OPCB$$')\r\n        }\r\n        if (t.indexOf('}') >= 0) {\r\n            t.replace('}', '$$CLCB$$')\r\n        }\r\n        if (t.indexOf('TIS_Sup') >= 0) {\r\n            // debugger;\r\n            let arr = [];\r\n            arr = t.split('<FONT FACE=\"TIS_Sup\">');\r\n            let str = arr.join(' ');\r\n            arr = str.split(' ');\r\n\r\n            for (var i = 0; i < arr.length; i++) {\r\n                if (arr[i].indexOf('</FONT>') >= 0) {\r\n                    let txt = new createjs_module__WEBPACK_IMPORTED_MODULE_0__[\"Text\"]();\r\n                    let txtToAdd = arr[i].split('</FONT>')[0];\r\n                    txt.x = tmpX;\r\n                    txt.y = y;\r\n                    txt.font = \"TISSup\";\r\n                    txt.text = txtToAdd\r\n                    txt.color = f.color;\r\n                    txt.textAlign = \"left\";\r\n                    txt.lineWidth = f.width;\r\n                    lCanvas.addChild(txt)\r\n                    tmpX += txt.getMeasuredWidth() + 2\r\n                } else {\r\n                    let txt = new createjs_module__WEBPACK_IMPORTED_MODULE_0__[\"Text\"]();\r\n                    let txtToAdd = arr[i];\r\n                    txt.x = tmpX;\r\n                    txt.y = y;\r\n                    txt.font = f.style;\r\n                    txt.text = txtToAdd;\r\n                    txt.color = f.color;\r\n                    txt.textAlign = \"left\";\r\n                    txt.lineWidth = f.width;\r\n                    lCanvas.addChild(txt)\r\n                    tmpX += txt.getMeasuredWidth() + 2\r\n                }\r\n            }\r\n        } else if (t.indexOf('TIS_Sub') >= 0) {\r\n            // debugger;\r\n            let arr = [];\r\n            arr = t.split('<FONT FACE=\"TIS_Sub\">');\r\n            let str = arr.join(' ');\r\n            arr = str.split(' ');\r\n\r\n            for (var i = 0; i < arr.length; i++) {\r\n                if (arr[i].indexOf('</FONT>') >= 0) {\r\n                    let txt = new createjs_module__WEBPACK_IMPORTED_MODULE_0__[\"Text\"]();\r\n                    let txtToAdd = arr[i].split('</FONT>')[0];\r\n                    txt.x = tmpX;\r\n                    txt.y = y;\r\n                    txt.font = \"TISSub\";\r\n                    txt.text = txtToAdd\r\n                    txt.color = f.color;\r\n                    txt.textAlign = \"left\";\r\n                    txt.lineWidth = f.width;\r\n                    lCanvas.addChild(txt)\r\n                    tmpX += txt.getMeasuredWidth() + 2\r\n                } else {\r\n                    let txt = new createjs_module__WEBPACK_IMPORTED_MODULE_0__[\"Text\"]();\r\n                    let txtToAdd = arr[i];\r\n                    txt.x = tmpX;\r\n                    txt.y = y;\r\n                    txt.font = f.style;\r\n                    txt.text = txtToAdd;\r\n                    txt.color = f.color;\r\n                    txt.textAlign = \"left\";\r\n                    txt.lineWidth = f.width;\r\n                    lCanvas.addChild(txt)\r\n                    tmpX += txt.getMeasuredWidth() + 2\r\n                }\r\n            }\r\n        } else if (t.indexOf('TIS_Symbol') >= 0) {\r\n            // debugger;\r\n            let tmpArr = [];\r\n            tmpArr = t.split('<FONT FACE=\"TIS_Symbol\">');\r\n            let str = tmpArr.join(' ');\r\n            tmpArr = str.split(' ');\r\n            //debugger;\r\n            for (var i = 0; i < tmpArr.length; i++) {\r\n                if (tmpArr[i].indexOf('</FONT>') >= 0) {\r\n                    let txt = new createjs_module__WEBPACK_IMPORTED_MODULE_0__[\"Text\"]();\r\n                    let tmpArr1 = [];\r\n                    //debugger;\r\n                    tmpArr1 = tmpArr[i].split('</FONT>')\r\n\r\n                    let str1 = tmpArr[i]\r\n                    let str2 = str1.substring(str1.indexOf('>'), str1.length)\r\n                    if (str2.length > 1) {\r\n                        tmpArr.splice((i + 1), 0, str2.slice(1, str.length));\r\n                    }\r\n                    let txtToAdd = tmpArr1[0];\r\n\r\n                    txt.x = tmpX;\r\n                    txt.y = y;\r\n                    txt.font = \"TISSup\";\r\n                    txt.text = txtToAdd\r\n                    txt.color = f.color;\r\n                    txt.textAlign = \"left\";\r\n                    txt.lineWidth = f.width;\r\n                    lCanvas.addChild(txt)\r\n                    tmpX += txt.getMeasuredWidth() + 2\r\n                } else {\r\n                    let txt = new createjs_module__WEBPACK_IMPORTED_MODULE_0__[\"Text\"]();\r\n                    let txtToAdd = tmpArr[i];\r\n                    txt.x = tmpX;\r\n                    txt.y = y;\r\n                    txt.font = f.style;\r\n                    txt.text = txtToAdd;\r\n                    txt.color = f.color;\r\n                    txt.textAlign = \"left\";\r\n                    txt.lineWidth = f.width;\r\n                    lCanvas.addChild(txt)\r\n                    tmpX += txt.getMeasuredWidth() + 2\r\n                }\r\n            }\r\n        }\r\n        return txt;\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (TextUtil);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvVGV4dFV0aWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvVGV4dFV0aWwuanM/NGI5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0IH0gZnJvbSBcImNyZWF0ZWpzLW1vZHVsZVwiO1xyXG5cclxuY2xhc3MgVGV4dFV0aWwge1xyXG5cclxuICAgIHN0YXRpYyBkZWZhdWx0U3R5bGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgXCJzdHlsZVwiOiBcIm5vcm1hbCAxOHB4IFZlcmRhbmFcIiwgXCJjb2xvclwiOiBcIiNGRkZcIiwgXCJ3aWR0aFwiOiA2MDAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlbWJlZGVkRm9udFN0eWxlKGZvbnROYW1lLCBzaXplLCBjb2xvciwgd2lkdGgpIHtcclxuXHJcbiAgICAgICAgbGV0IHMgPSBcIm5vcm1hbCBcIiArIHNpemUgKyBcInB4IFwiICsgZm9udE5hbWU7XHJcbiAgICAgICAgbGV0IGMgPSBjb2xvcjtcclxuICAgICAgICBsZXQgdyA9IHdpZHRoO1xyXG5cclxuICAgICAgICByZXR1cm4geyBcInN0eWxlXCI6IHMsIFwiY29sb3JcIjogYywgXCJ3aWR0aFwiOiB3IH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0VGV4dCh7IHgsIHksIHQsIGYsIGxDYW52YXMgfSkge1xyXG4gICAgICAgIGlmICh0LmluZGV4T2YoJzxGT05UIEZBQ0UnKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUZXh0VXRpbC5mb3JtYXRUZXh0KHsgeCwgeSwgdCwgZiwgbENhbnZhcyB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgdHh0ID0gbmV3IFRleHQoKTtcclxuICAgICAgICAgICAgdHh0LnggPSB4O1xyXG4gICAgICAgICAgICB0eHQueSA9IHk7XHJcbiAgICAgICAgICAgIHR4dC5mb250ID0gZi5zdHlsZTtcclxuICAgICAgICAgICAgdHh0LmNvbG9yID0gZi5jb2xvcjtcclxuICAgICAgICAgICAgdHh0LnRleHQgPSB0O1xyXG4gICAgICAgICAgICB0eHQudGV4dEFsaWduID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgIHR4dC5saW5lV2lkdGggPSBmLndpZHRoO1xyXG4gICAgICAgICAgICBsQ2FudmFzLmFkZENoaWxkKHR4dClcclxuICAgICAgICAgICAgcmV0dXJuIHR4dFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZm9ybWF0VGV4dCh7IHgsIHksIHQsIGYsIGxDYW52YXMgfSkge1xyXG4gICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dCgpO1xyXG4gICAgICAgIGxldCB0bXBYID0geDtcclxuICAgICAgICBpZiAodC5pbmRleE9mKCd7JykgPj0gMCkge1xyXG4gICAgICAgICAgICB0LnJlcGxhY2UoJ3snLCAnJCRPUENCJCQnKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodC5pbmRleE9mKCd9JykgPj0gMCkge1xyXG4gICAgICAgICAgICB0LnJlcGxhY2UoJ30nLCAnJCRDTENCJCQnKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodC5pbmRleE9mKCdUSVNfU3VwJykgPj0gMCkge1xyXG4gICAgICAgICAgICAvLyBkZWJ1Z2dlcjtcclxuICAgICAgICAgICAgbGV0IGFyciA9IFtdO1xyXG4gICAgICAgICAgICBhcnIgPSB0LnNwbGl0KCc8Rk9OVCBGQUNFPVwiVElTX1N1cFwiPicpO1xyXG4gICAgICAgICAgICBsZXQgc3RyID0gYXJyLmpvaW4oJyAnKTtcclxuICAgICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcgJyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFycltpXS5pbmRleE9mKCc8L0ZPTlQ+JykgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0eHRUb0FkZCA9IGFycltpXS5zcGxpdCgnPC9GT05UPicpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC54ID0gdG1wWDtcclxuICAgICAgICAgICAgICAgICAgICB0eHQueSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHh0LmZvbnQgPSBcIlRJU1N1cFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC50ZXh0ID0gdHh0VG9BZGRcclxuICAgICAgICAgICAgICAgICAgICB0eHQuY29sb3IgPSBmLmNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgICAgICB0eHQubGluZVdpZHRoID0gZi53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBsQ2FudmFzLmFkZENoaWxkKHR4dClcclxuICAgICAgICAgICAgICAgICAgICB0bXBYICs9IHR4dC5nZXRNZWFzdXJlZFdpZHRoKCkgKyAyXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0eHRUb0FkZCA9IGFycltpXTtcclxuICAgICAgICAgICAgICAgICAgICB0eHQueCA9IHRtcFg7XHJcbiAgICAgICAgICAgICAgICAgICAgdHh0LnkgPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC5mb250ID0gZi5zdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICB0eHQudGV4dCA9IHR4dFRvQWRkO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC5jb2xvciA9IGYuY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdHh0LnRleHRBbGlnbiA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC5saW5lV2lkdGggPSBmLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGxDYW52YXMuYWRkQ2hpbGQodHh0KVxyXG4gICAgICAgICAgICAgICAgICAgIHRtcFggKz0gdHh0LmdldE1lYXN1cmVkV2lkdGgoKSArIDJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodC5pbmRleE9mKCdUSVNfU3ViJykgPj0gMCkge1xyXG4gICAgICAgICAgICAvLyBkZWJ1Z2dlcjtcclxuICAgICAgICAgICAgbGV0IGFyciA9IFtdO1xyXG4gICAgICAgICAgICBhcnIgPSB0LnNwbGl0KCc8Rk9OVCBGQUNFPVwiVElTX1N1YlwiPicpO1xyXG4gICAgICAgICAgICBsZXQgc3RyID0gYXJyLmpvaW4oJyAnKTtcclxuICAgICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcgJyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFycltpXS5pbmRleE9mKCc8L0ZPTlQ+JykgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0eHRUb0FkZCA9IGFycltpXS5zcGxpdCgnPC9GT05UPicpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC54ID0gdG1wWDtcclxuICAgICAgICAgICAgICAgICAgICB0eHQueSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHh0LmZvbnQgPSBcIlRJU1N1YlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC50ZXh0ID0gdHh0VG9BZGRcclxuICAgICAgICAgICAgICAgICAgICB0eHQuY29sb3IgPSBmLmNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgICAgICB0eHQubGluZVdpZHRoID0gZi53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBsQ2FudmFzLmFkZENoaWxkKHR4dClcclxuICAgICAgICAgICAgICAgICAgICB0bXBYICs9IHR4dC5nZXRNZWFzdXJlZFdpZHRoKCkgKyAyXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0eHRUb0FkZCA9IGFycltpXTtcclxuICAgICAgICAgICAgICAgICAgICB0eHQueCA9IHRtcFg7XHJcbiAgICAgICAgICAgICAgICAgICAgdHh0LnkgPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC5mb250ID0gZi5zdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICB0eHQudGV4dCA9IHR4dFRvQWRkO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC5jb2xvciA9IGYuY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdHh0LnRleHRBbGlnbiA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC5saW5lV2lkdGggPSBmLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGxDYW52YXMuYWRkQ2hpbGQodHh0KVxyXG4gICAgICAgICAgICAgICAgICAgIHRtcFggKz0gdHh0LmdldE1lYXN1cmVkV2lkdGgoKSArIDJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodC5pbmRleE9mKCdUSVNfU3ltYm9sJykgPj0gMCkge1xyXG4gICAgICAgICAgICAvLyBkZWJ1Z2dlcjtcclxuICAgICAgICAgICAgbGV0IHRtcEFyciA9IFtdO1xyXG4gICAgICAgICAgICB0bXBBcnIgPSB0LnNwbGl0KCc8Rk9OVCBGQUNFPVwiVElTX1N5bWJvbFwiPicpO1xyXG4gICAgICAgICAgICBsZXQgc3RyID0gdG1wQXJyLmpvaW4oJyAnKTtcclxuICAgICAgICAgICAgdG1wQXJyID0gc3RyLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgIC8vZGVidWdnZXI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG1wQXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG1wQXJyW2ldLmluZGV4T2YoJzwvRk9OVD4nKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR4dCA9IG5ldyBUZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRtcEFycjEgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAvL2RlYnVnZ2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcEFycjEgPSB0bXBBcnJbaV0uc3BsaXQoJzwvRk9OVD4nKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RyMSA9IHRtcEFycltpXVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHIyID0gc3RyMS5zdWJzdHJpbmcoc3RyMS5pbmRleE9mKCc+JyksIHN0cjEubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIyLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wQXJyLnNwbGljZSgoaSArIDEpLCAwLCBzdHIyLnNsaWNlKDEsIHN0ci5sZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR4dFRvQWRkID0gdG1wQXJyMVswXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdHh0LnggPSB0bXBYO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC55ID0geTtcclxuICAgICAgICAgICAgICAgICAgICB0eHQuZm9udCA9IFwiVElTU3VwXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdHh0LnRleHQgPSB0eHRUb0FkZFxyXG4gICAgICAgICAgICAgICAgICAgIHR4dC5jb2xvciA9IGYuY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdHh0LnRleHRBbGlnbiA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC5saW5lV2lkdGggPSBmLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGxDYW52YXMuYWRkQ2hpbGQodHh0KVxyXG4gICAgICAgICAgICAgICAgICAgIHRtcFggKz0gdHh0LmdldE1lYXN1cmVkV2lkdGgoKSArIDJcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR4dCA9IG5ldyBUZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR4dFRvQWRkID0gdG1wQXJyW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC54ID0gdG1wWDtcclxuICAgICAgICAgICAgICAgICAgICB0eHQueSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHh0LmZvbnQgPSBmLnN0eWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dC50ZXh0ID0gdHh0VG9BZGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdHh0LmNvbG9yID0gZi5jb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICB0eHQudGV4dEFsaWduID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdHh0LmxpbmVXaWR0aCA9IGYud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgbENhbnZhcy5hZGRDaGlsZCh0eHQpXHJcbiAgICAgICAgICAgICAgICAgICAgdG1wWCArPSB0eHQuZ2V0TWVhc3VyZWRXaWR0aCgpICsgMlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eHQ7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUZXh0VXRpbCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils/TextUtil.js\n");

/***/ }),

/***/ "./src/utils/Utils.js":
/*!****************************!*\
  !*** ./src/utils/Utils.js ***!
  \****************************/
/*! exports provided: DisplayUtils, XMLUtils, ArrayUtils, Timer, Iterator, EventManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DisplayUtils\", function() { return DisplayUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"XMLUtils\", function() { return XMLUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrayUtils\", function() { return ArrayUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Timer\", function() { return Timer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Iterator\", function() { return Iterator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventManager\", function() { return EventManager; });\nclass Timer {\r\n\r\n\tcreateTimer(time, updateCall, callbackFunc, ref) {\r\n\t\tthis.timerParam = {\r\n\t\t\ttime,\r\n\t\t\tupdateCall,\r\n\t\t\tcallbackFunc,\r\n\t\t\tref\r\n\t\t};\r\n\t}\r\n\r\n\tstartTimer() {\r\n\t\t// this.createTimer(this.timerParam.time, this.timerParam.updateCall,\r\n\t\t// this.timerParam.callbackFunc, this.timerParam.ref) this.stopTimer();\r\n\r\n\t\tthis.seconds = this.timerParam.time + 1;\r\n\t\tthis.stopTimer();\r\n\r\n\t\tthis.countdownTimer = window.setInterval(() => {\r\n\t\t\tif (!this.timerPaused) {\r\n\t\t\t\tif (this.seconds < 1) {\r\n\t\t\t\t\tconsole.log(\"Time's up!\");\r\n\t\t\t\t\tthis.timerParam.callbackFunc(this.timerParam.ref);\r\n\t\t\t\t\tthis.stopTimer();\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//console.log(\"counting >> \", this.seconds);\r\n\t\t\t\t\tthis.seconds--;\r\n\t\t\t\t\tthis\r\n\t\t\t\t\t\t.timerParam\r\n\t\t\t\t\t\t.updateCall(this.timerParam.ref);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, 1000);\r\n\t}\r\n\r\n\tpauseTimer() {\r\n\t\tthis.timerPaused = true;\r\n\t}\r\n\r\n\tresumeTimer() {\r\n\t\tthis.timerPaused = false;\r\n\t}\r\n\r\n\tstopTimer() {\r\n\t\tif (this.countdownTimer) {\r\n\t\t\tclearInterval(this.countdownTimer);\r\n\t\t\tthis.countdownTimer = null;\r\n\t\t\t//this.timerPaused = false;\r\n\t\t}\r\n\t}\r\n\r\n\tgetTime() {\r\n\t\treturn this.seconds;\r\n\r\n\t}\r\n\tgetFormattedTime() {\r\n\t\tlet pad = function (input) {\r\n\t\t\treturn input < 10\r\n\t\t\t\t? \"0\" + input + \" Sec\"\r\n\t\t\t\t: input + \" Sec\";\r\n\t\t}\r\n\t\treturn pad(this.getTime());\r\n\r\n\t}\r\n\tgetConvertedTime() {\r\n\t\treturn this.convertTime(this.seconds);\r\n\t}\r\n\r\n\tconvertTime(input, separator) {\r\n\t\tlet pad = function (input) {\r\n\t\t\treturn input < 10\r\n\t\t\t\t? \"0\" + input\r\n\t\t\t\t: input;\r\n\t\t};\r\n\t\treturn [\r\n\t\t\t/*pad(Math.floor(input / 3600)),*/\r\n\t\t\tpad(Math.floor(input % 3600 / 60)),\r\n\t\t\tpad(Math.floor(input % 60))\r\n\t\t].join(typeof separator !== 'undefined'\r\n\t\t\t? separator\r\n\t\t\t: ':');\r\n\t}\r\n}\r\n\r\nclass ArrayUtils {\r\n\tstatic getRandomBool() {\r\n\t\treturn (Math.random() > 0.5)\r\n\t\t\t? 1\r\n\t\t\t: 0\r\n\t}\r\n\r\n\tstatic shuffleArray(arr) {\r\n\t\tlet a = ArrayUtils.copyArray(arr);\r\n\t\tlet l = a.length;\r\n\t\tlet i = 0;\r\n\t\tfor (i; i < l; i++) {\r\n\t\t\tlet tmp = a[i];\r\n\t\t\tlet rand = Math.floor(Number(Math.random() * l));\r\n\t\t\t//alert(rand)\r\n\t\t\ta[i] = a[rand];\r\n\t\t\ta[rand] = tmp;\r\n\t\t}\r\n\t\treturn a\r\n\t}\r\n\r\n\tstatic getRandomValue(arr) {\r\n\t\treturn arr[Math.floor(Math.random() * arr.length)]\r\n\t}\r\n\r\n\tstatic copyArray(a) {\r\n\t\treturn a.slice()\r\n\t}\r\n}\r\n\r\nclass DisplayUtils {\r\n\r\n\tstatic setTransform(target_mc, x, y, regX, regY) {\r\n\t\ttarget_mc.setTransform(x, y, 1, 1, 0, 0, 0, regX, regY);\r\n\t}\r\n}\r\n\r\nclass XMLUtils {\r\n\r\n\tstatic xmlToJson(xml) {\r\n\r\n\t\t// Create the return object\r\n\t\tvar obj = {};\r\n\r\n\t\tif (xml.nodeType === 1) { // element\r\n\t\t\t// do attributes\r\n\t\t\tif (xml.attributes.length > 0) {\r\n\t\t\t\tobj[\"@attributes\"] = {};\r\n\t\t\t\tfor (var j = 0; j < xml.attributes.length; j++) {\r\n\t\t\t\t\tvar attribute = xml\r\n\t\t\t\t\t\t.attributes\r\n\t\t\t\t\t\t.item(j);\r\n\t\t\t\t\tobj[\"@attributes\"][attribute.nodeName] = attribute.nodeValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (xml.nodeType === 3) { // text\r\n\t\t\tobj = xml.nodeValue;\r\n\t\t}\r\n\r\n\t\t// do children If just one text node inside\r\n\t\tif (xml.hasChildNodes() && xml.childNodes.length === 1 && xml.childNodes[0].nodeType === 3) {\r\n\t\t\tobj = xml.childNodes[0].nodeValue;\r\n\t\t} else if (xml.hasChildNodes()) {\r\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\r\n\t\t\t\tvar item = xml\r\n\t\t\t\t\t.childNodes\r\n\t\t\t\t\t.item(i);\r\n\t\t\t\tvar nodeName = item.nodeName;\r\n\t\t\t\tif (typeof (obj[nodeName]) === \"undefined\") {\r\n\t\t\t\t\tobj[nodeName] = this.xmlToJson(item);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (typeof (obj[nodeName].push) === \"undefined\") {\r\n\t\t\t\t\t\tvar old = obj[nodeName];\r\n\t\t\t\t\t\tobj[nodeName] = [];\r\n\t\t\t\t\t\tobj[nodeName].push(old);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tobj[nodeName].push(this.xmlToJson(item));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn obj;\r\n\t}\r\n\r\n}\r\n\r\nclass Iterator {\r\n\tconstructor(elements) {\r\n\t\tif (!Array.isArray(elements))\r\n\t\t\tthrow new Error('Parameter to constructor must be array');\r\n\r\n\t\tthis.elements = elements;\r\n\r\n\t} * iterator() {\r\n\r\n\t\tfor (let key in this.elements) {\r\n\t\t\tvar value = this.elements[key];\r\n\t\t\tyield value;\r\n\t\t}\r\n\t}\r\n\r\n\tget(key) {\r\n\t\treturn this.elements[key];\r\n\t} [Symbol.iterator]() {\r\n\t\treturn this.iterator();\r\n\t}\r\n}\r\n\r\nclass EventManager {\r\n\tconstructor(isSingleton) {\r\n\t\t// console.log(\"EventManager: starting\"); Collection of {event,\r\n\t\t// [subscribedCallbacks]}\r\n\t\tthis.subscriptions = []\r\n\t\t// if isSingleton is true, the object is attached to the document (only once)\r\n\t\tif (isSingleton) {\r\n\t\t\tif (window.eventManager === undefined) {\r\n\t\t\t\t//console.log(\"EventManager: creating singleton\");\r\n\t\t\t\twindow.eventManager = this\r\n\t\t\t} else {\r\n\t\t\t\t//console.log(\"EventManager: already instantiated\");\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t//console.log(\"EventManager: is not a singleton\");\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsubscribe(eventToSubscribe, callback) {\r\n\t\tvar eventObject = this.isCallbackSubscribed(eventToSubscribe, callback)\r\n\t\tif (eventObject === undefined) {\r\n\t\t\tvar eventFound = false\r\n\t\t\tthis\r\n\t\t\t\t.subscriptions\r\n\t\t\t\t.forEach(function (e) {\r\n\t\t\t\t\tif (e._event === eventToSubscribe) {\r\n\t\t\t\t\t\teventFound = true\r\n\t\t\t\t\t\te\r\n\t\t\t\t\t\t\t.subscribedCallbacks\r\n\t\t\t\t\t\t\t.push(callback)\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\r\n\t\t\tif (!eventFound) {\r\n\t\t\t\tvar subscribedCallbacks = [callback]\r\n\t\t\t\tthis\r\n\t\t\t\t\t.subscriptions\r\n\t\t\t\t\t.push({ _event: eventToSubscribe, subscribedCallbacks: subscribedCallbacks })\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tconsole.log(\"EventManager: callback already subscribed to event \" + eventToSubscribe);\r\n\t\t}\r\n\t}\r\n\r\n\tunsubscribe(eventToUnubscribe, callback) {\r\n\t\tvar eventObj = this.isCallbackSubscribed(eventToUnubscribe, callback);\r\n\t\tif (eventObj !== undefined) {\r\n\t\t\tthis\r\n\t\t\t\t.subscriptions[eventObj.eventIndex]\r\n\t\t\t\t.subscribedCallbacks\r\n\t\t\t\t.pop(eventObj.callbackIndex)\r\n\t\t}\r\n\t\tconsole.log(\"EventManager: callback unsubscribed from \" + eventToUnubscribe);\r\n\t}\r\n\r\n\tisCallbackSubscribed(event, callback) {\r\n\t\tvar result = undefined\r\n\t\tthis\r\n\t\t\t.subscriptions\r\n\t\t\t.forEach(function (e, i) {\r\n\t\t\t\tif (e._event === event) {\r\n\t\t\t\t\te\r\n\t\t\t\t\t\t.subscribedCallbacks\r\n\t\t\t\t\t\t.forEach(function (c, j) {\r\n\t\t\t\t\t\t\tif (c.toString() === callback.toString()) {\r\n\t\t\t\t\t\t\t\tresult = {\r\n\t\t\t\t\t\t\t\t\teventIndex: i,\r\n\t\t\t\t\t\t\t\t\tcallbackIndex: j\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\treturn result\r\n\t}\r\n\r\n\tdispatch(eventToDispatch, payload) {\r\n\t\t/* console.log(\"EventManager: dispatching\");\r\n\t\tconsole.log({_event: eventToDispatch, payload: payload}); */\r\n\t\tthis\r\n\t\t\t.subscriptions\r\n\t\t\t.forEach(function (e) {\r\n\t\t\t\tif (e._event === eventToDispatch) {\r\n\t\t\t\t\te\r\n\t\t\t\t\t\t.subscribedCallbacks\r\n\t\t\t\t\t\t.forEach(function (c) {\r\n\t\t\t\t\t\t\tc(payload)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t}\r\n\r\n\tshowAllSubsriptions() {\r\n\t\t//console.log($.extend(true, {}, this.subscriptions));\r\n\t}\r\n}\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvVXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvVXRpbHMuanM/YTE2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBUaW1lciB7XHJcblxyXG5cdGNyZWF0ZVRpbWVyKHRpbWUsIHVwZGF0ZUNhbGwsIGNhbGxiYWNrRnVuYywgcmVmKSB7XHJcblx0XHR0aGlzLnRpbWVyUGFyYW0gPSB7XHJcblx0XHRcdHRpbWUsXHJcblx0XHRcdHVwZGF0ZUNhbGwsXHJcblx0XHRcdGNhbGxiYWNrRnVuYyxcclxuXHRcdFx0cmVmXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0c3RhcnRUaW1lcigpIHtcclxuXHRcdC8vIHRoaXMuY3JlYXRlVGltZXIodGhpcy50aW1lclBhcmFtLnRpbWUsIHRoaXMudGltZXJQYXJhbS51cGRhdGVDYWxsLFxyXG5cdFx0Ly8gdGhpcy50aW1lclBhcmFtLmNhbGxiYWNrRnVuYywgdGhpcy50aW1lclBhcmFtLnJlZikgdGhpcy5zdG9wVGltZXIoKTtcclxuXHJcblx0XHR0aGlzLnNlY29uZHMgPSB0aGlzLnRpbWVyUGFyYW0udGltZSArIDE7XHJcblx0XHR0aGlzLnN0b3BUaW1lcigpO1xyXG5cclxuXHRcdHRoaXMuY291bnRkb3duVGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG5cdFx0XHRpZiAoIXRoaXMudGltZXJQYXVzZWQpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5zZWNvbmRzIDwgMSkge1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJUaW1lJ3MgdXAhXCIpO1xyXG5cdFx0XHRcdFx0dGhpcy50aW1lclBhcmFtLmNhbGxiYWNrRnVuYyh0aGlzLnRpbWVyUGFyYW0ucmVmKTtcclxuXHRcdFx0XHRcdHRoaXMuc3RvcFRpbWVyKCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coXCJjb3VudGluZyA+PiBcIiwgdGhpcy5zZWNvbmRzKTtcclxuXHRcdFx0XHRcdHRoaXMuc2Vjb25kcy0tO1xyXG5cdFx0XHRcdFx0dGhpc1xyXG5cdFx0XHRcdFx0XHQudGltZXJQYXJhbVxyXG5cdFx0XHRcdFx0XHQudXBkYXRlQ2FsbCh0aGlzLnRpbWVyUGFyYW0ucmVmKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sIDEwMDApO1xyXG5cdH1cclxuXHJcblx0cGF1c2VUaW1lcigpIHtcclxuXHRcdHRoaXMudGltZXJQYXVzZWQgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0cmVzdW1lVGltZXIoKSB7XHJcblx0XHR0aGlzLnRpbWVyUGF1c2VkID0gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRzdG9wVGltZXIoKSB7XHJcblx0XHRpZiAodGhpcy5jb3VudGRvd25UaW1lcikge1xyXG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMuY291bnRkb3duVGltZXIpO1xyXG5cdFx0XHR0aGlzLmNvdW50ZG93blRpbWVyID0gbnVsbDtcclxuXHRcdFx0Ly90aGlzLnRpbWVyUGF1c2VkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRnZXRUaW1lKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vjb25kcztcclxuXHJcblx0fVxyXG5cdGdldEZvcm1hdHRlZFRpbWUoKSB7XHJcblx0XHRsZXQgcGFkID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcblx0XHRcdHJldHVybiBpbnB1dCA8IDEwXHJcblx0XHRcdFx0PyBcIjBcIiArIGlucHV0ICsgXCIgU2VjXCJcclxuXHRcdFx0XHQ6IGlucHV0ICsgXCIgU2VjXCI7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcGFkKHRoaXMuZ2V0VGltZSgpKTtcclxuXHJcblx0fVxyXG5cdGdldENvbnZlcnRlZFRpbWUoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb252ZXJ0VGltZSh0aGlzLnNlY29uZHMpO1xyXG5cdH1cclxuXHJcblx0Y29udmVydFRpbWUoaW5wdXQsIHNlcGFyYXRvcikge1xyXG5cdFx0bGV0IHBhZCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG5cdFx0XHRyZXR1cm4gaW5wdXQgPCAxMFxyXG5cdFx0XHRcdD8gXCIwXCIgKyBpbnB1dFxyXG5cdFx0XHRcdDogaW5wdXQ7XHJcblx0XHR9O1xyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0LypwYWQoTWF0aC5mbG9vcihpbnB1dCAvIDM2MDApKSwqL1xyXG5cdFx0XHRwYWQoTWF0aC5mbG9vcihpbnB1dCAlIDM2MDAgLyA2MCkpLFxyXG5cdFx0XHRwYWQoTWF0aC5mbG9vcihpbnB1dCAlIDYwKSlcclxuXHRcdF0uam9pbih0eXBlb2Ygc2VwYXJhdG9yICE9PSAndW5kZWZpbmVkJ1xyXG5cdFx0XHQ/IHNlcGFyYXRvclxyXG5cdFx0XHQ6ICc6Jyk7XHJcblx0fVxyXG59XHJcblxyXG5jbGFzcyBBcnJheVV0aWxzIHtcclxuXHRzdGF0aWMgZ2V0UmFuZG9tQm9vbCgpIHtcclxuXHRcdHJldHVybiAoTWF0aC5yYW5kb20oKSA+IDAuNSlcclxuXHRcdFx0PyAxXHJcblx0XHRcdDogMFxyXG5cdH1cclxuXHJcblx0c3RhdGljIHNodWZmbGVBcnJheShhcnIpIHtcclxuXHRcdGxldCBhID0gQXJyYXlVdGlscy5jb3B5QXJyYXkoYXJyKTtcclxuXHRcdGxldCBsID0gYS5sZW5ndGg7XHJcblx0XHRsZXQgaSA9IDA7XHJcblx0XHRmb3IgKGk7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0bGV0IHRtcCA9IGFbaV07XHJcblx0XHRcdGxldCByYW5kID0gTWF0aC5mbG9vcihOdW1iZXIoTWF0aC5yYW5kb20oKSAqIGwpKTtcclxuXHRcdFx0Ly9hbGVydChyYW5kKVxyXG5cdFx0XHRhW2ldID0gYVtyYW5kXTtcclxuXHRcdFx0YVtyYW5kXSA9IHRtcDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBhXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZ2V0UmFuZG9tVmFsdWUoYXJyKSB7XHJcblx0XHRyZXR1cm4gYXJyW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyci5sZW5ndGgpXVxyXG5cdH1cclxuXHJcblx0c3RhdGljIGNvcHlBcnJheShhKSB7XHJcblx0XHRyZXR1cm4gYS5zbGljZSgpXHJcblx0fVxyXG59XHJcblxyXG5jbGFzcyBEaXNwbGF5VXRpbHMge1xyXG5cclxuXHRzdGF0aWMgc2V0VHJhbnNmb3JtKHRhcmdldF9tYywgeCwgeSwgcmVnWCwgcmVnWSkge1xyXG5cdFx0dGFyZ2V0X21jLnNldFRyYW5zZm9ybSh4LCB5LCAxLCAxLCAwLCAwLCAwLCByZWdYLCByZWdZKTtcclxuXHR9XHJcbn1cclxuXHJcbmNsYXNzIFhNTFV0aWxzIHtcclxuXHJcblx0c3RhdGljIHhtbFRvSnNvbih4bWwpIHtcclxuXHJcblx0XHQvLyBDcmVhdGUgdGhlIHJldHVybiBvYmplY3RcclxuXHRcdHZhciBvYmogPSB7fTtcclxuXHJcblx0XHRpZiAoeG1sLm5vZGVUeXBlID09PSAxKSB7IC8vIGVsZW1lbnRcclxuXHRcdFx0Ly8gZG8gYXR0cmlidXRlc1xyXG5cdFx0XHRpZiAoeG1sLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdG9ialtcIkBhdHRyaWJ1dGVzXCJdID0ge307XHJcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB4bWwuYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IHhtbFxyXG5cdFx0XHRcdFx0XHQuYXR0cmlidXRlc1xyXG5cdFx0XHRcdFx0XHQuaXRlbShqKTtcclxuXHRcdFx0XHRcdG9ialtcIkBhdHRyaWJ1dGVzXCJdW2F0dHJpYnV0ZS5ub2RlTmFtZV0gPSBhdHRyaWJ1dGUubm9kZVZhbHVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICh4bWwubm9kZVR5cGUgPT09IDMpIHsgLy8gdGV4dFxyXG5cdFx0XHRvYmogPSB4bWwubm9kZVZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRvIGNoaWxkcmVuIElmIGp1c3Qgb25lIHRleHQgbm9kZSBpbnNpZGVcclxuXHRcdGlmICh4bWwuaGFzQ2hpbGROb2RlcygpICYmIHhtbC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJiB4bWwuY2hpbGROb2Rlc1swXS5ub2RlVHlwZSA9PT0gMykge1xyXG5cdFx0XHRvYmogPSB4bWwuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWU7XHJcblx0XHR9IGVsc2UgaWYgKHhtbC5oYXNDaGlsZE5vZGVzKCkpIHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHZhciBpdGVtID0geG1sXHJcblx0XHRcdFx0XHQuY2hpbGROb2Rlc1xyXG5cdFx0XHRcdFx0Lml0ZW0oaSk7XHJcblx0XHRcdFx0dmFyIG5vZGVOYW1lID0gaXRlbS5ub2RlTmFtZTtcclxuXHRcdFx0XHRpZiAodHlwZW9mIChvYmpbbm9kZU5hbWVdKSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRcdFx0b2JqW25vZGVOYW1lXSA9IHRoaXMueG1sVG9Kc29uKGl0ZW0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAodHlwZW9mIChvYmpbbm9kZU5hbWVdLnB1c2gpID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdFx0XHRcdHZhciBvbGQgPSBvYmpbbm9kZU5hbWVdO1xyXG5cdFx0XHRcdFx0XHRvYmpbbm9kZU5hbWVdID0gW107XHJcblx0XHRcdFx0XHRcdG9ialtub2RlTmFtZV0ucHVzaChvbGQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0b2JqW25vZGVOYW1lXS5wdXNoKHRoaXMueG1sVG9Kc29uKGl0ZW0pKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBvYmo7XHJcblx0fVxyXG5cclxufVxyXG5cclxuY2xhc3MgSXRlcmF0b3Ige1xyXG5cdGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XHJcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkoZWxlbWVudHMpKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciB0byBjb25zdHJ1Y3RvciBtdXN0IGJlIGFycmF5Jyk7XHJcblxyXG5cdFx0dGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xyXG5cclxuXHR9ICogaXRlcmF0b3IoKSB7XHJcblxyXG5cdFx0Zm9yIChsZXQga2V5IGluIHRoaXMuZWxlbWVudHMpIHtcclxuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5lbGVtZW50c1trZXldO1xyXG5cdFx0XHR5aWVsZCB2YWx1ZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGdldChrZXkpIHtcclxuXHRcdHJldHVybiB0aGlzLmVsZW1lbnRzW2tleV07XHJcblx0fSBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCk7XHJcblx0fVxyXG59XHJcblxyXG5jbGFzcyBFdmVudE1hbmFnZXIge1xyXG5cdGNvbnN0cnVjdG9yKGlzU2luZ2xldG9uKSB7XHJcblx0XHQvLyBjb25zb2xlLmxvZyhcIkV2ZW50TWFuYWdlcjogc3RhcnRpbmdcIik7IENvbGxlY3Rpb24gb2Yge2V2ZW50LFxyXG5cdFx0Ly8gW3N1YnNjcmliZWRDYWxsYmFja3NdfVxyXG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zID0gW11cclxuXHRcdC8vIGlmIGlzU2luZ2xldG9uIGlzIHRydWUsIHRoZSBvYmplY3QgaXMgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50IChvbmx5IG9uY2UpXHJcblx0XHRpZiAoaXNTaW5nbGV0b24pIHtcclxuXHRcdFx0aWYgKHdpbmRvdy5ldmVudE1hbmFnZXIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coXCJFdmVudE1hbmFnZXI6IGNyZWF0aW5nIHNpbmdsZXRvblwiKTtcclxuXHRcdFx0XHR3aW5kb3cuZXZlbnRNYW5hZ2VyID0gdGhpc1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coXCJFdmVudE1hbmFnZXI6IGFscmVhZHkgaW5zdGFudGlhdGVkXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKFwiRXZlbnRNYW5hZ2VyOiBpcyBub3QgYSBzaW5nbGV0b25cIik7XHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c3Vic2NyaWJlKGV2ZW50VG9TdWJzY3JpYmUsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgZXZlbnRPYmplY3QgPSB0aGlzLmlzQ2FsbGJhY2tTdWJzY3JpYmVkKGV2ZW50VG9TdWJzY3JpYmUsIGNhbGxiYWNrKVxyXG5cdFx0aWYgKGV2ZW50T2JqZWN0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dmFyIGV2ZW50Rm91bmQgPSBmYWxzZVxyXG5cdFx0XHR0aGlzXHJcblx0XHRcdFx0LnN1YnNjcmlwdGlvbnNcclxuXHRcdFx0XHQuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0aWYgKGUuX2V2ZW50ID09PSBldmVudFRvU3Vic2NyaWJlKSB7XHJcblx0XHRcdFx0XHRcdGV2ZW50Rm91bmQgPSB0cnVlXHJcblx0XHRcdFx0XHRcdGVcclxuXHRcdFx0XHRcdFx0XHQuc3Vic2NyaWJlZENhbGxiYWNrc1xyXG5cdFx0XHRcdFx0XHRcdC5wdXNoKGNhbGxiYWNrKVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pXHJcblxyXG5cdFx0XHRpZiAoIWV2ZW50Rm91bmQpIHtcclxuXHRcdFx0XHR2YXIgc3Vic2NyaWJlZENhbGxiYWNrcyA9IFtjYWxsYmFja11cclxuXHRcdFx0XHR0aGlzXHJcblx0XHRcdFx0XHQuc3Vic2NyaXB0aW9uc1xyXG5cdFx0XHRcdFx0LnB1c2goeyBfZXZlbnQ6IGV2ZW50VG9TdWJzY3JpYmUsIHN1YnNjcmliZWRDYWxsYmFja3M6IHN1YnNjcmliZWRDYWxsYmFja3MgfSlcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJFdmVudE1hbmFnZXI6IGNhbGxiYWNrIGFscmVhZHkgc3Vic2NyaWJlZCB0byBldmVudCBcIiArIGV2ZW50VG9TdWJzY3JpYmUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dW5zdWJzY3JpYmUoZXZlbnRUb1VudWJzY3JpYmUsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgZXZlbnRPYmogPSB0aGlzLmlzQ2FsbGJhY2tTdWJzY3JpYmVkKGV2ZW50VG9VbnVic2NyaWJlLCBjYWxsYmFjayk7XHJcblx0XHRpZiAoZXZlbnRPYmogIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdFx0LnN1YnNjcmlwdGlvbnNbZXZlbnRPYmouZXZlbnRJbmRleF1cclxuXHRcdFx0XHQuc3Vic2NyaWJlZENhbGxiYWNrc1xyXG5cdFx0XHRcdC5wb3AoZXZlbnRPYmouY2FsbGJhY2tJbmRleClcclxuXHRcdH1cclxuXHRcdGNvbnNvbGUubG9nKFwiRXZlbnRNYW5hZ2VyOiBjYWxsYmFjayB1bnN1YnNjcmliZWQgZnJvbSBcIiArIGV2ZW50VG9VbnVic2NyaWJlKTtcclxuXHR9XHJcblxyXG5cdGlzQ2FsbGJhY2tTdWJzY3JpYmVkKGV2ZW50LCBjYWxsYmFjaykge1xyXG5cdFx0dmFyIHJlc3VsdCA9IHVuZGVmaW5lZFxyXG5cdFx0dGhpc1xyXG5cdFx0XHQuc3Vic2NyaXB0aW9uc1xyXG5cdFx0XHQuZm9yRWFjaChmdW5jdGlvbiAoZSwgaSkge1xyXG5cdFx0XHRcdGlmIChlLl9ldmVudCA9PT0gZXZlbnQpIHtcclxuXHRcdFx0XHRcdGVcclxuXHRcdFx0XHRcdFx0LnN1YnNjcmliZWRDYWxsYmFja3NcclxuXHRcdFx0XHRcdFx0LmZvckVhY2goZnVuY3Rpb24gKGMsIGopIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoYy50b1N0cmluZygpID09PSBjYWxsYmFjay50b1N0cmluZygpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgPSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGV2ZW50SW5kZXg6IGksXHJcblx0XHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrSW5kZXg6IGpcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KVxyXG5cdFx0cmV0dXJuIHJlc3VsdFxyXG5cdH1cclxuXHJcblx0ZGlzcGF0Y2goZXZlbnRUb0Rpc3BhdGNoLCBwYXlsb2FkKSB7XHJcblx0XHQvKiBjb25zb2xlLmxvZyhcIkV2ZW50TWFuYWdlcjogZGlzcGF0Y2hpbmdcIik7XHJcblx0XHRjb25zb2xlLmxvZyh7X2V2ZW50OiBldmVudFRvRGlzcGF0Y2gsIHBheWxvYWQ6IHBheWxvYWR9KTsgKi9cclxuXHRcdHRoaXNcclxuXHRcdFx0LnN1YnNjcmlwdGlvbnNcclxuXHRcdFx0LmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRpZiAoZS5fZXZlbnQgPT09IGV2ZW50VG9EaXNwYXRjaCkge1xyXG5cdFx0XHRcdFx0ZVxyXG5cdFx0XHRcdFx0XHQuc3Vic2NyaWJlZENhbGxiYWNrc1xyXG5cdFx0XHRcdFx0XHQuZm9yRWFjaChmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdFx0XHRcdGMocGF5bG9hZClcclxuXHRcdFx0XHRcdFx0fSlcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pXHJcblx0fVxyXG5cclxuXHRzaG93QWxsU3Vic3JpcHRpb25zKCkge1xyXG5cdFx0Ly9jb25zb2xlLmxvZygkLmV4dGVuZCh0cnVlLCB7fSwgdGhpcy5zdWJzY3JpcHRpb25zKSk7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQge1xyXG5cdERpc3BsYXlVdGlscyxcclxuXHRYTUxVdGlscyxcclxuXHRBcnJheVV0aWxzLFxyXG5cdFRpbWVyLFxyXG5cdEl0ZXJhdG9yLFxyXG5cdEV2ZW50TWFuYWdlclxyXG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils/Utils.js\n");

/***/ }),

/***/ "./src/views/App.js":
/*!**************************!*\
  !*** ./src/views/App.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _GameDisplay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameDisplay */ \"./src/views/GameDisplay.js\");\n/* harmony import */ var _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/SoundUtil */ \"./src/utils/SoundUtil.js\");\n\n\n\nclass App {\n\n  start() {\n\n    this.window = window;\n    this.document = window.document;\n    this.createjs = window.createjs;\n    this.AdobeAn = window.AdobeAn;\n\n    this.progressElement = null;\n    this.loadCheck = false;\n\n    this.loadData();\n  }\n\n  loadData() {\n\n    this.canvas = this\n      .document\n      .getElementById(\"canvas\");\n    this.anim_container = this\n      .document\n      .getElementById(\"animation_container\");\n    this.dom_overlay_container = this\n      .document\n      .getElementById(\"dom_overlay_container\");\n\n    var comp = this\n      .AdobeAn\n      .getComposition(\"A30E223B12428B4F8D0612006303F8DA\");\n    this.comp = comp;\n\n    this\n      .createjs\n      .MotionGuidePlugin\n      .install();\n\n    this.loader = new this\n      .createjs\n      .LoadQueue(false);\n\n    this\n      .loader\n      .installPlugin(this.createjs.Sound);\n\n    this\n      .loader\n      .loadFile({ src: \"./assets/CricketChallengeXmlStructure.xml\", id: 'gameData' });\n\n\n    this.lib = this\n      .comp\n      .getLibrary();\n    this\n      .loader\n      .loadManifest(this.lib.properties.manifest);\n\n    this\n      .loader\n      .addEventListener(\"fileload\", (evt) => {\n        this.handleFileLoad(evt)\n      });\n\n    //old technique\n    this.loader.addEventListener(\"progress\", (evt) => {\n      this.progressElement = this.document.getElementById(\"progress\");\n      let progressVal = Math.ceil(evt.progress * 100);\n      this.progressElement.style.setProperty('width', progressVal + '%');\n      this.progressElement.textContent = \"Loading Assets - \" + progressVal + \"%\";\n    });\n\n\n    this.loader.addEventListener(\"complete\", (evt) => {\n      this.handleComplete(evt);\n    });\n\n  }\n\n  handleFileLoad(evt) {\n\n    var images = this\n      .comp\n      .getImages();\n    if (evt && (evt.item.type === \"image\")) {\n      images[evt.item.id] = evt.result;\n    }\n    if (evt && (evt.item.type === \"sound\")) {\n      //console.log(evt.item.id, \"loading \", this.loader); //._parsePath(evt.item.src)\n      _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_1__[\"default\"].registerSound(evt.item.src, evt.item.id);\n    }\n    this.loader.crossOrigin = \"Anonymous\";\n    //console.log(evt.item.id, \" load \", this.loader);\n    //this.progressElement.textContent = \"Loading Asset (\" + evt.item.id + \") of type [\" + evt.item.type + \"]\";\n  }\n\n  handleComplete(evt) {\n\n    this.loader.removeAllEventListeners();\n\n    this.assetLoadedCheck(); //used with old tehnique\n\n    let _data = new this\n      .window\n      .X2JS({ keepCData: true });\n    this.xmlData = _data.xml2json(this.loader.getResult(\"gameData\"));\n\n    let lib = this\n      .comp\n      .getLibrary();\n    let ss = this\n      .comp\n      .getSpriteSheet();\n\n    let queue = evt.target;\n    let ssMetadata = lib.ssMetadata;\n    for (let i = 0; i < ssMetadata.length; i++) {\n      ss[ssMetadata[i].name] = new this\n        .createjs\n        .SpriteSheet({\n          \"images\": [queue.getResult(ssMetadata[i].name)],\n          \"frames\": ssMetadata[i].frames\n        })\n    }\n\n    this.AdobeAn.compositionLoaded(lib.properties.id);\n  }\n\n  assetLoadedCheck() {\n\n    /* let progress = (this.loader.getItems(true)).length / (this.loader.getItems(false)).length;\n    let progressPer = Math.ceil(progress * 100); */\n    this.progressElement.textContent = \"Wait... preparing assets\";\n\n    this.delayInterval = window.setTimeout(() => {\n      if ((this.loader.getItems(true)).length === (this.loader.getItems(false)).length) {\n        window.clearInterval(this.delayInterval);\n\n        this.progressElement.style\n          .setProperty(\"display\", \"none\");\n\n        this.startGame();\n      } else {\n        this.assetLoadedCheck();\n      }\n    }, 1000);\n  }\n\n  startGame() {\n\n    let lib = this\n      .comp\n      .getLibrary();\n\n    this.exportRoot = new lib.fl_assets();\n    this.stage = new lib.Stage(this.canvas);\n    //this.stage = new this.createjs.StageGL(\"canvas\");\n\n    var game = new _GameDisplay__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n      window: this.window,\n      createjs: this.createjs,\n      canvas: this.canvas,\n      stage: this.stage,\n      exportRoot: this.exportRoot,\n      lib: this.lib,\n      xmlData: this.xmlData\n    });\n    game.config();\n\n    this.window.playGame = function (p) {\n      game.init(p);\n    }\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (App);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmlld3MvQXBwLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL0FwcC5qcz9jNTE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHYW1lRGlzcGxheSBmcm9tICcuL0dhbWVEaXNwbGF5JztcbmltcG9ydCBTb3VuZFV0aWwgZnJvbSAnLi4vdXRpbHMvU291bmRVdGlsJztcblxuY2xhc3MgQXBwIHtcblxuICBzdGFydCgpIHtcblxuICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgIHRoaXMuZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgdGhpcy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqcztcbiAgICB0aGlzLkFkb2JlQW4gPSB3aW5kb3cuQWRvYmVBbjtcblxuICAgIHRoaXMucHJvZ3Jlc3NFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmxvYWRDaGVjayA9IGZhbHNlO1xuXG4gICAgdGhpcy5sb2FkRGF0YSgpO1xuICB9XG5cbiAgbG9hZERhdGEoKSB7XG5cbiAgICB0aGlzLmNhbnZhcyA9IHRoaXNcbiAgICAgIC5kb2N1bWVudFxuICAgICAgLmdldEVsZW1lbnRCeUlkKFwiY2FudmFzXCIpO1xuICAgIHRoaXMuYW5pbV9jb250YWluZXIgPSB0aGlzXG4gICAgICAuZG9jdW1lbnRcbiAgICAgIC5nZXRFbGVtZW50QnlJZChcImFuaW1hdGlvbl9jb250YWluZXJcIik7XG4gICAgdGhpcy5kb21fb3ZlcmxheV9jb250YWluZXIgPSB0aGlzXG4gICAgICAuZG9jdW1lbnRcbiAgICAgIC5nZXRFbGVtZW50QnlJZChcImRvbV9vdmVybGF5X2NvbnRhaW5lclwiKTtcblxuICAgIHZhciBjb21wID0gdGhpc1xuICAgICAgLkFkb2JlQW5cbiAgICAgIC5nZXRDb21wb3NpdGlvbihcIkEzMEUyMjNCMTI0MjhCNEY4RDA2MTIwMDYzMDNGOERBXCIpO1xuICAgIHRoaXMuY29tcCA9IGNvbXA7XG5cbiAgICB0aGlzXG4gICAgICAuY3JlYXRlanNcbiAgICAgIC5Nb3Rpb25HdWlkZVBsdWdpblxuICAgICAgLmluc3RhbGwoKTtcblxuICAgIHRoaXMubG9hZGVyID0gbmV3IHRoaXNcbiAgICAgIC5jcmVhdGVqc1xuICAgICAgLkxvYWRRdWV1ZShmYWxzZSk7XG5cbiAgICB0aGlzXG4gICAgICAubG9hZGVyXG4gICAgICAuaW5zdGFsbFBsdWdpbih0aGlzLmNyZWF0ZWpzLlNvdW5kKTtcblxuICAgIHRoaXNcbiAgICAgIC5sb2FkZXJcbiAgICAgIC5sb2FkRmlsZSh7IHNyYzogXCIuL2Fzc2V0cy9Dcmlja2V0Q2hhbGxlbmdlWG1sU3RydWN0dXJlLnhtbFwiLCBpZDogJ2dhbWVEYXRhJyB9KTtcblxuXG4gICAgdGhpcy5saWIgPSB0aGlzXG4gICAgICAuY29tcFxuICAgICAgLmdldExpYnJhcnkoKTtcbiAgICB0aGlzXG4gICAgICAubG9hZGVyXG4gICAgICAubG9hZE1hbmlmZXN0KHRoaXMubGliLnByb3BlcnRpZXMubWFuaWZlc3QpO1xuXG4gICAgdGhpc1xuICAgICAgLmxvYWRlclxuICAgICAgLmFkZEV2ZW50TGlzdGVuZXIoXCJmaWxlbG9hZFwiLCAoZXZ0KSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlRmlsZUxvYWQoZXZ0KVxuICAgICAgfSk7XG5cbiAgICAvL29sZCB0ZWNobmlxdWVcbiAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgKGV2dCkgPT4ge1xuICAgICAgdGhpcy5wcm9ncmVzc0VsZW1lbnQgPSB0aGlzLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJvZ3Jlc3NcIik7XG4gICAgICBsZXQgcHJvZ3Jlc3NWYWwgPSBNYXRoLmNlaWwoZXZ0LnByb2dyZXNzICogMTAwKTtcbiAgICAgIHRoaXMucHJvZ3Jlc3NFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCd3aWR0aCcsIHByb2dyZXNzVmFsICsgJyUnKTtcbiAgICAgIHRoaXMucHJvZ3Jlc3NFbGVtZW50LnRleHRDb250ZW50ID0gXCJMb2FkaW5nIEFzc2V0cyAtIFwiICsgcHJvZ3Jlc3NWYWwgKyBcIiVcIjtcbiAgICB9KTtcblxuXG4gICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbXBsZXRlXCIsIChldnQpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlQ29tcGxldGUoZXZ0KTtcbiAgICB9KTtcblxuICB9XG5cbiAgaGFuZGxlRmlsZUxvYWQoZXZ0KSB7XG5cbiAgICB2YXIgaW1hZ2VzID0gdGhpc1xuICAgICAgLmNvbXBcbiAgICAgIC5nZXRJbWFnZXMoKTtcbiAgICBpZiAoZXZ0ICYmIChldnQuaXRlbS50eXBlID09PSBcImltYWdlXCIpKSB7XG4gICAgICBpbWFnZXNbZXZ0Lml0ZW0uaWRdID0gZXZ0LnJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGV2dCAmJiAoZXZ0Lml0ZW0udHlwZSA9PT0gXCJzb3VuZFwiKSkge1xuICAgICAgLy9jb25zb2xlLmxvZyhldnQuaXRlbS5pZCwgXCJsb2FkaW5nIFwiLCB0aGlzLmxvYWRlcik7IC8vLl9wYXJzZVBhdGgoZXZ0Lml0ZW0uc3JjKVxuICAgICAgU291bmRVdGlsLnJlZ2lzdGVyU291bmQoZXZ0Lml0ZW0uc3JjLCBldnQuaXRlbS5pZCk7XG4gICAgfVxuICAgIHRoaXMubG9hZGVyLmNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIjtcbiAgICAvL2NvbnNvbGUubG9nKGV2dC5pdGVtLmlkLCBcIiBsb2FkIFwiLCB0aGlzLmxvYWRlcik7XG4gICAgLy90aGlzLnByb2dyZXNzRWxlbWVudC50ZXh0Q29udGVudCA9IFwiTG9hZGluZyBBc3NldCAoXCIgKyBldnQuaXRlbS5pZCArIFwiKSBvZiB0eXBlIFtcIiArIGV2dC5pdGVtLnR5cGUgKyBcIl1cIjtcbiAgfVxuXG4gIGhhbmRsZUNvbXBsZXRlKGV2dCkge1xuXG4gICAgdGhpcy5sb2FkZXIucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIHRoaXMuYXNzZXRMb2FkZWRDaGVjaygpOyAvL3VzZWQgd2l0aCBvbGQgdGVobmlxdWVcblxuICAgIGxldCBfZGF0YSA9IG5ldyB0aGlzXG4gICAgICAud2luZG93XG4gICAgICAuWDJKUyh7IGtlZXBDRGF0YTogdHJ1ZSB9KTtcbiAgICB0aGlzLnhtbERhdGEgPSBfZGF0YS54bWwyanNvbih0aGlzLmxvYWRlci5nZXRSZXN1bHQoXCJnYW1lRGF0YVwiKSk7XG5cbiAgICBsZXQgbGliID0gdGhpc1xuICAgICAgLmNvbXBcbiAgICAgIC5nZXRMaWJyYXJ5KCk7XG4gICAgbGV0IHNzID0gdGhpc1xuICAgICAgLmNvbXBcbiAgICAgIC5nZXRTcHJpdGVTaGVldCgpO1xuXG4gICAgbGV0IHF1ZXVlID0gZXZ0LnRhcmdldDtcbiAgICBsZXQgc3NNZXRhZGF0YSA9IGxpYi5zc01ldGFkYXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3NNZXRhZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgc3Nbc3NNZXRhZGF0YVtpXS5uYW1lXSA9IG5ldyB0aGlzXG4gICAgICAgIC5jcmVhdGVqc1xuICAgICAgICAuU3ByaXRlU2hlZXQoe1xuICAgICAgICAgIFwiaW1hZ2VzXCI6IFtxdWV1ZS5nZXRSZXN1bHQoc3NNZXRhZGF0YVtpXS5uYW1lKV0sXG4gICAgICAgICAgXCJmcmFtZXNcIjogc3NNZXRhZGF0YVtpXS5mcmFtZXNcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLkFkb2JlQW4uY29tcG9zaXRpb25Mb2FkZWQobGliLnByb3BlcnRpZXMuaWQpO1xuICB9XG5cbiAgYXNzZXRMb2FkZWRDaGVjaygpIHtcblxuICAgIC8qIGxldCBwcm9ncmVzcyA9ICh0aGlzLmxvYWRlci5nZXRJdGVtcyh0cnVlKSkubGVuZ3RoIC8gKHRoaXMubG9hZGVyLmdldEl0ZW1zKGZhbHNlKSkubGVuZ3RoO1xuICAgIGxldCBwcm9ncmVzc1BlciA9IE1hdGguY2VpbChwcm9ncmVzcyAqIDEwMCk7ICovXG4gICAgdGhpcy5wcm9ncmVzc0VsZW1lbnQudGV4dENvbnRlbnQgPSBcIldhaXQuLi4gcHJlcGFyaW5nIGFzc2V0c1wiO1xuXG4gICAgdGhpcy5kZWxheUludGVydmFsID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCh0aGlzLmxvYWRlci5nZXRJdGVtcyh0cnVlKSkubGVuZ3RoID09PSAodGhpcy5sb2FkZXIuZ2V0SXRlbXMoZmFsc2UpKS5sZW5ndGgpIHtcbiAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5kZWxheUludGVydmFsKTtcblxuICAgICAgICB0aGlzLnByb2dyZXNzRWxlbWVudC5zdHlsZVxuICAgICAgICAgIC5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuXG4gICAgICAgIHRoaXMuc3RhcnRHYW1lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFzc2V0TG9hZGVkQ2hlY2soKTtcbiAgICAgIH1cbiAgICB9LCAxMDAwKTtcbiAgfVxuXG4gIHN0YXJ0R2FtZSgpIHtcblxuICAgIGxldCBsaWIgPSB0aGlzXG4gICAgICAuY29tcFxuICAgICAgLmdldExpYnJhcnkoKTtcblxuICAgIHRoaXMuZXhwb3J0Um9vdCA9IG5ldyBsaWIuZmxfYXNzZXRzKCk7XG4gICAgdGhpcy5zdGFnZSA9IG5ldyBsaWIuU3RhZ2UodGhpcy5jYW52YXMpO1xuICAgIC8vdGhpcy5zdGFnZSA9IG5ldyB0aGlzLmNyZWF0ZWpzLlN0YWdlR0woXCJjYW52YXNcIik7XG5cbiAgICB2YXIgZ2FtZSA9IG5ldyBHYW1lRGlzcGxheSh7XG4gICAgICB3aW5kb3c6IHRoaXMud2luZG93LFxuICAgICAgY3JlYXRlanM6IHRoaXMuY3JlYXRlanMsXG4gICAgICBjYW52YXM6IHRoaXMuY2FudmFzLFxuICAgICAgc3RhZ2U6IHRoaXMuc3RhZ2UsXG4gICAgICBleHBvcnRSb290OiB0aGlzLmV4cG9ydFJvb3QsXG4gICAgICBsaWI6IHRoaXMubGliLFxuICAgICAgeG1sRGF0YTogdGhpcy54bWxEYXRhXG4gICAgfSk7XG4gICAgZ2FtZS5jb25maWcoKTtcblxuICAgIHRoaXMud2luZG93LnBsYXlHYW1lID0gZnVuY3Rpb24gKHApIHtcbiAgICAgIGdhbWUuaW5pdChwKTtcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBcHA7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/views/App.js\n");

/***/ }),

/***/ "./src/views/GameDisplay.js":
/*!**********************************!*\
  !*** ./src/views/GameDisplay.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Utils */ \"./src/utils/Utils.js\");\n/* harmony import */ var _models_Models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/Models */ \"./src/models/Models.js\");\n/* harmony import */ var _Question__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Question */ \"./src/views/Question.js\");\n/* harmony import */ var _ScoreBoard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ScoreBoard */ \"./src/views/ScoreBoard.js\");\n/* harmony import */ var _models_GameEvent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../models/GameEvent */ \"./src/models/GameEvent.js\");\n/* harmony import */ var _InfoStatus__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./InfoStatus */ \"./src/views/InfoStatus.js\");\n/* harmony import */ var _models_Umpire__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../models/Umpire */ \"./src/models/Umpire.js\");\n/* harmony import */ var _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/SoundUtil */ \"./src/utils/SoundUtil.js\");\n/* harmony import */ var _utils_TextUtil__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/TextUtil */ \"./src/utils/TextUtil.js\");\n/* harmony import */ var _utils_ButtonUtil__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/ButtonUtil */ \"./src/utils/ButtonUtil.js\");\n/* harmony import */ var _models_TeamData__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../models/TeamData */ \"./src/models/TeamData.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass GameDisplay {\r\n\r\n    constructor(param) {\r\n\r\n        this.dev = false;\r\n        this.win = param.window;\r\n\r\n        this.createjs = param.createjs;\r\n        this.canvas = param.canvas;\r\n        this.exportRoot = param.exportRoot;\r\n        this.lib = param.lib;\r\n        this.stage = param.stage;\r\n\r\n\r\n        this.stage.enableMouseOver(20);\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().xmlData = param.xmlData;\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire = new _models_Umpire__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().scoreboard = new _ScoreBoard__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef = this;\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.gamePaused = false;\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.canHideBallNote = false;\r\n        this.gameOverSeen = false; \r\n\r\n        this.setupEvents();\r\n\r\n        this.win.canvasObjRef = {\r\n            startBtn: {},\r\n            htpBtn: {},\r\n            skipBtn: {},\r\n            submitBtn: {},\r\n            continueBtn: {},\r\n\r\n            /** Intro callback -----------------------------------------------------------------------*/\r\n            startOfIntro(p) {\r\n\r\n                _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"MusicMix\");\r\n\r\n                p.GameDes_txt.text = _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .xmlData\r\n                    .GameContent\r\n                    .Gamedata\r\n                    .GameEdge\r\n                    .descriptionTxt;\r\n                p.GameDes_txt.font = _utils_TextUtil__WEBPACK_IMPORTED_MODULE_8__[\"default\"]\r\n                    .defaultStyle()\r\n                    .style;\r\n                p.GameDes_txt.color = _utils_TextUtil__WEBPACK_IMPORTED_MODULE_8__[\"default\"]\r\n                    .defaultStyle()\r\n                    .color;\r\n                p.GameDes_txt.textAlign = \"left\";\r\n                p.GameDes_txt.lineWidth = _utils_TextUtil__WEBPACK_IMPORTED_MODULE_8__[\"default\"]\r\n                    .defaultStyle()\r\n                    .width;\r\n\r\n                p.GameDes_txt.visible = false;\r\n\r\n                this.startBtn = p.getChildByName(\"startBtnMc\");\r\n                this.startBtn.on(\"click\", (evt) => {\r\n                    _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.initToss();\r\n                });\r\n                this.startBtn.visible = false;\r\n                _utils_ButtonUtil__WEBPACK_IMPORTED_MODULE_9__[\"default\"].configure(this.startBtn);\r\n\r\n\r\n                this.htpBtn = p.getChildByName(\"howToPlayBtnMc\");\r\n                this.htpBtn.on(\"click\", (evt) => {\r\n                    _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.showHelpScreen();\r\n                });\r\n                this.htpBtn.visible = false;\r\n                _utils_ButtonUtil__WEBPACK_IMPORTED_MODULE_9__[\"default\"].configure(this.htpBtn);\r\n\r\n                this.skipBtn = p.getChildByName(\"skipBtn\");\r\n                this.skipBtn.on(\"click\", (evt) => {\r\n                    p.gotoAndStop(\"end\"); // end\r\n                    p.GameDes_txt.visible = true;\r\n                    _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].stopSound(\"MusicMix\");\r\n                });\r\n                _utils_ButtonUtil__WEBPACK_IMPORTED_MODULE_9__[\"default\"].configure(this.skipBtn);\r\n\r\n            },\r\n\r\n            hideSkip(p) {\r\n                this.skipBtn.visible = false;\r\n            },\r\n            endOfIntro(p) {\r\n                p.stop();\r\n\r\n                p.GameDes_txt.visible = true;\r\n\r\n                this.startBtn.visible = this.htpBtn.visible = true;\r\n                this.skipBtn.visible = false;\r\n\r\n                _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"stadium_noise\", 0.08, 0, -1);\r\n            },\r\n            /** Intro callback ends --------------------------------------------------------------- */\r\n\r\n            /** Help callback -------------------------------------------------------------------- */\r\n            startOfHelp(p) {\r\n                if (p.viewed === undefined) {\r\n                    p.viewed = true;\r\n                    this.skipBtn = p.getChildByName(\"skip\");\r\n                    this.skipBtn.on(\"click\", (evt) => {\r\n                        //SoundUtil.pauseSound(\"a_helpAudio\");\r\n                        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.restartBgSound();\r\n                        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.initToss();\r\n                    });\r\n                    _utils_ButtonUtil__WEBPACK_IMPORTED_MODULE_9__[\"default\"].configure(this.skipBtn);\r\n                    this.skipBtn.x = 0;\r\n\r\n                    this.closeBtn = p.getChildByName(\"close\");\r\n                    this.closeBtn.on(\"click\", (evt) => {\r\n                        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.restartBgSound();\r\n                        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.initToss();\r\n                    });\r\n                    this.closeBtn.visible = false;\r\n                    _utils_ButtonUtil__WEBPACK_IMPORTED_MODULE_9__[\"default\"].configure(this.closeBtn);\r\n\r\n                    this.readBtn = p.getChildByName(\"more\");\r\n                    this.readBtn.on(\"click\", (evt) => {\r\n                        p.gotoAndStop(\"readmore\");\r\n                        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.restartBgSound();\r\n                    });\r\n                    this.readBtn.visible = false;\r\n                    _utils_ButtonUtil__WEBPACK_IMPORTED_MODULE_9__[\"default\"].configure(this.readBtn);\r\n\r\n                    this.htpBtn = p.getChildByName(\"howToPlayBtnMc\");\r\n                    this.htpBtn.on(\"click\", (evt) => {\r\n                        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.restartBgSound();\r\n                        p.gotoAndPlay(\"start\");\r\n                    });\r\n                    this.htpBtn.visible = false;\r\n                    _utils_ButtonUtil__WEBPACK_IMPORTED_MODULE_9__[\"default\"].configure(this.htpBtn);\r\n\r\n                } else {\r\n                    this.skipBtn.visible = true;\r\n                    this.readBtn.visible = true;\r\n                    this.closeBtn.visible = false;\r\n                    this.htpBtn.visible = false;\r\n                }\r\n\r\n                //SoundUtil.playSound(\"a_helpAudio\");\r\n            },\r\n            endOfHelp(p) {\r\n                p.stop();\r\n                this.skipBtn.x = -112.4;\r\n                this.readBtn.visible = true;\r\n            },\r\n            onReadMore(p) {\r\n                p.stop();\r\n                //SoundUtil.stopSound(\"a_helpAudio\");\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.restartBgSound();\r\n                this.skipBtn.visible = this.readBtn.visible = false;\r\n                this.htpBtn.visible = this.closeBtn.visible = true;\r\n            },\r\n\r\n            /** Help callback ends --------------------------------------------------------------- */\r\n\r\n            /** Toss callback -------------------------------------------------------------------- */\r\n            startOfToss(p) {\r\n                _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"crowd_noise\", 0.6);\r\n            },\r\n            onToss(p) {\r\n                p.stop();\r\n\r\n                _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"a_toss2\");\r\n\r\n                p\r\n                    .tossBtn\r\n                    .on(\"click\", (evt) => {\r\n                        _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].stopSound(\"a_toss2\");\r\n                        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                            .getInstance()\r\n                            .umpire\r\n                            .Toss();\r\n                        p.gotoAndPlay(\"play_toss\");\r\n                    });\r\n                _utils_ButtonUtil__WEBPACK_IMPORTED_MODULE_9__[\"default\"].configure(p.tossBtn);\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .iStatus\r\n                    .setText(\"TOSS_INFO\");\r\n            },\r\n            onTossDecision(p) {\r\n                p.stop();\r\n                p.gotoAndPlay(_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.whoWonToss() + \"WinToss\");\r\n            },\r\n            onBlueReadyToBat(p) {\r\n                p.stop();\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.startMatch();\r\n            },\r\n            onRedReadyToBat(p) {\r\n                p.stop();\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.startMatch();\r\n            },\r\n            /** Toss callback ends --------------------------------------------------------------- */\r\n\r\n            /** Game callback -------------------------------------------------------------------- */\r\n            startOfQuestions(p) {\r\n                p.stop();\r\n                /*\r\n                 let bvo = \"\";\r\n                 if ((GameModel.getInstance().umpire.getMatchStat().inning === 0) && (GameModel.getInstance().umpire.getBattingTeam().getBallCount() === 0)) {\r\n                    bvo = GameModel.getInstance().umpire.getBattingTeam().getBallVO() + \"_match\"\r\n                } else { \r\n                    bvo = GameModel.getInstance().umpire.getBattingTeam().getBallVO();\r\n                }*/\r\n                //console.log(GameModel.getInstance().umpire.getMatchStat().inning, \" startOfQuestions \", GameModel.getInstance().umpire.getBattingTeam().getBallCount())\r\n                _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.getBattingTeam().getBallVO(), 1, 0, 0, _models_GameEvent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ACTIVATE_QUESTION); //\r\n\r\n            },\r\n            /** Game callback ends --------------------------------------------------------------- */\r\n            /**  the first ball of the innings */\r\n            onInningsStart(p) {\r\n                p.stop();\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.umpireDecision();\r\n            },\r\n\r\n            /** Shots callback -------------------------------------------------------------------- */\r\n\r\n            onSixerEnd(p) {\r\n                //console.log(GameModel.getInstance().gameRef, this.thisRef);\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .umpireDecision();\r\n            },\r\n            onBoundaryEnd(p) {\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .umpireDecision();\r\n            },\r\n            onDoublesEnd(p) {\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .umpireDecision();\r\n            },\r\n            onSinglesEnd(p) {\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .umpireDecision();\r\n            },\r\n            onDotEnd(p) {\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .umpireDecision();\r\n            },\r\n            onBowledEnd(p) {\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .umpireDecision();\r\n            },\r\n            onCaughtEnd(p) {\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .umpireDecision();\r\n            },\r\n            onDuck(p) {\r\n\r\n                if (_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.getBattingTeam().getLastDownScore() === 0) {\r\n                    p.duck_anim.gotoAndPlay(1);\r\n                    _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"basketballhit2\", 1, 0.1);\r\n                    _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"bounce1\", 1, 0.5);\r\n                    _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"sad_down\", 1, 0.8);\r\n                }\r\n            },\r\n\r\n            onShotCommentry(p) {\r\n                //console.log(\" getBallCount-\", GameModel.getInstance().umpire.getBattingTeam().getBallCount() - 1, \"  vo-\", GameModel.getInstance().strike.vo)\r\n                //.. shot played\r\n                if (_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.shot.value !== -1) {\r\n                    //.. VO\r\n                    _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().strike.vo[_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.getBattingTeam().getBallCount() - 1]);\r\n                    //.. Cheers\r\n                    _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().strike.cheers, 0.9, 30);\r\n                    _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"CrowdCheer\", 0.2, 100);\r\n                    _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"crowd_noise\", 0.5, 80);\r\n                } else {\r\n                    //... OUT\r\n                    //.. VO\r\n                    _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(_utils_Utils__WEBPACK_IMPORTED_MODULE_0__[\"ArrayUtils\"].getRandomValue(_models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"][\r\n                        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                            .getInstance()\r\n                            .gameRef\r\n                            .shot\r\n                            .label\r\n                    ]));\r\n                    //.. wicketdown_cheer\r\n                    _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"wicketdown_cheer\", 0.5, 30);\r\n                    _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"crowd_noise\", 0.2, 80);\r\n                }\r\n            },\r\n            /** Shots callback ends --------------------------------------------------------------- */\r\n\r\n            onShowTeamPerformance(p) {\r\n                p.stop();\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().scoreboard.scoreUpdate();\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.ballNote = p.getChildByName(\"ballnote\");\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.canHideBallNote = true;\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.ballNote.visible = true;\r\n\r\n                let ms = _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.getMatchStat();\r\n\r\n                if (ms.gameover && !_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.gameOverSeen) {\r\n                    //.. game over sound\r\n                    _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"a_game_complete\");\r\n                    //GameModel.getInstance().gameRef.ballNote.visible = false; //override\r\n                    p.txt.text = \"GAME COMPLETED. \" + ms.msg;\r\n                } else {\r\n                    _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"a_innings_change\");\r\n                    p.txt.text = ms.msg;\r\n                }\r\n\r\n                p.txt.visible = true;\r\n\r\n                this.continueBtn = p.getChildByName(\"continue_mc\");\r\n\r\n\r\n\r\n                if (!this.continueBtn.hasEventListener(\"click\")) {\r\n                    this\r\n                        .continueBtn\r\n                        .on(\"click\", (evt) => {\r\n\r\n                            ms = _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.getMatchStat();\r\n\r\n                            p.play();\r\n\r\n                            if (ms.gameover && !_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.gameOverSeen) {\r\n                                //.. again one time \r\n                                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.gameOverSeen = true;\r\n                                _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].stopSound(\"a_game_complete\");\r\n\r\n                                if (_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.screenQuestionObject.done) {\r\n                                    _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.continueNextInnings();\r\n                                } else {\r\n                                    window.setTimeout(() => {\r\n                                        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.delegatedumpireDecision();\r\n                                    }, 150);\r\n                                }\r\n                            } else {\r\n                                console.log('continue with game');\r\n                                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.continueNextInnings();\r\n                            }\r\n\r\n                            _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].stopSound(\"a_innings_change\"); //optional incsase sound is still playing\r\n\r\n                            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.canHideBallNote = false;\r\n                            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.ballNote.visible = true;\r\n                        });\r\n                    _utils_ButtonUtil__WEBPACK_IMPORTED_MODULE_9__[\"default\"].configure(this.continueBtn);\r\n                }\r\n                this.continueBtn.visible = true;\r\n            },\r\n\r\n            onStartUserFeedback(p) {\r\n\r\n                p.stop();\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.exportRoot.response_mc.arrowMc.visible = false;\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.exportRoot.response_mc.closeMc.visible = false;\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .scoreboard\r\n                    .enableClick(true);\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .exportRoot\r\n                    .response_mc\r\n                    .removeChildAt(3);\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.resumeQuestionActivity();\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.gamePaused = false;\r\n            },\r\n\r\n            onLoadUserFeedback() {\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .fq = new _Question__WEBPACK_IMPORTED_MODULE_2__[\"default\"]((new _utils_Utils__WEBPACK_IMPORTED_MODULE_0__[\"Iterator\"]([\r\n                        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                            .getInstance()\r\n                            .umpire\r\n                            .getBattingTeam()\r\n                            .getInningsQuestions()[\r\n                        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                            .getInstance()\r\n                            .gameRef\r\n                            .questionFeedback_id\r\n                        ]\r\n                    ]).iterator()).next());\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .fq\r\n                    .addResponseScreen(_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.getBattingTeam().countOver()[_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.questionFeedback_id].userselect); //userselected response\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.pauseQuestionActivity();\r\n            },\r\n\r\n            onShowUserFeedback(p) {\r\n                p.stop();\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.gamePaused = true;\r\n\r\n                if (!p.closeMc.hasEventListener(\"click\")) {\r\n                    p\r\n                        .closeMc\r\n                        .on(\"click\", (evt) => {\r\n                            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                                .getInstance()\r\n                                .gameRef\r\n                                .exportRoot\r\n                                .response_mc\r\n                                .gotoAndStop(0);\r\n                        });\r\n                    _utils_ButtonUtil__WEBPACK_IMPORTED_MODULE_9__[\"default\"].configure(p.closeMc);\r\n                }\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .exportRoot\r\n                    .response_mc\r\n                    .arrowMc\r\n                    .gotoAndStop(_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.questionFeedback_id);\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .exportRoot\r\n                    .response_mc\r\n                    .arrowMc\r\n                    .visible = true;\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .exportRoot\r\n                    .response_mc\r\n                    .closeMc\r\n                    .visible = true;\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .exportRoot\r\n                    .response_mc.QuestionSetMc_2.bgMc.gotoAndStop(_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.getBattingTeam().getTeamId());\r\n\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .exportRoot\r\n                    .response_mc\r\n                    .addChild(_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.fq.getScreen());\r\n            },\r\n\r\n            set_iText(p) {\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.iStatus.setText(\"USER_STRIKE\");\r\n            }\r\n\r\n        };\r\n\r\n        this.setupStage();\r\n    }\r\n\r\n    restartBgSound() {\r\n        console.log('restartBgSound');\r\n        _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].stopAllSounds();\r\n        _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"stadium_noise\", 0.08, 0, -1);\r\n    }\r\n\r\n    setupEvents() {\r\n        //.. Setting up events\r\n        new _utils_Utils__WEBPACK_IMPORTED_MODULE_0__[\"EventManager\"](true);\r\n\r\n        this.win.eventManager.subscribe(_models_GameEvent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].CONTINUE, this.continueGame);\r\n\r\n        this.win.eventManager.subscribe(_models_GameEvent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].GAME_OVER, this.gameOver);\r\n\r\n        this.win.eventManager.subscribe(_models_GameEvent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].CLEANUP_SCOREBOARD, this.clearDisplayBoard);\r\n\r\n        this.win.eventManager.subscribe(_models_GameEvent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SHOW_TEAM_PERFORMANCE, this.showTeamPerformance);\r\n\r\n        this.win.eventManager.subscribe(_models_GameEvent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SHOW_QUESTION_FEEDBACK, this.showQuestionFeedback);\r\n\r\n        this.win.eventManager.subscribe(_models_GameEvent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ACTIVATE_QUESTION, this.activateQuestion);\r\n    }\r\n\r\n    setupStage() {\r\n        this.baseContainer = new this\r\n            .createjs\r\n            .Container();\r\n        this\r\n            .stage\r\n            .addChild(this.baseContainer);\r\n\r\n        /* this\r\n            .createjs\r\n            .Ticker\r\n            .setFPS(this.lib.properties.fps); */\r\n\r\n        this.createjs.Ticker.framerate = (this.lib.properties.fps);\r\n\r\n        this.createjs.Ticker.addEventListener(\"tick\", this.stage);\r\n    }\r\n\r\n    init(config) {\r\n\r\n        _models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].randomize = config.randomize;\r\n        _models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].timeDivision = _models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].timeConfig[config.timer];\r\n\r\n        if (this.dev) {\r\n            this.startMatch();\r\n        } else {\r\n            this\r\n                .baseContainer\r\n                .addChild(this.exportRoot.intro); //\r\n            this.exportRoot.intro.gotoAndPlay(0);\r\n        }\r\n    }\r\n\r\n    config() {\r\n        //.. bg graphic cricket ground\r\n        this.bg_graphic = new this\r\n            .lib\r\n            .gr_bg();\r\n        this\r\n            .bg_graphic\r\n            .gotoAndStop(0);\r\n        this.bg_graphic.x = 496;\r\n        this.bg_graphic.y = 307.35;\r\n        this\r\n            .baseContainer\r\n            .addChild(this.bg_graphic);\r\n\r\n        this.win.showConfigScreen();\r\n    }\r\n\r\n    showHelpScreen() {\r\n        this.baseContainer.removeAllChildren();\r\n        this.baseContainer.addChild(this.exportRoot.helpAnimMc);\r\n        this.exportRoot.helpAnimMc.gotoAndPlay(1);\r\n    }\r\n\r\n\r\n    initToss() {\r\n        this.baseContainer.removeAllChildren();\r\n        this.baseContainer.addChild(this.exportRoot.tossMc);\r\n\r\n        this.iStatus = new _InfoStatus__WEBPACK_IMPORTED_MODULE_5__[\"default\"](\"CLEAR\");\r\n        this\r\n            .baseContainer\r\n            .addChild(this.iStatus.getClip());\r\n    }\r\n\r\n    startMatch() {\r\n\r\n        if (this.dev) {\r\n            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                .getInstance()\r\n                .umpire\r\n                .Toss();\r\n            _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"stadium_noise\", 0.08, 0, -1);\r\n        } else {\r\n            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.iStatus.setText(\"USER_STRIKE\");\r\n        }\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n            .getInstance()\r\n            .umpire\r\n            .startGame(_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().xmlData, this.dev);\r\n\r\n        this\r\n            .baseContainer\r\n            .removeAllChildren();\r\n\r\n        //.. bg graphic cricket ground\r\n        this.bg_graphic = new this\r\n            .lib\r\n            .gr_bg();\r\n        this\r\n            .bg_graphic\r\n            .gotoAndStop(0);\r\n        this.bg_graphic.x = 496;\r\n        this.bg_graphic.y = 307.35;\r\n        this\r\n            .baseContainer\r\n            .addChild(this.bg_graphic);\r\n\r\n        //.. shots anim clips\r\n        this\r\n            .baseContainer\r\n            .addChild(this.exportRoot.shotRed);\r\n\r\n        this\r\n            .baseContainer\r\n            .addChild(this.exportRoot.shotBlue);\r\n\r\n        //.. add feeback mc\r\n        this\r\n            .baseContainer\r\n            .addChild(this.exportRoot.feedback_mc);\r\n\r\n        //.. timer\r\n        if (this.hasTimer()) {\r\n            this.timer = new _utils_Utils__WEBPACK_IMPORTED_MODULE_0__[\"Timer\"]();\r\n            this\r\n                .timer\r\n                .createTimer(_models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].timeDivision[0], this.onTimerUpdate, this.onTimerUpdate, this);\r\n        }\r\n\r\n        //.. Show innings title\r\n        this.tInfo = new this\r\n            .lib\r\n            .TitleInfo();\r\n        this.tInfo.x = 243;\r\n        this\r\n            .baseContainer\r\n            .addChild(this.tInfo);\r\n\r\n        //.. Bottom Over display\r\n        this.wDisplay = new this\r\n            .lib\r\n            .BallDisplayMc();\r\n        this.wDisplay.y = 536.5;\r\n        this\r\n            .baseContainer\r\n            .addChild(this.wDisplay);\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n            .getInstance()\r\n            .scoreboard\r\n            .connectDisplay(this.wDisplay);\r\n\r\n        this.iStatus = new _InfoStatus__WEBPACK_IMPORTED_MODULE_5__[\"default\"](\"USER_STRIKE\");\r\n\r\n        this\r\n            .baseContainer\r\n            .addChild(this.iStatus.getClip());\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n            .getInstance()\r\n            .gameRef\r\n            .baseContainer\r\n            .addChild(_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.exportRoot.response_mc);\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n            .getInstance()\r\n            .gameRef\r\n            .exportRoot\r\n            .response_mc\r\n            .x = 18;\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n            .getInstance()\r\n            .gameRef\r\n            .exportRoot\r\n            .response_mc\r\n            .y = 172;\r\n\r\n        //\r\n\r\n        this.umpireDecision();\r\n    }\r\n\r\n    showQuestion() {\r\n\r\n        if (!_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.wDisplay.visible) {\r\n            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.wDisplay.visible = true;\r\n        }\r\n\r\n        this\r\n            .exportRoot\r\n            .shotRed\r\n            .gotoAndStop(1);\r\n\r\n        this\r\n            .exportRoot\r\n            .shotBlue\r\n            .gotoAndStop(1);\r\n\r\n\r\n\r\n        this.q = new _Question__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.screenQuestionObject);\r\n        this.q.addQuestionScreen();\r\n\r\n        this.baseContainer.addChildAt(this.q.getScreen(), 1);\r\n\r\n        _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"imageappear\");\r\n\r\n        //.. \r\n\r\n        if (this.hasTimer()) {\r\n\r\n            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                .getInstance()\r\n                .gameRef\r\n                .timer\r\n                .startTimer();\r\n            _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"countdown_tick\", 0.2, 0, -1);\r\n\r\n            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().strike = _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.getStrikeName(_models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].timeDivision[0]);\r\n\r\n            this.q.updateSubmitBtnState({\r\n                txt: _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().strike.txt,\r\n                time: _models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].timeDivision[0] + \" Sec\"\r\n            });\r\n\r\n            window.setTimeout(() => {\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.pauseQuestionActivity();\r\n            }, 150);\r\n\r\n        } else {\r\n            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                .getInstance()\r\n                .strike = _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef.getStrikeName(1);\r\n\r\n            this.q.updateSubmitBtnState({\r\n                txt: _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .strike.txt, time: \"\"\r\n            });\r\n        }\r\n    }\r\n\r\n    activateQuestion() {\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.q.disableScreen(false);\r\n\r\n        if (_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.gamePaused) {\r\n            window.setTimeout(() => {\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.pauseQuestionActivity();\r\n            }, 150);\r\n        } else {\r\n            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.resumeQuestionActivity();\r\n        }\r\n\r\n    }\r\n\r\n    showQuestionFeedback(p) {\r\n\r\n        _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"imageappear\");\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.exportRoot.response_mc.gotoAndStop(0);\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.questionFeedback_id = p.id;\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.exportRoot.response_mc.gotoAndPlay(1);\r\n\r\n        if (_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.canHideBallNote) {\r\n            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.ballNote.visible = false;\r\n        }\r\n\r\n    }\r\n\r\n    continueGame() {\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.tInfo.infoTxt.text = _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.getInningTitle();\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n            .getInstance()\r\n            .gameRef\r\n            .exportRoot[\"shot\" + _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                .getInstance()\r\n                .umpire\r\n                .getBattingTeam()\r\n                .getTeamId()\r\n        ]\r\n            .gotoAndPlay(\"start\");\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.wDisplay.visible = false;\r\n\r\n    }\r\n\r\n    gameOver() {\r\n\r\n        let ms = _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.getMatchStat();\r\n        let toplay = '';\r\n        //console.log(\"GAME OVER - overup\", ms);\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance()\r\n            .gameRef.baseContainer\r\n            .addChildAt(_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.exportRoot.GameOverFeedback_mc, 1);\r\n\r\n        if (ms.winner === 'None') {\r\n            if ((ms.TeamRed === 0) && (ms.TeamBlue === 0)) {\r\n                toplay = 'NoRunScore';\r\n                _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"a_zero_runs\");\r\n            } else {\r\n                toplay = 'AllTeamLost';\r\n                _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"a_drawn\");\r\n            }\r\n        } else {\r\n            toplay = 'Win';\r\n            _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"a_cong_won\");\r\n            _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].playSound(\"win_bg_music\", 0.8);\r\n            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.exportRoot.GameOverFeedback_mc.teamnameMC.txt\r\n                .text = ms.msg;\r\n        }\r\n        (_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.exportRoot.GameOverFeedback_mc).gotoAndPlay(toplay);\r\n\r\n    }\r\n\r\n    showTeamPerformance(p) {\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.performanceType = p;\r\n        (_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.baseContainer.getChildByName(\"feedback_mc\")).gotoAndPlay(1);\r\n    }\r\n\r\n    pauseQuestionActivity() {\r\n        if (_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.q.isQuestionActive()) {\r\n            if (_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.hasTimer()) {\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .timer\r\n                    .pauseTimer();\r\n                _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].pauseSound(\"countdown_tick\");\r\n                if (_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.q.alertOn) {\r\n                    _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].stopSound(\"Spaceso\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    resumeQuestionActivity() {\r\n\r\n        if (_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.q.isQuestionActive()) {\r\n            if (_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                .getInstance()\r\n                .gameRef.hasTimer()) {\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .timer\r\n                    .resumeTimer();\r\n                _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].resumeSound(\"countdown_tick\");\r\n                if (_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.q.alertOn) {\r\n                    _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_7__[\"default\"].resumeSound(\"Spaceso\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    clearDisplayBoard() {\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n            .getInstance()\r\n            .scoreboard\r\n            .cleanupScoreBoard();\r\n    }\r\n\r\n    umpireDecision() {\r\n\r\n        this\r\n            .exportRoot\r\n            .shotRed\r\n            .gotoAndStop(0); // change for RED and BLUE\r\n        this\r\n            .exportRoot\r\n            .shotBlue\r\n            .gotoAndStop(0);\r\n\r\n        //console.log(GameModel.getInstance().umpire.getMatchStat(), \"umpireDecision1 \", GameModel.getInstance().gameRef);\r\n\r\n        this.screenQuestionObject = _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.nextBall();\r\n\r\n        if (_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.getMatchStat().gameover && !_models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.gameOverSeen) {\r\n            //.. onetime game completed event dispatch\r\n            let o = { \"overup\": this.screenQuestionObject.done }\r\n            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.gameOver(o);\r\n            return\r\n        }\r\n        this.delegatedumpireDecision();\r\n\r\n        window.setTimeout(() => {\r\n            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().scoreboard.scoreUpdate();\r\n        }, 250);\r\n    }\r\n\r\n    delegatedumpireDecision() {\r\n        if (this.screenQuestionObject.done) {\r\n            let o = { \"overup\": this.screenQuestionObject.done }\r\n            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.overUp(o);\r\n        } else {\r\n            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().gameRef.showQuestion();\r\n        }\r\n    }\r\n\r\n    playShot(s) {\r\n\r\n        if (this.hasTimer()) {\r\n            this.timer.stopTimer();\r\n        }\r\n\r\n        this.q.removeScreen();\r\n\r\n        this.baseContainer.removeChildAt(1);\r\n\r\n        //.. shot logic\r\n        let shot = {\r\n            label: \"\",\r\n            value: 0,\r\n            userselect: s.id\r\n        };\r\n\r\n        if (s.id === s.correctAns) {\r\n            shot.label = _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().strike.label;\r\n            shot.value = _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().strike.value;\r\n        } else {\r\n            shot.label = _utils_Utils__WEBPACK_IMPORTED_MODULE_0__[\"ArrayUtils\"].getRandomBool()\r\n                ? \"caught\"\r\n                : \"bowled\";\r\n            shot.value = -1;\r\n        }\r\n\r\n        this.exportRoot[\"shot\" +\r\n            _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.getBattingTeam().getTeamId()].gotoAndPlay(shot.label);\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n            .getInstance()\r\n            .umpire\r\n            .captureShot(shot);\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n            .getInstance()\r\n            .gameRef\r\n            .shot = shot;\r\n    }\r\n\r\n    getStrikeName(time) {\r\n        //console.log(\"getBallCount \", GameModel.getInstance().umpire.getBattingTeam().getBallCount());\r\n        if (time > _models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].timeDivision[1]) {\r\n            let ballIdx = _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().umpire.getBattingTeam().getBallCount()\r\n            return ((ballIdx === 0) || (ballIdx === 1) || (ballIdx === 5))\r\n                ? _models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].strikeName[0]\r\n                : _models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].strikeName[1]\r\n        }\r\n        if (time > _models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].timeDivision[2]) {\r\n            return _models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].strikeName[2]\r\n        }\r\n        if (time > _models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].timeDivision[3]) {\r\n            return _models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].strikeName[3]\r\n        }\r\n        if (time > _models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].timeDivision[4]) {\r\n            return _models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].strikeName[4]\r\n        }\r\n        if (time === _models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].timeDivision[4]) {\r\n            return _models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].strikeName[5]\r\n        }\r\n    }\r\n\r\n    onTimerUpdate(e) {\r\n\r\n        if (e.timer.getTime() == 6) {\r\n            // console.log(\"trigger alert\");\r\n            e.q.triggerAlert();\r\n        }\r\n\r\n        if (e.timer.getTime() == 0) {\r\n            //console.log(\"stop alert\");\r\n            e.q.stopAlert();\r\n        }\r\n\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n            .getInstance()\r\n            .strike = e.getStrikeName(e.timer.getTime());\r\n\r\n        e\r\n            .q\r\n            .updateSubmitBtnState({\r\n                \"time\": e\r\n                    .timer\r\n                    .getFormattedTime(),\r\n                \"txt\": _models_Models__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n                    .getInstance()\r\n                    .strike.txt\r\n            });\r\n\r\n    }\r\n\r\n    hasTimer() {\r\n        return (_models_TeamData__WEBPACK_IMPORTED_MODULE_10__[\"default\"].timeDivision[0] !== 0)\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (GameDisplay);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmlld3MvR2FtZURpc3BsYXkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvR2FtZURpc3BsYXkuanM/NzQyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcnJheVV0aWxzLCBUaW1lciwgRXZlbnRNYW5hZ2VyLCBJdGVyYXRvciB9IGZyb20gXCIuLi91dGlscy9VdGlsc1wiO1xyXG5cclxuaW1wb3J0IEdhbWVNb2RlbCBmcm9tIFwiLi4vbW9kZWxzL01vZGVsc1wiO1xyXG5pbXBvcnQgUXVlc3Rpb24gZnJvbSBcIi4vUXVlc3Rpb25cIjtcclxuaW1wb3J0IFNjb3JlQm9hcmQgZnJvbSBcIi4vU2NvcmVCb2FyZFwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi9tb2RlbHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCBJbmZvU3RhdHVzIGZyb20gXCIuL0luZm9TdGF0dXNcIjtcclxuaW1wb3J0IFVtcGlyZSBmcm9tIFwiLi4vbW9kZWxzL1VtcGlyZVwiO1xyXG5pbXBvcnQgU291bmRVdGlsIGZyb20gXCIuLi91dGlscy9Tb3VuZFV0aWxcIjtcclxuaW1wb3J0IFRleHRVdGlsIGZyb20gXCIuLi91dGlscy9UZXh0VXRpbFwiO1xyXG5pbXBvcnQgQnV0dG9uVXRpbCBmcm9tIFwiLi4vdXRpbHMvQnV0dG9uVXRpbFwiO1xyXG5pbXBvcnQgVGVhbURhdGEgZnJvbSBcIi4uL21vZGVscy9UZWFtRGF0YVwiO1xyXG5cclxuY2xhc3MgR2FtZURpc3BsYXkge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZGV2ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy53aW4gPSBwYXJhbS53aW5kb3c7XHJcblxyXG4gICAgICAgIHRoaXMuY3JlYXRlanMgPSBwYXJhbS5jcmVhdGVqcztcclxuICAgICAgICB0aGlzLmNhbnZhcyA9IHBhcmFtLmNhbnZhcztcclxuICAgICAgICB0aGlzLmV4cG9ydFJvb3QgPSBwYXJhbS5leHBvcnRSb290O1xyXG4gICAgICAgIHRoaXMubGliID0gcGFyYW0ubGliO1xyXG4gICAgICAgIHRoaXMuc3RhZ2UgPSBwYXJhbS5zdGFnZTtcclxuXHJcblxyXG4gICAgICAgIHRoaXMuc3RhZ2UuZW5hYmxlTW91c2VPdmVyKDIwKTtcclxuXHJcbiAgICAgICAgR2FtZU1vZGVsLmdldEluc3RhbmNlKCkueG1sRGF0YSA9IHBhcmFtLnhtbERhdGE7XHJcbiAgICAgICAgR2FtZU1vZGVsLmdldEluc3RhbmNlKCkudW1waXJlID0gbmV3IFVtcGlyZSgpO1xyXG4gICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLnNjb3JlYm9hcmQgPSBuZXcgU2NvcmVCb2FyZCgpO1xyXG4gICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYgPSB0aGlzO1xyXG4gICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuZ2FtZVBhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuY2FuSGlkZUJhbGxOb3RlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5nYW1lT3ZlclNlZW4gPSBmYWxzZTsgXHJcblxyXG4gICAgICAgIHRoaXMuc2V0dXBFdmVudHMoKTtcclxuXHJcbiAgICAgICAgdGhpcy53aW4uY2FudmFzT2JqUmVmID0ge1xyXG4gICAgICAgICAgICBzdGFydEJ0bjoge30sXHJcbiAgICAgICAgICAgIGh0cEJ0bjoge30sXHJcbiAgICAgICAgICAgIHNraXBCdG46IHt9LFxyXG4gICAgICAgICAgICBzdWJtaXRCdG46IHt9LFxyXG4gICAgICAgICAgICBjb250aW51ZUJ0bjoge30sXHJcblxyXG4gICAgICAgICAgICAvKiogSW50cm8gY2FsbGJhY2sgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgICAgICAgICBzdGFydE9mSW50cm8ocCkge1xyXG5cclxuICAgICAgICAgICAgICAgIFNvdW5kVXRpbC5wbGF5U291bmQoXCJNdXNpY01peFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwLkdhbWVEZXNfdHh0LnRleHQgPSBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC54bWxEYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgLkdhbWVDb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLkdhbWVkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgLkdhbWVFZGdlXHJcbiAgICAgICAgICAgICAgICAgICAgLmRlc2NyaXB0aW9uVHh0O1xyXG4gICAgICAgICAgICAgICAgcC5HYW1lRGVzX3R4dC5mb250ID0gVGV4dFV0aWxcclxuICAgICAgICAgICAgICAgICAgICAuZGVmYXVsdFN0eWxlKClcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICBwLkdhbWVEZXNfdHh0LmNvbG9yID0gVGV4dFV0aWxcclxuICAgICAgICAgICAgICAgICAgICAuZGVmYXVsdFN0eWxlKClcclxuICAgICAgICAgICAgICAgICAgICAuY29sb3I7XHJcbiAgICAgICAgICAgICAgICBwLkdhbWVEZXNfdHh0LnRleHRBbGlnbiA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgcC5HYW1lRGVzX3R4dC5saW5lV2lkdGggPSBUZXh0VXRpbFxyXG4gICAgICAgICAgICAgICAgICAgIC5kZWZhdWx0U3R5bGUoKVxyXG4gICAgICAgICAgICAgICAgICAgIC53aWR0aDtcclxuXHJcbiAgICAgICAgICAgICAgICBwLkdhbWVEZXNfdHh0LnZpc2libGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0QnRuID0gcC5nZXRDaGlsZEJ5TmFtZShcInN0YXJ0QnRuTWNcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0QnRuLm9uKFwiY2xpY2tcIiwgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuaW5pdFRvc3MoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEJ0bi52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBCdXR0b25VdGlsLmNvbmZpZ3VyZSh0aGlzLnN0YXJ0QnRuKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5odHBCdG4gPSBwLmdldENoaWxkQnlOYW1lKFwiaG93VG9QbGF5QnRuTWNcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmh0cEJ0bi5vbihcImNsaWNrXCIsIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLnNob3dIZWxwU2NyZWVuKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaHRwQnRuLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIEJ1dHRvblV0aWwuY29uZmlndXJlKHRoaXMuaHRwQnRuKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBCdG4gPSBwLmdldENoaWxkQnlOYW1lKFwic2tpcEJ0blwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2tpcEJ0bi5vbihcImNsaWNrXCIsIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBwLmdvdG9BbmRTdG9wKFwiZW5kXCIpOyAvLyBlbmRcclxuICAgICAgICAgICAgICAgICAgICBwLkdhbWVEZXNfdHh0LnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIFNvdW5kVXRpbC5zdG9wU291bmQoXCJNdXNpY01peFwiKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgQnV0dG9uVXRpbC5jb25maWd1cmUodGhpcy5za2lwQnRuKTtcclxuXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBoaWRlU2tpcChwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBCdG4udmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbmRPZkludHJvKHApIHtcclxuICAgICAgICAgICAgICAgIHAuc3RvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHAuR2FtZURlc190eHQudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEJ0bi52aXNpYmxlID0gdGhpcy5odHBCdG4udmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBCdG4udmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIFNvdW5kVXRpbC5wbGF5U291bmQoXCJzdGFkaXVtX25vaXNlXCIsIDAuMDgsIDAsIC0xKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqIEludHJvIGNhbGxiYWNrIGVuZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgICAgICAgICAvKiogSGVscCBjYWxsYmFjayAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgICAgICAgICBzdGFydE9mSGVscChwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC52aWV3ZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHAudmlld2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNraXBCdG4gPSBwLmdldENoaWxkQnlOYW1lKFwic2tpcFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNraXBCdG4ub24oXCJjbGlja1wiLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vU291bmRVdGlsLnBhdXNlU291bmQoXCJhX2hlbHBBdWRpb1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi5yZXN0YXJ0QmdTb3VuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLmluaXRUb3NzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgQnV0dG9uVXRpbC5jb25maWd1cmUodGhpcy5za2lwQnRuKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNraXBCdG4ueCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VCdG4gPSBwLmdldENoaWxkQnlOYW1lKFwiY2xvc2VcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZUJ0bi5vbihcImNsaWNrXCIsIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi5yZXN0YXJ0QmdTb3VuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLmluaXRUb3NzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZUJ0bi52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgQnV0dG9uVXRpbC5jb25maWd1cmUodGhpcy5jbG9zZUJ0bik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEJ0biA9IHAuZ2V0Q2hpbGRCeU5hbWUoXCJtb3JlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEJ0bi5vbihcImNsaWNrXCIsIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcC5nb3RvQW5kU3RvcChcInJlYWRtb3JlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLnJlc3RhcnRCZ1NvdW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQnRuLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBCdXR0b25VdGlsLmNvbmZpZ3VyZSh0aGlzLnJlYWRCdG4pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmh0cEJ0biA9IHAuZ2V0Q2hpbGRCeU5hbWUoXCJob3dUb1BsYXlCdG5NY1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmh0cEJ0bi5vbihcImNsaWNrXCIsIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi5yZXN0YXJ0QmdTb3VuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwLmdvdG9BbmRQbGF5KFwic3RhcnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5odHBCdG4udmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIEJ1dHRvblV0aWwuY29uZmlndXJlKHRoaXMuaHRwQnRuKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcEJ0bi52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRCdG4udmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZUJ0bi52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5odHBCdG4udmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vU291bmRVdGlsLnBsYXlTb3VuZChcImFfaGVscEF1ZGlvXCIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbmRPZkhlbHAocCkge1xyXG4gICAgICAgICAgICAgICAgcC5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBCdG4ueCA9IC0xMTIuNDtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVhZEJ0bi52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25SZWFkTW9yZShwKSB7XHJcbiAgICAgICAgICAgICAgICBwLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIC8vU291bmRVdGlsLnN0b3BTb3VuZChcImFfaGVscEF1ZGlvXCIpO1xyXG4gICAgICAgICAgICAgICAgR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi5yZXN0YXJ0QmdTb3VuZCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5za2lwQnRuLnZpc2libGUgPSB0aGlzLnJlYWRCdG4udmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5odHBCdG4udmlzaWJsZSA9IHRoaXMuY2xvc2VCdG4udmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvKiogSGVscCBjYWxsYmFjayBlbmRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgICAgICAgICAgLyoqIFRvc3MgY2FsbGJhY2sgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgICAgICAgICAgc3RhcnRPZlRvc3MocCkge1xyXG4gICAgICAgICAgICAgICAgU291bmRVdGlsLnBsYXlTb3VuZChcImNyb3dkX25vaXNlXCIsIDAuNik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uVG9zcyhwKSB7XHJcbiAgICAgICAgICAgICAgICBwLnN0b3AoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBTb3VuZFV0aWwucGxheVNvdW5kKFwiYV90b3NzMlwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwXHJcbiAgICAgICAgICAgICAgICAgICAgLnRvc3NCdG5cclxuICAgICAgICAgICAgICAgICAgICAub24oXCJjbGlja1wiLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNvdW5kVXRpbC5zdG9wU291bmQoXCJhX3Rvc3MyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudW1waXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuVG9zcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwLmdvdG9BbmRQbGF5KFwicGxheV90b3NzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgQnV0dG9uVXRpbC5jb25maWd1cmUocC50b3NzQnRuKTtcclxuXHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5nYW1lUmVmXHJcbiAgICAgICAgICAgICAgICAgICAgLmlTdGF0dXNcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VGV4dChcIlRPU1NfSU5GT1wiKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25Ub3NzRGVjaXNpb24ocCkge1xyXG4gICAgICAgICAgICAgICAgcC5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICBwLmdvdG9BbmRQbGF5KEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLnVtcGlyZS53aG9Xb25Ub3NzKCkgKyBcIldpblRvc3NcIik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uQmx1ZVJlYWR5VG9CYXQocCkge1xyXG4gICAgICAgICAgICAgICAgcC5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLnN0YXJ0TWF0Y2goKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25SZWRSZWFkeVRvQmF0KHApIHtcclxuICAgICAgICAgICAgICAgIHAuc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi5zdGFydE1hdGNoKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKiBUb3NzIGNhbGxiYWNrIGVuZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgICAgICAgICAvKiogR2FtZSBjYWxsYmFjayAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgICAgICAgICBzdGFydE9mUXVlc3Rpb25zKHApIHtcclxuICAgICAgICAgICAgICAgIHAuc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICBsZXQgYnZvID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICBpZiAoKEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLnVtcGlyZS5nZXRNYXRjaFN0YXQoKS5pbm5pbmcgPT09IDApICYmIChHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS51bXBpcmUuZ2V0QmF0dGluZ1RlYW0oKS5nZXRCYWxsQ291bnQoKSA9PT0gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBidm8gPSBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS51bXBpcmUuZ2V0QmF0dGluZ1RlYW0oKS5nZXRCYWxsVk8oKSArIFwiX21hdGNoXCJcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IFxyXG4gICAgICAgICAgICAgICAgICAgIGJ2byA9IEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLnVtcGlyZS5nZXRCYXR0aW5nVGVhbSgpLmdldEJhbGxWTygpO1xyXG4gICAgICAgICAgICAgICAgfSovXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLnVtcGlyZS5nZXRNYXRjaFN0YXQoKS5pbm5pbmcsIFwiIHN0YXJ0T2ZRdWVzdGlvbnMgXCIsIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLnVtcGlyZS5nZXRCYXR0aW5nVGVhbSgpLmdldEJhbGxDb3VudCgpKVxyXG4gICAgICAgICAgICAgICAgU291bmRVdGlsLnBsYXlTb3VuZChHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS51bXBpcmUuZ2V0QmF0dGluZ1RlYW0oKS5nZXRCYWxsVk8oKSwgMSwgMCwgMCwgR2FtZUV2ZW50LkFDVElWQVRFX1FVRVNUSU9OKTsgLy9cclxuXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKiBHYW1lIGNhbGxiYWNrIGVuZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICAgICAgICAgIC8qKiAgdGhlIGZpcnN0IGJhbGwgb2YgdGhlIGlubmluZ3MgKi9cclxuICAgICAgICAgICAgb25Jbm5pbmdzU3RhcnQocCkge1xyXG4gICAgICAgICAgICAgICAgcC5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLnVtcGlyZURlY2lzaW9uKCk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvKiogU2hvdHMgY2FsbGJhY2sgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAgICAgICAgIG9uU2l4ZXJFbmQocCkge1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLCB0aGlzLnRoaXNSZWYpO1xyXG4gICAgICAgICAgICAgICAgR2FtZU1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgLmdldEluc3RhbmNlKClcclxuICAgICAgICAgICAgICAgICAgICAuZ2FtZVJlZlxyXG4gICAgICAgICAgICAgICAgICAgIC51bXBpcmVEZWNpc2lvbigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkJvdW5kYXJ5RW5kKHApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5nYW1lUmVmXHJcbiAgICAgICAgICAgICAgICAgICAgLnVtcGlyZURlY2lzaW9uKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRG91Ymxlc0VuZChwKSB7XHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5nYW1lUmVmXHJcbiAgICAgICAgICAgICAgICAgICAgLnVtcGlyZURlY2lzaW9uKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uU2luZ2xlc0VuZChwKSB7XHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5nYW1lUmVmXHJcbiAgICAgICAgICAgICAgICAgICAgLnVtcGlyZURlY2lzaW9uKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRG90RW5kKHApIHtcclxuICAgICAgICAgICAgICAgIEdhbWVNb2RlbFxyXG4gICAgICAgICAgICAgICAgICAgIC5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmdhbWVSZWZcclxuICAgICAgICAgICAgICAgICAgICAudW1waXJlRGVjaXNpb24oKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25Cb3dsZWRFbmQocCkge1xyXG4gICAgICAgICAgICAgICAgR2FtZU1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgLmdldEluc3RhbmNlKClcclxuICAgICAgICAgICAgICAgICAgICAuZ2FtZVJlZlxyXG4gICAgICAgICAgICAgICAgICAgIC51bXBpcmVEZWNpc2lvbigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkNhdWdodEVuZChwKSB7XHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5nYW1lUmVmXHJcbiAgICAgICAgICAgICAgICAgICAgLnVtcGlyZURlY2lzaW9uKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRHVjayhwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLnVtcGlyZS5nZXRCYXR0aW5nVGVhbSgpLmdldExhc3REb3duU2NvcmUoKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHAuZHVja19hbmltLmdvdG9BbmRQbGF5KDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIFNvdW5kVXRpbC5wbGF5U291bmQoXCJiYXNrZXRiYWxsaGl0MlwiLCAxLCAwLjEpO1xyXG4gICAgICAgICAgICAgICAgICAgIFNvdW5kVXRpbC5wbGF5U291bmQoXCJib3VuY2UxXCIsIDEsIDAuNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgU291bmRVdGlsLnBsYXlTb3VuZChcInNhZF9kb3duXCIsIDEsIDAuOCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBvblNob3RDb21tZW50cnkocCkge1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIiBnZXRCYWxsQ291bnQtXCIsIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLnVtcGlyZS5nZXRCYXR0aW5nVGVhbSgpLmdldEJhbGxDb3VudCgpIC0gMSwgXCIgIHZvLVwiLCBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5zdHJpa2Uudm8pXHJcbiAgICAgICAgICAgICAgICAvLy4uIHNob3QgcGxheWVkXHJcbiAgICAgICAgICAgICAgICBpZiAoR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi5zaG90LnZhbHVlICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vLi4gVk9cclxuICAgICAgICAgICAgICAgICAgICBTb3VuZFV0aWwucGxheVNvdW5kKEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLnN0cmlrZS52b1tHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS51bXBpcmUuZ2V0QmF0dGluZ1RlYW0oKS5nZXRCYWxsQ291bnQoKSAtIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICAvLy4uIENoZWVyc1xyXG4gICAgICAgICAgICAgICAgICAgIFNvdW5kVXRpbC5wbGF5U291bmQoR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuc3RyaWtlLmNoZWVycywgMC45LCAzMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgU291bmRVdGlsLnBsYXlTb3VuZChcIkNyb3dkQ2hlZXJcIiwgMC4yLCAxMDApO1xyXG4gICAgICAgICAgICAgICAgICAgIFNvdW5kVXRpbC5wbGF5U291bmQoXCJjcm93ZF9ub2lzZVwiLCAwLjUsIDgwKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8uLi4gT1VUXHJcbiAgICAgICAgICAgICAgICAgICAgLy8uLiBWT1xyXG4gICAgICAgICAgICAgICAgICAgIFNvdW5kVXRpbC5wbGF5U291bmQoQXJyYXlVdGlscy5nZXRSYW5kb21WYWx1ZShUZWFtRGF0YVtcclxuICAgICAgICAgICAgICAgICAgICAgICAgR2FtZU1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdhbWVSZWZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zaG90XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubGFiZWxcclxuICAgICAgICAgICAgICAgICAgICBdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8uLiB3aWNrZXRkb3duX2NoZWVyXHJcbiAgICAgICAgICAgICAgICAgICAgU291bmRVdGlsLnBsYXlTb3VuZChcIndpY2tldGRvd25fY2hlZXJcIiwgMC41LCAzMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgU291bmRVdGlsLnBsYXlTb3VuZChcImNyb3dkX25vaXNlXCIsIDAuMiwgODApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKiogU2hvdHMgY2FsbGJhY2sgZW5kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAgICAgICAgIG9uU2hvd1RlYW1QZXJmb3JtYW5jZShwKSB7XHJcbiAgICAgICAgICAgICAgICBwLnN0b3AoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5zY29yZWJvYXJkLnNjb3JlVXBkYXRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi5iYWxsTm90ZSA9IHAuZ2V0Q2hpbGRCeU5hbWUoXCJiYWxsbm90ZVwiKTtcclxuICAgICAgICAgICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuY2FuSGlkZUJhbGxOb3RlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuYmFsbE5vdGUudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IG1zID0gR2FtZU1vZGVsLmdldEluc3RhbmNlKCkudW1waXJlLmdldE1hdGNoU3RhdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtcy5nYW1lb3ZlciAmJiAhR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi5nYW1lT3ZlclNlZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLy4uIGdhbWUgb3ZlciBzb3VuZFxyXG4gICAgICAgICAgICAgICAgICAgIFNvdW5kVXRpbC5wbGF5U291bmQoXCJhX2dhbWVfY29tcGxldGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9HYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLmJhbGxOb3RlLnZpc2libGUgPSBmYWxzZTsgLy9vdmVycmlkZVxyXG4gICAgICAgICAgICAgICAgICAgIHAudHh0LnRleHQgPSBcIkdBTUUgQ09NUExFVEVELiBcIiArIG1zLm1zZztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgU291bmRVdGlsLnBsYXlTb3VuZChcImFfaW5uaW5nc19jaGFuZ2VcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcC50eHQudGV4dCA9IG1zLm1zZztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBwLnR4dC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlQnRuID0gcC5nZXRDaGlsZEJ5TmFtZShcImNvbnRpbnVlX21jXCIpO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRpbnVlQnRuLmhhc0V2ZW50TGlzdGVuZXIoXCJjbGlja1wiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbnRpbnVlQnRuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcImNsaWNrXCIsIChldnQpID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcyA9IEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLnVtcGlyZS5nZXRNYXRjaFN0YXQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnBsYXkoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXMuZ2FtZW92ZXIgJiYgIUdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuZ2FtZU92ZXJTZWVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8uLiBhZ2FpbiBvbmUgdGltZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLmdhbWVPdmVyU2VlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU291bmRVdGlsLnN0b3BTb3VuZChcImFfZ2FtZV9jb21wbGV0ZVwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuc2NyZWVuUXVlc3Rpb25PYmplY3QuZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS51bXBpcmUuY29udGludWVOZXh0SW5uaW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuZGVsZWdhdGVkdW1waXJlRGVjaXNpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTUwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb250aW51ZSB3aXRoIGdhbWUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS51bXBpcmUuY29udGludWVOZXh0SW5uaW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNvdW5kVXRpbC5zdG9wU291bmQoXCJhX2lubmluZ3NfY2hhbmdlXCIpOyAvL29wdGlvbmFsIGluY3Nhc2Ugc291bmQgaXMgc3RpbGwgcGxheWluZ1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuY2FuSGlkZUJhbGxOb3RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLmJhbGxOb3RlLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBCdXR0b25VdGlsLmNvbmZpZ3VyZSh0aGlzLmNvbnRpbnVlQnRuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVCdG4udmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBvblN0YXJ0VXNlckZlZWRiYWNrKHApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBwLnN0b3AoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLmV4cG9ydFJvb3QucmVzcG9uc2VfbWMuYXJyb3dNYy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLmV4cG9ydFJvb3QucmVzcG9uc2VfbWMuY2xvc2VNYy52aXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgR2FtZU1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgLmdldEluc3RhbmNlKClcclxuICAgICAgICAgICAgICAgICAgICAuc2NvcmVib2FyZFxyXG4gICAgICAgICAgICAgICAgICAgIC5lbmFibGVDbGljayh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5nYW1lUmVmXHJcbiAgICAgICAgICAgICAgICAgICAgLmV4cG9ydFJvb3RcclxuICAgICAgICAgICAgICAgICAgICAucmVzcG9uc2VfbWNcclxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2hpbGRBdCgzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLnJlc3VtZVF1ZXN0aW9uQWN0aXZpdHkoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLmdhbWVQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIG9uTG9hZFVzZXJGZWVkYmFjaygpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5nYW1lUmVmXHJcbiAgICAgICAgICAgICAgICAgICAgLmZxID0gbmV3IFF1ZXN0aW9uKChuZXcgSXRlcmF0b3IoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudW1waXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0QmF0dGluZ1RlYW0oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldElubmluZ3NRdWVzdGlvbnMoKVtcclxuICAgICAgICAgICAgICAgICAgICAgICAgR2FtZU1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdhbWVSZWZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5xdWVzdGlvbkZlZWRiYWNrX2lkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgICAgICBdKS5pdGVyYXRvcigpKS5uZXh0KCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIEdhbWVNb2RlbFxyXG4gICAgICAgICAgICAgICAgICAgIC5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmdhbWVSZWZcclxuICAgICAgICAgICAgICAgICAgICAuZnFcclxuICAgICAgICAgICAgICAgICAgICAuYWRkUmVzcG9uc2VTY3JlZW4oR2FtZU1vZGVsLmdldEluc3RhbmNlKCkudW1waXJlLmdldEJhdHRpbmdUZWFtKCkuY291bnRPdmVyKClbR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi5xdWVzdGlvbkZlZWRiYWNrX2lkXS51c2Vyc2VsZWN0KTsgLy91c2Vyc2VsZWN0ZWQgcmVzcG9uc2VcclxuXHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLnBhdXNlUXVlc3Rpb25BY3Rpdml0eSgpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgb25TaG93VXNlckZlZWRiYWNrKHApIHtcclxuICAgICAgICAgICAgICAgIHAuc3RvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuZ2FtZVBhdXNlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFwLmNsb3NlTWMuaGFzRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2xvc2VNY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJjbGlja1wiLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nYW1lUmVmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmV4cG9ydFJvb3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVzcG9uc2VfbWNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ290b0FuZFN0b3AoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIEJ1dHRvblV0aWwuY29uZmlndXJlKHAuY2xvc2VNYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgR2FtZU1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgLmdldEluc3RhbmNlKClcclxuICAgICAgICAgICAgICAgICAgICAuZ2FtZVJlZlxyXG4gICAgICAgICAgICAgICAgICAgIC5leHBvcnRSb290XHJcbiAgICAgICAgICAgICAgICAgICAgLnJlc3BvbnNlX21jXHJcbiAgICAgICAgICAgICAgICAgICAgLmFycm93TWNcclxuICAgICAgICAgICAgICAgICAgICAuZ290b0FuZFN0b3AoR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi5xdWVzdGlvbkZlZWRiYWNrX2lkKTtcclxuXHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5nYW1lUmVmXHJcbiAgICAgICAgICAgICAgICAgICAgLmV4cG9ydFJvb3RcclxuICAgICAgICAgICAgICAgICAgICAucmVzcG9uc2VfbWNcclxuICAgICAgICAgICAgICAgICAgICAuYXJyb3dNY1xyXG4gICAgICAgICAgICAgICAgICAgIC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5nYW1lUmVmXHJcbiAgICAgICAgICAgICAgICAgICAgLmV4cG9ydFJvb3RcclxuICAgICAgICAgICAgICAgICAgICAucmVzcG9uc2VfbWNcclxuICAgICAgICAgICAgICAgICAgICAuY2xvc2VNY1xyXG4gICAgICAgICAgICAgICAgICAgIC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5nYW1lUmVmXHJcbiAgICAgICAgICAgICAgICAgICAgLmV4cG9ydFJvb3RcclxuICAgICAgICAgICAgICAgICAgICAucmVzcG9uc2VfbWMuUXVlc3Rpb25TZXRNY18yLmJnTWMuZ290b0FuZFN0b3AoR2FtZU1vZGVsLmdldEluc3RhbmNlKCkudW1waXJlLmdldEJhdHRpbmdUZWFtKCkuZ2V0VGVhbUlkKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIEdhbWVNb2RlbFxyXG4gICAgICAgICAgICAgICAgICAgIC5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmdhbWVSZWZcclxuICAgICAgICAgICAgICAgICAgICAuZXhwb3J0Um9vdFxyXG4gICAgICAgICAgICAgICAgICAgIC5yZXNwb25zZV9tY1xyXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDaGlsZChHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLmZxLmdldFNjcmVlbigpKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHNldF9pVGV4dChwKSB7XHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLmlTdGF0dXMuc2V0VGV4dChcIlVTRVJfU1RSSUtFXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuc2V0dXBTdGFnZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3RhcnRCZ1NvdW5kKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdyZXN0YXJ0QmdTb3VuZCcpO1xyXG4gICAgICAgIFNvdW5kVXRpbC5zdG9wQWxsU291bmRzKCk7XHJcbiAgICAgICAgU291bmRVdGlsLnBsYXlTb3VuZChcInN0YWRpdW1fbm9pc2VcIiwgMC4wOCwgMCwgLTEpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldHVwRXZlbnRzKCkge1xyXG4gICAgICAgIC8vLi4gU2V0dGluZyB1cCBldmVudHNcclxuICAgICAgICBuZXcgRXZlbnRNYW5hZ2VyKHRydWUpO1xyXG5cclxuICAgICAgICB0aGlzLndpbi5ldmVudE1hbmFnZXIuc3Vic2NyaWJlKEdhbWVFdmVudC5DT05USU5VRSwgdGhpcy5jb250aW51ZUdhbWUpO1xyXG5cclxuICAgICAgICB0aGlzLndpbi5ldmVudE1hbmFnZXIuc3Vic2NyaWJlKEdhbWVFdmVudC5HQU1FX09WRVIsIHRoaXMuZ2FtZU92ZXIpO1xyXG5cclxuICAgICAgICB0aGlzLndpbi5ldmVudE1hbmFnZXIuc3Vic2NyaWJlKEdhbWVFdmVudC5DTEVBTlVQX1NDT1JFQk9BUkQsIHRoaXMuY2xlYXJEaXNwbGF5Qm9hcmQpO1xyXG5cclxuICAgICAgICB0aGlzLndpbi5ldmVudE1hbmFnZXIuc3Vic2NyaWJlKEdhbWVFdmVudC5TSE9XX1RFQU1fUEVSRk9STUFOQ0UsIHRoaXMuc2hvd1RlYW1QZXJmb3JtYW5jZSk7XHJcblxyXG4gICAgICAgIHRoaXMud2luLmV2ZW50TWFuYWdlci5zdWJzY3JpYmUoR2FtZUV2ZW50LlNIT1dfUVVFU1RJT05fRkVFREJBQ0ssIHRoaXMuc2hvd1F1ZXN0aW9uRmVlZGJhY2spO1xyXG5cclxuICAgICAgICB0aGlzLndpbi5ldmVudE1hbmFnZXIuc3Vic2NyaWJlKEdhbWVFdmVudC5BQ1RJVkFURV9RVUVTVElPTiwgdGhpcy5hY3RpdmF0ZVF1ZXN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXR1cFN0YWdlKCkge1xyXG4gICAgICAgIHRoaXMuYmFzZUNvbnRhaW5lciA9IG5ldyB0aGlzXHJcbiAgICAgICAgICAgIC5jcmVhdGVqc1xyXG4gICAgICAgICAgICAuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAuc3RhZ2VcclxuICAgICAgICAgICAgLmFkZENoaWxkKHRoaXMuYmFzZUNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgIC8qIHRoaXNcclxuICAgICAgICAgICAgLmNyZWF0ZWpzXHJcbiAgICAgICAgICAgIC5UaWNrZXJcclxuICAgICAgICAgICAgLnNldEZQUyh0aGlzLmxpYi5wcm9wZXJ0aWVzLmZwcyk7ICovXHJcblxyXG4gICAgICAgIHRoaXMuY3JlYXRlanMuVGlja2VyLmZyYW1lcmF0ZSA9ICh0aGlzLmxpYi5wcm9wZXJ0aWVzLmZwcyk7XHJcblxyXG4gICAgICAgIHRoaXMuY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIHRoaXMuc3RhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGluaXQoY29uZmlnKSB7XHJcblxyXG4gICAgICAgIFRlYW1EYXRhLnJhbmRvbWl6ZSA9IGNvbmZpZy5yYW5kb21pemU7XHJcbiAgICAgICAgVGVhbURhdGEudGltZURpdmlzaW9uID0gVGVhbURhdGEudGltZUNvbmZpZ1tjb25maWcudGltZXJdO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kZXYpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydE1hdGNoKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAgICAgLmJhc2VDb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hZGRDaGlsZCh0aGlzLmV4cG9ydFJvb3QuaW50cm8pOyAvL1xyXG4gICAgICAgICAgICB0aGlzLmV4cG9ydFJvb3QuaW50cm8uZ290b0FuZFBsYXkoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbmZpZygpIHtcclxuICAgICAgICAvLy4uIGJnIGdyYXBoaWMgY3JpY2tldCBncm91bmRcclxuICAgICAgICB0aGlzLmJnX2dyYXBoaWMgPSBuZXcgdGhpc1xyXG4gICAgICAgICAgICAubGliXHJcbiAgICAgICAgICAgIC5ncl9iZygpO1xyXG4gICAgICAgIHRoaXNcclxuICAgICAgICAgICAgLmJnX2dyYXBoaWNcclxuICAgICAgICAgICAgLmdvdG9BbmRTdG9wKDApO1xyXG4gICAgICAgIHRoaXMuYmdfZ3JhcGhpYy54ID0gNDk2O1xyXG4gICAgICAgIHRoaXMuYmdfZ3JhcGhpYy55ID0gMzA3LjM1O1xyXG4gICAgICAgIHRoaXNcclxuICAgICAgICAgICAgLmJhc2VDb250YWluZXJcclxuICAgICAgICAgICAgLmFkZENoaWxkKHRoaXMuYmdfZ3JhcGhpYyk7XHJcblxyXG4gICAgICAgIHRoaXMud2luLnNob3dDb25maWdTY3JlZW4oKTtcclxuICAgIH1cclxuXHJcbiAgICBzaG93SGVscFNjcmVlbigpIHtcclxuICAgICAgICB0aGlzLmJhc2VDb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcclxuICAgICAgICB0aGlzLmJhc2VDb250YWluZXIuYWRkQ2hpbGQodGhpcy5leHBvcnRSb290LmhlbHBBbmltTWMpO1xyXG4gICAgICAgIHRoaXMuZXhwb3J0Um9vdC5oZWxwQW5pbU1jLmdvdG9BbmRQbGF5KDEpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpbml0VG9zcygpIHtcclxuICAgICAgICB0aGlzLmJhc2VDb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcclxuICAgICAgICB0aGlzLmJhc2VDb250YWluZXIuYWRkQ2hpbGQodGhpcy5leHBvcnRSb290LnRvc3NNYyk7XHJcblxyXG4gICAgICAgIHRoaXMuaVN0YXR1cyA9IG5ldyBJbmZvU3RhdHVzKFwiQ0xFQVJcIik7XHJcbiAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAuYmFzZUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYWRkQ2hpbGQodGhpcy5pU3RhdHVzLmdldENsaXAoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhcnRNYXRjaCgpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGV2KSB7XHJcbiAgICAgICAgICAgIEdhbWVNb2RlbFxyXG4gICAgICAgICAgICAgICAgLmdldEluc3RhbmNlKClcclxuICAgICAgICAgICAgICAgIC51bXBpcmVcclxuICAgICAgICAgICAgICAgIC5Ub3NzKCk7XHJcbiAgICAgICAgICAgIFNvdW5kVXRpbC5wbGF5U291bmQoXCJzdGFkaXVtX25vaXNlXCIsIDAuMDgsIDAsIC0xKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLmlTdGF0dXMuc2V0VGV4dChcIlVTRVJfU1RSSUtFXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgR2FtZU1vZGVsXHJcbiAgICAgICAgICAgIC5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgICAgIC51bXBpcmVcclxuICAgICAgICAgICAgLnN0YXJ0R2FtZShHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS54bWxEYXRhLCB0aGlzLmRldik7XHJcblxyXG4gICAgICAgIHRoaXNcclxuICAgICAgICAgICAgLmJhc2VDb250YWluZXJcclxuICAgICAgICAgICAgLnJlbW92ZUFsbENoaWxkcmVuKCk7XHJcblxyXG4gICAgICAgIC8vLi4gYmcgZ3JhcGhpYyBjcmlja2V0IGdyb3VuZFxyXG4gICAgICAgIHRoaXMuYmdfZ3JhcGhpYyA9IG5ldyB0aGlzXHJcbiAgICAgICAgICAgIC5saWJcclxuICAgICAgICAgICAgLmdyX2JnKCk7XHJcbiAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAuYmdfZ3JhcGhpY1xyXG4gICAgICAgICAgICAuZ290b0FuZFN0b3AoMCk7XHJcbiAgICAgICAgdGhpcy5iZ19ncmFwaGljLnggPSA0OTY7XHJcbiAgICAgICAgdGhpcy5iZ19ncmFwaGljLnkgPSAzMDcuMzU7XHJcbiAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAuYmFzZUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYWRkQ2hpbGQodGhpcy5iZ19ncmFwaGljKTtcclxuXHJcbiAgICAgICAgLy8uLiBzaG90cyBhbmltIGNsaXBzXHJcbiAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAuYmFzZUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYWRkQ2hpbGQodGhpcy5leHBvcnRSb290LnNob3RSZWQpO1xyXG5cclxuICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgIC5iYXNlQ29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hZGRDaGlsZCh0aGlzLmV4cG9ydFJvb3Quc2hvdEJsdWUpO1xyXG5cclxuICAgICAgICAvLy4uIGFkZCBmZWViYWNrIG1jXHJcbiAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAuYmFzZUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYWRkQ2hpbGQodGhpcy5leHBvcnRSb290LmZlZWRiYWNrX21jKTtcclxuXHJcbiAgICAgICAgLy8uLiB0aW1lclxyXG4gICAgICAgIGlmICh0aGlzLmhhc1RpbWVyKCkpIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lciA9IG5ldyBUaW1lcigpO1xyXG4gICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgICAgICAudGltZXJcclxuICAgICAgICAgICAgICAgIC5jcmVhdGVUaW1lcihUZWFtRGF0YS50aW1lRGl2aXNpb25bMF0sIHRoaXMub25UaW1lclVwZGF0ZSwgdGhpcy5vblRpbWVyVXBkYXRlLCB0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLi4gU2hvdyBpbm5pbmdzIHRpdGxlXHJcbiAgICAgICAgdGhpcy50SW5mbyA9IG5ldyB0aGlzXHJcbiAgICAgICAgICAgIC5saWJcclxuICAgICAgICAgICAgLlRpdGxlSW5mbygpO1xyXG4gICAgICAgIHRoaXMudEluZm8ueCA9IDI0MztcclxuICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgIC5iYXNlQ29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hZGRDaGlsZCh0aGlzLnRJbmZvKTtcclxuXHJcbiAgICAgICAgLy8uLiBCb3R0b20gT3ZlciBkaXNwbGF5XHJcbiAgICAgICAgdGhpcy53RGlzcGxheSA9IG5ldyB0aGlzXHJcbiAgICAgICAgICAgIC5saWJcclxuICAgICAgICAgICAgLkJhbGxEaXNwbGF5TWMoKTtcclxuICAgICAgICB0aGlzLndEaXNwbGF5LnkgPSA1MzYuNTtcclxuICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgIC5iYXNlQ29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hZGRDaGlsZCh0aGlzLndEaXNwbGF5KTtcclxuXHJcbiAgICAgICAgR2FtZU1vZGVsXHJcbiAgICAgICAgICAgIC5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgICAgIC5zY29yZWJvYXJkXHJcbiAgICAgICAgICAgIC5jb25uZWN0RGlzcGxheSh0aGlzLndEaXNwbGF5KTtcclxuXHJcbiAgICAgICAgdGhpcy5pU3RhdHVzID0gbmV3IEluZm9TdGF0dXMoXCJVU0VSX1NUUklLRVwiKTtcclxuXHJcbiAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAuYmFzZUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYWRkQ2hpbGQodGhpcy5pU3RhdHVzLmdldENsaXAoKSk7XHJcblxyXG4gICAgICAgIEdhbWVNb2RlbFxyXG4gICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAuZ2FtZVJlZlxyXG4gICAgICAgICAgICAuYmFzZUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYWRkQ2hpbGQoR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi5leHBvcnRSb290LnJlc3BvbnNlX21jKTtcclxuXHJcbiAgICAgICAgR2FtZU1vZGVsXHJcbiAgICAgICAgICAgIC5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgICAgIC5nYW1lUmVmXHJcbiAgICAgICAgICAgIC5leHBvcnRSb290XHJcbiAgICAgICAgICAgIC5yZXNwb25zZV9tY1xyXG4gICAgICAgICAgICAueCA9IDE4O1xyXG4gICAgICAgIEdhbWVNb2RlbFxyXG4gICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAuZ2FtZVJlZlxyXG4gICAgICAgICAgICAuZXhwb3J0Um9vdFxyXG4gICAgICAgICAgICAucmVzcG9uc2VfbWNcclxuICAgICAgICAgICAgLnkgPSAxNzI7XHJcblxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIHRoaXMudW1waXJlRGVjaXNpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICBzaG93UXVlc3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGlmICghR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi53RGlzcGxheS52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYud0Rpc3BsYXkudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgIC5leHBvcnRSb290XHJcbiAgICAgICAgICAgIC5zaG90UmVkXHJcbiAgICAgICAgICAgIC5nb3RvQW5kU3RvcCgxKTtcclxuXHJcbiAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAuZXhwb3J0Um9vdFxyXG4gICAgICAgICAgICAuc2hvdEJsdWVcclxuICAgICAgICAgICAgLmdvdG9BbmRTdG9wKDEpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIHRoaXMucSA9IG5ldyBRdWVzdGlvbih0aGlzLnNjcmVlblF1ZXN0aW9uT2JqZWN0KTtcclxuICAgICAgICB0aGlzLnEuYWRkUXVlc3Rpb25TY3JlZW4oKTtcclxuXHJcbiAgICAgICAgdGhpcy5iYXNlQ29udGFpbmVyLmFkZENoaWxkQXQodGhpcy5xLmdldFNjcmVlbigpLCAxKTtcclxuXHJcbiAgICAgICAgU291bmRVdGlsLnBsYXlTb3VuZChcImltYWdlYXBwZWFyXCIpO1xyXG5cclxuICAgICAgICAvLy4uIFxyXG5cclxuICAgICAgICBpZiAodGhpcy5oYXNUaW1lcigpKSB7XHJcblxyXG4gICAgICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgIC5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgICAgICAgICAuZ2FtZVJlZlxyXG4gICAgICAgICAgICAgICAgLnRpbWVyXHJcbiAgICAgICAgICAgICAgICAuc3RhcnRUaW1lcigpO1xyXG4gICAgICAgICAgICBTb3VuZFV0aWwucGxheVNvdW5kKFwiY291bnRkb3duX3RpY2tcIiwgMC4yLCAwLCAtMSk7XHJcblxyXG4gICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5zdHJpa2UgPSBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLmdldFN0cmlrZU5hbWUoVGVhbURhdGEudGltZURpdmlzaW9uWzBdKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucS51cGRhdGVTdWJtaXRCdG5TdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICB0eHQ6IEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLnN0cmlrZS50eHQsXHJcbiAgICAgICAgICAgICAgICB0aW1lOiBUZWFtRGF0YS50aW1lRGl2aXNpb25bMF0gKyBcIiBTZWNcIlxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYucGF1c2VRdWVzdGlvbkFjdGl2aXR5KCk7XHJcbiAgICAgICAgICAgIH0sIDE1MCk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIEdhbWVNb2RlbFxyXG4gICAgICAgICAgICAgICAgLmdldEluc3RhbmNlKClcclxuICAgICAgICAgICAgICAgIC5zdHJpa2UgPSBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5nYW1lUmVmLmdldFN0cmlrZU5hbWUoMSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnEudXBkYXRlU3VibWl0QnRuU3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgdHh0OiBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHJpa2UudHh0LCB0aW1lOiBcIlwiXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhY3RpdmF0ZVF1ZXN0aW9uKCkge1xyXG5cclxuICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLnEuZGlzYWJsZVNjcmVlbihmYWxzZSk7XHJcblxyXG4gICAgICAgIGlmIChHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLmdhbWVQYXVzZWQpIHtcclxuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi5wYXVzZVF1ZXN0aW9uQWN0aXZpdHkoKTtcclxuICAgICAgICAgICAgfSwgMTUwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLnJlc3VtZVF1ZXN0aW9uQWN0aXZpdHkoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHNob3dRdWVzdGlvbkZlZWRiYWNrKHApIHtcclxuXHJcbiAgICAgICAgU291bmRVdGlsLnBsYXlTb3VuZChcImltYWdlYXBwZWFyXCIpO1xyXG5cclxuICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLmV4cG9ydFJvb3QucmVzcG9uc2VfbWMuZ290b0FuZFN0b3AoMCk7XHJcblxyXG4gICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYucXVlc3Rpb25GZWVkYmFja19pZCA9IHAuaWQ7XHJcblxyXG4gICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuZXhwb3J0Um9vdC5yZXNwb25zZV9tYy5nb3RvQW5kUGxheSgxKTtcclxuXHJcbiAgICAgICAgaWYgKEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuY2FuSGlkZUJhbGxOb3RlKSB7XHJcbiAgICAgICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuYmFsbE5vdGUudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgY29udGludWVHYW1lKCkge1xyXG5cclxuICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLnRJbmZvLmluZm9UeHQudGV4dCA9IEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLnVtcGlyZS5nZXRJbm5pbmdUaXRsZSgpO1xyXG5cclxuICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgLmdldEluc3RhbmNlKClcclxuICAgICAgICAgICAgLmdhbWVSZWZcclxuICAgICAgICAgICAgLmV4cG9ydFJvb3RbXCJzaG90XCIgKyBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgIC5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgICAgICAgICAudW1waXJlXHJcbiAgICAgICAgICAgICAgICAuZ2V0QmF0dGluZ1RlYW0oKVxyXG4gICAgICAgICAgICAgICAgLmdldFRlYW1JZCgpXHJcbiAgICAgICAgXVxyXG4gICAgICAgICAgICAuZ290b0FuZFBsYXkoXCJzdGFydFwiKTtcclxuXHJcbiAgICAgICAgR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi53RGlzcGxheS52aXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdhbWVPdmVyKCkge1xyXG5cclxuICAgICAgICBsZXQgbXMgPSBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS51bXBpcmUuZ2V0TWF0Y2hTdGF0KCk7XHJcbiAgICAgICAgbGV0IHRvcGxheSA9ICcnO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJHQU1FIE9WRVIgLSBvdmVydXBcIiwgbXMpO1xyXG5cclxuICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAuZ2FtZVJlZi5iYXNlQ29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hZGRDaGlsZEF0KEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuZXhwb3J0Um9vdC5HYW1lT3ZlckZlZWRiYWNrX21jLCAxKTtcclxuXHJcbiAgICAgICAgaWYgKG1zLndpbm5lciA9PT0gJ05vbmUnKSB7XHJcbiAgICAgICAgICAgIGlmICgobXMuVGVhbVJlZCA9PT0gMCkgJiYgKG1zLlRlYW1CbHVlID09PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgdG9wbGF5ID0gJ05vUnVuU2NvcmUnO1xyXG4gICAgICAgICAgICAgICAgU291bmRVdGlsLnBsYXlTb3VuZChcImFfemVyb19ydW5zXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdG9wbGF5ID0gJ0FsbFRlYW1Mb3N0JztcclxuICAgICAgICAgICAgICAgIFNvdW5kVXRpbC5wbGF5U291bmQoXCJhX2RyYXduXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdG9wbGF5ID0gJ1dpbic7XHJcbiAgICAgICAgICAgIFNvdW5kVXRpbC5wbGF5U291bmQoXCJhX2Nvbmdfd29uXCIpO1xyXG4gICAgICAgICAgICBTb3VuZFV0aWwucGxheVNvdW5kKFwid2luX2JnX211c2ljXCIsIDAuOCk7XHJcbiAgICAgICAgICAgIEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuZXhwb3J0Um9vdC5HYW1lT3ZlckZlZWRiYWNrX21jLnRlYW1uYW1lTUMudHh0XHJcbiAgICAgICAgICAgICAgICAudGV4dCA9IG1zLm1zZztcclxuICAgICAgICB9XHJcbiAgICAgICAgKEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuZXhwb3J0Um9vdC5HYW1lT3ZlckZlZWRiYWNrX21jKS5nb3RvQW5kUGxheSh0b3BsYXkpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzaG93VGVhbVBlcmZvcm1hbmNlKHApIHtcclxuICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLnBlcmZvcm1hbmNlVHlwZSA9IHA7XHJcbiAgICAgICAgKEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuYmFzZUNvbnRhaW5lci5nZXRDaGlsZEJ5TmFtZShcImZlZWRiYWNrX21jXCIpKS5nb3RvQW5kUGxheSgxKTtcclxuICAgIH1cclxuXHJcbiAgICBwYXVzZVF1ZXN0aW9uQWN0aXZpdHkoKSB7XHJcbiAgICAgICAgaWYgKEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYucS5pc1F1ZXN0aW9uQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYuaGFzVGltZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgR2FtZU1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgLmdldEluc3RhbmNlKClcclxuICAgICAgICAgICAgICAgICAgICAuZ2FtZVJlZlxyXG4gICAgICAgICAgICAgICAgICAgIC50aW1lclxyXG4gICAgICAgICAgICAgICAgICAgIC5wYXVzZVRpbWVyKCk7XHJcbiAgICAgICAgICAgICAgICBTb3VuZFV0aWwucGF1c2VTb3VuZChcImNvdW50ZG93bl90aWNrXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYucS5hbGVydE9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgU291bmRVdGlsLnN0b3BTb3VuZChcIlNwYWNlc29cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVzdW1lUXVlc3Rpb25BY3Rpdml0eSgpIHtcclxuXHJcbiAgICAgICAgaWYgKEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYucS5pc1F1ZXN0aW9uQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKEdhbWVNb2RlbFxyXG4gICAgICAgICAgICAgICAgLmdldEluc3RhbmNlKClcclxuICAgICAgICAgICAgICAgIC5nYW1lUmVmLmhhc1RpbWVyKCkpIHtcclxuICAgICAgICAgICAgICAgIEdhbWVNb2RlbFxyXG4gICAgICAgICAgICAgICAgICAgIC5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmdhbWVSZWZcclxuICAgICAgICAgICAgICAgICAgICAudGltZXJcclxuICAgICAgICAgICAgICAgICAgICAucmVzdW1lVGltZXIoKTtcclxuICAgICAgICAgICAgICAgIFNvdW5kVXRpbC5yZXN1bWVTb3VuZChcImNvdW50ZG93bl90aWNrXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLmdhbWVSZWYucS5hbGVydE9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgU291bmRVdGlsLnJlc3VtZVNvdW5kKFwiU3BhY2Vzb1wiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGVhckRpc3BsYXlCb2FyZCgpIHtcclxuXHJcbiAgICAgICAgR2FtZU1vZGVsXHJcbiAgICAgICAgICAgIC5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgICAgIC5zY29yZWJvYXJkXHJcbiAgICAgICAgICAgIC5jbGVhbnVwU2NvcmVCb2FyZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHVtcGlyZURlY2lzaW9uKCkge1xyXG5cclxuICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgIC5leHBvcnRSb290XHJcbiAgICAgICAgICAgIC5zaG90UmVkXHJcbiAgICAgICAgICAgIC5nb3RvQW5kU3RvcCgwKTsgLy8gY2hhbmdlIGZvciBSRUQgYW5kIEJMVUVcclxuICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgIC5leHBvcnRSb290XHJcbiAgICAgICAgICAgIC5zaG90Qmx1ZVxyXG4gICAgICAgICAgICAuZ290b0FuZFN0b3AoMCk7XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coR2FtZU1vZGVsLmdldEluc3RhbmNlKCkudW1waXJlLmdldE1hdGNoU3RhdCgpLCBcInVtcGlyZURlY2lzaW9uMSBcIiwgR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZik7XHJcblxyXG4gICAgICAgIHRoaXMuc2NyZWVuUXVlc3Rpb25PYmplY3QgPSBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS51bXBpcmUubmV4dEJhbGwoKTtcclxuXHJcbiAgICAgICAgaWYgKEdhbWVNb2RlbC5nZXRJbnN0YW5jZSgpLnVtcGlyZS5nZXRNYXRjaFN0YXQoKS5nYW1lb3ZlciAmJiAhR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi5nYW1lT3ZlclNlZW4pIHtcclxuICAgICAgICAgICAgLy8uLiBvbmV0aW1lIGdhbWUgY29tcGxldGVkIGV2ZW50IGRpc3BhdGNoXHJcbiAgICAgICAgICAgIGxldCBvID0geyBcIm92ZXJ1cFwiOiB0aGlzLnNjcmVlblF1ZXN0aW9uT2JqZWN0LmRvbmUgfVxyXG4gICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS51bXBpcmUuZ2FtZU92ZXIobyk7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRlbGVnYXRlZHVtcGlyZURlY2lzaW9uKCk7XHJcblxyXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuc2NvcmVib2FyZC5zY29yZVVwZGF0ZSgpO1xyXG4gICAgICAgIH0sIDI1MCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZWdhdGVkdW1waXJlRGVjaXNpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NyZWVuUXVlc3Rpb25PYmplY3QuZG9uZSkge1xyXG4gICAgICAgICAgICBsZXQgbyA9IHsgXCJvdmVydXBcIjogdGhpcy5zY3JlZW5RdWVzdGlvbk9iamVjdC5kb25lIH1cclxuICAgICAgICAgICAgR2FtZU1vZGVsLmdldEluc3RhbmNlKCkudW1waXJlLm92ZXJVcChvKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLnNob3dRdWVzdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwbGF5U2hvdChzKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmhhc1RpbWVyKCkpIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lci5zdG9wVGltZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucS5yZW1vdmVTY3JlZW4oKTtcclxuXHJcbiAgICAgICAgdGhpcy5iYXNlQ29udGFpbmVyLnJlbW92ZUNoaWxkQXQoMSk7XHJcblxyXG4gICAgICAgIC8vLi4gc2hvdCBsb2dpY1xyXG4gICAgICAgIGxldCBzaG90ID0ge1xyXG4gICAgICAgICAgICBsYWJlbDogXCJcIixcclxuICAgICAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgICAgIHVzZXJzZWxlY3Q6IHMuaWRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAocy5pZCA9PT0gcy5jb3JyZWN0QW5zKSB7XHJcbiAgICAgICAgICAgIHNob3QubGFiZWwgPSBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5zdHJpa2UubGFiZWw7XHJcbiAgICAgICAgICAgIHNob3QudmFsdWUgPSBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5zdHJpa2UudmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2hvdC5sYWJlbCA9IEFycmF5VXRpbHMuZ2V0UmFuZG9tQm9vbCgpXHJcbiAgICAgICAgICAgICAgICA/IFwiY2F1Z2h0XCJcclxuICAgICAgICAgICAgICAgIDogXCJib3dsZWRcIjtcclxuICAgICAgICAgICAgc2hvdC52YWx1ZSA9IC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5leHBvcnRSb290W1wic2hvdFwiICtcclxuICAgICAgICAgICAgR2FtZU1vZGVsLmdldEluc3RhbmNlKCkudW1waXJlLmdldEJhdHRpbmdUZWFtKCkuZ2V0VGVhbUlkKCldLmdvdG9BbmRQbGF5KHNob3QubGFiZWwpO1xyXG5cclxuICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgLmdldEluc3RhbmNlKClcclxuICAgICAgICAgICAgLnVtcGlyZVxyXG4gICAgICAgICAgICAuY2FwdHVyZVNob3Qoc2hvdCk7XHJcblxyXG4gICAgICAgIEdhbWVNb2RlbFxyXG4gICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAuZ2FtZVJlZlxyXG4gICAgICAgICAgICAuc2hvdCA9IHNob3Q7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U3RyaWtlTmFtZSh0aW1lKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImdldEJhbGxDb3VudCBcIiwgR2FtZU1vZGVsLmdldEluc3RhbmNlKCkudW1waXJlLmdldEJhdHRpbmdUZWFtKCkuZ2V0QmFsbENvdW50KCkpO1xyXG4gICAgICAgIGlmICh0aW1lID4gVGVhbURhdGEudGltZURpdmlzaW9uWzFdKSB7XHJcbiAgICAgICAgICAgIGxldCBiYWxsSWR4ID0gR2FtZU1vZGVsLmdldEluc3RhbmNlKCkudW1waXJlLmdldEJhdHRpbmdUZWFtKCkuZ2V0QmFsbENvdW50KClcclxuICAgICAgICAgICAgcmV0dXJuICgoYmFsbElkeCA9PT0gMCkgfHwgKGJhbGxJZHggPT09IDEpIHx8IChiYWxsSWR4ID09PSA1KSlcclxuICAgICAgICAgICAgICAgID8gVGVhbURhdGEuc3RyaWtlTmFtZVswXVxyXG4gICAgICAgICAgICAgICAgOiBUZWFtRGF0YS5zdHJpa2VOYW1lWzFdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aW1lID4gVGVhbURhdGEudGltZURpdmlzaW9uWzJdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUZWFtRGF0YS5zdHJpa2VOYW1lWzJdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aW1lID4gVGVhbURhdGEudGltZURpdmlzaW9uWzNdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUZWFtRGF0YS5zdHJpa2VOYW1lWzNdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aW1lID4gVGVhbURhdGEudGltZURpdmlzaW9uWzRdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUZWFtRGF0YS5zdHJpa2VOYW1lWzRdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aW1lID09PSBUZWFtRGF0YS50aW1lRGl2aXNpb25bNF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRlYW1EYXRhLnN0cmlrZU5hbWVbNV1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25UaW1lclVwZGF0ZShlKSB7XHJcblxyXG4gICAgICAgIGlmIChlLnRpbWVyLmdldFRpbWUoKSA9PSA2KSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwidHJpZ2dlciBhbGVydFwiKTtcclxuICAgICAgICAgICAgZS5xLnRyaWdnZXJBbGVydCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGUudGltZXIuZ2V0VGltZSgpID09IDApIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInN0b3AgYWxlcnRcIik7XHJcbiAgICAgICAgICAgIGUucS5zdG9wQWxlcnQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEdhbWVNb2RlbFxyXG4gICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAuc3RyaWtlID0gZS5nZXRTdHJpa2VOYW1lKGUudGltZXIuZ2V0VGltZSgpKTtcclxuXHJcbiAgICAgICAgZVxyXG4gICAgICAgICAgICAucVxyXG4gICAgICAgICAgICAudXBkYXRlU3VibWl0QnRuU3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgXCJ0aW1lXCI6IGVcclxuICAgICAgICAgICAgICAgICAgICAudGltZXJcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0Rm9ybWF0dGVkVGltZSgpLFxyXG4gICAgICAgICAgICAgICAgXCJ0eHRcIjogR2FtZU1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgLmdldEluc3RhbmNlKClcclxuICAgICAgICAgICAgICAgICAgICAuc3RyaWtlLnR4dFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgaGFzVGltZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChUZWFtRGF0YS50aW1lRGl2aXNpb25bMF0gIT09IDApXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHYW1lRGlzcGxheTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/views/GameDisplay.js\n");

/***/ }),

/***/ "./src/views/InfoStatus.js":
/*!*********************************!*\
  !*** ./src/views/InfoStatus.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var createjs_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! createjs-module */ \"./node_modules/createjs-module/createjs.js\");\n/* harmony import */ var createjs_module__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(createjs_module__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nclass InfoStatus {\r\n\r\n    constructor(param) {\r\n\r\n        this.iFont = {\r\n            \"style\": \"normal 16px Verdana\",\r\n            \"color\": \"#000000\"\r\n        };\r\n\r\n        this.msg = {\r\n            \"CLEAR\": \"\",\r\n            \"USER_STRIKE\": \"Select the correct option and click Strike.\",\r\n            \"TOSS_INFO\": \"Click Toss to toss the coin and see which team will begin.\"\r\n        }\r\n\r\n        this.x = 0;\r\n        this.y = 580;\r\n        this.w = 993;\r\n        this.h = 29;\r\n\r\n        this.base = new createjs_module__WEBPACK_IMPORTED_MODULE_0__[\"Container\"]();\r\n\r\n        this.s = new createjs_module__WEBPACK_IMPORTED_MODULE_0__[\"Shape\"]();\r\n\r\n        this\r\n            .s\r\n            .graphics\r\n            .setStrokeStyle(1)\r\n            .beginStroke(\"#ccc\")\r\n            .drawRect(this.x, this.y, this.w, this.h)\r\n            .beginFill(\"#eee\")\r\n            .drawRect(this.x, this.y, this.w, this.h)\r\n            .endFill();\r\n\r\n        this\r\n            .base\r\n            .addChild(this.s);\r\n\r\n        this.addText({\r\n            x: this.x + 10,\r\n            y: this.y + 4,\r\n            t: this.msg[param],\r\n            f: this.iFont\r\n        });\r\n\r\n    }\r\n\r\n    getClip() {\r\n        return this.base\r\n    }\r\n\r\n    setText(param) {\r\n        this.txt.text = this.msg[param];\r\n    }\r\n\r\n    addText({x, y, t, f}) {\r\n        this.txt = new createjs_module__WEBPACK_IMPORTED_MODULE_0__[\"Text\"](); //tis_subregular\r\n        this.txt.x = x;\r\n        this.txt.y = y;\r\n        this.txt.font = f.style;\r\n        this.txt.color = f.color;\r\n        this.txt.text = t;\r\n        this.txt.textAlign = \"left\";\r\n        this.txt.lineWidth = 850;\r\n\r\n        this\r\n            .base\r\n            .addChild(this.txt);\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (InfoStatus);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmlld3MvSW5mb1N0YXR1cy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy92aWV3cy9JbmZvU3RhdHVzLmpzPzJkNDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtUZXh0LCBTaGFwZSwgQ29udGFpbmVyfSBmcm9tIFwiY3JlYXRlanMtbW9kdWxlXCI7XHJcblxyXG5jbGFzcyBJbmZvU3RhdHVzIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbSkge1xyXG5cclxuICAgICAgICB0aGlzLmlGb250ID0ge1xyXG4gICAgICAgICAgICBcInN0eWxlXCI6IFwibm9ybWFsIDE2cHggVmVyZGFuYVwiLFxyXG4gICAgICAgICAgICBcImNvbG9yXCI6IFwiIzAwMDAwMFwiXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5tc2cgPSB7XHJcbiAgICAgICAgICAgIFwiQ0xFQVJcIjogXCJcIixcclxuICAgICAgICAgICAgXCJVU0VSX1NUUklLRVwiOiBcIlNlbGVjdCB0aGUgY29ycmVjdCBvcHRpb24gYW5kIGNsaWNrIFN0cmlrZS5cIixcclxuICAgICAgICAgICAgXCJUT1NTX0lORk9cIjogXCJDbGljayBUb3NzIHRvIHRvc3MgdGhlIGNvaW4gYW5kIHNlZSB3aGljaCB0ZWFtIHdpbGwgYmVnaW4uXCJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMueCA9IDA7XHJcbiAgICAgICAgdGhpcy55ID0gNTgwO1xyXG4gICAgICAgIHRoaXMudyA9IDk5MztcclxuICAgICAgICB0aGlzLmggPSAyOTtcclxuXHJcbiAgICAgICAgdGhpcy5iYXNlID0gbmV3IENvbnRhaW5lcigpO1xyXG5cclxuICAgICAgICB0aGlzLnMgPSBuZXcgU2hhcGUoKTtcclxuXHJcbiAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAuc1xyXG4gICAgICAgICAgICAuZ3JhcGhpY3NcclxuICAgICAgICAgICAgLnNldFN0cm9rZVN0eWxlKDEpXHJcbiAgICAgICAgICAgIC5iZWdpblN0cm9rZShcIiNjY2NcIilcclxuICAgICAgICAgICAgLmRyYXdSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLncsIHRoaXMuaClcclxuICAgICAgICAgICAgLmJlZ2luRmlsbChcIiNlZWVcIilcclxuICAgICAgICAgICAgLmRyYXdSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLncsIHRoaXMuaClcclxuICAgICAgICAgICAgLmVuZEZpbGwoKTtcclxuXHJcbiAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAuYmFzZVxyXG4gICAgICAgICAgICAuYWRkQ2hpbGQodGhpcy5zKTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRUZXh0KHtcclxuICAgICAgICAgICAgeDogdGhpcy54ICsgMTAsXHJcbiAgICAgICAgICAgIHk6IHRoaXMueSArIDQsXHJcbiAgICAgICAgICAgIHQ6IHRoaXMubXNnW3BhcmFtXSxcclxuICAgICAgICAgICAgZjogdGhpcy5pRm9udFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZXRDbGlwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VcclxuICAgIH1cclxuXHJcbiAgICBzZXRUZXh0KHBhcmFtKSB7XHJcbiAgICAgICAgdGhpcy50eHQudGV4dCA9IHRoaXMubXNnW3BhcmFtXTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRUZXh0KHt4LCB5LCB0LCBmfSkge1xyXG4gICAgICAgIHRoaXMudHh0ID0gbmV3IFRleHQoKTsgLy90aXNfc3VicmVndWxhclxyXG4gICAgICAgIHRoaXMudHh0LnggPSB4O1xyXG4gICAgICAgIHRoaXMudHh0LnkgPSB5O1xyXG4gICAgICAgIHRoaXMudHh0LmZvbnQgPSBmLnN0eWxlO1xyXG4gICAgICAgIHRoaXMudHh0LmNvbG9yID0gZi5jb2xvcjtcclxuICAgICAgICB0aGlzLnR4dC50ZXh0ID0gdDtcclxuICAgICAgICB0aGlzLnR4dC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcclxuICAgICAgICB0aGlzLnR4dC5saW5lV2lkdGggPSA4NTA7XHJcblxyXG4gICAgICAgIHRoaXNcclxuICAgICAgICAgICAgLmJhc2VcclxuICAgICAgICAgICAgLmFkZENoaWxkKHRoaXMudHh0KTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEluZm9TdGF0dXMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/views/InfoStatus.js\n");

/***/ }),

/***/ "./src/views/Question.js":
/*!*******************************!*\
  !*** ./src/views/Question.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _models_Models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/Models */ \"./src/models/Models.js\");\n/* harmony import */ var _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/SoundUtil */ \"./src/utils/SoundUtil.js\");\n/* harmony import */ var _utils_TextUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/TextUtil */ \"./src/utils/TextUtil.js\");\n\r\n\r\n\r\n\r\nclass Question {\r\n\r\n    constructor(screendata) {\r\n\r\n        this.qFont = {\r\n            \"style\": \"normal 16px Verdana\",\r\n            \"color\": \"#000000\",\r\n            \"width\": 850\r\n        };\r\n        this.oFont = {\r\n            \"style\": \"normal 15px Verdana\",\r\n            \"color\": \"#000000\",\r\n            \"width\": 850\r\n        };\r\n\r\n        this.userSelectedValue = null;\r\n        this.optionArr = [];\r\n        this.isOptionSelected = false;\r\n        this.alertOn = false;\r\n        this.active = false;\r\n        this.timeUp = false;\r\n        this.screenData = screendata;\r\n\r\n        this.lib = _models_Models__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\r\n            .getInstance()\r\n            .gameRef\r\n            .lib;\r\n        this.createjs = _models_Models__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\r\n            .getInstance()\r\n            .gameRef\r\n            .createjs;\r\n    }\r\n\r\n    addQuestionScreen() {\r\n        this.active = true;\r\n        this.addBg();\r\n        this.addQuestion();\r\n        this.addInstruction();\r\n        this.addOptions(true);\r\n        this.update();\r\n    }\r\n\r\n    addResponseScreen(p) {\r\n\r\n        this.userSelectedValue = p;\r\n        this.active = true;\r\n\r\n        this.qscreen = new this\r\n            .createjs\r\n            .Container();\r\n\r\n        this.addQuestion();\r\n        this.addOptions(false);\r\n\r\n        this.setXY(16, -170);\r\n    }\r\n\r\n    getScreen() {\r\n        return this.qscreen\r\n    }\r\n\r\n    update() {\r\n        this.setXY(16, 55);\r\n        this.updateBatsmanStates();\r\n    }\r\n\r\n    setXY(x, y) {\r\n        this.qscreen.x = x;\r\n        this.qscreen.y = y;\r\n    }\r\n\r\n    updateSubmitBtnState(p) {\r\n        this.qscreen.submit.shot_txt.text = p.txt;\r\n        this.qscreen.submit.countdown.txt.text = p.time;\r\n    }\r\n\r\n    triggerAlert() {\r\n        if (_models_Models__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getInstance().gameRef.hasTimer()) {\r\n            if (!this.alertOn) {\r\n                this.alertOn = true;\r\n                _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_1__[\"default\"].playSound(\"Spaceso\", 0.8, 0, -1);\r\n                this.qscreen.submit.countdown.alertMc.play();\r\n            }\r\n        }\r\n    }\r\n\r\n    stopAlert() {\r\n        if (_models_Models__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getInstance().gameRef.hasTimer()) {\r\n            _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_1__[\"default\"].stopSound(\"countdown_tick\");\r\n            if (this.alertOn) {\r\n                _utils_SoundUtil__WEBPACK_IMPORTED_MODULE_1__[\"default\"].stopSound(\"Spaceso\");\r\n            }\r\n            this.qscreen.submit.countdown.alertMc.gotoAndStop(0);\r\n        }\r\n        this.alertOn = false;\r\n        this.timeUp = true;\r\n        this.active = false;\r\n    }\r\n\r\n    updateBatsmanStates() {\r\n        _models_Models__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\r\n            .getInstance()\r\n            .umpire\r\n            .getBattingTeam()\r\n            .getPlayerStates()\r\n            .forEach(el => {\r\n                let mc = this.qscreen[\"wk_\" + el.id];\r\n                mc.gotoAndStop(el.state);\r\n                mc.txt.text = el.run;\r\n            });\r\n    }\r\n\r\n    removeScreen() {\r\n        this.stopAlert();\r\n        this\r\n            .qscreen\r\n            .removeAllChildren();\r\n    }\r\n\r\n    addBg() {\r\n\r\n        this.qscreen = new this\r\n            .lib\r\n            .QScreen();\r\n\r\n        this\r\n            .qscreen\r\n            .gotoAndStop(\"Question\" + _models_Models__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getInstance().umpire.getBattingTeam().getTeamId());\r\n\r\n        this.qscreen.team_txt.text = _models_Models__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\r\n            .getInstance()\r\n            .umpire\r\n            .getBattingTeam()\r\n            .getTeamName();\r\n\r\n        this.qscreen.submit.cursor = \"pointer\";\r\n        this.qscreen.submit.on(\"mouseover\", (event) => {\r\n            if (this.isOptionSelected) {\r\n                this.qscreen.submit.gotoAndStop('over');\r\n            }\r\n        });\r\n        this.qscreen.submit.on(\"mouseout\", (event) => {\r\n            if (this.isOptionSelected) {\r\n                this.qscreen.submit.gotoAndStop('normal');\r\n            }\r\n        });\r\n        this.qscreen.submit.addEventListener(\"click\", (e) => {\r\n            if (this.isOptionSelected) {\r\n                this.stopAlert();\r\n                _models_Models__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\r\n                    .getInstance()\r\n                    .gameRef\r\n                    .playShot(this.playedShot);\r\n            }\r\n        })\r\n\r\n    }\r\n\r\n    addQuestion() {\r\n        _utils_TextUtil__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getText({ x: 100, y: 180, t: this.screenData.value.qtag.__cdata, f: this.qFont, lCanvas: this.qscreen });\r\n    }\r\n\r\n    addInstruction() {\r\n        this.qscreen.qinfotxt_mc.txt.text = this.screenData.value._skill;\r\n        //this.qscreen.qinfotxt_mc.txtBg.width = this.qscreen.qinfotxt_mc.txt.text.width;\r\n    }\r\n\r\n    addOptions(p) {\r\n\r\n        let oStartPoint = 217;\r\n        let optiongap = 35;\r\n        let o = this.screenData.value.option;\r\n        let t;\r\n\r\n        o.forEach((each, i) => {\r\n            let omc = new this\r\n                .lib\r\n                .OptionMc1();\r\n\r\n            omc.x = 120;\r\n            omc.y = oStartPoint + (optiongap * i);\r\n            omc.name = \"opt\" + (i + 1);\r\n            omc.id = i;\r\n\r\n            this\r\n                .optionArr\r\n                .push(omc);\r\n\r\n            t = _utils_TextUtil__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getText({ x: 10, y: 0, t: each.__cdata, f: this.oFont, lCanvas: omc })\r\n\r\n            omc.selected = false;\r\n            omc.correctAns = (each._correctans === \"true\")\r\n                ? i\r\n                : -1;\r\n            console.log('option-', i, omc.correctAns);\r\n\r\n\r\n            if (p) {\r\n                omc.validateMc.visible = false;\r\n                omc.cursor = \"pointer\";\r\n                omc.addEventListener(\"mouseover\", (event) => {\r\n                    if (!omc.selected) {\r\n                        omc.gotoAndStop(\"over\"); // assetFix\r\n                    }\r\n                });\r\n                omc.addEventListener(\"mouseout\", (event) => {\r\n                    if (!omc.selected) {\r\n                        omc.gotoAndStop(\"normal\"); // assetFix\r\n                    }\r\n                });\r\n                omc.addEventListener(\"click\", (event) => {\r\n                    this.deselectAllOptions();\r\n                    this.playedShot = omc;\r\n\r\n                    omc.gotoAndStop(\"selected\");\r\n                    omc.selected = true;\r\n                    this.isOptionSelected = true;\r\n                    this\r\n                        .qscreen\r\n                        .submit\r\n                        .gotoAndStop('normal');\r\n                });\r\n            } else {\r\n                if (i == this.userSelectedValue) {\r\n                    if (each._correctans) {\r\n\r\n                    } else {\r\n                        omc.validateMc.visible = true;\r\n                        omc.validateMc.tick.visible = false;\r\n                    }\r\n                } else {\r\n                    omc.validateMc.visible = false;\r\n                }\r\n\r\n                if ((each._correctans === \"true\")) {\r\n                    omc.validateMc.visible = true;\r\n                    omc.validateMc.cross.visible = false;\r\n                }\r\n            }\r\n            this\r\n                .qscreen\r\n                .addChild(omc);\r\n\r\n        })\r\n\r\n        this.disableScreen(true);\r\n    }\r\n\r\n    deselectAllOptions() {\r\n        this\r\n            .optionArr\r\n            .forEach((each, i) => {\r\n                each.gotoAndStop(\"normal\");\r\n                each.selected = false;\r\n            })\r\n    }\r\n\r\n    disableScreen(p) {\r\n        this.optionArr.forEach((each, i) => {\r\n            each.mouseEnabled = each.mouseChildren = !p;\r\n        })\r\n        this.qscreen.mouseEnabled = this.qscreen.mouseChildren = !p;\r\n    }\r\n\r\n    isQuestionActive() {\r\n        return (!this.timeUp && this.active)\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Question);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmlld3MvUXVlc3Rpb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvUXVlc3Rpb24uanM/YThhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR2FtZU1vZGVsIGZyb20gXCIuLi9tb2RlbHMvTW9kZWxzXCI7XHJcbmltcG9ydCBTb3VuZFV0aWwgZnJvbSBcIi4uL3V0aWxzL1NvdW5kVXRpbFwiO1xyXG5pbXBvcnQgVGV4dFV0aWwgZnJvbSBcIi4uL3V0aWxzL1RleHRVdGlsXCI7XHJcblxyXG5jbGFzcyBRdWVzdGlvbiB7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioc2NyZWVuZGF0YSkge1xyXG5cclxuICAgICAgICB0aGlzLnFGb250ID0ge1xyXG4gICAgICAgICAgICBcInN0eWxlXCI6IFwibm9ybWFsIDE2cHggVmVyZGFuYVwiLFxyXG4gICAgICAgICAgICBcImNvbG9yXCI6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICBcIndpZHRoXCI6IDg1MFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vRm9udCA9IHtcclxuICAgICAgICAgICAgXCJzdHlsZVwiOiBcIm5vcm1hbCAxNXB4IFZlcmRhbmFcIixcclxuICAgICAgICAgICAgXCJjb2xvclwiOiBcIiMwMDAwMDBcIixcclxuICAgICAgICAgICAgXCJ3aWR0aFwiOiA4NTBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLnVzZXJTZWxlY3RlZFZhbHVlID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9wdGlvbkFyciA9IFtdO1xyXG4gICAgICAgIHRoaXMuaXNPcHRpb25TZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYWxlcnRPbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50aW1lVXAgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNjcmVlbkRhdGEgPSBzY3JlZW5kYXRhO1xyXG5cclxuICAgICAgICB0aGlzLmxpYiA9IEdhbWVNb2RlbFxyXG4gICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAuZ2FtZVJlZlxyXG4gICAgICAgICAgICAubGliO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlanMgPSBHYW1lTW9kZWxcclxuICAgICAgICAgICAgLmdldEluc3RhbmNlKClcclxuICAgICAgICAgICAgLmdhbWVSZWZcclxuICAgICAgICAgICAgLmNyZWF0ZWpzO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZFF1ZXN0aW9uU2NyZWVuKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFkZEJnKCk7XHJcbiAgICAgICAgdGhpcy5hZGRRdWVzdGlvbigpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5zdHJ1Y3Rpb24oKTtcclxuICAgICAgICB0aGlzLmFkZE9wdGlvbnModHJ1ZSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRSZXNwb25zZVNjcmVlbihwKSB7XHJcblxyXG4gICAgICAgIHRoaXMudXNlclNlbGVjdGVkVmFsdWUgPSBwO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5xc2NyZWVuID0gbmV3IHRoaXNcclxuICAgICAgICAgICAgLmNyZWF0ZWpzXHJcbiAgICAgICAgICAgIC5Db250YWluZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRRdWVzdGlvbigpO1xyXG4gICAgICAgIHRoaXMuYWRkT3B0aW9ucyhmYWxzZSk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0WFkoMTYsIC0xNzApO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFNjcmVlbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5xc2NyZWVuXHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIHRoaXMuc2V0WFkoMTYsIDU1KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUJhdHNtYW5TdGF0ZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRYWSh4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5xc2NyZWVuLnggPSB4O1xyXG4gICAgICAgIHRoaXMucXNjcmVlbi55ID0geTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVTdWJtaXRCdG5TdGF0ZShwKSB7XHJcbiAgICAgICAgdGhpcy5xc2NyZWVuLnN1Ym1pdC5zaG90X3R4dC50ZXh0ID0gcC50eHQ7XHJcbiAgICAgICAgdGhpcy5xc2NyZWVuLnN1Ym1pdC5jb3VudGRvd24udHh0LnRleHQgPSBwLnRpbWU7XHJcbiAgICB9XHJcblxyXG4gICAgdHJpZ2dlckFsZXJ0KCkge1xyXG4gICAgICAgIGlmIChHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS5nYW1lUmVmLmhhc1RpbWVyKCkpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmFsZXJ0T24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWxlcnRPbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBTb3VuZFV0aWwucGxheVNvdW5kKFwiU3BhY2Vzb1wiLCAwLjgsIDAsIC0xKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucXNjcmVlbi5zdWJtaXQuY291bnRkb3duLmFsZXJ0TWMucGxheSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0b3BBbGVydCgpIHtcclxuICAgICAgICBpZiAoR2FtZU1vZGVsLmdldEluc3RhbmNlKCkuZ2FtZVJlZi5oYXNUaW1lcigpKSB7XHJcbiAgICAgICAgICAgIFNvdW5kVXRpbC5zdG9wU291bmQoXCJjb3VudGRvd25fdGlja1wiKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWxlcnRPbikge1xyXG4gICAgICAgICAgICAgICAgU291bmRVdGlsLnN0b3BTb3VuZChcIlNwYWNlc29cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5xc2NyZWVuLnN1Ym1pdC5jb3VudGRvd24uYWxlcnRNYy5nb3RvQW5kU3RvcCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hbGVydE9uID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50aW1lVXAgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlQmF0c21hblN0YXRlcygpIHtcclxuICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgLmdldEluc3RhbmNlKClcclxuICAgICAgICAgICAgLnVtcGlyZVxyXG4gICAgICAgICAgICAuZ2V0QmF0dGluZ1RlYW0oKVxyXG4gICAgICAgICAgICAuZ2V0UGxheWVyU3RhdGVzKClcclxuICAgICAgICAgICAgLmZvckVhY2goZWwgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IG1jID0gdGhpcy5xc2NyZWVuW1wid2tfXCIgKyBlbC5pZF07XHJcbiAgICAgICAgICAgICAgICBtYy5nb3RvQW5kU3RvcChlbC5zdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBtYy50eHQudGV4dCA9IGVsLnJ1bjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlU2NyZWVuKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcEFsZXJ0KCk7XHJcbiAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAucXNjcmVlblxyXG4gICAgICAgICAgICAucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRCZygpIHtcclxuXHJcbiAgICAgICAgdGhpcy5xc2NyZWVuID0gbmV3IHRoaXNcclxuICAgICAgICAgICAgLmxpYlxyXG4gICAgICAgICAgICAuUVNjcmVlbigpO1xyXG5cclxuICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgIC5xc2NyZWVuXHJcbiAgICAgICAgICAgIC5nb3RvQW5kU3RvcChcIlF1ZXN0aW9uXCIgKyBHYW1lTW9kZWwuZ2V0SW5zdGFuY2UoKS51bXBpcmUuZ2V0QmF0dGluZ1RlYW0oKS5nZXRUZWFtSWQoKSk7XHJcblxyXG4gICAgICAgIHRoaXMucXNjcmVlbi50ZWFtX3R4dC50ZXh0ID0gR2FtZU1vZGVsXHJcbiAgICAgICAgICAgIC5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgICAgIC51bXBpcmVcclxuICAgICAgICAgICAgLmdldEJhdHRpbmdUZWFtKClcclxuICAgICAgICAgICAgLmdldFRlYW1OYW1lKCk7XHJcblxyXG4gICAgICAgIHRoaXMucXNjcmVlbi5zdWJtaXQuY3Vyc29yID0gXCJwb2ludGVyXCI7XHJcbiAgICAgICAgdGhpcy5xc2NyZWVuLnN1Ym1pdC5vbihcIm1vdXNlb3ZlclwiLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNPcHRpb25TZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xc2NyZWVuLnN1Ym1pdC5nb3RvQW5kU3RvcCgnb3ZlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5xc2NyZWVuLnN1Ym1pdC5vbihcIm1vdXNlb3V0XCIsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc09wdGlvblNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnFzY3JlZW4uc3VibWl0LmdvdG9BbmRTdG9wKCdub3JtYWwnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucXNjcmVlbi5zdWJtaXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzT3B0aW9uU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEFsZXJ0KCk7XHJcbiAgICAgICAgICAgICAgICBHYW1lTW9kZWxcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5nYW1lUmVmXHJcbiAgICAgICAgICAgICAgICAgICAgLnBsYXlTaG90KHRoaXMucGxheWVkU2hvdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBhZGRRdWVzdGlvbigpIHtcclxuICAgICAgICBUZXh0VXRpbC5nZXRUZXh0KHsgeDogMTAwLCB5OiAxODAsIHQ6IHRoaXMuc2NyZWVuRGF0YS52YWx1ZS5xdGFnLl9fY2RhdGEsIGY6IHRoaXMucUZvbnQsIGxDYW52YXM6IHRoaXMucXNjcmVlbiB9KTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRJbnN0cnVjdGlvbigpIHtcclxuICAgICAgICB0aGlzLnFzY3JlZW4ucWluZm90eHRfbWMudHh0LnRleHQgPSB0aGlzLnNjcmVlbkRhdGEudmFsdWUuX3NraWxsO1xyXG4gICAgICAgIC8vdGhpcy5xc2NyZWVuLnFpbmZvdHh0X21jLnR4dEJnLndpZHRoID0gdGhpcy5xc2NyZWVuLnFpbmZvdHh0X21jLnR4dC50ZXh0LndpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZE9wdGlvbnMocCkge1xyXG5cclxuICAgICAgICBsZXQgb1N0YXJ0UG9pbnQgPSAyMTc7XHJcbiAgICAgICAgbGV0IG9wdGlvbmdhcCA9IDM1O1xyXG4gICAgICAgIGxldCBvID0gdGhpcy5zY3JlZW5EYXRhLnZhbHVlLm9wdGlvbjtcclxuICAgICAgICBsZXQgdDtcclxuXHJcbiAgICAgICAgby5mb3JFYWNoKChlYWNoLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBvbWMgPSBuZXcgdGhpc1xyXG4gICAgICAgICAgICAgICAgLmxpYlxyXG4gICAgICAgICAgICAgICAgLk9wdGlvbk1jMSgpO1xyXG5cclxuICAgICAgICAgICAgb21jLnggPSAxMjA7XHJcbiAgICAgICAgICAgIG9tYy55ID0gb1N0YXJ0UG9pbnQgKyAob3B0aW9uZ2FwICogaSk7XHJcbiAgICAgICAgICAgIG9tYy5uYW1lID0gXCJvcHRcIiArIChpICsgMSk7XHJcbiAgICAgICAgICAgIG9tYy5pZCA9IGk7XHJcblxyXG4gICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgICAgICAub3B0aW9uQXJyXHJcbiAgICAgICAgICAgICAgICAucHVzaChvbWMpO1xyXG5cclxuICAgICAgICAgICAgdCA9IFRleHRVdGlsLmdldFRleHQoeyB4OiAxMCwgeTogMCwgdDogZWFjaC5fX2NkYXRhLCBmOiB0aGlzLm9Gb250LCBsQ2FudmFzOiBvbWMgfSlcclxuXHJcbiAgICAgICAgICAgIG9tYy5zZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBvbWMuY29ycmVjdEFucyA9IChlYWNoLl9jb3JyZWN0YW5zID09PSBcInRydWVcIilcclxuICAgICAgICAgICAgICAgID8gaVxyXG4gICAgICAgICAgICAgICAgOiAtMTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ29wdGlvbi0nLCBpLCBvbWMuY29ycmVjdEFucyk7XHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKHApIHtcclxuICAgICAgICAgICAgICAgIG9tYy52YWxpZGF0ZU1jLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIG9tYy5jdXJzb3IgPSBcInBvaW50ZXJcIjtcclxuICAgICAgICAgICAgICAgIG9tYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb21jLnNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9tYy5nb3RvQW5kU3RvcChcIm92ZXJcIik7IC8vIGFzc2V0Rml4XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBvbWMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb21jLnNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9tYy5nb3RvQW5kU3RvcChcIm5vcm1hbFwiKTsgLy8gYXNzZXRGaXhcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG9tYy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXNlbGVjdEFsbE9wdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXllZFNob3QgPSBvbWM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9tYy5nb3RvQW5kU3RvcChcInNlbGVjdGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9tYy5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc09wdGlvblNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5xc2NyZWVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJtaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmdvdG9BbmRTdG9wKCdub3JtYWwnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gdGhpcy51c2VyU2VsZWN0ZWRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlYWNoLl9jb3JyZWN0YW5zKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9tYy52YWxpZGF0ZU1jLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbWMudmFsaWRhdGVNYy50aWNrLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9tYy52YWxpZGF0ZU1jLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKGVhY2guX2NvcnJlY3RhbnMgPT09IFwidHJ1ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9tYy52YWxpZGF0ZU1jLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG9tYy52YWxpZGF0ZU1jLmNyb3NzLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgICAgICAucXNjcmVlblxyXG4gICAgICAgICAgICAgICAgLmFkZENoaWxkKG9tYyk7XHJcblxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHRoaXMuZGlzYWJsZVNjcmVlbih0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBkZXNlbGVjdEFsbE9wdGlvbnMoKSB7XHJcbiAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAub3B0aW9uQXJyXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKChlYWNoLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlYWNoLmdvdG9BbmRTdG9wKFwibm9ybWFsXCIpO1xyXG4gICAgICAgICAgICAgICAgZWFjaC5zZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGRpc2FibGVTY3JlZW4ocCkge1xyXG4gICAgICAgIHRoaXMub3B0aW9uQXJyLmZvckVhY2goKGVhY2gsIGkpID0+IHtcclxuICAgICAgICAgICAgZWFjaC5tb3VzZUVuYWJsZWQgPSBlYWNoLm1vdXNlQ2hpbGRyZW4gPSAhcDtcclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMucXNjcmVlbi5tb3VzZUVuYWJsZWQgPSB0aGlzLnFzY3JlZW4ubW91c2VDaGlsZHJlbiA9ICFwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzUXVlc3Rpb25BY3RpdmUoKSB7XHJcbiAgICAgICAgcmV0dXJuICghdGhpcy50aW1lVXAgJiYgdGhpcy5hY3RpdmUpXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBRdWVzdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/views/Question.js\n");

/***/ }),

/***/ "./src/views/ScoreBoard.js":
/*!*********************************!*\
  !*** ./src/views/ScoreBoard.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _models_Models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/Models */ \"./src/models/Models.js\");\n/* harmony import */ var _models_GameEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/GameEvent */ \"./src/models/GameEvent.js\");\n\r\n\r\n\r\nclass ScoreBoard {\r\n\r\n    connectDisplay(boardDisplay) {\r\n        this.bd = boardDisplay;\r\n    }\r\n\r\n    scoreUpdate() {\r\n\r\n        this.cleanupScoreBoard();\r\n\r\n        let team = _models_Models__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\r\n            .getInstance()\r\n            .umpire\r\n            .getBattingTeam();\r\n\r\n        this.ballCount = (team.countOver().length > 0) ? team.countOver().length : 0;\r\n\r\n        this.bd.TeamTxt.text = team.getTeamName();\r\n        this.bd.ScoreMc.txt.text = team.getScore();\r\n        this.bd.WicketsMc.txt.text = team.wicketsDown();\r\n        this.bd.MsgTxt.text = _models_Models__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\r\n            .getInstance()\r\n            .umpire\r\n            .getMatchStat()\r\n            .s_msg;\r\n\r\n        //console.log(team.countOver(), \" -- ballCount \", this.ballCount);\r\n\r\n        if (this.ballCount === 0) {\r\n\r\n            this.bd[\"bl_0\"].gotoAndStop(1);\r\n        } else {\r\n\r\n            team.countOver().forEach((ball, id) => {\r\n\r\n                let el = this.bd[\"bl_\" + id];\r\n                el.gotoAndStop(2);\r\n                el.id = id;\r\n                el.txt.text = ball.ballValue;\r\n\r\n                //el.cursor = \"pointer\";\r\n                //el.mouseChildren = el.mouseEnabled = true; // = el.mouseEnabled\r\n                if (!el.hasEventListener(\"click\")) {\r\n                    el.on(\"click\", (evt) => {\r\n                        //this.enableClick(true);\r\n                        //console.log(evt.target);\r\n                        //evt.target.mouseChildren = false;\r\n                        //evt.target.mouseEnabled = false;\r\n                        //evt.target.cursor = \"default\";\r\n                        window.eventManager.dispatch(_models_GameEvent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SHOW_QUESTION_FEEDBACK, { id: el.id });\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        if (this.ballCount < 6) {\r\n            // console.log(\"ballCount \", this.ballCount);\r\n            this.bd[\"bl_\" + this.ballCount].gotoAndStop(1);\r\n        }\r\n\r\n    }\r\n\r\n    enableClick(p) {\r\n        for (let i = 0; i < this.ballCount; i++) {\r\n            //console.log(i, \" enabling ... \", this.bd[\"bl_\" + i]);\r\n            this.bd[\"bl_\" + i].mouseChildren = p;\r\n            //this.bd[\"bl_\" + i].mouseEnabled = p;\r\n            //this.bd[\"bl_\" + i].cursor = \"pointer\";\r\n        }\r\n    }\r\n\r\n    cleanupScoreBoard() {\r\n\r\n        let ball = this.bd;\r\n\r\n        ball.TeamTxt.text = \"\";\r\n        ball.ScoreMc.txt.text = \"\";\r\n        ball.WicketsMc.txt.text = \"\";\r\n        ball.MsgTxt.text = \"\";\r\n        for (let i = 0; i < 6; i++) {\r\n            ball[\"bl_\" + i].txt.text = '';\r\n            ball[\"bl_\" + i].gotoAndStop(0);\r\n            if (ball[\"bl_\" + i].hasEventListener(\"click\")) {\r\n                ball[\"bl_\" + i].removeAllEventListeners(\"click\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ScoreBoard);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmlld3MvU2NvcmVCb2FyZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy92aWV3cy9TY29yZUJvYXJkLmpzPzJiNDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdhbWVNb2RlbCBmcm9tIFwiLi4vbW9kZWxzL01vZGVsc1wiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi9tb2RlbHMvR2FtZUV2ZW50XCI7XHJcblxyXG5jbGFzcyBTY29yZUJvYXJkIHtcclxuXHJcbiAgICBjb25uZWN0RGlzcGxheShib2FyZERpc3BsYXkpIHtcclxuICAgICAgICB0aGlzLmJkID0gYm9hcmREaXNwbGF5O1xyXG4gICAgfVxyXG5cclxuICAgIHNjb3JlVXBkYXRlKCkge1xyXG5cclxuICAgICAgICB0aGlzLmNsZWFudXBTY29yZUJvYXJkKCk7XHJcblxyXG4gICAgICAgIGxldCB0ZWFtID0gR2FtZU1vZGVsXHJcbiAgICAgICAgICAgIC5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgICAgIC51bXBpcmVcclxuICAgICAgICAgICAgLmdldEJhdHRpbmdUZWFtKCk7XHJcblxyXG4gICAgICAgIHRoaXMuYmFsbENvdW50ID0gKHRlYW0uY291bnRPdmVyKCkubGVuZ3RoID4gMCkgPyB0ZWFtLmNvdW50T3ZlcigpLmxlbmd0aCA6IDA7XHJcblxyXG4gICAgICAgIHRoaXMuYmQuVGVhbVR4dC50ZXh0ID0gdGVhbS5nZXRUZWFtTmFtZSgpO1xyXG4gICAgICAgIHRoaXMuYmQuU2NvcmVNYy50eHQudGV4dCA9IHRlYW0uZ2V0U2NvcmUoKTtcclxuICAgICAgICB0aGlzLmJkLldpY2tldHNNYy50eHQudGV4dCA9IHRlYW0ud2lja2V0c0Rvd24oKTtcclxuICAgICAgICB0aGlzLmJkLk1zZ1R4dC50ZXh0ID0gR2FtZU1vZGVsXHJcbiAgICAgICAgICAgIC5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgICAgIC51bXBpcmVcclxuICAgICAgICAgICAgLmdldE1hdGNoU3RhdCgpXHJcbiAgICAgICAgICAgIC5zX21zZztcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0ZWFtLmNvdW50T3ZlcigpLCBcIiAtLSBiYWxsQ291bnQgXCIsIHRoaXMuYmFsbENvdW50KTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYmFsbENvdW50ID09PSAwKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJkW1wiYmxfMFwiXS5nb3RvQW5kU3RvcCgxKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdGVhbS5jb3VudE92ZXIoKS5mb3JFYWNoKChiYWxsLCBpZCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBlbCA9IHRoaXMuYmRbXCJibF9cIiArIGlkXTtcclxuICAgICAgICAgICAgICAgIGVsLmdvdG9BbmRTdG9wKDIpO1xyXG4gICAgICAgICAgICAgICAgZWwuaWQgPSBpZDtcclxuICAgICAgICAgICAgICAgIGVsLnR4dC50ZXh0ID0gYmFsbC5iYWxsVmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9lbC5jdXJzb3IgPSBcInBvaW50ZXJcIjtcclxuICAgICAgICAgICAgICAgIC8vZWwubW91c2VDaGlsZHJlbiA9IGVsLm1vdXNlRW5hYmxlZCA9IHRydWU7IC8vID0gZWwubW91c2VFbmFibGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVsLmhhc0V2ZW50TGlzdGVuZXIoXCJjbGlja1wiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLm9uKFwiY2xpY2tcIiwgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMuZW5hYmxlQ2xpY2sodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZXZ0LnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZXZ0LnRhcmdldC5tb3VzZUNoaWxkcmVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZXZ0LnRhcmdldC5tb3VzZUVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9ldnQudGFyZ2V0LmN1cnNvciA9IFwiZGVmYXVsdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZXZlbnRNYW5hZ2VyLmRpc3BhdGNoKEdhbWVFdmVudC5TSE9XX1FVRVNUSU9OX0ZFRURCQUNLLCB7IGlkOiBlbC5pZCB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5iYWxsQ291bnQgPCA2KSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiYmFsbENvdW50IFwiLCB0aGlzLmJhbGxDb3VudCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmRbXCJibF9cIiArIHRoaXMuYmFsbENvdW50XS5nb3RvQW5kU3RvcCgxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGVuYWJsZUNsaWNrKHApIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmFsbENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhpLCBcIiBlbmFibGluZyAuLi4gXCIsIHRoaXMuYmRbXCJibF9cIiArIGldKTtcclxuICAgICAgICAgICAgdGhpcy5iZFtcImJsX1wiICsgaV0ubW91c2VDaGlsZHJlbiA9IHA7XHJcbiAgICAgICAgICAgIC8vdGhpcy5iZFtcImJsX1wiICsgaV0ubW91c2VFbmFibGVkID0gcDtcclxuICAgICAgICAgICAgLy90aGlzLmJkW1wiYmxfXCIgKyBpXS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYW51cFNjb3JlQm9hcmQoKSB7XHJcblxyXG4gICAgICAgIGxldCBiYWxsID0gdGhpcy5iZDtcclxuXHJcbiAgICAgICAgYmFsbC5UZWFtVHh0LnRleHQgPSBcIlwiO1xyXG4gICAgICAgIGJhbGwuU2NvcmVNYy50eHQudGV4dCA9IFwiXCI7XHJcbiAgICAgICAgYmFsbC5XaWNrZXRzTWMudHh0LnRleHQgPSBcIlwiO1xyXG4gICAgICAgIGJhbGwuTXNnVHh0LnRleHQgPSBcIlwiO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJhbGxbXCJibF9cIiArIGldLnR4dC50ZXh0ID0gJyc7XHJcbiAgICAgICAgICAgIGJhbGxbXCJibF9cIiArIGldLmdvdG9BbmRTdG9wKDApO1xyXG4gICAgICAgICAgICBpZiAoYmFsbFtcImJsX1wiICsgaV0uaGFzRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBiYWxsW1wiYmxfXCIgKyBpXS5yZW1vdmVBbGxFdmVudExpc3RlbmVycyhcImNsaWNrXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTY29yZUJvYXJkIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/views/ScoreBoard.js\n");

/***/ })

/******/ });